/**
 * @since 1.0.0
 */
import * as Headers from "@effect/platform/Headers";
import * as HttpApp from "@effect/platform/HttpApp";
import * as HttpLayerRouter from "@effect/platform/HttpLayerRouter";
import * as HttpRouter from "@effect/platform/HttpRouter";
import * as HttpServerRequest from "@effect/platform/HttpServerRequest";
import * as HttpServerResponse from "@effect/platform/HttpServerResponse";
import * as SocketServer from "@effect/platform/SocketServer";
import * as Transferable from "@effect/platform/Transferable";
import * as WorkerRunner from "@effect/platform/WorkerRunner";
import * as Arr from "effect/Array";
import * as Cause from "effect/Cause";
import * as Chunk from "effect/Chunk";
import * as Context from "effect/Context";
import * as Deferred from "effect/Deferred";
import * as Effect from "effect/Effect";
import * as Exit from "effect/Exit";
import * as Fiber from "effect/Fiber";
import * as FiberId from "effect/FiberId";
import * as FiberSet from "effect/FiberSet";
import { constant, constTrue, constVoid, identity } from "effect/Function";
import * as Layer from "effect/Layer";
import * as Mailbox from "effect/Mailbox";
import * as Option from "effect/Option";
import { TreeFormatter } from "effect/ParseResult";
import * as Predicate from "effect/Predicate";
import * as Runtime from "effect/Runtime";
import * as Schedule from "effect/Schedule";
import * as Schema from "effect/Schema";
import * as Scope from "effect/Scope";
import * as Stream from "effect/Stream";
import * as Tracer from "effect/Tracer";
import { withRun } from "./internal/utils.js";
import * as Rpc from "./Rpc.js";
import { constEof, constPong, RequestId, ResponseDefectEncoded } from "./RpcMessage.js";
import * as RpcSchema from "./RpcSchema.js";
import * as RpcSerialization from "./RpcSerialization.js";
/**
 * @since 1.0.0
 * @category server
 */
export const makeNoSerialization = /*#__PURE__*/Effect.fnUntraced(function* (group, options) {
  const enableTracing = options.disableTracing !== true;
  const enableSpanPropagation = options.disableSpanPropagation !== true;
  const supportsAck = options.disableClientAcks !== true;
  const spanPrefix = options.spanPrefix ?? "RpcServer";
  const concurrency = options.concurrency ?? "unbounded";
  const disableFatalDefects = options.disableFatalDefects ?? false;
  const context = yield* Effect.context();
  const scope = Context.get(context, Scope.Scope);
  const fiberSet = yield* FiberSet.make();
  const runFork = yield* FiberSet.runtime(fiberSet)().pipe(Effect.interruptible);
  const concurrencySemaphore = concurrency === "unbounded" ? undefined : yield* Effect.makeSemaphore(concurrency);
  const clients = new Map();
  let isShutdown = false;
  const shutdownLatch = Effect.unsafeMakeLatch(false);
  yield* Scope.addFinalizer(scope, Effect.fiberIdWith(fiberId => {
    isShutdown = true;
    for (const client of clients.values()) {
      client.ended = true;
      if (client.fibers.size === 0) {
        runFork(endClient(client));
        continue;
      }
      for (const fiber of client.fibers.values()) {
        fiber.unsafeInterruptAsFork(fiberId);
      }
    }
    if (clients.size === 0) {
      return Effect.void;
    }
    return shutdownLatch.await;
  }));
  const disconnect = clientId => Effect.fiberIdWith(fiberId => {
    const client = clients.get(clientId);
    if (!client) return Effect.void;
    for (const fiber of client.fibers.values()) {
      fiber.unsafeInterruptAsFork(fiberId);
    }
    clients.delete(clientId);
    return Effect.void;
  });
  const write = (clientId, message) => Effect.catchAllDefect(Effect.withFiberRuntime(requestFiber => {
    if (isShutdown) return Effect.interrupt;
    let client = clients.get(clientId);
    if (!client) {
      client = {
        id: clientId,
        latches: new Map(),
        fibers: new Map(),
        ended: false
      };
      clients.set(clientId, client);
    } else if (client.ended) {
      return Effect.interrupt;
    }
    switch (message._tag) {
      case "Request":
        {
          return handleRequest(requestFiber, client, message);
        }
      case "Ack":
        {
          const latch = client.latches.get(message.requestId);
          return latch ? latch.open : Effect.void;
        }
      case "Interrupt":
        {
          const fiber = client.fibers.get(message.requestId);
          return fiber ? Fiber.interruptFork(fiber) : options.onFromServer({
            _tag: "Exit",
            clientId,
            requestId: message.requestId,
            exit: Exit.interrupt(FiberId.none)
          });
        }
      case "Eof":
        {
          client.ended = true;
          if (client.fibers.size > 0) return Effect.void;
          return endClient(client);
        }
      default:
        {
          return sendDefect(client, `Unknown request tag: ${message._tag}`);
        }
    }
  }), defect => sendDefect(clients.get(clientId), defect));
  const endClient = client => {
    clients.delete(client.id);
    const write = options.onFromServer({
      _tag: "ClientEnd",
      clientId: client.id
    });
    if (isShutdown && clients.size === 0) {
      return Effect.zipRight(write, shutdownLatch.open);
    }
    return write;
  };
  const handleRequest = (requestFiber, client, request) => {
    if (client.fibers.has(request.id)) {
      return Effect.interrupt;
    }
    const rpc = group.requests.get(request.tag);
    const entry = context.unsafeMap.get(rpc?.key);
    if (!rpc || !entry) {
      const write = Effect.catchAllDefect(options.onFromServer({
        _tag: "Exit",
        clientId: client.id,
        requestId: request.id,
        exit: Exit.die(`Unknown request tag: ${request.tag}`)
      }), defect => sendDefect(client, defect));
      if (!client.ended || client.fibers.size > 0) return write;
      return Effect.zipRight(write, endClient(client));
    }
    const isStream = RpcSchema.isStreamSchema(rpc.successSchema);
    const result = entry.handler(request.payload, request.headers);
    // if the handler requested forking, then we skip the concurrency control
    const isFork = Rpc.isFork(result);
    // unwrap the fork data type
    const streamOrEffect = isFork ? result.value : result;
    let responded = false;
    let effect = Effect.uninterruptible(Effect.matchCauseEffect(Effect.interruptible(applyMiddleware(rpc, context, client.id, request.payload, request.headers, isStream ? streamEffect(client, request, streamOrEffect) : streamOrEffect)), {
      onSuccess: value => {
        responded = true;
        return options.onFromServer({
          _tag: "Exit",
          clientId: client.id,
          requestId: request.id,
          exit: Exit.succeed(value)
        });
      },
      onFailure: cause => {
        responded = true;
        if (!disableFatalDefects && Cause.isDie(cause)) {
          return sendDefect(client, Cause.squash(cause));
        }
        return options.onFromServer({
          _tag: "Exit",
          clientId: client.id,
          requestId: request.id,
          exit: Exit.failCause(cause)
        });
      }
    }));
    if (enableTracing) {
      const parentSpan = requestFiber.currentContext.unsafeMap.get(Tracer.ParentSpan.key);
      effect = Effect.withSpan(effect, `${spanPrefix}.${request.tag}`, {
        captureStackTrace: false,
        attributes: options.spanAttributes,
        parent: enableSpanPropagation && request.spanId ? {
          _tag: "ExternalSpan",
          traceId: request.traceId,
          spanId: request.spanId,
          sampled: request.sampled,
          context: Context.empty()
        } : undefined,
        links: enableSpanPropagation && parentSpan ? [{
          _tag: "SpanLink",
          span: parentSpan,
          attributes: {}
        }] : undefined
      });
    }
    if (!isFork && concurrencySemaphore) {
      effect = concurrencySemaphore.withPermits(1)(effect);
    }
    const runtime = Runtime.make({
      context: Context.merge(entry.context, requestFiber.currentContext),
      fiberRefs: requestFiber.getFiberRefs(),
      runtimeFlags: Runtime.defaultRuntime.runtimeFlags
    });
    const fiber = Runtime.runFork(runtime, effect);
    FiberSet.unsafeAdd(fiberSet, fiber);
    client.fibers.set(request.id, fiber);
    fiber.addObserver(exit => {
      if (!responded && exit._tag === "Failure") {
        FiberSet.unsafeAdd(fiberSet, Runtime.runFork(runtime, options.onFromServer({
          _tag: "Exit",
          clientId: client.id,
          requestId: request.id,
          exit: Exit.interrupt(FiberId.none)
        })));
      }
      client.fibers.delete(request.id);
      client.latches.delete(request.id);
      if (client.ended && client.fibers.size === 0) {
        FiberSet.unsafeAdd(fiberSet, Runtime.runFork(runtime, endClient(client)));
      }
    });
    return Effect.void;
  };
  const streamEffect = (client, request, stream) => {
    let latch = client.latches.get(request.id);
    if (supportsAck && !latch) {
      latch = Effect.unsafeMakeLatch(false);
      client.latches.set(request.id, latch);
    }
    if (Effect.isEffect(stream)) {
      let done = false;
      return stream.pipe(Effect.flatMap(mailbox => Effect.whileLoop({
        while: () => !done,
        body: constant(Effect.flatMap(mailbox.takeAll, ([chunk, done_]) => {
          done = done_;
          if (!Chunk.isNonEmpty(chunk)) return Effect.void;
          const write = options.onFromServer({
            _tag: "Chunk",
            clientId: client.id,
            requestId: request.id,
            values: Chunk.toReadonlyArray(chunk)
          });
          if (!latch) return write;
          latch.unsafeClose();
          return Effect.zipRight(write, latch.await);
        })),
        step: constVoid
      })), Effect.scoped);
    }
    return Stream.runForEachChunk(stream, chunk => {
      if (!Chunk.isNonEmpty(chunk)) return Effect.void;
      const write = options.onFromServer({
        _tag: "Chunk",
        clientId: client.id,
        requestId: request.id,
        values: Chunk.toReadonlyArray(chunk)
      });
      if (!latch) return write;
      latch.unsafeClose();
      return Effect.zipRight(write, latch.await);
    });
  };
  const sendDefect = (client, defect) => Effect.suspend(() => {
    const shouldEnd = client.ended && client.fibers.size === 0;
    const write = options.onFromServer({
      _tag: "Defect",
      clientId: client.id,
      defect
    });
    if (!shouldEnd) return write;
    return Effect.zipRight(write, endClient(client));
  });
  return identity({
    write,
    disconnect
  });
});
const applyMiddleware = (rpc, context, clientId, payload, headers, handler) => {
  if (rpc.middlewares.size === 0) {
    return handler;
  }
  const options = {
    rpc,
    payload,
    headers,
    clientId
  };
  for (const tag of rpc.middlewares) {
    if (tag.wrap) {
      const middleware = Context.unsafeGet(context, tag);
      handler = middleware({
        ...options,
        next: handler
      });
    } else if (tag.optional) {
      const middleware = Context.unsafeGet(context, tag);
      const previous = handler;
      handler = Effect.matchEffect(middleware(options), {
        onFailure: () => previous,
        onSuccess: tag.provides !== undefined ? value => Effect.provideService(previous, tag.provides, value) : _ => previous
      });
    } else {
      const middleware = Context.unsafeGet(context, tag);
      handler = tag.provides !== undefined ? Effect.provideServiceEffect(handler, tag.provides, middleware(options)) : Effect.zipRight(middleware(options), handler);
    }
  }
  return handler;
};
/**
 * @since 1.0.0
 * @category server
 */
export const make = /*#__PURE__*/Effect.fnUntraced(function* (group, options) {
  const {
    disconnects,
    end,
    run,
    send,
    supportsAck,
    supportsSpanPropagation,
    supportsTransferables
  } = yield* Protocol;
  const context = yield* Effect.context();
  const scope = yield* Scope.make();
  const server = yield* makeNoSerialization(group, {
    ...options,
    disableClientAcks: !supportsAck,
    disableSpanPropagation: !supportsSpanPropagation,
    onFromServer(response) {
      const client = clients.get(response.clientId);
      if (!client) return Effect.void;
      switch (response._tag) {
        case "Chunk":
          {
            const schemas = client.schemas.get(response.requestId);
            if (!schemas) return Effect.void;
            return handleEncode(client, response.requestId, schemas.collector, Effect.provide(schemas.encodeChunk(response.values), schemas.context), values => ({
              _tag: "Chunk",
              requestId: String(response.requestId),
              values
            }));
          }
        case "Exit":
          {
            const schemas = client.schemas.get(response.requestId);
            if (!schemas) return Effect.void;
            client.schemas.delete(response.requestId);
            return handleEncode(client, response.requestId, schemas.collector, Effect.provide(schemas.encodeExit(response.exit), schemas.context), exit => ({
              _tag: "Exit",
              requestId: String(response.requestId),
              exit
            }));
          }
        case "Defect":
          {
            return sendDefect(client, response.defect);
          }
        case "ClientEnd":
          {
            clients.delete(response.clientId);
            return end(response.clientId);
          }
      }
    }
  }).pipe(Scope.extend(scope));
  // handle disconnects
  yield* Effect.fork(Effect.interruptible(Effect.whileLoop({
    while: constTrue,
    body: constant(Effect.flatMap(disconnects.take, clientId => {
      clients.delete(clientId);
      return server.disconnect(clientId);
    })),
    step: constVoid
  })));
  const schemasCache = new WeakMap();
  const getSchemas = rpc => {
    let schemas = schemasCache.get(rpc);
    if (!schemas) {
      const entry = context.unsafeMap.get(rpc.key);
      const streamSchemas = RpcSchema.getStreamSchemas(rpc.successSchema.ast);
      schemas = {
        decode: Schema.decodeUnknown(rpc.payloadSchema),
        encodeChunk: Schema.encodeUnknown(Schema.Array(Option.isSome(streamSchemas) ? streamSchemas.value.success : Schema.Any)),
        encodeExit: Schema.encodeUnknown(Rpc.exitSchema(rpc)),
        context: entry.context
      };
      schemasCache.set(rpc, schemas);
    }
    return schemas;
  };
  const clients = new Map();
  const handleEncode = (client, requestId, collector, effect, onSuccess) => (collector ? Effect.provideService(effect, Transferable.Collector, collector) : effect).pipe(Effect.flatMap(a => send(client.id, onSuccess(a), collector && collector.unsafeClear())), Effect.catchAllCause(cause => {
    client.schemas.delete(requestId);
    const defect = Cause.squash(Cause.map(cause, TreeFormatter.formatErrorSync));
    return Effect.zipRight(sendRequestDefect(client, requestId, defect), server.write(client.id, {
      _tag: "Interrupt",
      requestId,
      interruptors: []
    }));
  }));
  const sendRequestDefect = (client, requestId, defect) => Effect.catchAllCause(send(client.id, {
    _tag: "Exit",
    requestId: String(requestId),
    exit: {
      _tag: "Failure",
      cause: {
        _tag: "Die",
        defect
      }
    }
  }), cause => sendDefect(client, Cause.squash(cause)));
  const sendDefect = (client, defect) => Effect.catchAllCause(send(client.id, {
    _tag: "Defect",
    defect
  }), cause => Effect.annotateLogs(Effect.logDebug(cause), {
    module: "RpcServer",
    method: "sendDefect"
  }));
  // main server loop
  return yield* run((clientId, request) => {
    let client = clients.get(clientId);
    if (!client) {
      client = {
        id: clientId,
        schemas: new Map()
      };
      clients.set(clientId, client);
    }
    switch (request._tag) {
      case "Request":
        {
          const tag = Predicate.hasProperty(request, "tag") ? request.tag : "";
          const rpc = group.requests.get(tag);
          if (!rpc) {
            return sendDefect(client, `Unknown request tag: ${tag}`);
          }
          let requestId;
          switch (typeof request.id) {
            case "bigint":
            case "string":
              {
                requestId = RequestId(request.id);
                break;
              }
            default:
              {
                return sendDefect(client, `Invalid request id: ${request.id}`);
              }
          }
          const schemas = getSchemas(rpc);
          return Effect.matchEffect(Effect.provide(schemas.decode(request.payload), schemas.context), {
            onFailure: error => sendRequestDefect(client, requestId, TreeFormatter.formatErrorSync(error)),
            onSuccess: payload => {
              client.schemas.set(requestId, supportsTransferables ? {
                ...schemas,
                collector: Transferable.unsafeMakeCollector()
              } : schemas);
              return server.write(clientId, {
                ...request,
                id: requestId,
                payload,
                headers: Headers.fromInput(request.headers)
              });
            }
          });
        }
      case "Ping":
        {
          return Effect.catchAllCause(send(client.id, constPong), cause => sendDefect(client, Cause.squash(cause)));
        }
      case "Eof":
        {
          return server.write(clientId, request);
        }
      case "Ack":
        {
          return server.write(clientId, {
            ...request,
            requestId: RequestId(request.requestId)
          });
        }
      case "Interrupt":
        {
          return server.write(clientId, {
            ...request,
            requestId: RequestId(request.requestId),
            interruptors: []
          });
        }
      default:
        {
          return sendDefect(client, `Unknown request tag: ${request._tag}`);
        }
    }
  }).pipe(Effect.interruptible, Effect.tapErrorCause(cause => Effect.logFatal("BUG: RpcServer protocol crashed", cause)), Effect.onExit(exit => Scope.close(scope, exit)));
});
/**
 * @since 1.0.0
 * @category server
 */
export const layer = (group, options) => Layer.scopedDiscard(Effect.forkScoped(Effect.interruptible(make(group, options))));
/**
 * Create a RPC server that registers a HTTP route with a `HttpLayerRouter`.
 *
 * It defaults to using websockets for communication, but can be configured to
 * use HTTP.
 *
 * @since 1.0.0
 * @category protocol
 */
export const layerHttpRouter = options => layer(options.group, options).pipe(Layer.provide(options.protocol === "http" ? layerProtocolHttpRouter(options) : layerProtocolWebsocketRouter(options)));
/**
 * @since 1.0.0
 * @category protocol
 */
export class Protocol extends /*#__PURE__*/Context.Tag("@effect/rpc/RpcServer/Protocol")() {
  /**
   * @since 1.0.0
   */
  static make = /*#__PURE__*/withRun();
}
/**
 * @since 1.0.0
 * @category protocol
 */
export const makeProtocolSocketServer = /*#__PURE__*/Effect.gen(function* () {
  const server = yield* SocketServer.SocketServer;
  const {
    onSocket,
    protocol
  } = yield* makeSocketProtocol;
  yield* Effect.forkScoped(Effect.interruptible(server.run(Effect.fnUntraced(onSocket, Effect.scoped))));
  return protocol;
});
/**
 * A rpc protocol that uses `SocketServer` for communication.
 *
 * @since 1.0.0
 * @category protocol
 */
export const layerProtocolSocketServer = /*#__PURE__*/Layer.scoped(Protocol, makeProtocolSocketServer);
/**
 * @since 1.0.0
 * @category protocol
 */
export const makeProtocolWithHttpAppWebsocket = /*#__PURE__*/Effect.gen(function* () {
  const {
    onSocket,
    protocol
  } = yield* makeSocketProtocol;
  const httpApp = Effect.gen(function* () {
    const request = yield* HttpServerRequest.HttpServerRequest;
    const socket = yield* Effect.orDie(request.upgrade);
    yield* onSocket(socket);
    return HttpServerResponse.empty();
  });
  return {
    protocol,
    httpApp
  };
});
/**
 * @since 1.0.0
 * @category protocol
 */
export const makeProtocolWebsocket = /*#__PURE__*/Effect.fnUntraced(function* (options) {
  const {
    httpApp,
    protocol
  } = yield* makeProtocolWithHttpAppWebsocket;
  const router = yield* options.routerTag ?? HttpRouter.Default;
  yield* router.get(options.path, httpApp);
  return protocol;
});
/**
 * @since 1.0.0
 * @category protocol
 */
export const makeProtocolWebsocketRouter = /*#__PURE__*/Effect.fnUntraced(function* (options) {
  const router = yield* HttpLayerRouter.HttpRouter;
  const {
    httpApp,
    protocol
  } = yield* makeProtocolWithHttpAppWebsocket;
  yield* router.add("GET", options.path, httpApp);
  return protocol;
});
/**
 * A rpc protocol that uses websockets for communication.
 *
 * @since 1.0.0
 * @category protocol
 */
export const layerProtocolWebsocket = options => {
  const routerTag = options.routerTag ?? HttpRouter.Default;
  return Layer.effect(Protocol, makeProtocolWebsocket(options)).pipe(Layer.provide(routerTag.Live));
};
/**
 * A rpc protocol that uses websockets for communication.
 *
 * Uses a `HttpLayerRouter` to provide the websocket endpoint.
 *
 * @since 1.0.0
 * @category protocol
 */
export const layerProtocolWebsocketRouter = options => Layer.effect(Protocol, makeProtocolWebsocketRouter(options));
/**
 * @since 1.0.0
 * @category protocol
 */
export const makeProtocolWithHttpApp = /*#__PURE__*/Effect.gen(function* () {
  const serialization = yield* RpcSerialization.RpcSerialization;
  const includesFraming = serialization.includesFraming;
  const disconnects = yield* Mailbox.make();
  let writeRequest;
  let clientId = 0;
  const clients = new Map();
  const httpApp = Effect.gen(function* () {
    const request = yield* HttpServerRequest.HttpServerRequest;
    const data = yield* Effect.orDie(request.arrayBuffer);
    const id = clientId++;
    const mailbox = yield* Mailbox.make();
    const parser = serialization.unsafeMake();
    const encoder = new TextEncoder();
    const offer = data => typeof data === "string" ? mailbox.offer(encoder.encode(data)) : mailbox.offer(data);
    clients.set(id, {
      write: response => {
        try {
          if (!includesFraming) return mailbox.offer(response);
          const encoded = parser.encode(response);
          if (encoded === undefined) return Effect.void;
          return offer(encoded);
        } catch (cause) {
          return !includesFraming ? mailbox.offer(ResponseDefectEncoded(cause)) : offer(parser.encode(ResponseDefectEncoded(cause)));
        }
      },
      end: mailbox.end
    });
    const requestIds = [];
    try {
      const decoded = parser.decode(new Uint8Array(data));
      for (const message of decoded) {
        if (message._tag === "Request") {
          requestIds.push(RequestId(message.id));
        }
        yield* writeRequest(id, message);
      }
    } catch (cause) {
      yield* offer(parser.encode(ResponseDefectEncoded(cause)));
    }
    yield* writeRequest(id, constEof);
    if (!includesFraming) {
      let done = false;
      yield* Effect.addFinalizer(() => {
        clients.delete(id);
        disconnects.unsafeOffer(id);
        if (done) return Effect.void;
        return Effect.forEach(requestIds, requestId => writeRequest(id, {
          _tag: "Interrupt",
          requestId: String(requestId)
        }), {
          discard: true
        });
      });
      const responses = Arr.empty();
      while (true) {
        const [items, done] = yield* mailbox.takeAll;
        // eslint-disable-next-line no-restricted-syntax
        responses.push(...items);
        if (done) break;
      }
      done = true;
      return HttpServerResponse.text(parser.encode(responses), {
        contentType: serialization.contentType
      });
    }
    return HttpServerResponse.stream(Stream.ensuringWith(Mailbox.toStream(mailbox), exit => {
      clients.delete(id);
      disconnects.unsafeOffer(id);
      if (!Exit.isInterrupted(exit)) return Effect.void;
      return Effect.forEach(requestIds, requestId => writeRequest(id, {
        _tag: "Interrupt",
        requestId: String(requestId)
      }), {
        discard: true
      });
    }), {
      contentType: serialization.contentType
    });
  }).pipe(Effect.interruptible);
  const protocol = yield* Protocol.make(writeRequest_ => {
    writeRequest = writeRequest_;
    return Effect.succeed({
      disconnects,
      send(clientId, response) {
        const client = clients.get(clientId);
        if (!client) return Effect.void;
        return client.write(response);
      },
      end(clientId) {
        const client = clients.get(clientId);
        if (!client) return Effect.void;
        return client.end;
      },
      clientIds: Effect.sync(() => clients.keys()),
      initialMessage: Effect.succeedNone,
      supportsAck: false,
      supportsTransferables: false,
      supportsSpanPropagation: false
    });
  });
  return {
    protocol,
    httpApp
  };
});
/**
 * @since 1.0.0
 * @category protocol
 */
export const makeProtocolHttp = /*#__PURE__*/Effect.fnUntraced(function* (options) {
  const {
    httpApp,
    protocol
  } = yield* makeProtocolWithHttpApp;
  const router = yield* options.routerTag ?? HttpRouter.Default;
  yield* router.post(options.path, httpApp);
  return protocol;
});
/**
 * @since 1.0.0
 * @category protocol
 */
export const makeProtocolHttpRouter = /*#__PURE__*/Effect.fnUntraced(function* (options) {
  const router = yield* HttpLayerRouter.HttpRouter;
  const {
    httpApp,
    protocol
  } = yield* makeProtocolWithHttpApp;
  yield* router.add("POST", options.path, httpApp);
  return protocol;
});
/**
 * @since 1.0.0
 * @category protocol
 */
export const makeProtocolWorkerRunner = /*#__PURE__*/Protocol.make(/*#__PURE__*/Effect.fnUntraced(function* (writeRequest) {
  const fiber = yield* Effect.withFiberRuntime(Effect.succeed);
  const runner = yield* WorkerRunner.PlatformRunner;
  const closeLatch = yield* WorkerRunner.CloseLatch;
  const backing = yield* runner.start(closeLatch);
  const initialMessage = yield* Deferred.make();
  const clientIds = new Set();
  const disconnects = yield* Mailbox.make();
  yield* Deferred.await(closeLatch).pipe(Effect.onExit(() => {
    fiber.currentScheduler.scheduleTask(() => fiber.unsafeInterruptAsFork(fiber.id()), 0);
    return Effect.void;
  }), Effect.forkScoped);
  yield* backing.run((clientId, message) => {
    clientIds.add(clientId);
    if (message._tag === "InitialMessage") {
      return Deferred.succeed(initialMessage, message.value);
    }
    return writeRequest(clientId, message);
  });
  yield* disconnects.take.pipe(Effect.tap(clientId => {
    clientIds.delete(clientId);
    return disconnects.offer(clientId);
  }), Effect.forkScoped);
  return {
    disconnects,
    send: backing.send,
    end(_clientId) {
      return Effect.void;
    },
    clientIds: Effect.sync(() => clientIds.values()),
    initialMessage: Effect.asSome(Deferred.await(initialMessage)),
    supportsAck: true,
    supportsTransferables: true,
    supportsSpanPropagation: true
  };
}));
/**
 * @since 1.0.0
 * @category protocol
 */
export const layerProtocolWorkerRunner = /*#__PURE__*/Layer.scoped(Protocol, makeProtocolWorkerRunner);
/**
 * A rpc protocol that uses streaming http for communication.
 *
 * @since 1.0.0
 * @category protocol
 */
export const layerProtocolHttp = options => {
  const routerTag = options.routerTag ?? HttpRouter.Default;
  return Layer.effect(Protocol, makeProtocolHttp(options)).pipe(Layer.provide(routerTag.Live));
};
/**
 * A rpc protocol that uses streaming http for communication.
 *
 * Uses a `HttpLayerRouter` to provide the http endpoint.
 *
 * @since 1.0.0
 * @category protocol
 */
export const layerProtocolHttpRouter = options => Layer.effect(Protocol, makeProtocolHttpRouter(options));
/**
 * @since 1.0.0
 * @category http app
 */
export const toHttpApp = /*#__PURE__*/Effect.fnUntraced(function* (group, options) {
  const {
    httpApp,
    protocol
  } = yield* makeProtocolWithHttpApp;
  yield* make(group, options).pipe(Effect.provideService(Protocol, protocol), Effect.interruptible, Effect.forkScoped);
  return httpApp;
});
/**
 * @since 1.0.0
 * @category http app
 */
export const toHttpAppWebsocket = /*#__PURE__*/Effect.fnUntraced(function* (group, options) {
  const {
    httpApp,
    protocol
  } = yield* makeProtocolWithHttpAppWebsocket;
  yield* make(group, options).pipe(Effect.provideService(Protocol, protocol), Effect.interruptible, Effect.forkScoped);
  return httpApp;
});
/**
 * Construct an http web handler from an `RpcGroup`.
 *
 * @since 1.0.0
 * @category constructors
 */
export const toWebHandler = (group, options) => HttpApp.toWebHandlerLayerWith(Layer.mergeAll(options.layer, Layer.scope), {
  memoMap: options?.memoMap,
  middleware: options?.middleware,
  toHandler: r => Effect.provide(toHttpApp(group, options), r)
});
/**
 * Create a protocol that uses the provided `Stream` and `Sink` for communication.
 *
 * @since 1.0.0
 * @category protocol
 */
export const makeProtocolStdio = /*#__PURE__*/Effect.fnUntraced(function* (options) {
  const fiber = Option.getOrThrow(Fiber.getCurrentFiber());
  const serialization = yield* RpcSerialization.RpcSerialization;
  return yield* Protocol.make(Effect.fnUntraced(function* (writeRequest) {
    const mailbox = yield* Mailbox.make();
    const parser = serialization.unsafeMake();
    yield* options.stdin.pipe(Stream.runForEach(data => {
      const decoded = parser.decode(data);
      if (decoded.length === 0) return Effect.void;
      let i = 0;
      return Effect.whileLoop({
        while: () => i < decoded.length,
        body: () => writeRequest(0, decoded[i++]),
        step: constVoid
      });
    }), Effect.sandbox, Effect.tapError(Effect.logError), Effect.retry(Schedule.spaced(500)), Effect.tap(Effect.log("Stdio protocol stdin stream completed")), Effect.ensuring(Fiber.interruptFork(fiber)), Effect.forkScoped, Effect.interruptible);
    yield* Mailbox.toStream(mailbox).pipe(Stream.run(options.stdout), Effect.retry(Schedule.spaced(500)), Effect.forkScoped, Effect.interruptible);
    return {
      disconnects: yield* Mailbox.make(),
      send(_clientId, response) {
        const responseEncoded = parser.encode(response);
        if (responseEncoded === undefined) {
          return Effect.void;
        }
        return mailbox.offer(responseEncoded);
      },
      end(_clientId) {
        return mailbox.end;
      },
      clientIds: Effect.succeed([0]),
      initialMessage: Effect.succeedNone,
      supportsAck: true,
      supportsTransferables: false,
      supportsSpanPropagation: true
    };
  }));
});
/**
 * Create a protocol that uses the provided `Stream` and `Sink` for communication.
 *
 * @since 1.0.0
 * @category protocol
 */
export const layerProtocolStdio = options => Layer.scoped(Protocol, makeProtocolStdio(options));
// internal
const makeSocketProtocol = /*#__PURE__*/Effect.gen(function* () {
  const serialization = yield* RpcSerialization.RpcSerialization;
  const disconnects = yield* Mailbox.make();
  let clientId = 0;
  const clients = new Map();
  let writeRequest;
  const onSocket = function* (socket) {
    const scope = yield* Effect.scope;
    const parser = serialization.unsafeMake();
    const id = clientId++;
    yield* Scope.addFinalizerExit(scope, () => {
      clients.delete(id);
      return disconnects.offer(id);
    });
    const writeRaw = yield* socket.writer;
    const write = response => {
      try {
        const encoded = parser.encode(response);
        if (encoded === undefined) {
          return Effect.void;
        }
        return Effect.orDie(writeRaw(encoded));
      } catch (cause) {
        return Effect.orDie(writeRaw(parser.encode(ResponseDefectEncoded(cause))));
      }
    };
    clients.set(id, {
      write
    });
    yield* socket.runRaw(data => {
      try {
        const decoded = parser.decode(data);
        if (decoded.length === 0) return Effect.void;
        let i = 0;
        return Effect.whileLoop({
          while: () => i < decoded.length,
          body: () => writeRequest(id, decoded[i++]),
          step: constVoid
        });
      } catch (cause) {
        return writeRaw(parser.encode(ResponseDefectEncoded(cause)));
      }
    }).pipe(Effect.interruptible, Effect.catchIf(error => error.reason === "Close", () => Effect.void), Effect.orDie);
  };
  const protocol = yield* Protocol.make(writeRequest_ => {
    writeRequest = writeRequest_;
    return Effect.succeed({
      disconnects,
      send: (clientId, response) => {
        const client = clients.get(clientId);
        if (!client) return Effect.void;
        return Effect.orDie(client.write(response));
      },
      end(_clientId) {
        return Effect.void;
      },
      clientIds: Effect.sync(() => clients.keys()),
      initialMessage: Effect.succeedNone,
      supportsAck: true,
      supportsTransferables: false,
      supportsSpanPropagation: true
    });
  });
  return {
    protocol,
    onSocket
  };
});
//# sourceMappingURL=RpcServer.js.map