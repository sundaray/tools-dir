/**
 * @since 1.0.0
 */
import * as HttpApiEndpoint from "@effect/platform/HttpApiEndpoint";
import * as HttpApiGroup from "@effect/platform/HttpApiGroup";
import * as Rpc from "@effect/rpc/Rpc";
import * as RpcGroup from "@effect/rpc/RpcGroup";
import * as Schema from "effect/Schema";
import { AlreadyProcessingMessage, EntityNotManagedByRunner, MailboxFull, PersistenceError } from "./ClusterError.js";
import type * as Entity from "./Entity.js";
/**
 * Derives an `RpcGroup` from an `Entity`.
 *
 * ```ts
 * import { ClusterSchema, Entity, EntityProxy, EntityProxyServer } from "@effect/cluster"
 * import { Rpc, RpcServer } from "@effect/rpc"
 * import { Layer, Schema } from "effect"
 *
 * export const Counter = Entity.make("Counter", [
 *   Rpc.make("Increment", {
 *     payload: { id: Schema.String, amount: Schema.Number },
 *     primaryKey: ({ id }) => id,
 *     success: Schema.Number
 *   })
 * ]).annotateRpcs(ClusterSchema.Persisted, true)
 *
 * // Use EntityProxy.toRpcGroup to create a `RpcGroup` from the Counter entity
 * export class MyRpcs extends EntityProxy.toRpcGroup(Counter) {}
 *
 * // Use EntityProxyServer.layerRpcHandlers to create a layer that implements
 * // the rpc handlers
 * const RpcServerLayer = RpcServer.layer(MyRpcs).pipe(
 *   Layer.provide(EntityProxyServer.layerRpcHandlers(Counter))
 * )
 * ```
 *
 * @since 1.0.0
 * @category Constructors
 */
export declare const toRpcGroup: <Type extends string, Rpcs extends Rpc.Any>(entity: Entity.Entity<Type, Rpcs>) => RpcGroup.RpcGroup<ConvertRpcs<Rpcs, Type>>;
/**
 * @since 1.0.0
 */
export type ConvertRpcs<Rpcs extends Rpc.Any, Prefix extends string> = Rpcs extends Rpc.Rpc<infer _Tag, infer _Payload, infer _Success, infer _Error, infer _Middleware> ? Rpc.Rpc<`${Prefix}.${_Tag}`, Schema.Struct<{
    entityId: typeof Schema.String;
    payload: _Payload;
}>, _Success, Schema.Schema<_Error["Type"] | MailboxFull | AlreadyProcessingMessage | PersistenceError | EntityNotManagedByRunner, _Error["Encoded"] | typeof MailboxFull["Encoded"] | typeof AlreadyProcessingMessage["Encoded"] | typeof PersistenceError["Encoded"] | typeof EntityNotManagedByRunner["Encoded"], _Error["Context"]>> | Rpc.Rpc<`${Prefix}.${_Tag}Discard`, Schema.Struct<{
    entityId: typeof Schema.String;
    payload: _Payload;
}>, typeof Schema.Void, Schema.Union<[
    typeof MailboxFull,
    typeof AlreadyProcessingMessage,
    typeof PersistenceError,
    typeof EntityNotManagedByRunner
]>> : never;
/**
 * Derives an `HttpApiGroup` from an `Entity`.
 *
 * ```ts
 * import { ClusterSchema, Entity, EntityProxy, EntityProxyServer } from "@effect/cluster"
 * import { HttpApi, HttpApiBuilder } from "@effect/platform"
 * import { Rpc } from "@effect/rpc"
 * import { Layer, Schema } from "effect"
 *
 * export const Counter = Entity.make("Counter", [
 *   Rpc.make("Increment", {
 *     payload: { id: Schema.String, amount: Schema.Number },
 *     primaryKey: ({ id }) => id,
 *     success: Schema.Number
 *   })
 * ]).annotateRpcs(ClusterSchema.Persisted, true)
 *
 * // Use EntityProxy.toHttpApiGroup to create a `HttpApiGroup` from the
 * // Counter entity
 * export class MyApi extends HttpApi.make("api")
 *   .add(
 *     EntityProxy.toHttpApiGroup("counter", Counter)
 *       .prefix("/counter")
 *   )
 * {}
 *
 * // Use EntityProxyServer.layerHttpApi to create a layer that implements
 * // the handlers for the HttpApiGroup
 * const ApiLayer = HttpApiBuilder.api(MyApi).pipe(
 *   Layer.provide(EntityProxyServer.layerHttpApi(MyApi, "counter", Counter))
 * )
 * ```
 *
 * @since 1.0.0
 * @category Constructors
 */
export declare const toHttpApiGroup: <const Name extends string, Type extends string, Rpcs extends Rpc.Any>(name: Name, entity: Entity.Entity<Type, Rpcs>) => HttpApiGroup.HttpApiGroup<Name, ConvertHttpApi<Rpcs>>;
/**
 * @since 1.0.0
 */
export type ConvertHttpApi<Rpcs extends Rpc.Any> = Rpcs extends Rpc.Rpc<infer _Tag, infer _Payload, infer _Success, infer _Error, infer _Middleware> ? HttpApiEndpoint.HttpApiEndpoint<_Tag, "POST", {
    readonly entityId: string;
}, never, _Payload["Type"], never, _Success["Type"], _Error["Type"] | MailboxFull | AlreadyProcessingMessage | PersistenceError | EntityNotManagedByRunner, _Payload["Context"] | _Success["Context"], _Error["Context"]> | HttpApiEndpoint.HttpApiEndpoint<`${_Tag}Discard`, "POST", {
    readonly entityId: string;
}, never, _Payload["Type"], never, void, MailboxFull | AlreadyProcessingMessage | PersistenceError | EntityNotManagedByRunner> : never;
//# sourceMappingURL=EntityProxy.d.ts.map