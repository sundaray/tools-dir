/**
 * @since 1.0.0
 */
import * as Equal from "effect/Equal";
import * as Hash from "effect/Hash";
import * as S from "effect/Schema";
/**
 * @since 1.0.0
 * @category Symbols
 */
export declare const TypeId: unique symbol;
/**
 * @since 1.0.0
 * @category Symbols
 */
export type TypeId = typeof TypeId;
/**
 * @since 1.0.0
 * @category Constructors
 */
export declare const make: (group: string, id: number) => ShardId;
declare const ShardId_base: S.Class<ShardId, {
    group: typeof S.String;
    id: typeof S.Int;
}, S.Struct.Encoded<{
    group: typeof S.String;
    id: typeof S.Int;
}>, never, {
    readonly group: string;
} & {
    readonly id: number;
}, {}, {}>;
/**
 * @since 1.0.0
 * @category Models
 */
export declare class ShardId extends ShardId_base {
    /**
     * @since 1.0.0
     */
    readonly [TypeId]: TypeId;
    /**
     * @since 1.0.0
     */
    [Equal.symbol](that: ShardId): boolean;
    /**
     * @since 1.0.0
     */
    [Hash.symbol](): number;
    /**
     * @since 1.0.0
     */
    toString(): string;
    /**
     * @since 1.0.0
     */
    static toString(shardId: {
        readonly group: string;
        readonly id: number;
    }): string;
    /**
     * @since 1.0.0
     */
    static fromStringEncoded(s: string): {
        readonly group: string;
        readonly id: number;
    };
    /**
     * @since 1.0.0
     */
    static fromString(s: string): ShardId;
}
export {};
//# sourceMappingURL=ShardId.d.ts.map