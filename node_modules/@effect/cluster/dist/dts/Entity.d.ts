/**
 * @since 1.0.0
 */
import type * as Rpc from "@effect/rpc/Rpc";
import * as RpcClient from "@effect/rpc/RpcClient";
import * as RpcGroup from "@effect/rpc/RpcGroup";
import type { Brand } from "effect/Brand";
import type * as Cause from "effect/Cause";
import * as Context from "effect/Context";
import * as Data from "effect/Data";
import type { DurationInput } from "effect/Duration";
import * as Effect from "effect/Effect";
import * as Equal from "effect/Equal";
import * as Exit from "effect/Exit";
import * as Layer from "effect/Layer";
import * as Mailbox from "effect/Mailbox";
import * as Option from "effect/Option";
import type * as Schedule from "effect/Schedule";
import { Scope } from "effect/Scope";
import type * as Stream from "effect/Stream";
import type { AlreadyProcessingMessage, EntityNotManagedByRunner, MailboxFull, PersistenceError } from "./ClusterError.js";
import { EntityAddress } from "./EntityAddress.js";
import type { EntityId } from "./EntityId.js";
import * as Envelope from "./Envelope.js";
import type * as Reply from "./Reply.js";
import { RunnerAddress } from "./RunnerAddress.js";
import * as ShardId from "./ShardId.js";
import type { Sharding } from "./Sharding.js";
import { ShardingConfig } from "./ShardingConfig.js";
/**
 * @since 1.0.0
 * @category type ids
 */
export declare const TypeId: unique symbol;
/**
 * @since 1.0.0
 * @category type ids
 */
export type TypeId = typeof TypeId;
/**
 * @since 1.0.0
 * @category models
 */
export interface Entity<in out Type extends string, in out Rpcs extends Rpc.Any> extends Equal.Equal {
    readonly [TypeId]: TypeId;
    /**
     * The name of the entity type.
     */
    readonly type: Type & Brand<"EntityType">;
    /**
     * A RpcGroup definition for messages which represents the messaging protocol
     * that the entity is capable of processing.
     */
    readonly protocol: RpcGroup.RpcGroup<Rpcs>;
    /**
     * Get the shard group for the given EntityId.
     */
    getShardGroup(entityId: EntityId): string;
    /**
     * Get the ShardId for the given EntityId.
     */
    getShardId(entityId: EntityId): Effect.Effect<ShardId.ShardId, never, Sharding>;
    /**
     * Annotate the entity with a value.
     */
    annotate<I, S>(tag: Context.Tag<I, S>, value: S): Entity<Type, Rpcs>;
    /**
     * Annotate the Rpc's above this point with a value.
     */
    annotateRpcs<I, S>(tag: Context.Tag<I, S>, value: S): Entity<Type, Rpcs>;
    /**
     * Annotate the entity with a context object.
     */
    annotateContext<S>(context: Context.Context<S>): Entity<Type, Rpcs>;
    /**
     * Annotate the Rpc's above this point with a context object.
     */
    annotateRpcsContext<S>(context: Context.Context<S>): Entity<Type, Rpcs>;
    /**
     * Create a client for this entity.
     */
    readonly client: Effect.Effect<(entityId: string) => RpcClient.RpcClient.From<Rpcs, MailboxFull | AlreadyProcessingMessage | PersistenceError | EntityNotManagedByRunner>, never, Sharding>;
    /**
     * Create a Layer from an Entity.
     *
     * It will register the entity with the Sharding service.
     */
    toLayer<Handlers extends HandlersFrom<Rpcs>, RX = never>(build: Handlers | Effect.Effect<Handlers, never, RX>, options?: {
        readonly maxIdleTime?: DurationInput | undefined;
        readonly concurrency?: number | "unbounded" | undefined;
        readonly mailboxCapacity?: number | "unbounded" | undefined;
        readonly disableFatalDefects?: boolean | undefined;
        readonly defectRetryPolicy?: Schedule.Schedule<any, unknown> | undefined;
        readonly spanAttributes?: Record<string, string> | undefined;
    }): Layer.Layer<never, never, Exclude<RX, Scope | CurrentAddress | CurrentRunnerAddress> | RpcGroup.HandlersContext<Rpcs, Handlers> | Rpc.Context<Rpcs> | Rpc.Middleware<Rpcs> | Sharding>;
    of<Handlers extends HandlersFrom<Rpcs>>(handlers: Handlers): Handlers;
    /**
     * Create a Layer from an Entity.
     *
     * It will register the entity with the Sharding service.
     */
    toLayerMailbox<R, RX = never>(build: ((mailbox: Mailbox.ReadonlyMailbox<Envelope.Request<Rpcs>>, replier: Replier<Rpcs>) => Effect.Effect<never, never, R>) | Effect.Effect<(mailbox: Mailbox.ReadonlyMailbox<Envelope.Request<Rpcs>>, replier: Replier<Rpcs>) => Effect.Effect<never, never, R>, never, RX>, options?: {
        readonly maxIdleTime?: DurationInput | undefined;
        readonly mailboxCapacity?: number | "unbounded" | undefined;
        readonly disableFatalDefects?: boolean | undefined;
        readonly defectRetryPolicy?: Schedule.Schedule<any, unknown> | undefined;
        readonly spanAttributes?: Record<string, string> | undefined;
    }): Layer.Layer<never, never, Exclude<RX, Scope | CurrentAddress | CurrentRunnerAddress> | R | Rpc.Context<Rpcs> | Rpc.Middleware<Rpcs> | Sharding>;
}
/**
 * @since 1.0.0
 * @category models
 */
export type Any = Entity<string, Rpc.Any>;
/**
 * @since 1.0.0
 * @category models
 */
export type HandlersFrom<Rpc extends Rpc.Any> = {
    readonly [Current in Rpc as Current["_tag"]]: (envelope: Request<Current>) => Rpc.ResultFrom<Current, any> | Rpc.Fork<Rpc.ResultFrom<Current, any>>;
};
/**
 * @since 1.0.0
 * @category refinements
 */
export declare const isEntity: (u: unknown) => u is Any;
/**
 * Creates a new `Entity` of the specified `type` which will accept messages
 * that adhere to the provided `RpcGroup`.
 *
 * @since 1.0.0
 * @category constructors
 */
export declare const fromRpcGroup: <const Type extends string, Rpcs extends Rpc.Any>(
/**
 * The entity type name.
 */
type: Type, 
/**
 * The schema definition for messages that the entity is capable of
 * processing.
 */
protocol: RpcGroup.RpcGroup<Rpcs>) => Entity<Type, Rpcs>;
/**
 * Creates a new `Entity` of the specified `type` which will accept messages
 * that adhere to the provided schemas.
 *
 * @since 1.0.0
 * @category constructors
 */
export declare const make: <const Type extends string, Rpcs extends ReadonlyArray<Rpc.Any>>(
/**
 * The entity type name.
 */
type: Type, 
/**
 * The schema definition for messages that the entity is capable of
 * processing.
 */
protocol: Rpcs) => Entity<Type, Rpcs[number]>;
declare const CurrentAddress_base: Context.TagClass<CurrentAddress, "@effect/cluster/Entity/EntityAddress", EntityAddress>;
/**
 * A Context.Tag to access the current entity address.
 *
 * @since 1.0.0
 * @category context
 */
export declare class CurrentAddress extends CurrentAddress_base {
}
declare const CurrentRunnerAddress_base: Context.TagClass<CurrentRunnerAddress, "@effect/cluster/Entity/RunnerAddress", RunnerAddress>;
/**
 * A Context.Tag to access the current Runner address.
 *
 * @since 1.0.0
 * @category context
 */
export declare class CurrentRunnerAddress extends CurrentRunnerAddress_base {
}
/**
 * @since 1.0.0
 * @category Replier
 */
export interface Replier<Rpcs extends Rpc.Any> {
    readonly succeed: <R extends Rpcs>(request: Envelope.Request<R>, value: Replier.Success<R>) => Effect.Effect<void>;
    readonly fail: <R extends Rpcs>(request: Envelope.Request<R>, error: Rpc.Error<R>) => Effect.Effect<void>;
    readonly failCause: <R extends Rpcs>(request: Envelope.Request<R>, cause: Cause.Cause<Rpc.Error<R>>) => Effect.Effect<void>;
    readonly complete: <R extends Rpcs>(request: Envelope.Request<R>, exit: Exit.Exit<Replier.Success<R>, Rpc.Error<R>>) => Effect.Effect<void>;
}
/**
 * @since 1.0.0
 * @category Replier
 */
export declare namespace Replier {
    /**
     * @since 1.0.0
     * @category Replier
     */
    type Success<R extends Rpc.Any> = Rpc.Success<R> extends Stream.Stream<infer _A, infer _E, infer _R> ? Stream.Stream<_A, _E | Rpc.Error<R>, _R> | Mailbox.ReadonlyMailbox<_A, _E | Rpc.Error<R>> : Rpc.Success<R>;
}
/**
 * @since 1.0.0
 * @category Request
 */
export declare class Request<Rpc extends Rpc.Any> extends Data.Class<Envelope.Request<Rpc> & {
    readonly lastSentChunk: Option.Option<Reply.Chunk<Rpc>>;
}> {
    /**
     * @since 1.0.0
     */
    get lastSentChunkValue(): Option.Option<Rpc.SuccessChunk<Rpc>>;
    /**
     * @since 1.0.0
     */
    get nextSequence(): number;
}
/**
 * @since 1.0.0
 * @category Testing
 */
export declare const makeTestClient: <Type extends string, Rpcs extends Rpc.Any, LA, LE, LR>(entity: Entity<Type, Rpcs>, layer: Layer.Layer<LA, LE, LR>) => Effect.Effect<(entityId: string) => Effect.Effect<RpcClient.RpcClient<Rpcs>>, LE, Scope | ShardingConfig | Exclude<LR, Sharding> | Rpc.MiddlewareClient<Rpcs>>;
export {};
//# sourceMappingURL=Entity.d.ts.map