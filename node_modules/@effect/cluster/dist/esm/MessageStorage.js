import * as Arr from "effect/Array";
import * as Context from "effect/Context";
import * as Data from "effect/Data";
import * as Effect from "effect/Effect";
import * as Exit from "effect/Exit";
import * as FiberRef from "effect/FiberRef";
import { globalValue } from "effect/GlobalValue";
import * as Layer from "effect/Layer";
import * as Option from "effect/Option";
import * as Schema from "effect/Schema";
import { MalformedMessage } from "./ClusterError.js";
import * as DeliverAt from "./DeliverAt.js";
import * as Envelope from "./Envelope.js";
import * as Message from "./Message.js";
import * as Reply from "./Reply.js";
import { ShardId } from "./ShardId.js";
import * as Snowflake from "./Snowflake.js";
/**
 * @since 1.0.0
 * @category context
 */
export class MessageStorage extends /*#__PURE__*/Context.Tag("@effect/cluster/MessageStorage")() {}
/**
 * @since 1.0.0
 * @category SaveResult
 */
export const SaveResult = /*#__PURE__*/Data.taggedEnum();
/**
 * @since 1.0.0
 * @category SaveResult
 */
export const SaveResultEncoded = /*#__PURE__*/Data.taggedEnum();
/**
 * @since 1.0.0
 * @category constructors
 */
export const make = storage => Effect.sync(() => {
  const replyHandlers = new Map();
  return MessageStorage.of({
    ...storage,
    registerReplyHandler: message => Effect.sync(() => {
      replyHandlers.set(message.envelope.requestId, message._tag === "IncomingRequest" ? message.respond : reply => message.respond(reply.reply));
    }),
    saveReply(reply) {
      return Effect.flatMap(storage.saveReply(reply), () => {
        const handler = replyHandlers.get(reply.reply.requestId);
        if (!handler) {
          return Effect.void;
        } else if (reply.reply._tag === "WithExit") {
          replyHandlers.delete(reply.reply.requestId);
        }
        return handler(reply);
      });
    }
  });
});
/**
 * @since 1.0.0
 * @category constructors
 */
export const makeEncoded = /*#__PURE__*/Effect.fnUntraced(function* (encoded) {
  const snowflakeGen = yield* Snowflake.Generator;
  const clock = yield* Effect.clock;
  const storage = yield* make({
    saveRequest: message => Message.serializeEnvelope(message).pipe(Effect.flatMap(envelope => encoded.saveEnvelope({
      envelope,
      primaryKey: Envelope.primaryKey(message.envelope),
      deliverAt: DeliverAt.toMillis(message.envelope.payload)
    })), Effect.flatMap(result => {
      if (result._tag === "Success" || result.lastReceivedReply._tag === "None") {
        return Effect.succeed(result);
      }
      const duplicate = result;
      const schema = Reply.Reply(message.rpc);
      return Schema.decode(schema)(result.lastReceivedReply.value).pipe(Effect.locally(FiberRef.currentContext, message.context), MalformedMessage.refail, Effect.map(reply => SaveResult.Duplicate({
        originalId: duplicate.originalId,
        lastReceivedReply: Option.some(reply)
      })));
    })),
    saveEnvelope: message => Message.serializeEnvelope(message).pipe(Effect.flatMap(envelope => encoded.saveEnvelope({
      envelope,
      primaryKey: null,
      deliverAt: null
    })), Effect.asVoid),
    saveReply: reply => Effect.flatMap(Reply.serialize(reply), encoded.saveReply),
    clearReplies: encoded.clearReplies,
    repliesFor: Effect.fnUntraced(function* (messages) {
      const requestIds = Arr.empty();
      const map = new Map();
      for (const message of messages) {
        const id = String(message.envelope.requestId);
        requestIds.push(id);
        map.set(id, message);
      }
      if (requestIds.length === 0) return [];
      const encodedReplies = yield* encoded.repliesFor(requestIds);
      return yield* decodeReplies(map, encodedReplies);
    }),
    repliesForUnfiltered: ids => encoded.repliesForUnfiltered(Array.from(ids, String)),
    requestIdForPrimaryKey(options) {
      const primaryKey = Envelope.primaryKeyByAddress(options);
      return encoded.requestIdForPrimaryKey(primaryKey);
    },
    unprocessedMessages: shardIds => {
      const shards = Array.from(shardIds);
      if (shards.length === 0) return Effect.succeed([]);
      return Effect.flatMap(Effect.suspend(() => encoded.unprocessedMessages(shards.map(id => id.toString()), clock.unsafeCurrentTimeMillis())), decodeMessages);
    },
    unprocessedMessagesById(messageIds) {
      const ids = Array.from(messageIds);
      if (ids.length === 0) return Effect.succeed([]);
      return Effect.flatMap(Effect.suspend(() => encoded.unprocessedMessagesById(ids, clock.unsafeCurrentTimeMillis())), decodeMessages);
    },
    resetAddress: encoded.resetAddress,
    clearAddress: encoded.clearAddress,
    resetShards: shardIds => encoded.resetShards(Array.from(shardIds, id => id.toString()))
  });
  const decodeMessages = envelopes => {
    const messages = [];
    let index = 0;
    // if we have a malformed message, we should not return it and update
    // the storage with a defect
    const decodeMessage = Effect.catchAll(Effect.suspend(() => {
      const envelope = envelopes[index];
      if (!envelope) return Effect.succeed(undefined);
      return decodeEnvelopeWithReply(envelope);
    }), error => {
      const envelope = envelopes[index];
      return storage.saveReply(Reply.ReplyWithContext.fromDefect({
        id: snowflakeGen.unsafeNext(),
        requestId: Snowflake.Snowflake(envelope.envelope.requestId),
        defect: error.toString()
      })).pipe(Effect.forkDaemon, Effect.asVoid);
    });
    return Effect.as(Effect.whileLoop({
      while: () => index < envelopes.length,
      body: () => decodeMessage,
      step: message => {
        const envelope = envelopes[index++];
        if (!message) return;
        messages.push(message.envelope._tag === "Request" ? new Message.IncomingRequest({
          envelope: message.envelope,
          lastSentReply: envelope.lastSentReply,
          respond: storage.saveReply
        }) : new Message.IncomingEnvelope({
          envelope: message.envelope
        }));
      }
    }), messages);
  };
  const decodeReplies = (messages, encodedReplies) => {
    const replies = [];
    const ignoredRequests = new Set();
    let index = 0;
    const decodeReply = Effect.catchAll(Effect.suspend(() => {
      const reply = encodedReplies[index];
      if (ignoredRequests.has(reply.requestId)) return Effect.void;
      const message = messages.get(reply.requestId);
      if (!message) return Effect.void;
      const schema = Reply.Reply(message.rpc);
      return Schema.decode(schema)(reply).pipe(Effect.locally(FiberRef.currentContext, message.context));
    }), error => {
      const reply = encodedReplies[index];
      ignoredRequests.add(reply.requestId);
      return Effect.succeed(new Reply.WithExit({
        id: snowflakeGen.unsafeNext(),
        requestId: Snowflake.Snowflake(reply.requestId),
        exit: Exit.die(error)
      }));
    });
    return Effect.as(Effect.whileLoop({
      while: () => index < encodedReplies.length,
      body: () => decodeReply,
      step: reply => {
        index++;
        if (reply) replies.push(reply);
      }
    }), replies);
  };
  return storage;
});
/**
 * @since 1.0.0
 * @category Constructors
 */
export const noop = /*#__PURE__*/globalValue("@effect/cluster/MessageStorage/noop", () => Effect.runSync(make({
  saveRequest: () => Effect.succeed(SaveResult.Success()),
  saveEnvelope: () => Effect.void,
  saveReply: () => Effect.void,
  clearReplies: () => Effect.void,
  repliesFor: () => Effect.succeed([]),
  repliesForUnfiltered: () => Effect.succeed([]),
  requestIdForPrimaryKey: () => Effect.succeedNone,
  unprocessedMessages: () => Effect.succeed([]),
  unprocessedMessagesById: () => Effect.succeed([]),
  resetAddress: () => Effect.void,
  clearAddress: () => Effect.void,
  resetShards: () => Effect.void
})));
/**
 * @since 1.0.0
 * @category Memory
 */
export class MemoryDriver extends /*#__PURE__*/Effect.Service()("@effect/cluster/MessageStorage/MemoryDriver", {
  dependencies: [Snowflake.layerGenerator],
  effect: /*#__PURE__*/Effect.gen(function* () {
    const clock = yield* Effect.clock;
    const requests = new Map();
    const requestsByPrimaryKey = new Map();
    const unprocessed = new Set();
    const replyIds = new Set();
    const journal = [];
    const cursors = new WeakMap();
    const unprocessedWith = predicate => {
      const messages = [];
      const now = clock.unsafeCurrentTimeMillis();
      for (const envelope of unprocessed) {
        if (!predicate(envelope)) {
          continue;
        }
        if (envelope._tag === "Request") {
          const entry = requests.get(envelope.requestId);
          if (entry?.deliverAt && entry.deliverAt > now) {
            continue;
          }
          messages.push({
            envelope,
            lastSentReply: Option.fromNullable(entry?.replies[entry.replies.length - 1])
          });
        } else {
          messages.push({
            envelope,
            lastSentReply: Option.none()
          });
        }
      }
      return messages;
    };
    const replyLatch = yield* Effect.makeLatch();
    function repliesFor(requestIds) {
      const replies = Arr.empty();
      for (const requestId of requestIds) {
        const request = requests.get(requestId);
        if (!request) continue;else if (Option.isNone(request.lastReceivedChunk)) {
          // eslint-disable-next-line no-restricted-syntax
          replies.push(...request.replies);
          continue;
        }
        const sequence = request.lastReceivedChunk.value.sequence;
        for (const reply of request.replies) {
          if (reply._tag === "Chunk" && reply.sequence <= sequence) {
            continue;
          }
          replies.push(reply);
        }
      }
      return replies;
    }
    const encoded = {
      saveEnvelope: ({
        deliverAt,
        envelope: envelope_,
        primaryKey
      }) => Effect.sync(() => {
        const envelope = JSON.parse(JSON.stringify(envelope_));
        const existing = primaryKey ? requestsByPrimaryKey.get(primaryKey) : envelope._tag === "Request" && requests.get(envelope.requestId);
        if (existing) {
          return SaveResultEncoded.Duplicate({
            originalId: Snowflake.Snowflake(existing.envelope.requestId),
            lastReceivedReply: existing.replies.length === 1 && existing.replies[0]._tag === "WithExit" ? Option.some(existing.replies[0]) : existing.lastReceivedChunk
          });
        }
        if (envelope._tag === "Request") {
          const entry = {
            envelope,
            replies: [],
            lastReceivedChunk: Option.none(),
            deliverAt
          };
          requests.set(envelope.requestId, entry);
          if (primaryKey) {
            requestsByPrimaryKey.set(primaryKey, entry);
          }
        } else if (envelope._tag === "AckChunk") {
          const entry = requests.get(envelope.requestId);
          if (entry) {
            entry.lastReceivedChunk = Arr.findFirst(entry.replies, r => r._tag === "Chunk" && r.id === envelope.replyId).pipe(Option.orElse(() => entry.lastReceivedChunk));
          }
        }
        unprocessed.add(envelope);
        journal.push(envelope);
        return SaveResultEncoded.Success();
      }),
      saveReply: reply_ => Effect.sync(() => {
        const reply = JSON.parse(JSON.stringify(reply_));
        const entry = requests.get(reply.requestId);
        if (!entry || replyIds.has(reply.id)) return;
        if (reply._tag === "WithExit") {
          unprocessed.delete(entry.envelope);
        }
        entry.replies.push(reply);
        replyIds.add(reply.id);
        replyLatch.unsafeOpen();
      }),
      clearReplies: id => Effect.sync(() => {
        const entry = requests.get(String(id));
        if (!entry) return;
        entry.replies = [];
        entry.lastReceivedChunk = Option.none();
        unprocessed.add(entry.envelope);
      }),
      requestIdForPrimaryKey: primaryKey => Effect.sync(() => {
        const entry = requestsByPrimaryKey.get(primaryKey);
        return Option.fromNullable(entry?.envelope.requestId).pipe(Option.map(Snowflake.Snowflake));
      }),
      repliesFor: requestIds => Effect.sync(() => repliesFor(requestIds)),
      repliesForUnfiltered: requestIds => Effect.sync(() => requestIds.flatMap(id => requests.get(String(id))?.replies ?? [])),
      unprocessedMessages: shardIds => Effect.sync(() => {
        if (unprocessed.size === 0) return [];
        const now = clock.unsafeCurrentTimeMillis();
        const messages = Arr.empty();
        for (let index = 0; index < journal.length; index++) {
          const envelope = journal[index];
          const shardId = ShardId.make(envelope.address.shardId);
          if (!unprocessed.has(envelope) || !shardIds.includes(shardId.toString())) {
            continue;
          }
          if (envelope._tag === "Request") {
            const entry = requests.get(envelope.requestId);
            if (entry.deliverAt && entry.deliverAt > now) {
              continue;
            }
            messages.push({
              envelope,
              lastSentReply: Arr.last(entry.replies)
            });
          } else {
            messages.push({
              envelope,
              lastSentReply: Option.none()
            });
            unprocessed.delete(envelope);
          }
        }
        return messages;
      }),
      unprocessedMessagesById: ids => Effect.sync(() => {
        const envelopeIds = new Set();
        for (const id of ids) {
          envelopeIds.add(String(id));
        }
        return unprocessedWith(envelope => envelopeIds.has(envelope.requestId));
      }),
      resetAddress: () => Effect.void,
      clearAddress: address => Effect.sync(() => {
        for (let i = journal.length - 1; i >= 0; i--) {
          const envelope = journal[i];
          const sameAddress = address.entityType === envelope.address.entityType && address.entityId === envelope.address.entityId;
          if (!sameAddress || envelope._tag !== "Request") {
            continue;
          }
          unprocessed.delete(envelope);
          requests.delete(envelope.requestId);
          journal.splice(i, 1);
        }
      }),
      resetShards: () => Effect.void
    };
    const storage = yield* makeEncoded(encoded);
    return {
      storage,
      encoded,
      requests,
      requestsByPrimaryKey,
      unprocessed,
      replyIds,
      journal,
      cursors
    };
  })
}) {}
/**
 * @since 1.0.0
 * @category layers
 */
export const layerNoop = /*#__PURE__*/Layer.succeed(MessageStorage, noop);
/**
 * @since 1.0.0
 * @category layers
 */
export const layerMemory = /*#__PURE__*/Layer.effect(MessageStorage, Effect.map(MemoryDriver, _ => _.storage)).pipe(/*#__PURE__*/Layer.provideMerge(MemoryDriver.Default));
// --- internal ---
const EnvelopeWithReply = /*#__PURE__*/Schema.Struct({
  envelope: Envelope.PartialEncoded,
  lastSentReply: /*#__PURE__*/Schema.OptionFromSelf(Reply.Encoded)
});
const decodeEnvelopeWithReply = /*#__PURE__*/Schema.decode(EnvelopeWithReply);
//# sourceMappingURL=MessageStorage.js.map