/**
 * @since 1.0.0
 */
import * as Arr from "effect/Array";
import * as Context from "effect/Context";
import * as Effect from "effect/Effect";
import * as Layer from "effect/Layer";
import * as MutableHashMap from "effect/MutableHashMap";
import * as Option from "effect/Option";
import { Runner } from "./Runner.js";
import { RunnerAddress } from "./RunnerAddress.js";
import { ShardId } from "./ShardId.js";
/**
 * Represents a generic interface to the persistent storage required by the
 * cluster.
 *
 * @since 1.0.0
 * @category models
 */
export class ShardStorage extends /*#__PURE__*/Context.Tag("@effect/cluster/ShardStorage")() {}
/**
 * @since 1.0.0
 * @category layers
 */
export const makeEncoded = encoded => ShardStorage.of({
  getAssignments: Effect.map(encoded.getAssignments, assignments => {
    const arr = Arr.empty();
    for (const [shardId, runnerAddress] of assignments) {
      arr.push([ShardId.fromString(shardId), runnerAddress === null ? Option.none() : Option.some(decodeRunnerAddress(runnerAddress))]);
    }
    return arr;
  }),
  saveAssignments: assignments => {
    const arr = Arr.empty();
    for (const [shardId, runnerAddress] of assignments) {
      arr.push([shardId.toString(), Option.isNone(runnerAddress) ? null : encodeRunnerAddress(runnerAddress.value)]);
    }
    return encoded.saveAssignments(arr);
  },
  getRunners: Effect.gen(function* () {
    const runners = yield* encoded.getRunners;
    const results = [];
    for (let i = 0; i < runners.length; i++) {
      const [address, runner] = runners[i];
      try {
        results.push([decodeRunnerAddress(address), Runner.decodeSync(runner)]);
      } catch {
        //
      }
    }
    return results;
  }),
  saveRunners: runners => Effect.suspend(() => encoded.saveRunners(Array.from(runners, ([address, runner]) => [encodeRunnerAddress(address), Runner.encodeSync(runner)]))),
  acquire: (address, shardIds) => {
    const arr = Array.from(shardIds, id => id.toString());
    return encoded.acquire(encodeRunnerAddress(address), arr).pipe(Effect.map(shards => shards.map(ShardId.fromString)));
  },
  refresh: (address, shardIds) => {
    const arr = Array.from(shardIds, id => id.toString());
    return encoded.refresh(encodeRunnerAddress(address), arr).pipe(Effect.map(shards => shards.map(ShardId.fromString)));
  },
  release(address, shardId) {
    return encoded.release(encodeRunnerAddress(address), shardId.toString());
  },
  releaseAll(address) {
    return encoded.releaseAll(encodeRunnerAddress(address));
  }
});
/**
 * @since 1.0.0
 * @category layers
 */
export const layerNoop = /*#__PURE__*/Layer.sync(ShardStorage, () => {
  let acquired = [];
  return ShardStorage.of({
    getAssignments: Effect.sync(() => []),
    saveAssignments: () => Effect.void,
    getRunners: Effect.sync(() => []),
    saveRunners: () => Effect.void,
    acquire: (_address, shards) => {
      acquired = Array.from(shards);
      return Effect.succeed(Array.from(shards));
    },
    refresh: () => Effect.sync(() => acquired),
    release: () => Effect.void,
    releaseAll: () => Effect.void
  });
});
/**
 * @since 1.0.0
 * @category constructors
 */
export const makeMemory = /*#__PURE__*/Effect.gen(function* () {
  const assignments = MutableHashMap.empty();
  const runners = MutableHashMap.empty();
  function saveAssignments(value) {
    return Effect.sync(() => {
      for (const [shardId, runnerAddress] of value) {
        MutableHashMap.set(assignments, shardId, runnerAddress);
      }
    });
  }
  function saveRunners(value) {
    return Effect.sync(() => {
      for (const [address, runner] of value) {
        MutableHashMap.set(runners, address, runner);
      }
    });
  }
  let acquired = [];
  return ShardStorage.of({
    getAssignments: Effect.sync(() => Array.from(assignments)),
    saveAssignments,
    getRunners: Effect.sync(() => Array.from(runners)),
    saveRunners,
    acquire: (_address, shardIds) => {
      acquired = Array.from(shardIds);
      return Effect.succeed(Array.from(shardIds));
    },
    refresh: () => Effect.sync(() => acquired),
    release: () => Effect.void,
    releaseAll: () => Effect.void
  });
});
/**
 * @since 1.0.0
 * @category layers
 */
export const layerMemory = /*#__PURE__*/Layer.effect(ShardStorage, makeMemory);
// -------------------------------------------------------------------------------------
// internal
// -------------------------------------------------------------------------------------
const encodeRunnerAddress = runnerAddress => `${runnerAddress.host}:${runnerAddress.port}`;
const decodeRunnerAddress = runnerAddress => {
  const [host, port] = runnerAddress.split(":");
  return new RunnerAddress({
    host,
    port: Number(port)
  });
};
//# sourceMappingURL=ShardStorage.js.map