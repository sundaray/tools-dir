import {
  __export
} from "./chunk-G3PMV62Z.js";

// ../../node_modules/effect/dist/esm/Function.js
var Function_exports = {};
__export(Function_exports, {
  SK: () => SK,
  absurd: () => absurd,
  apply: () => apply,
  compose: () => compose,
  constFalse: () => constFalse,
  constNull: () => constNull,
  constTrue: () => constTrue,
  constUndefined: () => constUndefined,
  constVoid: () => constVoid,
  constant: () => constant,
  dual: () => dual,
  flip: () => flip,
  flow: () => flow,
  hole: () => hole,
  identity: () => identity,
  isFunction: () => isFunction,
  pipe: () => pipe,
  satisfies: () => satisfies,
  tupled: () => tupled,
  unsafeCoerce: () => unsafeCoerce,
  untupled: () => untupled
});
var isFunction = (input) => typeof input === "function";
var dual = function(arity, body) {
  if (typeof arity === "function") {
    return function() {
      if (arity(arguments)) {
        return body.apply(this, arguments);
      }
      return (self) => body(self, ...arguments);
    };
  }
  switch (arity) {
    case 0:
    case 1:
      throw new RangeError(`Invalid arity ${arity}`);
    case 2:
      return function(a, b) {
        if (arguments.length >= 2) {
          return body(a, b);
        }
        return function(self) {
          return body(self, a);
        };
      };
    case 3:
      return function(a, b, c) {
        if (arguments.length >= 3) {
          return body(a, b, c);
        }
        return function(self) {
          return body(self, a, b);
        };
      };
    case 4:
      return function(a, b, c, d) {
        if (arguments.length >= 4) {
          return body(a, b, c, d);
        }
        return function(self) {
          return body(self, a, b, c);
        };
      };
    case 5:
      return function(a, b, c, d, e) {
        if (arguments.length >= 5) {
          return body(a, b, c, d, e);
        }
        return function(self) {
          return body(self, a, b, c, d);
        };
      };
    default:
      return function() {
        if (arguments.length >= arity) {
          return body.apply(this, arguments);
        }
        const args2 = arguments;
        return function(self) {
          return body(self, ...args2);
        };
      };
  }
};
var apply = (...a) => (self) => self(...a);
var identity = (a) => a;
var satisfies = () => (b) => b;
var unsafeCoerce = identity;
var constant = (value10) => () => value10;
var constTrue = constant(true);
var constFalse = constant(false);
var constNull = constant(null);
var constUndefined = constant(void 0);
var constVoid = constUndefined;
var flip = (f) => (...b) => (...a) => f(...a)(...b);
var compose = dual(2, (ab, bc) => (a) => bc(ab(a)));
var absurd = (_) => {
  throw new Error("Called `absurd` function which should be uncallable");
};
var tupled = (f) => (a) => f(...a);
var untupled = (f) => (...a) => f(a);
function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
  switch (arguments.length) {
    case 1:
      return a;
    case 2:
      return ab(a);
    case 3:
      return bc(ab(a));
    case 4:
      return cd(bc(ab(a)));
    case 5:
      return de(cd(bc(ab(a))));
    case 6:
      return ef(de(cd(bc(ab(a)))));
    case 7:
      return fg(ef(de(cd(bc(ab(a))))));
    case 8:
      return gh(fg(ef(de(cd(bc(ab(a)))))));
    case 9:
      return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
    default: {
      let ret = arguments[0];
      for (let i = 1; i < arguments.length; i++) {
        ret = arguments[i](ret);
      }
      return ret;
    }
  }
}
function flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {
  switch (arguments.length) {
    case 1:
      return ab;
    case 2:
      return function() {
        return bc(ab.apply(this, arguments));
      };
    case 3:
      return function() {
        return cd(bc(ab.apply(this, arguments)));
      };
    case 4:
      return function() {
        return de(cd(bc(ab.apply(this, arguments))));
      };
    case 5:
      return function() {
        return ef(de(cd(bc(ab.apply(this, arguments)))));
      };
    case 6:
      return function() {
        return fg(ef(de(cd(bc(ab.apply(this, arguments))))));
      };
    case 7:
      return function() {
        return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));
      };
    case 8:
      return function() {
        return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));
      };
    case 9:
      return function() {
        return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));
      };
  }
  return;
}
var hole = unsafeCoerce(absurd);
var SK = (_, b) => b;

// ../../node_modules/effect/dist/esm/Arbitrary.js
var Arbitrary_exports = {};
__export(Arbitrary_exports, {
  getDescription: () => getDescription,
  make: () => make5,
  makeArrayConstraints: () => makeArrayConstraints,
  makeBigIntConstraints: () => makeBigIntConstraints,
  makeDateConstraints: () => makeDateConstraints,
  makeLazy: () => makeLazy2,
  makeNumberConstraints: () => makeNumberConstraints,
  makeStringConstraints: () => makeStringConstraints
});

// ../../node_modules/effect/dist/esm/Array.js
var Array_exports = {};
__export(Array_exports, {
  Do: () => Do3,
  allocate: () => allocate,
  append: () => append2,
  appendAll: () => appendAll2,
  bind: () => bind4,
  bindTo: () => bindTo4,
  cartesian: () => cartesian2,
  cartesianWith: () => cartesianWith2,
  chop: () => chop,
  chunksOf: () => chunksOf2,
  contains: () => contains3,
  containsWith: () => containsWith3,
  copy: () => copy,
  countBy: () => countBy2,
  dedupe: () => dedupe,
  dedupeAdjacent: () => dedupeAdjacent2,
  dedupeAdjacentWith: () => dedupeAdjacentWith2,
  dedupeWith: () => dedupeWith,
  difference: () => difference2,
  differenceWith: () => differenceWith,
  drop: () => drop2,
  dropRight: () => dropRight,
  dropWhile: () => dropWhile,
  empty: () => empty4,
  ensure: () => ensure,
  every: () => every3,
  extend: () => extend,
  filter: () => filter4,
  filterMap: () => filterMap4,
  filterMapWhile: () => filterMapWhile2,
  findFirst: () => findFirst3,
  findFirstIndex: () => findFirstIndex,
  findFirstWithIndex: () => findFirstWithIndex,
  findLast: () => findLast2,
  findLastIndex: () => findLastIndex,
  flatMap: () => flatMap4,
  flatMapNullable: () => flatMapNullable3,
  flatten: () => flatten3,
  forEach: () => forEach2,
  fromIterable: () => fromIterable2,
  fromNullable: () => fromNullable3,
  fromOption: () => fromOption3,
  fromRecord: () => fromRecord2,
  get: () => get2,
  getEquivalence: () => getEquivalence5,
  getLefts: () => getLefts3,
  getOrder: () => getOrder3,
  getRights: () => getRights3,
  getSomes: () => getSomes3,
  group: () => group2,
  groupBy: () => groupBy2,
  groupWith: () => groupWith2,
  head: () => head2,
  headNonEmpty: () => headNonEmpty,
  init: () => init,
  initNonEmpty: () => initNonEmpty,
  insertAt: () => insertAt,
  intersection: () => intersection2,
  intersectionWith: () => intersectionWith,
  intersperse: () => intersperse2,
  isArray: () => isArray,
  isEmptyArray: () => isEmptyArray,
  isEmptyReadonlyArray: () => isEmptyReadonlyArray,
  isNonEmptyArray: () => isNonEmptyArray2,
  isNonEmptyReadonlyArray: () => isNonEmptyReadonlyArray,
  join: () => join,
  last: () => last,
  lastNonEmpty: () => lastNonEmpty,
  length: () => length,
  let: () => let_4,
  liftEither: () => liftEither,
  liftNullable: () => liftNullable2,
  liftOption: () => liftOption,
  liftPredicate: () => liftPredicate3,
  make: () => make4,
  makeBy: () => makeBy2,
  map: () => map6,
  mapAccum: () => mapAccum,
  match: () => match3,
  matchLeft: () => matchLeft,
  matchRight: () => matchRight,
  max: () => max2,
  min: () => min2,
  modify: () => modify2,
  modifyNonEmptyHead: () => modifyNonEmptyHead,
  modifyNonEmptyLast: () => modifyNonEmptyLast,
  modifyOption: () => modifyOption2,
  of: () => of2,
  pad: () => pad,
  partition: () => partition2,
  partitionMap: () => partitionMap3,
  prepend: () => prepend2,
  prependAll: () => prependAll2,
  range: () => range2,
  reduce: () => reduce3,
  reduceRight: () => reduceRight,
  remove: () => remove2,
  removeOption: () => removeOption,
  replace: () => replace2,
  replaceOption: () => replaceOption2,
  replicate: () => replicate2,
  reverse: () => reverse2,
  rotate: () => rotate,
  scan: () => scan2,
  scanRight: () => scanRight,
  separate: () => separate2,
  setNonEmptyHead: () => setNonEmptyHead,
  setNonEmptyLast: () => setNonEmptyLast,
  some: () => some6,
  sort: () => sort,
  sortBy: () => sortBy,
  sortWith: () => sortWith,
  span: () => span,
  split: () => split,
  splitAt: () => splitAt,
  splitNonEmptyAt: () => splitNonEmptyAt,
  splitWhere: () => splitWhere,
  tail: () => tail,
  tailNonEmpty: () => tailNonEmpty,
  take: () => take2,
  takeRight: () => takeRight,
  takeWhile: () => takeWhile2,
  unappend: () => unappend,
  unfold: () => unfold2,
  union: () => union2,
  unionWith: () => unionWith,
  unprepend: () => unprepend,
  unsafeGet: () => unsafeGet,
  unzip: () => unzip,
  window: () => window,
  zip: () => zip2,
  zipWith: () => zipWith4
});

// ../../node_modules/effect/dist/esm/Either.js
var Either_exports = {};
__export(Either_exports, {
  Do: () => Do,
  TypeId: () => TypeId3,
  all: () => all3,
  andThen: () => andThen,
  ap: () => ap,
  bind: () => bind2,
  bindTo: () => bindTo2,
  filterOrLeft: () => filterOrLeft,
  flatMap: () => flatMap,
  flip: () => flip2,
  fromNullable: () => fromNullable,
  fromOption: () => fromOption2,
  gen: () => gen,
  getEquivalence: () => getEquivalence,
  getLeft: () => getLeft2,
  getOrElse: () => getOrElse,
  getOrNull: () => getOrNull,
  getOrThrow: () => getOrThrow,
  getOrThrowWith: () => getOrThrowWith,
  getOrUndefined: () => getOrUndefined,
  getRight: () => getRight2,
  isEither: () => isEither2,
  isLeft: () => isLeft2,
  isRight: () => isRight2,
  left: () => left2,
  let: () => let_2,
  liftPredicate: () => liftPredicate,
  map: () => map,
  mapBoth: () => mapBoth,
  mapLeft: () => mapLeft,
  match: () => match,
  merge: () => merge,
  orElse: () => orElse,
  right: () => right2,
  transposeMapOption: () => transposeMapOption,
  transposeOption: () => transposeOption,
  try: () => try_,
  void: () => void_,
  zipWith: () => zipWith
});

// ../../node_modules/effect/dist/esm/Equivalence.js
var Equivalence_exports = {};
__export(Equivalence_exports, {
  Date: () => Date2,
  all: () => all,
  array: () => array,
  bigint: () => bigint,
  boolean: () => boolean,
  combine: () => combine,
  combineAll: () => combineAll,
  combineMany: () => combineMany,
  make: () => make,
  mapInput: () => mapInput,
  number: () => number,
  product: () => product,
  productMany: () => productMany,
  strict: () => strict,
  string: () => string,
  struct: () => struct,
  symbol: () => symbol,
  tuple: () => tuple
});
var make = (isEquivalent) => (self, that) => self === that || isEquivalent(self, that);
var isStrictEquivalent = (x, y) => x === y;
var strict = () => isStrictEquivalent;
var string = strict();
var number = strict();
var boolean = strict();
var bigint = strict();
var symbol = strict();
var combine = dual(2, (self, that) => make((x, y) => self(x, y) && that(x, y)));
var combineMany = dual(2, (self, collection) => make((x, y) => {
  if (!self(x, y)) {
    return false;
  }
  for (const equivalence3 of collection) {
    if (!equivalence3(x, y)) {
      return false;
    }
  }
  return true;
}));
var isAlwaysEquivalent = (_x, _y) => true;
var combineAll = (collection) => combineMany(isAlwaysEquivalent, collection);
var mapInput = dual(2, (self, f) => make((x, y) => self(f(x), f(y))));
var Date2 = mapInput(number, (date5) => date5.getTime());
var product = dual(2, (self, that) => make(([xa, xb], [ya, yb]) => self(xa, ya) && that(xb, yb)));
var all = (collection) => {
  return make((x, y) => {
    const len = Math.min(x.length, y.length);
    let collectionLength = 0;
    for (const equivalence3 of collection) {
      if (collectionLength >= len) {
        break;
      }
      if (!equivalence3(x[collectionLength], y[collectionLength])) {
        return false;
      }
      collectionLength++;
    }
    return true;
  });
};
var productMany = (self, collection) => {
  const equivalence3 = all(collection);
  return make((x, y) => !self(x[0], y[0]) ? false : equivalence3(x.slice(1), y.slice(1)));
};
var tuple = (...elements) => all(elements);
var array = (item) => make((self, that) => {
  if (self.length !== that.length) {
    return false;
  }
  for (let i = 0; i < self.length; i++) {
    const isEq = item(self[i], that[i]);
    if (!isEq) {
      return false;
    }
  }
  return true;
});
var struct = (fields) => {
  const keys15 = Object.keys(fields);
  return make((self, that) => {
    for (const key of keys15) {
      if (!fields[key](self[key], that[key])) {
        return false;
      }
    }
    return true;
  });
};

// ../../node_modules/effect/dist/esm/internal/doNotation.js
var let_ = (map49) => dual(3, (self, name, f) => map49(self, (a) => ({
  ...a,
  [name]: f(a)
})));
var bindTo = (map49) => dual(2, (self, name) => map49(self, (a) => ({
  [name]: a
})));
var bind = (map49, flatMap29) => dual(3, (self, name, f) => flatMap29(self, (a) => map49(f(a), (b) => ({
  ...a,
  [name]: b
}))));

// ../../node_modules/effect/dist/esm/Equal.js
var Equal_exports = {};
__export(Equal_exports, {
  equals: () => equals,
  equivalence: () => equivalence,
  isEqual: () => isEqual,
  symbol: () => symbol3
});

// ../../node_modules/effect/dist/esm/Hash.js
var Hash_exports = {};
__export(Hash_exports, {
  array: () => array2,
  cached: () => cached,
  combine: () => combine2,
  hash: () => hash,
  isHash: () => isHash,
  number: () => number2,
  optimize: () => optimize,
  random: () => random,
  string: () => string2,
  structure: () => structure,
  structureKeys: () => structureKeys,
  symbol: () => symbol2
});

// ../../node_modules/effect/dist/esm/GlobalValue.js
var GlobalValue_exports = {};
__export(GlobalValue_exports, {
  globalValue: () => globalValue
});
var globalStoreId = `effect/GlobalValue`;
var globalStore;
var globalValue = (id3, compute) => {
  if (!globalStore) {
    globalThis[globalStoreId] ??= /* @__PURE__ */ new Map();
    globalStore = globalThis[globalStoreId];
  }
  if (!globalStore.has(id3)) {
    globalStore.set(id3, compute());
  }
  return globalStore.get(id3);
};

// ../../node_modules/effect/dist/esm/Predicate.js
var Predicate_exports = {};
__export(Predicate_exports, {
  all: () => all2,
  and: () => and,
  compose: () => compose2,
  eqv: () => eqv,
  every: () => every,
  hasProperty: () => hasProperty,
  implies: () => implies,
  isBigInt: () => isBigInt,
  isBoolean: () => isBoolean,
  isDate: () => isDate,
  isError: () => isError,
  isFunction: () => isFunction2,
  isIterable: () => isIterable,
  isMap: () => isMap,
  isNever: () => isNever,
  isNotNull: () => isNotNull,
  isNotNullable: () => isNotNullable,
  isNotUndefined: () => isNotUndefined,
  isNull: () => isNull,
  isNullable: () => isNullable,
  isNumber: () => isNumber,
  isObject: () => isObject,
  isPromise: () => isPromise,
  isPromiseLike: () => isPromiseLike,
  isPropertyKey: () => isPropertyKey,
  isReadonlyRecord: () => isReadonlyRecord,
  isRecord: () => isRecord,
  isRecordOrArray: () => isRecordOrArray,
  isRegExp: () => isRegExp,
  isSet: () => isSet,
  isString: () => isString,
  isSymbol: () => isSymbol,
  isTagged: () => isTagged,
  isTruthy: () => isTruthy,
  isTupleOf: () => isTupleOf,
  isTupleOfAtLeast: () => isTupleOfAtLeast,
  isUint8Array: () => isUint8Array,
  isUndefined: () => isUndefined,
  isUnknown: () => isUnknown,
  mapInput: () => mapInput2,
  nand: () => nand,
  nor: () => nor,
  not: () => not,
  or: () => or,
  product: () => product2,
  productMany: () => productMany2,
  some: () => some,
  struct: () => struct2,
  tuple: () => tuple2,
  xor: () => xor
});
var mapInput2 = dual(2, (self, f) => (b) => self(f(b)));
var isTupleOf = dual(2, (self, n) => self.length === n);
var isTupleOfAtLeast = dual(2, (self, n) => self.length >= n);
var isTruthy = (input) => !!input;
var isSet = (input) => input instanceof Set;
var isMap = (input) => input instanceof Map;
var isString = (input) => typeof input === "string";
var isNumber = (input) => typeof input === "number";
var isBoolean = (input) => typeof input === "boolean";
var isBigInt = (input) => typeof input === "bigint";
var isSymbol = (input) => typeof input === "symbol";
var isPropertyKey = (u) => isString(u) || isNumber(u) || isSymbol(u);
var isFunction2 = isFunction;
var isUndefined = (input) => input === void 0;
var isNotUndefined = (input) => input !== void 0;
var isNull = (input) => input === null;
var isNotNull = (input) => input !== null;
var isNever = (_) => false;
var isUnknown = (_) => true;
var isRecordOrArray = (input) => typeof input === "object" && input !== null;
var isObject = (input) => isRecordOrArray(input) || isFunction2(input);
var hasProperty = dual(2, (self, property2) => isObject(self) && property2 in self);
var isTagged = dual(2, (self, tag5) => hasProperty(self, "_tag") && self["_tag"] === tag5);
var isNullable = (input) => input === null || input === void 0;
var isNotNullable = (input) => input !== null && input !== void 0;
var isError = (input) => input instanceof Error;
var isUint8Array = (input) => input instanceof Uint8Array;
var isDate = (input) => input instanceof Date;
var isIterable = (input) => hasProperty(input, Symbol.iterator);
var isRecord = (input) => isRecordOrArray(input) && !Array.isArray(input);
var isReadonlyRecord = isRecord;
var isPromise = (input) => hasProperty(input, "then") && "catch" in input && isFunction2(input.then) && isFunction2(input.catch);
var isPromiseLike = (input) => hasProperty(input, "then") && isFunction2(input.then);
var isRegExp = (input) => input instanceof RegExp;
var compose2 = dual(2, (ab, bc) => (a) => ab(a) && bc(a));
var product2 = (self, that) => ([a, b]) => self(a) && that(b);
var all2 = (collection) => {
  return (as18) => {
    let collectionIndex = 0;
    for (const p of collection) {
      if (collectionIndex >= as18.length) {
        break;
      }
      if (p(as18[collectionIndex]) === false) {
        return false;
      }
      collectionIndex++;
    }
    return true;
  };
};
var productMany2 = (self, collection) => {
  const rest = all2(collection);
  return ([head13, ...tail5]) => self(head13) === false ? false : rest(tail5);
};
var tuple2 = (...elements) => all2(elements);
var struct2 = (fields) => {
  const keys15 = Object.keys(fields);
  return (a) => {
    for (const key of keys15) {
      if (!fields[key](a[key])) {
        return false;
      }
    }
    return true;
  };
};
var not = (self) => (a) => !self(a);
var or = dual(2, (self, that) => (a) => self(a) || that(a));
var and = dual(2, (self, that) => (a) => self(a) && that(a));
var xor = dual(2, (self, that) => (a) => self(a) !== that(a));
var eqv = dual(2, (self, that) => (a) => self(a) === that(a));
var implies = dual(2, (antecedent, consequent) => (a) => antecedent(a) ? consequent(a) : true);
var nor = dual(2, (self, that) => (a) => !(self(a) || that(a)));
var nand = dual(2, (self, that) => (a) => !(self(a) && that(a)));
var every = (collection) => (a) => {
  for (const p of collection) {
    if (!p(a)) {
      return false;
    }
  }
  return true;
};
var some = (collection) => (a) => {
  for (const p of collection) {
    if (p(a)) {
      return true;
    }
  }
  return false;
};

// ../../node_modules/effect/dist/esm/Utils.js
var Utils_exports = {};
__export(Utils_exports, {
  GenKindImpl: () => GenKindImpl,
  GenKindTypeId: () => GenKindTypeId,
  PCGRandom: () => PCGRandom,
  SingleShotGen: () => SingleShotGen,
  YieldWrap: () => YieldWrap,
  YieldWrapTypeId: () => YieldWrapTypeId,
  adapter: () => adapter,
  internalCall: () => internalCall,
  isGenKind: () => isGenKind,
  isGeneratorFunction: () => isGeneratorFunction,
  makeGenKind: () => makeGenKind,
  structuralRegion: () => structuralRegion,
  structuralRegionState: () => structuralRegionState,
  yieldWrapGet: () => yieldWrapGet
});

// ../../node_modules/effect/dist/esm/internal/errors.js
var getBugErrorMessage = (message) => `BUG: ${message} - please report an issue at https://github.com/Effect-TS/effect/issues`;

// ../../node_modules/effect/dist/esm/Utils.js
var GenKindTypeId = Symbol.for("effect/Gen/GenKind");
var isGenKind = (u) => isObject(u) && GenKindTypeId in u;
var GenKindImpl = class {
  value;
  constructor(value10) {
    this.value = value10;
  }
  /**
   * @since 2.0.0
   */
  get _F() {
    return identity;
  }
  /**
   * @since 2.0.0
   */
  get _R() {
    return (_) => _;
  }
  /**
   * @since 2.0.0
   */
  get _O() {
    return (_) => _;
  }
  /**
   * @since 2.0.0
   */
  get _E() {
    return (_) => _;
  }
  /**
   * @since 2.0.0
   */
  [GenKindTypeId] = GenKindTypeId;
  /**
   * @since 2.0.0
   */
  [Symbol.iterator]() {
    return new SingleShotGen(this);
  }
};
var SingleShotGen = class _SingleShotGen {
  self;
  called = false;
  constructor(self) {
    this.self = self;
  }
  /**
   * @since 2.0.0
   */
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  /**
   * @since 2.0.0
   */
  return(a) {
    return {
      value: a,
      done: true
    };
  }
  /**
   * @since 2.0.0
   */
  throw(e) {
    throw e;
  }
  /**
   * @since 2.0.0
   */
  [Symbol.iterator]() {
    return new _SingleShotGen(this.self);
  }
};
var makeGenKind = (kind) => new GenKindImpl(kind);
var adapter = () => function() {
  let x = arguments[0];
  for (let i = 1; i < arguments.length; i++) {
    x = arguments[i](x);
  }
  return new GenKindImpl(x);
};
var defaultIncHi = 335903614;
var defaultIncLo = 4150755663;
var MUL_HI = 1481765933 >>> 0;
var MUL_LO = 1284865837 >>> 0;
var BIT_53 = 9007199254740992;
var BIT_27 = 134217728;
var PCGRandom = class {
  _state;
  constructor(seedHi, seedLo, incHi, incLo) {
    if (isNullable(seedLo) && isNullable(seedHi)) {
      seedLo = Math.random() * 4294967295 >>> 0;
      seedHi = 0;
    } else if (isNullable(seedLo)) {
      seedLo = seedHi;
      seedHi = 0;
    }
    if (isNullable(incLo) && isNullable(incHi)) {
      incLo = this._state ? this._state[3] : defaultIncLo;
      incHi = this._state ? this._state[2] : defaultIncHi;
    } else if (isNullable(incLo)) {
      incLo = incHi;
      incHi = 0;
    }
    this._state = new Int32Array([0, 0, incHi >>> 0, ((incLo || 0) | 1) >>> 0]);
    this._next();
    add64(this._state, this._state[0], this._state[1], seedHi >>> 0, seedLo >>> 0);
    this._next();
    return this;
  }
  /**
   * Returns a copy of the internal state of this random number generator as a
   * JavaScript Array.
   *
   * @category getters
   * @since 2.0.0
   */
  getState() {
    return [this._state[0], this._state[1], this._state[2], this._state[3]];
  }
  /**
   * Restore state previously retrieved using `getState()`.
   *
   * @since 2.0.0
   */
  setState(state) {
    this._state[0] = state[0];
    this._state[1] = state[1];
    this._state[2] = state[2];
    this._state[3] = state[3] | 1;
  }
  /**
   * Get a uniformly distributed 32 bit integer between [0, max).
   *
   * @category getter
   * @since 2.0.0
   */
  integer(max13) {
    return Math.round(this.number() * Number.MAX_SAFE_INTEGER) % max13;
  }
  /**
   * Get a uniformly distributed IEEE-754 double between 0.0 and 1.0, with
   * 53 bits of precision (every bit of the mantissa is randomized).
   *
   * @category getters
   * @since 2.0.0
   */
  number() {
    const hi = (this._next() & 67108863) * 1;
    const lo = (this._next() & 134217727) * 1;
    return (hi * BIT_27 + lo) / BIT_53;
  }
  /** @internal */
  _next() {
    const oldHi = this._state[0] >>> 0;
    const oldLo = this._state[1] >>> 0;
    mul64(this._state, oldHi, oldLo, MUL_HI, MUL_LO);
    add64(this._state, this._state[0], this._state[1], this._state[2], this._state[3]);
    let xsHi = oldHi >>> 18;
    let xsLo = (oldLo >>> 18 | oldHi << 14) >>> 0;
    xsHi = (xsHi ^ oldHi) >>> 0;
    xsLo = (xsLo ^ oldLo) >>> 0;
    const xorshifted = (xsLo >>> 27 | xsHi << 5) >>> 0;
    const rot = oldHi >>> 27;
    const rot2 = (-rot >>> 0 & 31) >>> 0;
    return (xorshifted >>> rot | xorshifted << rot2) >>> 0;
  }
};
function mul64(out, aHi, aLo, bHi, bLo) {
  let c1 = (aLo >>> 16) * (bLo & 65535) >>> 0;
  let c0 = (aLo & 65535) * (bLo >>> 16) >>> 0;
  let lo = (aLo & 65535) * (bLo & 65535) >>> 0;
  let hi = (aLo >>> 16) * (bLo >>> 16) + ((c0 >>> 16) + (c1 >>> 16)) >>> 0;
  c0 = c0 << 16 >>> 0;
  lo = lo + c0 >>> 0;
  if (lo >>> 0 < c0 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  c1 = c1 << 16 >>> 0;
  lo = lo + c1 >>> 0;
  if (lo >>> 0 < c1 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  hi = hi + Math.imul(aLo, bHi) >>> 0;
  hi = hi + Math.imul(aHi, bLo) >>> 0;
  out[0] = hi;
  out[1] = lo;
}
function add64(out, aHi, aLo, bHi, bLo) {
  let hi = aHi + bHi >>> 0;
  const lo = aLo + bLo >>> 0;
  if (lo >>> 0 < aLo >>> 0) {
    hi = hi + 1 | 0;
  }
  out[0] = hi;
  out[1] = lo;
}
var YieldWrapTypeId = Symbol.for("effect/Utils/YieldWrap");
var YieldWrap = class {
  /**
   * @since 3.0.6
   */
  #value;
  constructor(value10) {
    this.#value = value10;
  }
  /**
   * @since 3.0.6
   */
  [YieldWrapTypeId]() {
    return this.#value;
  }
};
function yieldWrapGet(self) {
  if (typeof self === "object" && self !== null && YieldWrapTypeId in self) {
    return self[YieldWrapTypeId]();
  }
  throw new Error(getBugErrorMessage("yieldWrapGet"));
}
var structuralRegionState = globalValue("effect/Utils/isStructuralRegion", () => ({
  enabled: false,
  tester: void 0
}));
var structuralRegion = (body, tester) => {
  const current2 = structuralRegionState.enabled;
  const currentTester = structuralRegionState.tester;
  structuralRegionState.enabled = true;
  if (tester) {
    structuralRegionState.tester = tester;
  }
  try {
    return body();
  } finally {
    structuralRegionState.enabled = current2;
    structuralRegionState.tester = currentTester;
  }
};
var standard = {
  effect_internal_function: (body) => {
    return body();
  }
};
var forced = {
  effect_internal_function: (body) => {
    try {
      return body();
    } finally {
    }
  }
};
var isNotOptimizedAway = standard.effect_internal_function(() => new Error().stack)?.includes("effect_internal_function") === true;
var internalCall = isNotOptimizedAway ? standard.effect_internal_function : forced.effect_internal_function;
var genConstructor = (function* () {
}).constructor;
var isGeneratorFunction = (u) => isObject(u) && u.constructor === genConstructor;

// ../../node_modules/effect/dist/esm/Hash.js
var randomHashCache = globalValue(Symbol.for("effect/Hash/randomHashCache"), () => /* @__PURE__ */ new WeakMap());
var symbol2 = Symbol.for("effect/Hash");
var hash = (self) => {
  if (structuralRegionState.enabled === true) {
    return 0;
  }
  switch (typeof self) {
    case "number":
      return number2(self);
    case "bigint":
      return string2(self.toString(10));
    case "boolean":
      return string2(String(self));
    case "symbol":
      return string2(String(self));
    case "string":
      return string2(self);
    case "undefined":
      return string2("undefined");
    case "function":
    case "object": {
      if (self === null) {
        return string2("null");
      } else if (self instanceof Date) {
        return hash(self.toISOString());
      } else if (self instanceof URL) {
        return hash(self.href);
      } else if (isHash(self)) {
        return self[symbol2]();
      } else {
        return random(self);
      }
    }
    default:
      throw new Error(`BUG: unhandled typeof ${typeof self} - please report an issue at https://github.com/Effect-TS/effect/issues`);
  }
};
var random = (self) => {
  if (!randomHashCache.has(self)) {
    randomHashCache.set(self, number2(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)));
  }
  return randomHashCache.get(self);
};
var combine2 = (b) => (self) => self * 53 ^ b;
var optimize = (n) => n & 3221225471 | n >>> 1 & 1073741824;
var isHash = (u) => hasProperty(u, symbol2);
var number2 = (n) => {
  if (n !== n || n === Infinity) {
    return 0;
  }
  let h2 = n | 0;
  if (h2 !== n) {
    h2 ^= n * 4294967295;
  }
  while (n > 4294967295) {
    h2 ^= n /= 4294967295;
  }
  return optimize(h2);
};
var string2 = (str) => {
  let h2 = 5381, i = str.length;
  while (i) {
    h2 = h2 * 33 ^ str.charCodeAt(--i);
  }
  return optimize(h2);
};
var structureKeys = (o, keys15) => {
  let h2 = 12289;
  for (let i = 0; i < keys15.length; i++) {
    h2 ^= pipe(string2(keys15[i]), combine2(hash(o[keys15[i]])));
  }
  return optimize(h2);
};
var structure = (o) => structureKeys(o, Object.keys(o));
var array2 = (arr) => {
  let h2 = 6151;
  for (let i = 0; i < arr.length; i++) {
    h2 = pipe(h2, combine2(hash(arr[i])));
  }
  return optimize(h2);
};
var cached = function() {
  if (arguments.length === 1) {
    const self2 = arguments[0];
    return function(hash5) {
      Object.defineProperty(self2, symbol2, {
        value() {
          return hash5;
        },
        enumerable: false
      });
      return hash5;
    };
  }
  const self = arguments[0];
  const hash4 = arguments[1];
  Object.defineProperty(self, symbol2, {
    value() {
      return hash4;
    },
    enumerable: false
  });
  return hash4;
};

// ../../node_modules/effect/dist/esm/Equal.js
var symbol3 = Symbol.for("effect/Equal");
function equals() {
  if (arguments.length === 1) {
    return (self) => compareBoth(self, arguments[0]);
  }
  return compareBoth(arguments[0], arguments[1]);
}
function compareBoth(self, that) {
  if (self === that) {
    return true;
  }
  const selfType = typeof self;
  if (selfType !== typeof that) {
    return false;
  }
  if (selfType === "object" || selfType === "function") {
    if (self !== null && that !== null) {
      if (isEqual(self) && isEqual(that)) {
        if (hash(self) === hash(that) && self[symbol3](that)) {
          return true;
        } else {
          return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
        }
      } else if (self instanceof Date && that instanceof Date) {
        return self.toISOString() === that.toISOString();
      } else if (self instanceof URL && that instanceof URL) {
        return self.href === that.href;
      }
    }
    if (structuralRegionState.enabled) {
      if (Array.isArray(self) && Array.isArray(that)) {
        return self.length === that.length && self.every((v, i) => compareBoth(v, that[i]));
      }
      if (Object.getPrototypeOf(self) === Object.prototype && Object.getPrototypeOf(self) === Object.prototype) {
        const keysSelf = Object.keys(self);
        const keysThat = Object.keys(that);
        if (keysSelf.length === keysThat.length) {
          for (const key of keysSelf) {
            if (!(key in that && compareBoth(self[key], that[key]))) {
              return structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
            }
          }
          return true;
        }
      }
      return structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
    }
  }
  return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
}
var isEqual = (u) => hasProperty(u, symbol3);
var equivalence = () => equals;

// ../../node_modules/effect/dist/esm/Inspectable.js
var Inspectable_exports = {};
__export(Inspectable_exports, {
  BaseProto: () => BaseProto,
  Class: () => Class,
  NodeInspectSymbol: () => NodeInspectSymbol,
  format: () => format,
  isRedactable: () => isRedactable,
  redact: () => redact,
  stringifyCircular: () => stringifyCircular,
  symbolRedactable: () => symbolRedactable,
  toJSON: () => toJSON,
  toStringUnknown: () => toStringUnknown,
  withRedactableContext: () => withRedactableContext
});
var NodeInspectSymbol = Symbol.for("nodejs.util.inspect.custom");
var toJSON = (x) => {
  try {
    if (hasProperty(x, "toJSON") && isFunction2(x["toJSON"]) && x["toJSON"].length === 0) {
      return x.toJSON();
    } else if (Array.isArray(x)) {
      return x.map(toJSON);
    }
  } catch {
    return {};
  }
  return redact(x);
};
var format = (x) => JSON.stringify(x, null, 2);
var BaseProto = {
  toJSON() {
    return toJSON(this);
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var Class = class {
  /**
   * @since 2.0.0
   */
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  /**
   * @since 2.0.0
   */
  toString() {
    return format(this.toJSON());
  }
};
var toStringUnknown = (u, whitespace = 2) => {
  if (typeof u === "string") {
    return u;
  }
  try {
    return typeof u === "object" ? stringifyCircular(u, whitespace) : String(u);
  } catch {
    return String(u);
  }
};
var stringifyCircular = (obj, whitespace) => {
  let cache = [];
  const retVal = JSON.stringify(obj, (_key, value10) => typeof value10 === "object" && value10 !== null ? cache.includes(value10) ? void 0 : cache.push(value10) && (redactableState.fiberRefs !== void 0 && isRedactable(value10) ? value10[symbolRedactable](redactableState.fiberRefs) : value10) : value10, whitespace);
  cache = void 0;
  return retVal;
};
var symbolRedactable = Symbol.for("effect/Inspectable/Redactable");
var isRedactable = (u) => typeof u === "object" && u !== null && symbolRedactable in u;
var redactableState = globalValue("effect/Inspectable/redactableState", () => ({
  fiberRefs: void 0
}));
var withRedactableContext = (context15, f) => {
  const prev = redactableState.fiberRefs;
  redactableState.fiberRefs = context15;
  try {
    return f();
  } finally {
    redactableState.fiberRefs = prev;
  }
};
var redact = (u) => {
  if (isRedactable(u) && redactableState.fiberRefs !== void 0) {
    return u[symbolRedactable](redactableState.fiberRefs);
  }
  return u;
};

// ../../node_modules/effect/dist/esm/Pipeable.js
var Pipeable_exports = {};
__export(Pipeable_exports, {
  Class: () => Class2,
  Prototype: () => Prototype,
  pipeArguments: () => pipeArguments
});
var pipeArguments = (self, args2) => {
  switch (args2.length) {
    case 0:
      return self;
    case 1:
      return args2[0](self);
    case 2:
      return args2[1](args2[0](self));
    case 3:
      return args2[2](args2[1](args2[0](self)));
    case 4:
      return args2[3](args2[2](args2[1](args2[0](self))));
    case 5:
      return args2[4](args2[3](args2[2](args2[1](args2[0](self)))));
    case 6:
      return args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self))))));
    case 7:
      return args2[6](args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self)))))));
    case 8:
      return args2[7](args2[6](args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self))))))));
    case 9:
      return args2[8](args2[7](args2[6](args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self)))))))));
    default: {
      let ret = self;
      for (let i = 0, len = args2.length; i < len; i++) {
        ret = args2[i](ret);
      }
      return ret;
    }
  }
};
var Prototype = {
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var Base = function() {
  function PipeableBase() {
  }
  PipeableBase.prototype = Prototype;
  return PipeableBase;
}();
var Class2 = (klass) => klass ? class extends klass {
  pipe() {
    return pipeArguments(this, arguments);
  }
} : Base;

// ../../node_modules/effect/dist/esm/internal/opCodes/effect.js
var OP_ASYNC = "Async";
var OP_COMMIT = "Commit";
var OP_FAILURE = "Failure";
var OP_ON_FAILURE = "OnFailure";
var OP_ON_SUCCESS = "OnSuccess";
var OP_ON_SUCCESS_AND_FAILURE = "OnSuccessAndFailure";
var OP_SUCCESS = "Success";
var OP_SYNC = "Sync";
var OP_TAG = "Tag";
var OP_UPDATE_RUNTIME_FLAGS = "UpdateRuntimeFlags";
var OP_WHILE = "While";
var OP_ITERATOR = "Iterator";
var OP_WITH_RUNTIME = "WithRuntime";
var OP_YIELD = "Yield";
var OP_REVERT_FLAGS = "RevertFlags";

// ../../node_modules/effect/dist/esm/internal/version.js
var moduleVersion = "3.17.0";
var getCurrentVersion = () => moduleVersion;
var setCurrentVersion = (version) => {
  moduleVersion = version;
};

// ../../node_modules/effect/dist/esm/internal/effectable.js
var EffectTypeId = Symbol.for("effect/Effect");
var StreamTypeId = Symbol.for("effect/Stream");
var SinkTypeId = Symbol.for("effect/Sink");
var ChannelTypeId = Symbol.for("effect/Channel");
var effectVariance = {
  /* c8 ignore next */
  _R: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _,
  _V: getCurrentVersion()
};
var sinkVariance = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _L: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var channelVariance = {
  /* c8 ignore next */
  _Env: (_) => _,
  /* c8 ignore next */
  _InErr: (_) => _,
  /* c8 ignore next */
  _InElem: (_) => _,
  /* c8 ignore next */
  _InDone: (_) => _,
  /* c8 ignore next */
  _OutErr: (_) => _,
  /* c8 ignore next */
  _OutElem: (_) => _,
  /* c8 ignore next */
  _OutDone: (_) => _
};
var EffectPrototype = {
  [EffectTypeId]: effectVariance,
  [StreamTypeId]: effectVariance,
  [SinkTypeId]: sinkVariance,
  [ChannelTypeId]: channelVariance,
  [symbol3](that) {
    return this === that;
  },
  [symbol2]() {
    return cached(this, random(this));
  },
  [Symbol.iterator]() {
    return new SingleShotGen(new YieldWrap(this));
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var StructuralPrototype = {
  [symbol2]() {
    return cached(this, structure(this));
  },
  [symbol3](that) {
    const selfKeys = Object.keys(this);
    const thatKeys = Object.keys(that);
    if (selfKeys.length !== thatKeys.length) {
      return false;
    }
    for (const key of selfKeys) {
      if (!(key in that && equals(this[key], that[key]))) {
        return false;
      }
    }
    return true;
  }
};
var CommitPrototype = {
  ...EffectPrototype,
  _op: OP_COMMIT
};
var StructuralCommitPrototype = {
  ...CommitPrototype,
  ...StructuralPrototype
};
var Base2 = function() {
  function Base4() {
  }
  Base4.prototype = CommitPrototype;
  return Base4;
}();
var StructuralBase = function() {
  function Base4() {
  }
  Base4.prototype = StructuralCommitPrototype;
  return Base4;
}();

// ../../node_modules/effect/dist/esm/internal/option.js
var TypeId = Symbol.for("effect/Option");
var CommonProto = {
  ...EffectPrototype,
  [TypeId]: {
    _A: (_) => _
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var SomeProto = Object.assign(Object.create(CommonProto), {
  _tag: "Some",
  _op: "Some",
  [symbol3](that) {
    return isOption(that) && isSome(that) && equals(this.value, that.value);
  },
  [symbol2]() {
    return cached(this, combine2(hash(this._tag))(hash(this.value)));
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag,
      value: toJSON(this.value)
    };
  }
});
var NoneHash = hash("None");
var NoneProto = Object.assign(Object.create(CommonProto), {
  _tag: "None",
  _op: "None",
  [symbol3](that) {
    return isOption(that) && isNone(that);
  },
  [symbol2]() {
    return NoneHash;
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag
    };
  }
});
var isOption = (input) => hasProperty(input, TypeId);
var isNone = (fa) => fa._tag === "None";
var isSome = (fa) => fa._tag === "Some";
var none = Object.create(NoneProto);
var some2 = (value10) => {
  const a = Object.create(SomeProto);
  a.value = value10;
  return a;
};

// ../../node_modules/effect/dist/esm/internal/either.js
var TypeId2 = Symbol.for("effect/Either");
var CommonProto2 = {
  ...EffectPrototype,
  [TypeId2]: {
    _R: (_) => _
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var RightProto = Object.assign(Object.create(CommonProto2), {
  _tag: "Right",
  _op: "Right",
  [symbol3](that) {
    return isEither(that) && isRight(that) && equals(this.right, that.right);
  },
  [symbol2]() {
    return combine2(hash(this._tag))(hash(this.right));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      right: toJSON(this.right)
    };
  }
});
var LeftProto = Object.assign(Object.create(CommonProto2), {
  _tag: "Left",
  _op: "Left",
  [symbol3](that) {
    return isEither(that) && isLeft(that) && equals(this.left, that.left);
  },
  [symbol2]() {
    return combine2(hash(this._tag))(hash(this.left));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      left: toJSON(this.left)
    };
  }
});
var isEither = (input) => hasProperty(input, TypeId2);
var isLeft = (ma) => ma._tag === "Left";
var isRight = (ma) => ma._tag === "Right";
var left = (left3) => {
  const a = Object.create(LeftProto);
  a.left = left3;
  return a;
};
var right = (right3) => {
  const a = Object.create(RightProto);
  a.right = right3;
  return a;
};
var getLeft = (self) => isRight(self) ? none : some2(self.left);
var getRight = (self) => isLeft(self) ? none : some2(self.right);
var fromOption = dual(2, (self, onNone) => isNone(self) ? left(onNone()) : right(self.value));

// ../../node_modules/effect/dist/esm/Either.js
var TypeId3 = TypeId2;
var right2 = right;
var void_ = right2(void 0);
var left2 = left;
var fromNullable = dual(2, (self, onNullable) => self == null ? left2(onNullable(self)) : right2(self));
var fromOption2 = fromOption;
var try_ = (evaluate4) => {
  if (isFunction2(evaluate4)) {
    try {
      return right2(evaluate4());
    } catch (e) {
      return left2(e);
    }
  } else {
    try {
      return right2(evaluate4.try());
    } catch (e) {
      return left2(evaluate4.catch(e));
    }
  }
};
var isEither2 = isEither;
var isLeft2 = isLeft;
var isRight2 = isRight;
var getRight2 = getRight;
var getLeft2 = getLeft;
var getEquivalence = ({
  left: left3,
  right: right3
}) => make((x, y) => isLeft2(x) ? isLeft2(y) && left3(x.left, y.left) : isRight2(y) && right3(x.right, y.right));
var mapBoth = dual(2, (self, {
  onLeft,
  onRight
}) => isLeft2(self) ? left2(onLeft(self.left)) : right2(onRight(self.right)));
var mapLeft = dual(2, (self, f) => isLeft2(self) ? left2(f(self.left)) : right2(self.right));
var map = dual(2, (self, f) => isRight2(self) ? right2(f(self.right)) : left2(self.left));
var match = dual(2, (self, {
  onLeft,
  onRight
}) => isLeft2(self) ? onLeft(self.left) : onRight(self.right));
var liftPredicate = dual(3, (a, predicate, orLeftWith) => predicate(a) ? right2(a) : left2(orLeftWith(a)));
var filterOrLeft = dual(3, (self, predicate, orLeftWith) => flatMap(self, (r) => predicate(r) ? right2(r) : left2(orLeftWith(r))));
var merge = match({
  onLeft: identity,
  onRight: identity
});
var getOrElse = dual(2, (self, onLeft) => isLeft2(self) ? onLeft(self.left) : self.right);
var getOrNull = getOrElse(constNull);
var getOrUndefined = getOrElse(constUndefined);
var getOrThrowWith = dual(2, (self, onLeft) => {
  if (isRight2(self)) {
    return self.right;
  }
  throw onLeft(self.left);
});
var getOrThrow = getOrThrowWith(() => new Error("getOrThrow called on a Left"));
var orElse = dual(2, (self, that) => isLeft2(self) ? that(self.left) : right2(self.right));
var flatMap = dual(2, (self, f) => isLeft2(self) ? left2(self.left) : f(self.right));
var andThen = dual(2, (self, f) => flatMap(self, (a) => {
  const b = isFunction2(f) ? f(a) : f;
  return isEither2(b) ? b : right2(b);
}));
var zipWith = dual(3, (self, that, f) => flatMap(self, (r) => map(that, (r2) => f(r, r2))));
var ap = dual(2, (self, that) => zipWith(self, that, (f, a) => f(a)));
var all3 = (input) => {
  if (Symbol.iterator in input) {
    const out2 = [];
    for (const e of input) {
      if (isLeft2(e)) {
        return e;
      }
      out2.push(e.right);
    }
    return right2(out2);
  }
  const out = {};
  for (const key of Object.keys(input)) {
    const e = input[key];
    if (isLeft2(e)) {
      return e;
    }
    out[key] = e.right;
  }
  return right2(out);
};
var flip2 = (self) => isLeft2(self) ? right2(self.left) : left2(self.right);
var adapter2 = adapter();
var gen = (...args2) => {
  const f = args2.length === 1 ? args2[0] : args2[1].bind(args2[0]);
  const iterator = f(adapter2);
  let state = iterator.next();
  while (!state.done) {
    const current2 = isGenKind(state.value) ? state.value.value : yieldWrapGet(state.value);
    if (isLeft2(current2)) {
      return current2;
    }
    state = iterator.next(current2.right);
  }
  return right2(state.value);
};
var Do = right2({});
var bind2 = bind(map, flatMap);
var bindTo2 = bindTo(map);
var let_2 = let_(map);
var transposeOption = (self) => {
  return isNone(self) ? right2(none) : map(self.value, some2);
};
var transposeMapOption = dual(2, (self, f) => isNone(self) ? right2(none) : map(f(self.value), some2));

// ../../node_modules/effect/dist/esm/internal/array.js
var isNonEmptyArray = (self) => self.length > 0;

// ../../node_modules/effect/dist/esm/Iterable.js
var Iterable_exports = {};
__export(Iterable_exports, {
  append: () => append,
  appendAll: () => appendAll,
  cartesian: () => cartesian,
  cartesianWith: () => cartesianWith,
  chunksOf: () => chunksOf,
  contains: () => contains2,
  containsWith: () => containsWith2,
  countBy: () => countBy,
  dedupeAdjacent: () => dedupeAdjacent,
  dedupeAdjacentWith: () => dedupeAdjacentWith,
  drop: () => drop,
  empty: () => empty2,
  filter: () => filter2,
  filterMap: () => filterMap2,
  filterMapWhile: () => filterMapWhile,
  findFirst: () => findFirst,
  findLast: () => findLast,
  flatMap: () => flatMap3,
  flatMapNullable: () => flatMapNullable2,
  flatten: () => flatten2,
  forEach: () => forEach,
  fromRecord: () => fromRecord,
  getLefts: () => getLefts,
  getRights: () => getRights,
  getSomes: () => getSomes,
  group: () => group,
  groupBy: () => groupBy,
  groupWith: () => groupWith,
  head: () => head,
  intersperse: () => intersperse,
  isEmpty: () => isEmpty,
  makeBy: () => makeBy,
  map: () => map4,
  of: () => of,
  prepend: () => prepend,
  prependAll: () => prependAll,
  range: () => range,
  reduce: () => reduce,
  replicate: () => replicate,
  scan: () => scan,
  size: () => size,
  some: () => some4,
  take: () => take,
  takeWhile: () => takeWhile,
  unfold: () => unfold,
  unsafeHead: () => unsafeHead,
  zip: () => zip,
  zipWith: () => zipWith3
});

// ../../node_modules/effect/dist/esm/Option.js
var Option_exports = {};
__export(Option_exports, {
  Do: () => Do2,
  TypeId: () => TypeId4,
  all: () => all5,
  andThen: () => andThen2,
  ap: () => ap2,
  as: () => as,
  asVoid: () => asVoid,
  bind: () => bind3,
  bindTo: () => bindTo3,
  composeK: () => composeK,
  contains: () => contains,
  containsWith: () => containsWith,
  exists: () => exists,
  filter: () => filter,
  filterMap: () => filterMap,
  firstSomeOf: () => firstSomeOf,
  flatMap: () => flatMap2,
  flatMapNullable: () => flatMapNullable,
  flatten: () => flatten,
  fromIterable: () => fromIterable,
  fromNullable: () => fromNullable2,
  gen: () => gen2,
  getEquivalence: () => getEquivalence2,
  getLeft: () => getLeft3,
  getOrElse: () => getOrElse2,
  getOrNull: () => getOrNull2,
  getOrThrow: () => getOrThrow2,
  getOrThrowWith: () => getOrThrowWith2,
  getOrUndefined: () => getOrUndefined2,
  getOrder: () => getOrder,
  getRight: () => getRight3,
  isNone: () => isNone2,
  isOption: () => isOption2,
  isSome: () => isSome2,
  let: () => let_3,
  lift2: () => lift2,
  liftNullable: () => liftNullable,
  liftPredicate: () => liftPredicate2,
  liftThrowable: () => liftThrowable,
  map: () => map2,
  match: () => match2,
  mergeWith: () => mergeWith,
  none: () => none2,
  orElse: () => orElse2,
  orElseEither: () => orElseEither,
  orElseSome: () => orElseSome,
  partitionMap: () => partitionMap,
  product: () => product4,
  productMany: () => productMany4,
  reduceCompact: () => reduceCompact,
  some: () => some3,
  tap: () => tap,
  toArray: () => toArray,
  toRefinement: () => toRefinement,
  void: () => void_2,
  zipLeft: () => zipLeft,
  zipRight: () => zipRight,
  zipWith: () => zipWith2
});

// ../../node_modules/effect/dist/esm/Order.js
var Order_exports = {};
__export(Order_exports, {
  Date: () => Date3,
  all: () => all4,
  array: () => array3,
  between: () => between,
  bigint: () => bigint2,
  boolean: () => boolean2,
  clamp: () => clamp,
  combine: () => combine3,
  combineAll: () => combineAll2,
  combineMany: () => combineMany2,
  empty: () => empty,
  greaterThan: () => greaterThan,
  greaterThanOrEqualTo: () => greaterThanOrEqualTo,
  lessThan: () => lessThan,
  lessThanOrEqualTo: () => lessThanOrEqualTo,
  make: () => make2,
  mapInput: () => mapInput3,
  max: () => max,
  min: () => min,
  number: () => number3,
  product: () => product3,
  productMany: () => productMany3,
  reverse: () => reverse,
  string: () => string3,
  struct: () => struct3,
  tuple: () => tuple3
});
var make2 = (compare2) => (self, that) => self === that ? 0 : compare2(self, that);
var string3 = make2((self, that) => self < that ? -1 : 1);
var number3 = make2((self, that) => self < that ? -1 : 1);
var boolean2 = make2((self, that) => self < that ? -1 : 1);
var bigint2 = make2((self, that) => self < that ? -1 : 1);
var reverse = (O) => make2((self, that) => O(that, self));
var combine3 = dual(2, (self, that) => make2((a1, a2) => {
  const out = self(a1, a2);
  if (out !== 0) {
    return out;
  }
  return that(a1, a2);
}));
var combineMany2 = dual(2, (self, collection) => make2((a1, a2) => {
  let out = self(a1, a2);
  if (out !== 0) {
    return out;
  }
  for (const O of collection) {
    out = O(a1, a2);
    if (out !== 0) {
      return out;
    }
  }
  return out;
}));
var empty = () => make2(() => 0);
var combineAll2 = (collection) => combineMany2(empty(), collection);
var mapInput3 = dual(2, (self, f) => make2((b1, b2) => self(f(b1), f(b2))));
var Date3 = mapInput3(number3, (date5) => date5.getTime());
var product3 = dual(2, (self, that) => make2(([xa, xb], [ya, yb]) => {
  const o = self(xa, ya);
  return o !== 0 ? o : that(xb, yb);
}));
var all4 = (collection) => {
  return make2((x, y) => {
    const len = Math.min(x.length, y.length);
    let collectionLength = 0;
    for (const O of collection) {
      if (collectionLength >= len) {
        break;
      }
      const o = O(x[collectionLength], y[collectionLength]);
      if (o !== 0) {
        return o;
      }
      collectionLength++;
    }
    return 0;
  });
};
var productMany3 = dual(2, (self, collection) => {
  const O = all4(collection);
  return make2((x, y) => {
    const o = self(x[0], y[0]);
    return o !== 0 ? o : O(x.slice(1), y.slice(1));
  });
});
var tuple3 = (...elements) => all4(elements);
var array3 = (O) => make2((self, that) => {
  const aLen = self.length;
  const bLen = that.length;
  const len = Math.min(aLen, bLen);
  for (let i = 0; i < len; i++) {
    const o = O(self[i], that[i]);
    if (o !== 0) {
      return o;
    }
  }
  return number3(aLen, bLen);
});
var struct3 = (fields) => {
  const keys15 = Object.keys(fields);
  return make2((self, that) => {
    for (const key of keys15) {
      const o = fields[key](self[key], that[key]);
      if (o !== 0) {
        return o;
      }
    }
    return 0;
  });
};
var lessThan = (O) => dual(2, (self, that) => O(self, that) === -1);
var greaterThan = (O) => dual(2, (self, that) => O(self, that) === 1);
var lessThanOrEqualTo = (O) => dual(2, (self, that) => O(self, that) !== 1);
var greaterThanOrEqualTo = (O) => dual(2, (self, that) => O(self, that) !== -1);
var min = (O) => dual(2, (self, that) => self === that || O(self, that) < 1 ? self : that);
var max = (O) => dual(2, (self, that) => self === that || O(self, that) > -1 ? self : that);
var clamp = (O) => dual(2, (self, options) => min(O)(options.maximum, max(O)(options.minimum, self)));
var between = (O) => dual(2, (self, options) => !lessThan(O)(self, options.minimum) && !greaterThan(O)(self, options.maximum));

// ../../node_modules/effect/dist/esm/Option.js
var TypeId4 = Symbol.for("effect/Option");
var none2 = () => none;
var some3 = some2;
var isOption2 = isOption;
var isNone2 = isNone;
var isSome2 = isSome;
var match2 = dual(2, (self, {
  onNone,
  onSome
}) => isNone2(self) ? onNone() : onSome(self.value));
var toRefinement = (f) => (a) => isSome2(f(a));
var fromIterable = (collection) => {
  for (const a of collection) {
    return some3(a);
  }
  return none2();
};
var getRight3 = getRight;
var getLeft3 = getLeft;
var getOrElse2 = dual(2, (self, onNone) => isNone2(self) ? onNone() : self.value);
var orElse2 = dual(2, (self, that) => isNone2(self) ? that() : self);
var orElseSome = dual(2, (self, onNone) => isNone2(self) ? some3(onNone()) : self);
var orElseEither = dual(2, (self, that) => isNone2(self) ? map2(that(), right) : map2(self, left));
var firstSomeOf = (collection) => {
  let out = none2();
  for (out of collection) {
    if (isSome2(out)) {
      return out;
    }
  }
  return out;
};
var fromNullable2 = (nullableValue) => nullableValue == null ? none2() : some3(nullableValue);
var liftNullable = (f) => (...a) => fromNullable2(f(...a));
var getOrNull2 = getOrElse2(constNull);
var getOrUndefined2 = getOrElse2(constUndefined);
var liftThrowable = (f) => (...a) => {
  try {
    return some3(f(...a));
  } catch {
    return none2();
  }
};
var getOrThrowWith2 = dual(2, (self, onNone) => {
  if (isSome2(self)) {
    return self.value;
  }
  throw onNone();
});
var getOrThrow2 = getOrThrowWith2(() => new Error("getOrThrow called on a None"));
var map2 = dual(2, (self, f) => isNone2(self) ? none2() : some3(f(self.value)));
var as = dual(2, (self, b) => map2(self, () => b));
var asVoid = as(void 0);
var void_2 = some3(void 0);
var flatMap2 = dual(2, (self, f) => isNone2(self) ? none2() : f(self.value));
var andThen2 = dual(2, (self, f) => flatMap2(self, (a) => {
  const b = isFunction(f) ? f(a) : f;
  return isOption2(b) ? b : some3(b);
}));
var flatMapNullable = dual(2, (self, f) => isNone2(self) ? none2() : fromNullable2(f(self.value)));
var flatten = flatMap2(identity);
var zipRight = dual(2, (self, that) => flatMap2(self, () => that));
var zipLeft = dual(2, (self, that) => tap(self, () => that));
var composeK = dual(2, (afb, bfc) => (a) => flatMap2(afb(a), bfc));
var tap = dual(2, (self, f) => flatMap2(self, (a) => map2(f(a), () => a)));
var product4 = (self, that) => isSome2(self) && isSome2(that) ? some3([self.value, that.value]) : none2();
var productMany4 = (self, collection) => {
  if (isNone2(self)) {
    return none2();
  }
  const out = [self.value];
  for (const o of collection) {
    if (isNone2(o)) {
      return none2();
    }
    out.push(o.value);
  }
  return some3(out);
};
var all5 = (input) => {
  if (Symbol.iterator in input) {
    const out2 = [];
    for (const o of input) {
      if (isNone2(o)) {
        return none2();
      }
      out2.push(o.value);
    }
    return some3(out2);
  }
  const out = {};
  for (const key of Object.keys(input)) {
    const o = input[key];
    if (isNone2(o)) {
      return none2();
    }
    out[key] = o.value;
  }
  return some3(out);
};
var zipWith2 = dual(3, (self, that, f) => map2(product4(self, that), ([a, b]) => f(a, b)));
var ap2 = dual(2, (self, that) => zipWith2(self, that, (f, a) => f(a)));
var reduceCompact = dual(3, (self, b, f) => {
  let out = b;
  for (const oa of self) {
    if (isSome2(oa)) {
      out = f(out, oa.value);
    }
  }
  return out;
});
var toArray = (self) => isNone2(self) ? [] : [self.value];
var partitionMap = dual(2, (self, f) => {
  if (isNone2(self)) {
    return [none2(), none2()];
  }
  const e = f(self.value);
  return isLeft(e) ? [some3(e.left), none2()] : [none2(), some3(e.right)];
});
var filterMap = flatMap2;
var filter = dual(2, (self, predicate) => filterMap(self, (b) => predicate(b) ? some2(b) : none));
var getEquivalence2 = (isEquivalent) => make((x, y) => isNone2(x) ? isNone2(y) : isNone2(y) ? false : isEquivalent(x.value, y.value));
var getOrder = (O) => make2((self, that) => isSome2(self) ? isSome2(that) ? O(self.value, that.value) : 1 : -1);
var lift2 = (f) => dual(2, (self, that) => zipWith2(self, that, f));
var liftPredicate2 = dual(2, (b, predicate) => predicate(b) ? some3(b) : none2());
var containsWith = (isEquivalent) => dual(2, (self, a) => isNone2(self) ? false : isEquivalent(self.value, a));
var _equivalence = equivalence();
var contains = containsWith(_equivalence);
var exists = dual(2, (self, refinement) => isNone2(self) ? false : refinement(self.value));
var bindTo3 = bindTo(map2);
var let_3 = let_(map2);
var bind3 = bind(map2, flatMap2);
var Do2 = some3({});
var adapter3 = adapter();
var gen2 = (...args2) => {
  const f = args2.length === 1 ? args2[0] : args2[1].bind(args2[0]);
  const iterator = f(adapter3);
  let state = iterator.next();
  while (!state.done) {
    const current2 = isGenKind(state.value) ? state.value.value : yieldWrapGet(state.value);
    if (isNone2(current2)) {
      return current2;
    }
    state = iterator.next(current2.value);
  }
  return some3(state.value);
};
var mergeWith = (f) => (o1, o2) => {
  if (isNone2(o1)) {
    return o2;
  } else if (isNone2(o2)) {
    return o1;
  }
  return some3(f(o1.value, o2.value));
};

// ../../node_modules/effect/dist/esm/Tuple.js
var Tuple_exports = {};
__export(Tuple_exports, {
  appendElement: () => appendElement,
  at: () => at,
  getEquivalence: () => getEquivalence3,
  getFirst: () => getFirst,
  getOrder: () => getOrder2,
  getSecond: () => getSecond,
  isTupleOf: () => isTupleOf,
  isTupleOfAtLeast: () => isTupleOfAtLeast,
  make: () => make3,
  map: () => map3,
  mapBoth: () => mapBoth2,
  mapFirst: () => mapFirst,
  mapSecond: () => mapSecond,
  swap: () => swap
});
var make3 = (...elements) => elements;
var getFirst = (self) => self[0];
var getSecond = (self) => self[1];
var map3 = dual(2, (self, fn2) => self.map((element2) => fn2(element2)));
var mapBoth2 = dual(2, (self, {
  onFirst,
  onSecond
}) => [onFirst(self[0]), onSecond(self[1])]);
var mapFirst = dual(2, (self, f) => [f(self[0]), self[1]]);
var mapSecond = dual(2, (self, f) => [self[0], f(self[1])]);
var swap = (self) => [self[1], self[0]];
var getEquivalence3 = tuple;
var getOrder2 = tuple3;
var appendElement = dual(2, (self, that) => [...self, that]);
var at = dual(2, (self, index) => self[index]);

// ../../node_modules/effect/dist/esm/Iterable.js
var makeBy = (f, options) => {
  const max13 = options?.length !== void 0 ? Math.max(1, Math.floor(options.length)) : Infinity;
  return {
    [Symbol.iterator]() {
      let i = 0;
      return {
        next() {
          if (i < max13) {
            return {
              value: f(i++),
              done: false
            };
          }
          return {
            done: true,
            value: void 0
          };
        }
      };
    }
  };
};
var range = (start5, end7) => {
  if (end7 === void 0) {
    return makeBy((i) => start5 + i);
  }
  return makeBy((i) => start5 + i, {
    length: start5 <= end7 ? end7 - start5 + 1 : 1
  });
};
var replicate = dual(2, (a, n) => makeBy(() => a, {
  length: n
}));
var fromRecord = (self) => ({
  *[Symbol.iterator]() {
    for (const key in self) {
      if (Object.prototype.hasOwnProperty.call(self, key)) {
        yield [key, self[key]];
      }
    }
  }
});
var prepend = dual(2, (self, head13) => prependAll(self, [head13]));
var prependAll = dual(2, (self, that) => appendAll(that, self));
var append = dual(2, (self, last8) => appendAll(self, [last8]));
var appendAll = dual(2, (self, that) => ({
  [Symbol.iterator]() {
    const iterA = self[Symbol.iterator]();
    let doneA = false;
    let iterB;
    return {
      next() {
        if (!doneA) {
          const r = iterA.next();
          if (r.done) {
            doneA = true;
            iterB = that[Symbol.iterator]();
            return iterB.next();
          }
          return r;
        }
        return iterB.next();
      }
    };
  }
}));
var scan = dual(3, (self, b, f) => ({
  [Symbol.iterator]() {
    let acc = b;
    let iterator;
    function next6() {
      if (iterator === void 0) {
        iterator = self[Symbol.iterator]();
        return {
          done: false,
          value: acc
        };
      }
      const result = iterator.next();
      if (result.done) {
        return result;
      }
      acc = f(acc, result.value);
      return {
        done: false,
        value: acc
      };
    }
    return {
      next: next6
    };
  }
}));
var isEmpty = (self) => {
  const iterator = self[Symbol.iterator]();
  return iterator.next().done === true;
};
var size = (self) => {
  const iterator = self[Symbol.iterator]();
  let count9 = 0;
  while (!iterator.next().done) {
    count9++;
  }
  return count9;
};
var head = (self) => {
  const iterator = self[Symbol.iterator]();
  const result = iterator.next();
  return result.done ? none2() : some3(result.value);
};
var unsafeHead = (self) => {
  const iterator = self[Symbol.iterator]();
  const result = iterator.next();
  if (result.done) throw new Error("unsafeHead: empty iterable");
  return result.value;
};
var take = dual(2, (self, n) => ({
  [Symbol.iterator]() {
    let i = 0;
    const iterator = self[Symbol.iterator]();
    return {
      next() {
        if (i < n) {
          i++;
          return iterator.next();
        }
        return {
          done: true,
          value: void 0
        };
      }
    };
  }
}));
var takeWhile = dual(2, (self, predicate) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let i = 0;
    return {
      next() {
        const result = iterator.next();
        if (result.done || !predicate(result.value, i++)) {
          return {
            done: true,
            value: void 0
          };
        }
        return result;
      }
    };
  }
}));
var drop = dual(2, (self, n) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let i = 0;
    return {
      next() {
        while (i < n) {
          const result = iterator.next();
          if (result.done) {
            return {
              done: true,
              value: void 0
            };
          }
          i++;
        }
        return iterator.next();
      }
    };
  }
}));
var findFirst = dual(2, (self, f) => {
  let i = 0;
  for (const a of self) {
    const o = f(a, i);
    if (isBoolean(o)) {
      if (o) {
        return some3(a);
      }
    } else {
      if (isSome2(o)) {
        return o;
      }
    }
    i++;
  }
  return none2();
});
var findLast = dual(2, (self, f) => {
  let i = 0;
  let last8 = none2();
  for (const a of self) {
    const o = f(a, i);
    if (isBoolean(o)) {
      if (o) {
        last8 = some3(a);
      }
    } else {
      if (isSome2(o)) {
        last8 = o;
      }
    }
    i++;
  }
  return last8;
});
var zip = dual(2, (self, that) => zipWith3(self, that, make3));
var zipWith3 = dual(3, (self, that, f) => ({
  [Symbol.iterator]() {
    const selfIterator = self[Symbol.iterator]();
    const thatIterator = that[Symbol.iterator]();
    return {
      next() {
        const selfResult = selfIterator.next();
        const thatResult = thatIterator.next();
        if (selfResult.done || thatResult.done) {
          return {
            done: true,
            value: void 0
          };
        }
        return {
          done: false,
          value: f(selfResult.value, thatResult.value)
        };
      }
    };
  }
}));
var intersperse = dual(2, (self, middle) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let next6 = iterator.next();
    let emitted = false;
    return {
      next() {
        if (next6.done) {
          return next6;
        } else if (emitted) {
          emitted = false;
          return {
            done: false,
            value: middle
          };
        }
        emitted = true;
        const result = next6;
        next6 = iterator.next();
        return result;
      }
    };
  }
}));
var containsWith2 = (isEquivalent) => dual(2, (self, a) => {
  for (const i of self) {
    if (isEquivalent(a, i)) {
      return true;
    }
  }
  return false;
});
var _equivalence2 = equivalence();
var contains2 = containsWith2(_equivalence2);
var chunksOf = dual(2, (self, n) => {
  const safeN = Math.max(1, Math.floor(n));
  return {
    [Symbol.iterator]() {
      let iterator = self[Symbol.iterator]();
      return {
        next() {
          if (iterator === void 0) {
            return {
              done: true,
              value: void 0
            };
          }
          const chunk7 = [];
          for (let i = 0; i < safeN; i++) {
            const result = iterator.next();
            if (result.done) {
              iterator = void 0;
              return chunk7.length === 0 ? {
                done: true,
                value: void 0
              } : {
                done: false,
                value: chunk7
              };
            }
            chunk7.push(result.value);
          }
          return {
            done: false,
            value: chunk7
          };
        }
      };
    }
  };
});
var groupWith = dual(2, (self, isEquivalent) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let nextResult;
    return {
      next() {
        let result;
        if (nextResult !== void 0) {
          if (nextResult.done) {
            return {
              done: true,
              value: void 0
            };
          }
          result = nextResult;
          nextResult = void 0;
        } else {
          result = iterator.next();
          if (result.done) {
            return {
              done: true,
              value: void 0
            };
          }
        }
        const chunk7 = [result.value];
        while (true) {
          const next6 = iterator.next();
          if (next6.done || !isEquivalent(result.value, next6.value)) {
            nextResult = next6;
            return {
              done: false,
              value: chunk7
            };
          }
          chunk7.push(next6.value);
        }
      }
    };
  }
}));
var group = groupWith(equivalence());
var groupBy = dual(2, (self, f) => {
  const out = {};
  for (const a of self) {
    const k = f(a);
    if (Object.prototype.hasOwnProperty.call(out, k)) {
      out[k].push(a);
    } else {
      out[k] = [a];
    }
  }
  return out;
});
var constEmpty = {
  [Symbol.iterator]() {
    return constEmptyIterator;
  }
};
var constEmptyIterator = {
  next() {
    return {
      done: true,
      value: void 0
    };
  }
};
var empty2 = () => constEmpty;
var of = (a) => [a];
var map4 = dual(2, (self, f) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let i = 0;
    return {
      next() {
        const result = iterator.next();
        if (result.done) {
          return {
            done: true,
            value: void 0
          };
        }
        return {
          done: false,
          value: f(result.value, i++)
        };
      }
    };
  }
}));
var flatMap3 = dual(2, (self, f) => flatten2(map4(self, f)));
var flatten2 = (self) => ({
  [Symbol.iterator]() {
    const outerIterator = self[Symbol.iterator]();
    let innerIterator;
    function next6() {
      if (innerIterator === void 0) {
        const next7 = outerIterator.next();
        if (next7.done) {
          return next7;
        }
        innerIterator = next7.value[Symbol.iterator]();
      }
      const result = innerIterator.next();
      if (result.done) {
        innerIterator = void 0;
        return next6();
      }
      return result;
    }
    return {
      next: next6
    };
  }
});
var filterMap2 = dual(2, (self, f) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let i = 0;
    return {
      next() {
        let result = iterator.next();
        while (!result.done) {
          const b = f(result.value, i++);
          if (isSome2(b)) {
            return {
              done: false,
              value: b.value
            };
          }
          result = iterator.next();
        }
        return {
          done: true,
          value: void 0
        };
      }
    };
  }
}));
var filterMapWhile = dual(2, (self, f) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let i = 0;
    return {
      next() {
        const result = iterator.next();
        if (result.done) {
          return {
            done: true,
            value: void 0
          };
        }
        const b = f(result.value, i++);
        if (isSome2(b)) {
          return {
            done: false,
            value: b.value
          };
        }
        return {
          done: true,
          value: void 0
        };
      }
    };
  }
}));
var getSomes = filterMap2(identity);
var getLefts = (self) => filterMap2(self, getLeft2);
var getRights = (self) => filterMap2(self, getRight2);
var filter2 = dual(2, (self, predicate) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let i = 0;
    return {
      next() {
        let result = iterator.next();
        while (!result.done) {
          if (predicate(result.value, i++)) {
            return {
              done: false,
              value: result.value
            };
          }
          result = iterator.next();
        }
        return {
          done: true,
          value: void 0
        };
      }
    };
  }
}));
var flatMapNullable2 = dual(2, (self, f) => filterMap2(self, (a) => {
  const b = f(a);
  return b == null ? none2() : some3(b);
}));
var some4 = dual(2, (self, predicate) => {
  let i = 0;
  for (const a of self) {
    if (predicate(a, i++)) {
      return true;
    }
  }
  return false;
});
var unfold = (b, f) => ({
  [Symbol.iterator]() {
    let next6 = b;
    return {
      next() {
        const o = f(next6);
        if (isNone2(o)) {
          return {
            done: true,
            value: void 0
          };
        }
        const [a, b2] = o.value;
        next6 = b2;
        return {
          done: false,
          value: a
        };
      }
    };
  }
});
var forEach = dual(2, (self, f) => {
  let i = 0;
  for (const a of self) {
    f(a, i++);
  }
});
var reduce = dual(3, (self, b, f) => {
  if (Array.isArray(self)) {
    return self.reduce(f, b);
  }
  let i = 0;
  let result = b;
  for (const n of self) {
    result = f(result, n, i++);
  }
  return result;
});
var dedupeAdjacentWith = dual(2, (self, isEquivalent) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let first5 = true;
    let last8;
    function next6() {
      const result = iterator.next();
      if (result.done) {
        return {
          done: true,
          value: void 0
        };
      }
      if (first5) {
        first5 = false;
        last8 = result.value;
        return result;
      }
      const current2 = result.value;
      if (isEquivalent(last8, current2)) {
        return next6();
      }
      last8 = current2;
      return result;
    }
    return {
      next: next6
    };
  }
}));
var dedupeAdjacent = dedupeAdjacentWith(equivalence());
var cartesianWith = dual(3, (self, that, f) => flatMap3(self, (a) => map4(that, (b) => f(a, b))));
var cartesian = dual(2, (self, that) => cartesianWith(self, that, (a, b) => [a, b]));
var countBy = dual(2, (self, f) => {
  let count9 = 0;
  let i = 0;
  for (const a of self) {
    if (f(a, i)) {
      count9++;
    }
    i++;
  }
  return count9;
});

// ../../node_modules/effect/dist/esm/Record.js
var Record_exports = {};
__export(Record_exports, {
  collect: () => collect,
  difference: () => difference,
  empty: () => empty3,
  every: () => every2,
  filter: () => filter3,
  filterMap: () => filterMap3,
  findFirst: () => findFirst2,
  fromEntries: () => fromEntries,
  fromIterableBy: () => fromIterableBy,
  fromIterableWith: () => fromIterableWith,
  get: () => get,
  getEquivalence: () => getEquivalence4,
  getLefts: () => getLefts2,
  getRights: () => getRights2,
  getSomes: () => getSomes2,
  has: () => has,
  intersection: () => intersection,
  isEmptyReadonlyRecord: () => isEmptyReadonlyRecord,
  isEmptyRecord: () => isEmptyRecord,
  isSubrecord: () => isSubrecord,
  isSubrecordBy: () => isSubrecordBy,
  keys: () => keys,
  map: () => map5,
  mapEntries: () => mapEntries,
  mapKeys: () => mapKeys,
  modify: () => modify,
  modifyOption: () => modifyOption,
  partition: () => partition,
  partitionMap: () => partitionMap2,
  pop: () => pop,
  reduce: () => reduce2,
  remove: () => remove,
  replace: () => replace,
  replaceOption: () => replaceOption,
  separate: () => separate,
  set: () => set,
  singleton: () => singleton,
  size: () => size2,
  some: () => some5,
  toEntries: () => toEntries,
  union: () => union,
  values: () => values
});
var empty3 = () => ({});
var isEmptyRecord = (self) => keys(self).length === 0;
var isEmptyReadonlyRecord = isEmptyRecord;
var fromIterableWith = dual(2, (self, f) => {
  const out = empty3();
  for (const a of self) {
    const [k, b] = f(a);
    out[k] = b;
  }
  return out;
});
var fromIterableBy = (items, f) => fromIterableWith(items, (a) => [f(a), a]);
var fromEntries = Object.fromEntries;
var collect = dual(2, (self, f) => {
  const out = [];
  for (const key of keys(self)) {
    out.push(f(key, self[key]));
  }
  return out;
});
var toEntries = collect((key, value10) => [key, value10]);
var size2 = (self) => keys(self).length;
var has = dual(2, (self, key) => Object.prototype.hasOwnProperty.call(self, key));
var get = dual(2, (self, key) => has(self, key) ? some3(self[key]) : none2());
var modify = dual(3, (self, key, f) => {
  if (!has(self, key)) {
    return {
      ...self
    };
  }
  return {
    ...self,
    [key]: f(self[key])
  };
});
var modifyOption = dual(3, (self, key, f) => {
  if (!has(self, key)) {
    return none2();
  }
  return some3({
    ...self,
    [key]: f(self[key])
  });
});
var replaceOption = dual(3, (self, key, b) => modifyOption(self, key, () => b));
var remove = dual(2, (self, key) => {
  if (!has(self, key)) {
    return {
      ...self
    };
  }
  const out = {
    ...self
  };
  delete out[key];
  return out;
});
var pop = dual(2, (self, key) => has(self, key) ? some3([self[key], remove(self, key)]) : none2());
var map5 = dual(2, (self, f) => {
  const out = {
    ...self
  };
  for (const key of keys(self)) {
    out[key] = f(self[key], key);
  }
  return out;
});
var mapKeys = dual(2, (self, f) => {
  const out = {};
  for (const key of keys(self)) {
    const a = self[key];
    out[f(key, a)] = a;
  }
  return out;
});
var mapEntries = dual(2, (self, f) => {
  const out = {};
  for (const key of keys(self)) {
    const [k, b] = f(self[key], key);
    out[k] = b;
  }
  return out;
});
var filterMap3 = dual(2, (self, f) => {
  const out = empty3();
  for (const key of keys(self)) {
    const o = f(self[key], key);
    if (isSome2(o)) {
      out[key] = o.value;
    }
  }
  return out;
});
var filter3 = dual(2, (self, predicate) => {
  const out = empty3();
  for (const key of keys(self)) {
    if (predicate(self[key], key)) {
      out[key] = self[key];
    }
  }
  return out;
});
var getSomes2 = filterMap3(identity);
var getLefts2 = (self) => {
  const out = empty3();
  for (const key of keys(self)) {
    const value10 = self[key];
    if (isLeft2(value10)) {
      out[key] = value10.left;
    }
  }
  return out;
};
var getRights2 = (self) => {
  const out = empty3();
  for (const key of keys(self)) {
    const value10 = self[key];
    if (isRight2(value10)) {
      out[key] = value10.right;
    }
  }
  return out;
};
var partitionMap2 = dual(2, (self, f) => {
  const left3 = empty3();
  const right3 = empty3();
  for (const key of keys(self)) {
    const e = f(self[key], key);
    if (isLeft2(e)) {
      left3[key] = e.left;
    } else {
      right3[key] = e.right;
    }
  }
  return [left3, right3];
});
var separate = partitionMap2(identity);
var partition = dual(2, (self, predicate) => {
  const left3 = empty3();
  const right3 = empty3();
  for (const key of keys(self)) {
    if (predicate(self[key], key)) {
      right3[key] = self[key];
    } else {
      left3[key] = self[key];
    }
  }
  return [left3, right3];
});
var keys = (self) => Object.keys(self);
var values = (self) => collect(self, (_, a) => a);
var set = dual(3, (self, key, value10) => {
  return {
    ...self,
    [key]: value10
  };
});
var replace = dual(3, (self, key, value10) => {
  if (has(self, key)) {
    return {
      ...self,
      [key]: value10
    };
  }
  return {
    ...self
  };
});
var isSubrecordBy = (equivalence3) => dual(2, (self, that) => {
  for (const key of keys(self)) {
    if (!has(that, key) || !equivalence3(self[key], that[key])) {
      return false;
    }
  }
  return true;
});
var isSubrecord = isSubrecordBy(equivalence());
var reduce2 = dual(3, (self, zero3, f) => {
  let out = zero3;
  for (const key of keys(self)) {
    out = f(out, self[key], key);
  }
  return out;
});
var every2 = dual(2, (self, refinement) => {
  for (const key of keys(self)) {
    if (!refinement(self[key], key)) {
      return false;
    }
  }
  return true;
});
var some5 = dual(2, (self, predicate) => {
  for (const key of keys(self)) {
    if (predicate(self[key], key)) {
      return true;
    }
  }
  return false;
});
var union = dual(3, (self, that, combine20) => {
  if (isEmptyRecord(self)) {
    return {
      ...that
    };
  }
  if (isEmptyRecord(that)) {
    return {
      ...self
    };
  }
  const out = empty3();
  for (const key of keys(self)) {
    if (has(that, key)) {
      out[key] = combine20(self[key], that[key]);
    } else {
      out[key] = self[key];
    }
  }
  for (const key of keys(that)) {
    if (!has(out, key)) {
      out[key] = that[key];
    }
  }
  return out;
});
var intersection = dual(3, (self, that, combine20) => {
  const out = empty3();
  if (isEmptyRecord(self) || isEmptyRecord(that)) {
    return out;
  }
  for (const key of keys(self)) {
    if (has(that, key)) {
      out[key] = combine20(self[key], that[key]);
    }
  }
  return out;
});
var difference = dual(2, (self, that) => {
  if (isEmptyRecord(self)) {
    return {
      ...that
    };
  }
  if (isEmptyRecord(that)) {
    return {
      ...self
    };
  }
  const out = {};
  for (const key of keys(self)) {
    if (!has(that, key)) {
      out[key] = self[key];
    }
  }
  for (const key of keys(that)) {
    if (!has(self, key)) {
      out[key] = that[key];
    }
  }
  return out;
});
var getEquivalence4 = (equivalence3) => {
  const is4 = isSubrecordBy(equivalence3);
  return (self, that) => is4(self, that) && is4(that, self);
};
var singleton = (key, value10) => ({
  [key]: value10
});
var findFirst2 = dual(2, (self, f) => {
  const k = keys(self);
  for (let i = 0; i < k.length; i++) {
    const key = k[i];
    if (f(self[key], key)) {
      return some3([key, self[key]]);
    }
  }
  return none2();
});

// ../../node_modules/effect/dist/esm/Array.js
var make4 = (...elements) => elements;
var allocate = (n) => new Array(n);
var makeBy2 = dual(2, (n, f) => {
  const max13 = Math.max(1, Math.floor(n));
  const out = new Array(max13);
  for (let i = 0; i < max13; i++) {
    out[i] = f(i);
  }
  return out;
});
var range2 = (start5, end7) => start5 <= end7 ? makeBy2(end7 - start5 + 1, (i) => start5 + i) : [start5];
var replicate2 = dual(2, (a, n) => makeBy2(n, () => a));
var fromIterable2 = (collection) => Array.isArray(collection) ? collection : Array.from(collection);
var ensure = (self) => Array.isArray(self) ? self : [self];
var fromRecord2 = toEntries;
var fromOption3 = toArray;
var match3 = dual(2, (self, {
  onEmpty,
  onNonEmpty
}) => isNonEmptyReadonlyArray(self) ? onNonEmpty(self) : onEmpty());
var matchLeft = dual(2, (self, {
  onEmpty,
  onNonEmpty
}) => isNonEmptyReadonlyArray(self) ? onNonEmpty(headNonEmpty(self), tailNonEmpty(self)) : onEmpty());
var matchRight = dual(2, (self, {
  onEmpty,
  onNonEmpty
}) => isNonEmptyReadonlyArray(self) ? onNonEmpty(initNonEmpty(self), lastNonEmpty(self)) : onEmpty());
var prepend2 = dual(2, (self, head13) => [head13, ...self]);
var prependAll2 = dual(2, (self, that) => fromIterable2(that).concat(fromIterable2(self)));
var append2 = dual(2, (self, last8) => [...self, last8]);
var appendAll2 = dual(2, (self, that) => fromIterable2(self).concat(fromIterable2(that)));
var scan2 = dual(3, (self, b, f) => {
  const out = [b];
  let i = 0;
  for (const a of self) {
    out[i + 1] = f(out[i], a);
    i++;
  }
  return out;
});
var scanRight = dual(3, (self, b, f) => {
  const input = fromIterable2(self);
  const out = new Array(input.length + 1);
  out[input.length] = b;
  for (let i = input.length - 1; i >= 0; i--) {
    out[i] = f(out[i + 1], input[i]);
  }
  return out;
});
var isArray = Array.isArray;
var isEmptyArray = (self) => self.length === 0;
var isEmptyReadonlyArray = isEmptyArray;
var isNonEmptyArray2 = isNonEmptyArray;
var isNonEmptyReadonlyArray = isNonEmptyArray;
var length = (self) => self.length;
var isOutOfBounds = (i, as18) => i < 0 || i >= as18.length;
var clamp2 = (i, as18) => Math.floor(Math.min(Math.max(0, i), as18.length));
var get2 = dual(2, (self, index) => {
  const i = Math.floor(index);
  return isOutOfBounds(i, self) ? none2() : some3(self[i]);
});
var unsafeGet = dual(2, (self, index) => {
  const i = Math.floor(index);
  if (isOutOfBounds(i, self)) {
    throw new Error(`Index ${i} out of bounds`);
  }
  return self[i];
});
var unprepend = (self) => [headNonEmpty(self), tailNonEmpty(self)];
var unappend = (self) => [initNonEmpty(self), lastNonEmpty(self)];
var head2 = get2(0);
var headNonEmpty = unsafeGet(0);
var last = (self) => isNonEmptyReadonlyArray(self) ? some3(lastNonEmpty(self)) : none2();
var lastNonEmpty = (self) => self[self.length - 1];
var tail = (self) => {
  const input = fromIterable2(self);
  return isNonEmptyReadonlyArray(input) ? some3(tailNonEmpty(input)) : none2();
};
var tailNonEmpty = (self) => self.slice(1);
var init = (self) => {
  const input = fromIterable2(self);
  return isNonEmptyReadonlyArray(input) ? some3(initNonEmpty(input)) : none2();
};
var initNonEmpty = (self) => self.slice(0, -1);
var take2 = dual(2, (self, n) => {
  const input = fromIterable2(self);
  return input.slice(0, clamp2(n, input));
});
var takeRight = dual(2, (self, n) => {
  const input = fromIterable2(self);
  const i = clamp2(n, input);
  return i === 0 ? [] : input.slice(-i);
});
var takeWhile2 = dual(2, (self, predicate) => {
  let i = 0;
  const out = [];
  for (const a of self) {
    if (!predicate(a, i)) {
      break;
    }
    out.push(a);
    i++;
  }
  return out;
});
var spanIndex = (self, predicate) => {
  let i = 0;
  for (const a of self) {
    if (!predicate(a, i)) {
      break;
    }
    i++;
  }
  return i;
};
var span = dual(2, (self, predicate) => splitAt(self, spanIndex(self, predicate)));
var drop2 = dual(2, (self, n) => {
  const input = fromIterable2(self);
  return input.slice(clamp2(n, input), input.length);
});
var dropRight = dual(2, (self, n) => {
  const input = fromIterable2(self);
  return input.slice(0, input.length - clamp2(n, input));
});
var dropWhile = dual(2, (self, predicate) => fromIterable2(self).slice(spanIndex(self, predicate)));
var findFirstIndex = dual(2, (self, predicate) => {
  let i = 0;
  for (const a of self) {
    if (predicate(a, i)) {
      return some3(i);
    }
    i++;
  }
  return none2();
});
var findLastIndex = dual(2, (self, predicate) => {
  const input = fromIterable2(self);
  for (let i = input.length - 1; i >= 0; i--) {
    if (predicate(input[i], i)) {
      return some3(i);
    }
  }
  return none2();
});
var findFirst3 = findFirst;
var findLast2 = dual(2, (self, f) => {
  const input = fromIterable2(self);
  for (let i = input.length - 1; i >= 0; i--) {
    const a = input[i];
    const o = f(a, i);
    if (isBoolean(o)) {
      if (o) {
        return some3(a);
      }
    } else {
      if (isSome2(o)) {
        return o;
      }
    }
  }
  return none2();
});
var findFirstWithIndex = dual(2, (self, f) => {
  let i = 0;
  for (const a of self) {
    const o = f(a, i);
    if (isBoolean(o)) {
      if (o) {
        return some3([a, i]);
      }
    } else {
      if (isSome2(o)) {
        return some3([o.value, i]);
      }
    }
    i++;
  }
  return none2();
});
var countBy2 = dual(2, (self, f) => {
  let count9 = 0;
  const as18 = fromIterable2(self);
  for (let i = 0; i < as18.length; i++) {
    const a = as18[i];
    if (f(a, i)) {
      count9++;
    }
  }
  return count9;
});
var insertAt = dual(3, (self, i, b) => {
  const out = Array.from(self);
  if (i < 0 || i > out.length) {
    return none2();
  }
  out.splice(i, 0, b);
  return some3(out);
});
var replace2 = dual(3, (self, i, b) => modify2(self, i, () => b));
var replaceOption2 = dual(3, (self, i, b) => modifyOption2(self, i, () => b));
var modify2 = dual(3, (self, i, f) => {
  const out = Array.from(self);
  if (isOutOfBounds(i, out)) {
    return out;
  }
  const b = f(out[i]);
  out[i] = b;
  return out;
});
var modifyOption2 = dual(3, (self, i, f) => {
  const arr = fromIterable2(self);
  if (isOutOfBounds(i, arr)) {
    return none2();
  }
  const out = Array.isArray(self) ? self.slice() : arr;
  const b = f(arr[i]);
  out[i] = b;
  return some3(out);
});
var remove2 = dual(2, (self, i) => {
  const out = Array.from(self);
  if (isOutOfBounds(i, out)) {
    return out;
  }
  out.splice(i, 1);
  return out;
});
var removeOption = dual(2, (self, i) => {
  const arr = fromIterable2(self);
  if (isOutOfBounds(i, arr)) {
    return none2();
  }
  const out = Array.isArray(self) ? self.slice() : arr;
  out.splice(i, 1);
  return some3(out);
});
var reverse2 = (self) => Array.from(self).reverse();
var sort = dual(2, (self, O) => {
  const out = Array.from(self);
  out.sort(O);
  return out;
});
var sortWith = dual(3, (self, f, order) => Array.from(self).map((a) => [a, f(a)]).sort(([, a], [, b]) => order(a, b)).map(([_]) => _));
var sortBy = (...orders) => {
  const sortByAll = sort(combineAll2(orders));
  return (self) => {
    const input = fromIterable2(self);
    if (isNonEmptyReadonlyArray(input)) {
      return sortByAll(input);
    }
    return [];
  };
};
var zip2 = dual(2, (self, that) => zipWith4(self, that, make3));
var zipWith4 = dual(3, (self, that, f) => {
  const as18 = fromIterable2(self);
  const bs = fromIterable2(that);
  if (isNonEmptyReadonlyArray(as18) && isNonEmptyReadonlyArray(bs)) {
    const out = [f(headNonEmpty(as18), headNonEmpty(bs))];
    const len = Math.min(as18.length, bs.length);
    for (let i = 1; i < len; i++) {
      out[i] = f(as18[i], bs[i]);
    }
    return out;
  }
  return [];
});
var unzip = (self) => {
  const input = fromIterable2(self);
  if (isNonEmptyReadonlyArray(input)) {
    const fa = [input[0][0]];
    const fb = [input[0][1]];
    for (let i = 1; i < input.length; i++) {
      fa[i] = input[i][0];
      fb[i] = input[i][1];
    }
    return [fa, fb];
  }
  return [[], []];
};
var intersperse2 = dual(2, (self, middle) => {
  const input = fromIterable2(self);
  if (isNonEmptyReadonlyArray(input)) {
    const out = [headNonEmpty(input)];
    const tail5 = tailNonEmpty(input);
    for (let i = 0; i < tail5.length; i++) {
      if (i < tail5.length) {
        out.push(middle);
      }
      out.push(tail5[i]);
    }
    return out;
  }
  return [];
});
var modifyNonEmptyHead = dual(2, (self, f) => [f(headNonEmpty(self)), ...tailNonEmpty(self)]);
var setNonEmptyHead = dual(2, (self, b) => modifyNonEmptyHead(self, () => b));
var modifyNonEmptyLast = dual(2, (self, f) => append2(initNonEmpty(self), f(lastNonEmpty(self))));
var setNonEmptyLast = dual(2, (self, b) => modifyNonEmptyLast(self, () => b));
var rotate = dual(2, (self, n) => {
  const input = fromIterable2(self);
  if (isNonEmptyReadonlyArray(input)) {
    const len = input.length;
    const m = Math.round(n) % len;
    if (isOutOfBounds(Math.abs(m), input) || m === 0) {
      return copy(input);
    }
    if (m < 0) {
      const [f, s] = splitNonEmptyAt(input, -m);
      return appendAll2(s, f);
    } else {
      return rotate(self, m - len);
    }
  }
  return [];
});
var containsWith3 = (isEquivalent) => dual(2, (self, a) => {
  for (const i of self) {
    if (isEquivalent(a, i)) {
      return true;
    }
  }
  return false;
});
var _equivalence3 = equivalence();
var contains3 = containsWith3(_equivalence3);
var chop = dual(2, (self, f) => {
  const input = fromIterable2(self);
  if (isNonEmptyReadonlyArray(input)) {
    const [b, rest] = f(input);
    const out = [b];
    let next6 = rest;
    while (isNonEmptyArray(next6)) {
      const [b2, rest2] = f(next6);
      out.push(b2);
      next6 = rest2;
    }
    return out;
  }
  return [];
});
var splitAt = dual(2, (self, n) => {
  const input = Array.from(self);
  const _n = Math.floor(n);
  if (isNonEmptyReadonlyArray(input)) {
    if (_n >= 1) {
      return splitNonEmptyAt(input, _n);
    }
    return [[], input];
  }
  return [input, []];
});
var splitNonEmptyAt = dual(2, (self, n) => {
  const _n = Math.max(1, Math.floor(n));
  return _n >= self.length ? [copy(self), []] : [prepend2(self.slice(1, _n), headNonEmpty(self)), self.slice(_n)];
});
var split = dual(2, (self, n) => {
  const input = fromIterable2(self);
  return chunksOf2(input, Math.ceil(input.length / Math.floor(n)));
});
var splitWhere = dual(2, (self, predicate) => span(self, (a, i) => !predicate(a, i)));
var copy = (self) => self.slice();
var pad = dual(3, (self, n, fill) => {
  if (self.length >= n) {
    return take2(self, n);
  }
  return appendAll2(self, makeBy2(n - self.length, () => fill));
});
var chunksOf2 = dual(2, (self, n) => {
  const input = fromIterable2(self);
  if (isNonEmptyReadonlyArray(input)) {
    return chop(input, splitNonEmptyAt(n));
  }
  return [];
});
var window = dual(2, (self, n) => {
  const input = fromIterable2(self);
  if (n > 0 && isNonEmptyReadonlyArray(input)) {
    return Array.from({
      length: input.length - (n - 1)
    }, (_, index) => input.slice(index, index + n));
  }
  return [];
});
var groupWith2 = dual(2, (self, isEquivalent) => chop(self, (as18) => {
  const h2 = headNonEmpty(as18);
  const out = [h2];
  let i = 1;
  for (; i < as18.length; i++) {
    const a = as18[i];
    if (isEquivalent(a, h2)) {
      out.push(a);
    } else {
      break;
    }
  }
  return [out, as18.slice(i)];
}));
var group2 = groupWith2(equivalence());
var groupBy2 = dual(2, (self, f) => {
  const out = {};
  for (const a of self) {
    const k = f(a);
    if (Object.prototype.hasOwnProperty.call(out, k)) {
      out[k].push(a);
    } else {
      out[k] = [a];
    }
  }
  return out;
});
var unionWith = dual(3, (self, that, isEquivalent) => {
  const a = fromIterable2(self);
  const b = fromIterable2(that);
  if (isNonEmptyReadonlyArray(a)) {
    if (isNonEmptyReadonlyArray(b)) {
      const dedupe3 = dedupeWith(isEquivalent);
      return dedupe3(appendAll2(a, b));
    }
    return a;
  }
  return b;
});
var union2 = dual(2, (self, that) => unionWith(self, that, _equivalence3));
var intersectionWith = (isEquivalent) => {
  const has19 = containsWith3(isEquivalent);
  return dual(2, (self, that) => fromIterable2(self).filter((a) => has19(that, a)));
};
var intersection2 = intersectionWith(_equivalence3);
var differenceWith = (isEquivalent) => {
  const has19 = containsWith3(isEquivalent);
  return dual(2, (self, that) => fromIterable2(self).filter((a) => !has19(that, a)));
};
var difference2 = differenceWith(_equivalence3);
var empty4 = () => [];
var of2 = (a) => [a];
var map6 = dual(2, (self, f) => self.map(f));
var flatMap4 = dual(2, (self, f) => {
  if (isEmptyReadonlyArray(self)) {
    return [];
  }
  const out = [];
  for (let i = 0; i < self.length; i++) {
    const inner = f(self[i], i);
    for (let j = 0; j < inner.length; j++) {
      out.push(inner[j]);
    }
  }
  return out;
});
var flatten3 = flatMap4(identity);
var filterMap4 = dual(2, (self, f) => {
  const as18 = fromIterable2(self);
  const out = [];
  for (let i = 0; i < as18.length; i++) {
    const o = f(as18[i], i);
    if (isSome2(o)) {
      out.push(o.value);
    }
  }
  return out;
});
var filterMapWhile2 = dual(2, (self, f) => {
  let i = 0;
  const out = [];
  for (const a of self) {
    const b = f(a, i);
    if (isSome2(b)) {
      out.push(b.value);
    } else {
      break;
    }
    i++;
  }
  return out;
});
var partitionMap3 = dual(2, (self, f) => {
  const left3 = [];
  const right3 = [];
  const as18 = fromIterable2(self);
  for (let i = 0; i < as18.length; i++) {
    const e = f(as18[i], i);
    if (isLeft2(e)) {
      left3.push(e.left);
    } else {
      right3.push(e.right);
    }
  }
  return [left3, right3];
});
var getSomes3 = filterMap4(identity);
var getLefts3 = (self) => {
  const out = [];
  for (const a of self) {
    if (isLeft2(a)) {
      out.push(a.left);
    }
  }
  return out;
};
var getRights3 = (self) => {
  const out = [];
  for (const a of self) {
    if (isRight2(a)) {
      out.push(a.right);
    }
  }
  return out;
};
var filter4 = dual(2, (self, predicate) => {
  const as18 = fromIterable2(self);
  const out = [];
  for (let i = 0; i < as18.length; i++) {
    if (predicate(as18[i], i)) {
      out.push(as18[i]);
    }
  }
  return out;
});
var partition2 = dual(2, (self, predicate) => {
  const left3 = [];
  const right3 = [];
  const as18 = fromIterable2(self);
  for (let i = 0; i < as18.length; i++) {
    if (predicate(as18[i], i)) {
      right3.push(as18[i]);
    } else {
      left3.push(as18[i]);
    }
  }
  return [left3, right3];
});
var separate2 = partitionMap3(identity);
var reduce3 = dual(3, (self, b, f) => fromIterable2(self).reduce((b2, a, i) => f(b2, a, i), b));
var reduceRight = dual(3, (self, b, f) => fromIterable2(self).reduceRight((b2, a, i) => f(b2, a, i), b));
var liftPredicate3 = (predicate) => (b) => predicate(b) ? [b] : [];
var liftOption = (f) => (...a) => fromOption3(f(...a));
var fromNullable3 = (a) => a == null ? empty4() : [a];
var liftNullable2 = (f) => (...a) => fromNullable3(f(...a));
var flatMapNullable3 = dual(2, (self, f) => flatMap4(self, (a) => fromNullable3(f(a))));
var liftEither = (f) => (...a) => {
  const e = f(...a);
  return isLeft2(e) ? [] : [e.right];
};
var every3 = dual(2, (self, refinement) => self.every(refinement));
var some6 = dual(2, (self, predicate) => self.some(predicate));
var extend = dual(2, (self, f) => self.map((_, i, as18) => f(as18.slice(i))));
var min2 = dual(2, (self, O) => self.reduce(min(O)));
var max2 = dual(2, (self, O) => self.reduce(max(O)));
var unfold2 = (b, f) => {
  const out = [];
  let next6 = b;
  let o;
  while (isSome2(o = f(next6))) {
    const [a, b2] = o.value;
    out.push(a);
    next6 = b2;
  }
  return out;
};
var getOrder3 = array3;
var getEquivalence5 = array;
var forEach2 = dual(2, (self, f) => fromIterable2(self).forEach((a, i) => f(a, i)));
var dedupeWith = dual(2, (self, isEquivalent) => {
  const input = fromIterable2(self);
  if (isNonEmptyReadonlyArray(input)) {
    const out = [headNonEmpty(input)];
    const rest = tailNonEmpty(input);
    for (const r of rest) {
      if (out.every((a) => !isEquivalent(r, a))) {
        out.push(r);
      }
    }
    return out;
  }
  return [];
});
var dedupe = (self) => dedupeWith(self, equivalence());
var dedupeAdjacentWith2 = dual(2, (self, isEquivalent) => {
  const out = [];
  let lastA = none2();
  for (const a of self) {
    if (isNone2(lastA) || !isEquivalent(a, lastA.value)) {
      out.push(a);
      lastA = some3(a);
    }
  }
  return out;
});
var dedupeAdjacent2 = dedupeAdjacentWith2(equivalence());
var join = dual(2, (self, sep) => fromIterable2(self).join(sep));
var mapAccum = dual(3, (self, s, f) => {
  let i = 0;
  let s1 = s;
  const out = [];
  for (const a of self) {
    const r = f(s1, a, i);
    s1 = r[0];
    out.push(r[1]);
    i++;
  }
  return [s1, out];
});
var cartesianWith2 = dual(3, (self, that, f) => flatMap4(self, (a) => map6(that, (b) => f(a, b))));
var cartesian2 = dual(2, (self, that) => cartesianWith2(self, that, (a, b) => [a, b]));
var Do3 = of2({});
var bind4 = bind(map6, flatMap4);
var bindTo4 = bindTo(map6);
var let_4 = let_(map6);

// ../../node_modules/effect/dist/esm/FastCheck.js
var FastCheck_exports = {};
__export(FastCheck_exports, {
  Arbitrary: () => Arbitrary,
  ExecutionStatus: () => ExecutionStatus,
  PreconditionFailure: () => PreconditionFailure,
  Random: () => Random,
  Stream: () => Stream,
  Value: () => Value,
  VerbosityLevel: () => VerbosityLevel,
  __commitHash: () => __commitHash2,
  __type: () => __type2,
  __version: () => __version2,
  anything: () => anything,
  array: () => array4,
  ascii: () => ascii,
  asciiString: () => asciiString,
  assert: () => assert,
  asyncDefaultReportMessage: () => asyncDefaultReportMessage,
  asyncModelRun: () => asyncModelRun,
  asyncProperty: () => asyncProperty,
  asyncStringify: () => asyncStringify,
  asyncToStringMethod: () => asyncToStringMethod,
  base64: () => base64,
  base64String: () => base64String,
  bigInt: () => bigInt,
  bigInt64Array: () => bigInt64Array,
  bigIntN: () => bigIntN,
  bigUint: () => bigUint,
  bigUint64Array: () => bigUint64Array,
  bigUintN: () => bigUintN,
  boolean: () => boolean3,
  char: () => char,
  char16bits: () => char16bits,
  check: () => check,
  clone: () => clone,
  cloneIfNeeded: () => cloneIfNeeded,
  cloneMethod: () => cloneMethod,
  commands: () => commands,
  compareBooleanFunc: () => compareBooleanFunc,
  compareFunc: () => compareFunc,
  configureGlobal: () => configureGlobal,
  constant: () => constant2,
  constantFrom: () => constantFrom,
  context: () => context,
  createDepthIdentifier: () => createDepthIdentifier,
  date: () => date,
  defaultReportMessage: () => defaultReportMessage,
  dictionary: () => dictionary,
  domain: () => domain,
  double: () => double,
  emailAddress: () => emailAddress,
  falsy: () => falsy,
  float: () => float,
  float32Array: () => float32Array,
  float64Array: () => float64Array,
  fullUnicode: () => fullUnicode,
  fullUnicodeString: () => fullUnicodeString,
  func: () => func,
  gen: () => gen3,
  getDepthContextFor: () => getDepthContextFor,
  hasAsyncToStringMethod: () => hasAsyncToStringMethod,
  hasCloneMethod: () => hasCloneMethod,
  hasToStringMethod: () => hasToStringMethod,
  hash: () => hash2,
  hexa: () => hexa,
  hexaString: () => hexaString,
  infiniteStream: () => infiniteStream,
  int16Array: () => int16Array,
  int32Array: () => int32Array,
  int8Array: () => int8Array,
  integer: () => integer,
  ipV4: () => ipV4,
  ipV4Extended: () => ipV4Extended,
  ipV6: () => ipV6,
  json: () => json,
  jsonValue: () => jsonValue,
  letrec: () => letrec,
  limitShrink: () => limitShrink,
  lorem: () => lorem,
  mapToConstant: () => mapToConstant,
  maxSafeInteger: () => maxSafeInteger,
  maxSafeNat: () => maxSafeNat,
  memo: () => memo,
  mixedCase: () => mixedCase,
  modelRun: () => modelRun,
  nat: () => nat,
  noBias: () => noBias,
  noShrink: () => noShrink,
  object: () => object,
  oneof: () => oneof,
  option: () => option,
  pre: () => pre,
  property: () => property,
  readConfigureGlobal: () => readConfigureGlobal,
  record: () => record,
  resetConfigureGlobal: () => resetConfigureGlobal,
  sample: () => sample,
  scheduledModelRun: () => scheduledModelRun,
  scheduler: () => scheduler,
  schedulerFor: () => schedulerFor,
  shuffledSubarray: () => shuffledSubarray,
  sparseArray: () => sparseArray,
  statistics: () => statistics,
  stream: () => stream,
  string: () => string4,
  string16bits: () => string16bits,
  stringMatching: () => stringMatching,
  stringOf: () => stringOf,
  stringify: () => stringify,
  subarray: () => subarray,
  toStringMethod: () => toStringMethod,
  tuple: () => tuple4,
  uint16Array: () => uint16Array,
  uint32Array: () => uint32Array,
  uint8Array: () => uint8Array,
  uint8ClampedArray: () => uint8ClampedArray,
  ulid: () => ulid,
  unicode: () => unicode,
  unicodeJson: () => unicodeJson,
  unicodeJsonValue: () => unicodeJsonValue,
  unicodeString: () => unicodeString,
  uniqueArray: () => uniqueArray,
  uuid: () => uuid,
  uuidV: () => uuidV,
  webAuthority: () => webAuthority,
  webFragments: () => webFragments,
  webPath: () => webPath,
  webQueryParameters: () => webQueryParameters,
  webSegment: () => webSegment,
  webUrl: () => webUrl
});

// ../../node_modules/fast-check/lib/esm/check/precondition/PreconditionFailure.js
var PreconditionFailure = class _PreconditionFailure extends Error {
  constructor(interruptExecution = false) {
    super();
    this.interruptExecution = interruptExecution;
    this.footprint = _PreconditionFailure.SharedFootPrint;
  }
  static isFailure(err) {
    return err != null && err.footprint === _PreconditionFailure.SharedFootPrint;
  }
};
PreconditionFailure.SharedFootPrint = Symbol.for("fast-check/PreconditionFailure");

// ../../node_modules/fast-check/lib/esm/check/precondition/Pre.js
function pre(expectTruthy) {
  if (!expectTruthy) {
    throw new PreconditionFailure();
  }
}

// ../../node_modules/fast-check/lib/esm/stream/StreamHelpers.js
var Nil = class {
  [Symbol.iterator]() {
    return this;
  }
  next(value10) {
    return { value: value10, done: true };
  }
};
Nil.nil = new Nil();
function nilHelper() {
  return Nil.nil;
}
function* mapHelper(g, f) {
  for (const v of g) {
    yield f(v);
  }
}
function* flatMapHelper(g, f) {
  for (const v of g) {
    yield* f(v);
  }
}
function* filterHelper(g, f) {
  for (const v of g) {
    if (f(v)) {
      yield v;
    }
  }
}
function* takeNHelper(g, n) {
  for (let i = 0; i < n; ++i) {
    const cur = g.next();
    if (cur.done) {
      break;
    }
    yield cur.value;
  }
}
function* takeWhileHelper(g, f) {
  let cur = g.next();
  while (!cur.done && f(cur.value)) {
    yield cur.value;
    cur = g.next();
  }
}
function* joinHelper(g, others) {
  for (let cur = g.next(); !cur.done; cur = g.next()) {
    yield cur.value;
  }
  for (const s of others) {
    for (let cur = s.next(); !cur.done; cur = s.next()) {
      yield cur.value;
    }
  }
}

// ../../node_modules/fast-check/lib/esm/stream/Stream.js
var safeSymbolIterator = Symbol.iterator;
var Stream = class _Stream {
  static nil() {
    return new _Stream(nilHelper());
  }
  static of(...elements) {
    return new _Stream(elements[safeSymbolIterator]());
  }
  constructor(g) {
    this.g = g;
  }
  next() {
    return this.g.next();
  }
  [Symbol.iterator]() {
    return this.g;
  }
  map(f) {
    return new _Stream(mapHelper(this.g, f));
  }
  flatMap(f) {
    return new _Stream(flatMapHelper(this.g, f));
  }
  dropWhile(f) {
    let foundEligible = false;
    function* helper(v) {
      if (foundEligible || !f(v)) {
        foundEligible = true;
        yield v;
      }
    }
    return this.flatMap(helper);
  }
  drop(n) {
    if (n <= 0) {
      return this;
    }
    let idx = 0;
    function helper() {
      return idx++ < n;
    }
    return this.dropWhile(helper);
  }
  takeWhile(f) {
    return new _Stream(takeWhileHelper(this.g, f));
  }
  take(n) {
    return new _Stream(takeNHelper(this.g, n));
  }
  filter(f) {
    return new _Stream(filterHelper(this.g, f));
  }
  every(f) {
    for (const v of this.g) {
      if (!f(v)) {
        return false;
      }
    }
    return true;
  }
  has(f) {
    for (const v of this.g) {
      if (f(v)) {
        return [true, v];
      }
    }
    return [false, null];
  }
  join(...others) {
    return new _Stream(joinHelper(this.g, others));
  }
  getNthOrLast(nth) {
    let remaining = nth;
    let last8 = null;
    for (const v of this.g) {
      if (remaining-- === 0)
        return v;
      last8 = v;
    }
    return last8;
  }
};
function stream(g) {
  return new Stream(g);
}

// ../../node_modules/fast-check/lib/esm/check/symbols.js
var cloneMethod = Symbol.for("fast-check/cloneMethod");
function hasCloneMethod(instance) {
  return instance !== null && (typeof instance === "object" || typeof instance === "function") && cloneMethod in instance && typeof instance[cloneMethod] === "function";
}
function cloneIfNeeded(instance) {
  return hasCloneMethod(instance) ? instance[cloneMethod]() : instance;
}

// ../../node_modules/fast-check/lib/esm/check/arbitrary/definition/Value.js
var safeObjectDefineProperty = Object.defineProperty;
var Value = class {
  constructor(value_, context15, customGetValue = void 0) {
    this.value_ = value_;
    this.context = context15;
    this.hasToBeCloned = customGetValue !== void 0 || hasCloneMethod(value_);
    this.readOnce = false;
    if (this.hasToBeCloned) {
      safeObjectDefineProperty(this, "value", { get: customGetValue !== void 0 ? customGetValue : this.getValue });
    } else {
      this.value = value_;
    }
  }
  getValue() {
    if (this.hasToBeCloned) {
      if (!this.readOnce) {
        this.readOnce = true;
        return this.value_;
      }
      return this.value_[cloneMethod]();
    }
    return this.value_;
  }
};

// ../../node_modules/fast-check/lib/esm/check/arbitrary/definition/Arbitrary.js
var safeObjectAssign = Object.assign;
var Arbitrary = class {
  filter(refinement) {
    return new FilterArbitrary(this, refinement);
  }
  map(mapper, unmapper) {
    return new MapArbitrary(this, mapper, unmapper);
  }
  chain(chainer) {
    return new ChainArbitrary(this, chainer);
  }
  noShrink() {
    return new NoShrinkArbitrary(this);
  }
  noBias() {
    return new NoBiasArbitrary(this);
  }
};
var ChainArbitrary = class extends Arbitrary {
  constructor(arb, chainer) {
    super();
    this.arb = arb;
    this.chainer = chainer;
  }
  generate(mrng, biasFactor) {
    const clonedMrng = mrng.clone();
    const src = this.arb.generate(mrng, biasFactor);
    return this.valueChainer(src, mrng, clonedMrng, biasFactor);
  }
  canShrinkWithoutContext(value10) {
    return false;
  }
  shrink(value10, context15) {
    if (this.isSafeContext(context15)) {
      return (!context15.stoppedForOriginal ? this.arb.shrink(context15.originalValue, context15.originalContext).map((v) => this.valueChainer(v, context15.clonedMrng.clone(), context15.clonedMrng, context15.originalBias)) : Stream.nil()).join(context15.chainedArbitrary.shrink(value10, context15.chainedContext).map((dst) => {
        const newContext = safeObjectAssign(safeObjectAssign({}, context15), {
          chainedContext: dst.context,
          stoppedForOriginal: true
        });
        return new Value(dst.value_, newContext);
      }));
    }
    return Stream.nil();
  }
  valueChainer(v, generateMrng, clonedMrng, biasFactor) {
    const chainedArbitrary = this.chainer(v.value_);
    const dst = chainedArbitrary.generate(generateMrng, biasFactor);
    const context15 = {
      originalBias: biasFactor,
      originalValue: v.value_,
      originalContext: v.context,
      stoppedForOriginal: false,
      chainedArbitrary,
      chainedContext: dst.context,
      clonedMrng
    };
    return new Value(dst.value_, context15);
  }
  isSafeContext(context15) {
    return context15 != null && typeof context15 === "object" && "originalBias" in context15 && "originalValue" in context15 && "originalContext" in context15 && "stoppedForOriginal" in context15 && "chainedArbitrary" in context15 && "chainedContext" in context15 && "clonedMrng" in context15;
  }
};
var MapArbitrary = class extends Arbitrary {
  constructor(arb, mapper, unmapper) {
    super();
    this.arb = arb;
    this.mapper = mapper;
    this.unmapper = unmapper;
    this.bindValueMapper = (v) => this.valueMapper(v);
  }
  generate(mrng, biasFactor) {
    const g = this.arb.generate(mrng, biasFactor);
    return this.valueMapper(g);
  }
  canShrinkWithoutContext(value10) {
    if (this.unmapper !== void 0) {
      try {
        const unmapped = this.unmapper(value10);
        return this.arb.canShrinkWithoutContext(unmapped);
      } catch (_err) {
        return false;
      }
    }
    return false;
  }
  shrink(value10, context15) {
    if (this.isSafeContext(context15)) {
      return this.arb.shrink(context15.originalValue, context15.originalContext).map(this.bindValueMapper);
    }
    if (this.unmapper !== void 0) {
      const unmapped = this.unmapper(value10);
      return this.arb.shrink(unmapped, void 0).map(this.bindValueMapper);
    }
    return Stream.nil();
  }
  mapperWithCloneIfNeeded(v) {
    const sourceValue = v.value;
    const mappedValue = this.mapper(sourceValue);
    if (v.hasToBeCloned && (typeof mappedValue === "object" && mappedValue !== null || typeof mappedValue === "function") && Object.isExtensible(mappedValue) && !hasCloneMethod(mappedValue)) {
      Object.defineProperty(mappedValue, cloneMethod, { get: () => () => this.mapperWithCloneIfNeeded(v)[0] });
    }
    return [mappedValue, sourceValue];
  }
  valueMapper(v) {
    const [mappedValue, sourceValue] = this.mapperWithCloneIfNeeded(v);
    const context15 = { originalValue: sourceValue, originalContext: v.context };
    return new Value(mappedValue, context15);
  }
  isSafeContext(context15) {
    return context15 != null && typeof context15 === "object" && "originalValue" in context15 && "originalContext" in context15;
  }
};
var FilterArbitrary = class extends Arbitrary {
  constructor(arb, refinement) {
    super();
    this.arb = arb;
    this.refinement = refinement;
    this.bindRefinementOnValue = (v) => this.refinementOnValue(v);
  }
  generate(mrng, biasFactor) {
    while (true) {
      const g = this.arb.generate(mrng, biasFactor);
      if (this.refinementOnValue(g)) {
        return g;
      }
    }
  }
  canShrinkWithoutContext(value10) {
    return this.arb.canShrinkWithoutContext(value10) && this.refinement(value10);
  }
  shrink(value10, context15) {
    return this.arb.shrink(value10, context15).filter(this.bindRefinementOnValue);
  }
  refinementOnValue(v) {
    return this.refinement(v.value);
  }
};
var NoShrinkArbitrary = class extends Arbitrary {
  constructor(arb) {
    super();
    this.arb = arb;
  }
  generate(mrng, biasFactor) {
    return this.arb.generate(mrng, biasFactor);
  }
  canShrinkWithoutContext(value10) {
    return this.arb.canShrinkWithoutContext(value10);
  }
  shrink(_value, _context) {
    return Stream.nil();
  }
  noShrink() {
    return this;
  }
};
var NoBiasArbitrary = class extends Arbitrary {
  constructor(arb) {
    super();
    this.arb = arb;
  }
  generate(mrng, _biasFactor) {
    return this.arb.generate(mrng, void 0);
  }
  canShrinkWithoutContext(value10) {
    return this.arb.canShrinkWithoutContext(value10);
  }
  shrink(value10, context15) {
    return this.arb.shrink(value10, context15);
  }
  noBias() {
    return this;
  }
};
function isArbitrary(instance) {
  return typeof instance === "object" && instance !== null && "generate" in instance && "shrink" in instance && "canShrinkWithoutContext" in instance;
}
function assertIsArbitrary(instance) {
  if (!isArbitrary(instance)) {
    throw new Error("Unexpected value received: not an instance of Arbitrary");
  }
}

// ../../node_modules/fast-check/lib/esm/utils/apply.js
var untouchedApply = Function.prototype.apply;
var ApplySymbol = Symbol("apply");
function safeExtractApply(f) {
  try {
    return f.apply;
  } catch (err) {
    return void 0;
  }
}
function safeApplyHacky(f, instance, args2) {
  const ff = f;
  ff[ApplySymbol] = untouchedApply;
  const out = ff[ApplySymbol](instance, args2);
  delete ff[ApplySymbol];
  return out;
}
function safeApply(f, instance, args2) {
  if (safeExtractApply(f) === untouchedApply) {
    return f.apply(instance, args2);
  }
  return safeApplyHacky(f, instance, args2);
}

// ../../node_modules/fast-check/lib/esm/utils/globals.js
var SArray = typeof Array !== "undefined" ? Array : void 0;
var SBigInt = typeof BigInt !== "undefined" ? BigInt : void 0;
var SBigInt64Array = typeof BigInt64Array !== "undefined" ? BigInt64Array : void 0;
var SBigUint64Array = typeof BigUint64Array !== "undefined" ? BigUint64Array : void 0;
var SBoolean = typeof Boolean !== "undefined" ? Boolean : void 0;
var SDate = typeof Date !== "undefined" ? Date : void 0;
var SError = typeof Error !== "undefined" ? Error : void 0;
var SFloat32Array = typeof Float32Array !== "undefined" ? Float32Array : void 0;
var SFloat64Array = typeof Float64Array !== "undefined" ? Float64Array : void 0;
var SInt8Array = typeof Int8Array !== "undefined" ? Int8Array : void 0;
var SInt16Array = typeof Int16Array !== "undefined" ? Int16Array : void 0;
var SInt32Array = typeof Int32Array !== "undefined" ? Int32Array : void 0;
var SNumber = typeof Number !== "undefined" ? Number : void 0;
var SString = typeof String !== "undefined" ? String : void 0;
var SSet = typeof Set !== "undefined" ? Set : void 0;
var SUint8Array = typeof Uint8Array !== "undefined" ? Uint8Array : void 0;
var SUint8ClampedArray = typeof Uint8ClampedArray !== "undefined" ? Uint8ClampedArray : void 0;
var SUint16Array = typeof Uint16Array !== "undefined" ? Uint16Array : void 0;
var SUint32Array = typeof Uint32Array !== "undefined" ? Uint32Array : void 0;
var SencodeURIComponent = typeof encodeURIComponent !== "undefined" ? encodeURIComponent : void 0;
var SMap = Map;
var SSymbol = Symbol;
var untouchedForEach = Array.prototype.forEach;
var untouchedIndexOf = Array.prototype.indexOf;
var untouchedJoin = Array.prototype.join;
var untouchedMap = Array.prototype.map;
var untouchedFilter = Array.prototype.filter;
var untouchedPush = Array.prototype.push;
var untouchedPop = Array.prototype.pop;
var untouchedSplice = Array.prototype.splice;
var untouchedSlice = Array.prototype.slice;
var untouchedSort = Array.prototype.sort;
var untouchedEvery = Array.prototype.every;
function extractForEach(instance) {
  try {
    return instance.forEach;
  } catch (err) {
    return void 0;
  }
}
function extractIndexOf(instance) {
  try {
    return instance.indexOf;
  } catch (err) {
    return void 0;
  }
}
function extractJoin(instance) {
  try {
    return instance.join;
  } catch (err) {
    return void 0;
  }
}
function extractMap(instance) {
  try {
    return instance.map;
  } catch (err) {
    return void 0;
  }
}
function extractFilter(instance) {
  try {
    return instance.filter;
  } catch (err) {
    return void 0;
  }
}
function extractPush(instance) {
  try {
    return instance.push;
  } catch (err) {
    return void 0;
  }
}
function extractPop(instance) {
  try {
    return instance.pop;
  } catch (err) {
    return void 0;
  }
}
function extractSplice(instance) {
  try {
    return instance.splice;
  } catch (err) {
    return void 0;
  }
}
function extractSlice(instance) {
  try {
    return instance.slice;
  } catch (err) {
    return void 0;
  }
}
function extractSort(instance) {
  try {
    return instance.sort;
  } catch (err) {
    return void 0;
  }
}
function extractEvery(instance) {
  try {
    return instance.every;
  } catch (err) {
    return void 0;
  }
}
function safeForEach(instance, fn2) {
  if (extractForEach(instance) === untouchedForEach) {
    return instance.forEach(fn2);
  }
  return safeApply(untouchedForEach, instance, [fn2]);
}
function safeIndexOf(instance, ...args2) {
  if (extractIndexOf(instance) === untouchedIndexOf) {
    return instance.indexOf(...args2);
  }
  return safeApply(untouchedIndexOf, instance, args2);
}
function safeJoin(instance, ...args2) {
  if (extractJoin(instance) === untouchedJoin) {
    return instance.join(...args2);
  }
  return safeApply(untouchedJoin, instance, args2);
}
function safeMap(instance, fn2) {
  if (extractMap(instance) === untouchedMap) {
    return instance.map(fn2);
  }
  return safeApply(untouchedMap, instance, [fn2]);
}
function safeFilter(instance, predicate) {
  if (extractFilter(instance) === untouchedFilter) {
    return instance.filter(predicate);
  }
  return safeApply(untouchedFilter, instance, [predicate]);
}
function safePush(instance, ...args2) {
  if (extractPush(instance) === untouchedPush) {
    return instance.push(...args2);
  }
  return safeApply(untouchedPush, instance, args2);
}
function safePop(instance) {
  if (extractPop(instance) === untouchedPop) {
    return instance.pop();
  }
  return safeApply(untouchedPop, instance, []);
}
function safeSplice(instance, ...args2) {
  if (extractSplice(instance) === untouchedSplice) {
    return instance.splice(...args2);
  }
  return safeApply(untouchedSplice, instance, args2);
}
function safeSlice(instance, ...args2) {
  if (extractSlice(instance) === untouchedSlice) {
    return instance.slice(...args2);
  }
  return safeApply(untouchedSlice, instance, args2);
}
function safeSort(instance, ...args2) {
  if (extractSort(instance) === untouchedSort) {
    return instance.sort(...args2);
  }
  return safeApply(untouchedSort, instance, args2);
}
function safeEvery(instance, ...args2) {
  if (extractEvery(instance) === untouchedEvery) {
    return instance.every(...args2);
  }
  return safeApply(untouchedEvery, instance, args2);
}
var untouchedGetTime = Date.prototype.getTime;
var untouchedToISOString = Date.prototype.toISOString;
function extractGetTime(instance) {
  try {
    return instance.getTime;
  } catch (err) {
    return void 0;
  }
}
function extractToISOString(instance) {
  try {
    return instance.toISOString;
  } catch (err) {
    return void 0;
  }
}
function safeGetTime(instance) {
  if (extractGetTime(instance) === untouchedGetTime) {
    return instance.getTime();
  }
  return safeApply(untouchedGetTime, instance, []);
}
function safeToISOString(instance) {
  if (extractToISOString(instance) === untouchedToISOString) {
    return instance.toISOString();
  }
  return safeApply(untouchedToISOString, instance, []);
}
var untouchedAdd = Set.prototype.add;
var untouchedHas = Set.prototype.has;
function extractAdd(instance) {
  try {
    return instance.add;
  } catch (err) {
    return void 0;
  }
}
function extractHas(instance) {
  try {
    return instance.has;
  } catch (err) {
    return void 0;
  }
}
function safeAdd(instance, value10) {
  if (extractAdd(instance) === untouchedAdd) {
    return instance.add(value10);
  }
  return safeApply(untouchedAdd, instance, [value10]);
}
function safeHas(instance, value10) {
  if (extractHas(instance) === untouchedHas) {
    return instance.has(value10);
  }
  return safeApply(untouchedHas, instance, [value10]);
}
var untouchedSet = WeakMap.prototype.set;
var untouchedGet = WeakMap.prototype.get;
function extractSet(instance) {
  try {
    return instance.set;
  } catch (err) {
    return void 0;
  }
}
function extractGet(instance) {
  try {
    return instance.get;
  } catch (err) {
    return void 0;
  }
}
function safeSet(instance, key, value10) {
  if (extractSet(instance) === untouchedSet) {
    return instance.set(key, value10);
  }
  return safeApply(untouchedSet, instance, [key, value10]);
}
function safeGet(instance, key) {
  if (extractGet(instance) === untouchedGet) {
    return instance.get(key);
  }
  return safeApply(untouchedGet, instance, [key]);
}
var untouchedMapSet = Map.prototype.set;
var untouchedMapGet = Map.prototype.get;
function extractMapSet(instance) {
  try {
    return instance.set;
  } catch (err) {
    return void 0;
  }
}
function extractMapGet(instance) {
  try {
    return instance.get;
  } catch (err) {
    return void 0;
  }
}
function safeMapSet(instance, key, value10) {
  if (extractMapSet(instance) === untouchedMapSet) {
    return instance.set(key, value10);
  }
  return safeApply(untouchedMapSet, instance, [key, value10]);
}
function safeMapGet(instance, key) {
  if (extractMapGet(instance) === untouchedMapGet) {
    return instance.get(key);
  }
  return safeApply(untouchedMapGet, instance, [key]);
}
var untouchedSplit = String.prototype.split;
var untouchedStartsWith = String.prototype.startsWith;
var untouchedEndsWith = String.prototype.endsWith;
var untouchedSubstring = String.prototype.substring;
var untouchedToLowerCase = String.prototype.toLowerCase;
var untouchedToUpperCase = String.prototype.toUpperCase;
var untouchedPadStart = String.prototype.padStart;
var untouchedCharCodeAt = String.prototype.charCodeAt;
var untouchedNormalize = String.prototype.normalize;
var untouchedReplace = String.prototype.replace;
function extractSplit(instance) {
  try {
    return instance.split;
  } catch (err) {
    return void 0;
  }
}
function extractStartsWith(instance) {
  try {
    return instance.startsWith;
  } catch (err) {
    return void 0;
  }
}
function extractEndsWith(instance) {
  try {
    return instance.endsWith;
  } catch (err) {
    return void 0;
  }
}
function extractSubstring(instance) {
  try {
    return instance.substring;
  } catch (err) {
    return void 0;
  }
}
function extractToLowerCase(instance) {
  try {
    return instance.toLowerCase;
  } catch (err) {
    return void 0;
  }
}
function extractToUpperCase(instance) {
  try {
    return instance.toUpperCase;
  } catch (err) {
    return void 0;
  }
}
function extractPadStart(instance) {
  try {
    return instance.padStart;
  } catch (err) {
    return void 0;
  }
}
function extractCharCodeAt(instance) {
  try {
    return instance.charCodeAt;
  } catch (err) {
    return void 0;
  }
}
function extractNormalize(instance) {
  try {
    return instance.normalize;
  } catch (err) {
    return void 0;
  }
}
function extractReplace(instance) {
  try {
    return instance.replace;
  } catch (err) {
    return void 0;
  }
}
function safeSplit(instance, ...args2) {
  if (extractSplit(instance) === untouchedSplit) {
    return instance.split(...args2);
  }
  return safeApply(untouchedSplit, instance, args2);
}
function safeStartsWith(instance, ...args2) {
  if (extractStartsWith(instance) === untouchedStartsWith) {
    return instance.startsWith(...args2);
  }
  return safeApply(untouchedStartsWith, instance, args2);
}
function safeEndsWith(instance, ...args2) {
  if (extractEndsWith(instance) === untouchedEndsWith) {
    return instance.endsWith(...args2);
  }
  return safeApply(untouchedEndsWith, instance, args2);
}
function safeSubstring(instance, ...args2) {
  if (extractSubstring(instance) === untouchedSubstring) {
    return instance.substring(...args2);
  }
  return safeApply(untouchedSubstring, instance, args2);
}
function safeToLowerCase(instance) {
  if (extractToLowerCase(instance) === untouchedToLowerCase) {
    return instance.toLowerCase();
  }
  return safeApply(untouchedToLowerCase, instance, []);
}
function safeToUpperCase(instance) {
  if (extractToUpperCase(instance) === untouchedToUpperCase) {
    return instance.toUpperCase();
  }
  return safeApply(untouchedToUpperCase, instance, []);
}
function safePadStart(instance, ...args2) {
  if (extractPadStart(instance) === untouchedPadStart) {
    return instance.padStart(...args2);
  }
  return safeApply(untouchedPadStart, instance, args2);
}
function safeCharCodeAt(instance, index) {
  if (extractCharCodeAt(instance) === untouchedCharCodeAt) {
    return instance.charCodeAt(index);
  }
  return safeApply(untouchedCharCodeAt, instance, [index]);
}
function safeNormalize(instance, form) {
  if (extractNormalize(instance) === untouchedNormalize) {
    return instance.normalize(form);
  }
  return safeApply(untouchedNormalize, instance, [form]);
}
function safeReplace(instance, pattern2, replacement) {
  if (extractReplace(instance) === untouchedReplace) {
    return instance.replace(pattern2, replacement);
  }
  return safeApply(untouchedReplace, instance, [pattern2, replacement]);
}
var untouchedNumberToString = Number.prototype.toString;
function extractNumberToString(instance) {
  try {
    return instance.toString;
  } catch (err) {
    return void 0;
  }
}
function safeNumberToString(instance, ...args2) {
  if (extractNumberToString(instance) === untouchedNumberToString) {
    return instance.toString(...args2);
  }
  return safeApply(untouchedNumberToString, instance, args2);
}
var untouchedHasOwnProperty = Object.prototype.hasOwnProperty;
var untouchedToString = Object.prototype.toString;
function safeHasOwnProperty(instance, v) {
  return safeApply(untouchedHasOwnProperty, instance, [v]);
}
function safeToString(instance) {
  return safeApply(untouchedToString, instance, []);
}

// ../../node_modules/fast-check/lib/esm/stream/LazyIterableIterator.js
var LazyIterableIterator = class {
  constructor(producer) {
    this.producer = producer;
  }
  [Symbol.iterator]() {
    if (this.it === void 0) {
      this.it = this.producer();
    }
    return this.it;
  }
  next() {
    if (this.it === void 0) {
      this.it = this.producer();
    }
    return this.it.next();
  }
};
function makeLazy(producer) {
  return new LazyIterableIterator(producer);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/TupleArbitrary.js
var safeArrayIsArray = Array.isArray;
var safeObjectDefineProperty2 = Object.defineProperty;
function tupleMakeItCloneable(vs, values15) {
  return safeObjectDefineProperty2(vs, cloneMethod, {
    value: () => {
      const cloned = [];
      for (let idx = 0; idx !== values15.length; ++idx) {
        safePush(cloned, values15[idx].value);
      }
      tupleMakeItCloneable(cloned, values15);
      return cloned;
    }
  });
}
function tupleWrapper(values15) {
  let cloneable = false;
  const vs = [];
  const ctxs = [];
  for (let idx = 0; idx !== values15.length; ++idx) {
    const v = values15[idx];
    cloneable = cloneable || v.hasToBeCloned;
    safePush(vs, v.value);
    safePush(ctxs, v.context);
  }
  if (cloneable) {
    tupleMakeItCloneable(vs, values15);
  }
  return new Value(vs, ctxs);
}
function tupleShrink(arbs, value10, context15) {
  const shrinks2 = [];
  const safeContext = safeArrayIsArray(context15) ? context15 : [];
  for (let idx = 0; idx !== arbs.length; ++idx) {
    safePush(shrinks2, makeLazy(() => arbs[idx].shrink(value10[idx], safeContext[idx]).map((v) => {
      const nextValues = safeMap(value10, (v2, idx2) => new Value(cloneIfNeeded(v2), safeContext[idx2]));
      return [...safeSlice(nextValues, 0, idx), v, ...safeSlice(nextValues, idx + 1)];
    }).map(tupleWrapper)));
  }
  return Stream.nil().join(...shrinks2);
}
var TupleArbitrary = class extends Arbitrary {
  constructor(arbs) {
    super();
    this.arbs = arbs;
    for (let idx = 0; idx !== arbs.length; ++idx) {
      const arb = arbs[idx];
      if (arb == null || arb.generate == null)
        throw new Error(`Invalid parameter encountered at index ${idx}: expecting an Arbitrary`);
    }
  }
  generate(mrng, biasFactor) {
    const mapped = [];
    for (let idx = 0; idx !== this.arbs.length; ++idx) {
      safePush(mapped, this.arbs[idx].generate(mrng, biasFactor));
    }
    return tupleWrapper(mapped);
  }
  canShrinkWithoutContext(value10) {
    if (!safeArrayIsArray(value10) || value10.length !== this.arbs.length) {
      return false;
    }
    for (let index = 0; index !== this.arbs.length; ++index) {
      if (!this.arbs[index].canShrinkWithoutContext(value10[index])) {
        return false;
      }
    }
    return true;
  }
  shrink(value10, context15) {
    return tupleShrink(this.arbs, value10, context15);
  }
};

// ../../node_modules/fast-check/lib/esm/arbitrary/tuple.js
function tuple4(...arbs) {
  return new TupleArbitrary(arbs);
}

// ../../node_modules/fast-check/lib/esm/check/property/IRawProperty.js
var safeMathLog = Math.log;
function runIdToFrequency(runId) {
  return 2 + ~~(safeMathLog(runId + 1) * 0.4342944819032518);
}

// ../../node_modules/fast-check/lib/esm/check/runner/configuration/GlobalParameters.js
var globalParameters = {};
function configureGlobal(parameters) {
  globalParameters = parameters;
}
function readConfigureGlobal() {
  return globalParameters;
}
function resetConfigureGlobal() {
  globalParameters = {};
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/NoUndefinedAsContext.js
var UndefinedContextPlaceholder = Symbol("UndefinedContextPlaceholder");
function noUndefinedAsContext(value10) {
  if (value10.context !== void 0) {
    return value10;
  }
  if (value10.hasToBeCloned) {
    return new Value(value10.value_, UndefinedContextPlaceholder, () => value10.value);
  }
  return new Value(value10.value_, UndefinedContextPlaceholder);
}

// ../../node_modules/fast-check/lib/esm/check/property/AsyncProperty.generic.js
var AsyncProperty = class _AsyncProperty {
  constructor(arb, predicate) {
    this.arb = arb;
    this.predicate = predicate;
    const { asyncBeforeEach, asyncAfterEach, beforeEach, afterEach } = readConfigureGlobal() || {};
    if (asyncBeforeEach !== void 0 && beforeEach !== void 0) {
      throw SError(`Global "asyncBeforeEach" and "beforeEach" parameters can't be set at the same time when running async properties`);
    }
    if (asyncAfterEach !== void 0 && afterEach !== void 0) {
      throw SError(`Global "asyncAfterEach" and "afterEach" parameters can't be set at the same time when running async properties`);
    }
    this.beforeEachHook = asyncBeforeEach || beforeEach || _AsyncProperty.dummyHook;
    this.afterEachHook = asyncAfterEach || afterEach || _AsyncProperty.dummyHook;
  }
  isAsync() {
    return true;
  }
  generate(mrng, runId) {
    const value10 = this.arb.generate(mrng, runId != null ? runIdToFrequency(runId) : void 0);
    return noUndefinedAsContext(value10);
  }
  shrink(value10) {
    if (value10.context === void 0 && !this.arb.canShrinkWithoutContext(value10.value_)) {
      return Stream.nil();
    }
    const safeContext = value10.context !== UndefinedContextPlaceholder ? value10.context : void 0;
    return this.arb.shrink(value10.value_, safeContext).map(noUndefinedAsContext);
  }
  async runBeforeEach() {
    await this.beforeEachHook();
  }
  async runAfterEach() {
    await this.afterEachHook();
  }
  async run(v, dontRunHook) {
    if (!dontRunHook) {
      await this.beforeEachHook();
    }
    try {
      const output = await this.predicate(v);
      return output == null || output === true ? null : {
        error: new SError("Property failed by returning false"),
        errorMessage: "Error: Property failed by returning false"
      };
    } catch (err) {
      if (PreconditionFailure.isFailure(err))
        return err;
      if (err instanceof SError && err.stack) {
        return { error: err, errorMessage: err.stack };
      }
      return { error: err, errorMessage: SString(err) };
    } finally {
      if (!dontRunHook) {
        await this.afterEachHook();
      }
    }
  }
  beforeEach(hookFunction) {
    const previousBeforeEachHook = this.beforeEachHook;
    this.beforeEachHook = () => hookFunction(previousBeforeEachHook);
    return this;
  }
  afterEach(hookFunction) {
    const previousAfterEachHook = this.afterEachHook;
    this.afterEachHook = () => hookFunction(previousAfterEachHook);
    return this;
  }
};
AsyncProperty.dummyHook = () => {
};

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/AlwaysShrinkableArbitrary.js
var AlwaysShrinkableArbitrary = class extends Arbitrary {
  constructor(arb) {
    super();
    this.arb = arb;
  }
  generate(mrng, biasFactor) {
    const value10 = this.arb.generate(mrng, biasFactor);
    return noUndefinedAsContext(value10);
  }
  canShrinkWithoutContext(value10) {
    return true;
  }
  shrink(value10, context15) {
    if (context15 === void 0 && !this.arb.canShrinkWithoutContext(value10)) {
      return Stream.nil();
    }
    const safeContext = context15 !== UndefinedContextPlaceholder ? context15 : void 0;
    return this.arb.shrink(value10, safeContext).map(noUndefinedAsContext);
  }
};

// ../../node_modules/fast-check/lib/esm/check/property/AsyncProperty.js
function asyncProperty(...args2) {
  if (args2.length < 2) {
    throw new Error("asyncProperty expects at least two parameters");
  }
  const arbs = safeSlice(args2, 0, args2.length - 1);
  const p = args2[args2.length - 1];
  safeForEach(arbs, assertIsArbitrary);
  const mappedArbs = safeMap(arbs, (arb) => new AlwaysShrinkableArbitrary(arb));
  return new AsyncProperty(tuple4(...mappedArbs), (t) => p(...t));
}

// ../../node_modules/fast-check/lib/esm/check/property/Property.generic.js
var Property = class _Property {
  constructor(arb, predicate) {
    this.arb = arb;
    this.predicate = predicate;
    const { beforeEach = _Property.dummyHook, afterEach = _Property.dummyHook, asyncBeforeEach, asyncAfterEach } = readConfigureGlobal() || {};
    if (asyncBeforeEach !== void 0) {
      throw SError(`"asyncBeforeEach" can't be set when running synchronous properties`);
    }
    if (asyncAfterEach !== void 0) {
      throw SError(`"asyncAfterEach" can't be set when running synchronous properties`);
    }
    this.beforeEachHook = beforeEach;
    this.afterEachHook = afterEach;
  }
  isAsync() {
    return false;
  }
  generate(mrng, runId) {
    const value10 = this.arb.generate(mrng, runId != null ? runIdToFrequency(runId) : void 0);
    return noUndefinedAsContext(value10);
  }
  shrink(value10) {
    if (value10.context === void 0 && !this.arb.canShrinkWithoutContext(value10.value_)) {
      return Stream.nil();
    }
    const safeContext = value10.context !== UndefinedContextPlaceholder ? value10.context : void 0;
    return this.arb.shrink(value10.value_, safeContext).map(noUndefinedAsContext);
  }
  runBeforeEach() {
    this.beforeEachHook();
  }
  runAfterEach() {
    this.afterEachHook();
  }
  run(v, dontRunHook) {
    if (!dontRunHook) {
      this.beforeEachHook();
    }
    try {
      const output = this.predicate(v);
      return output == null || output === true ? null : {
        error: new SError("Property failed by returning false"),
        errorMessage: "Error: Property failed by returning false"
      };
    } catch (err) {
      if (PreconditionFailure.isFailure(err))
        return err;
      if (err instanceof SError && err.stack) {
        return { error: err, errorMessage: err.stack };
      }
      return { error: err, errorMessage: SString(err) };
    } finally {
      if (!dontRunHook) {
        this.afterEachHook();
      }
    }
  }
  beforeEach(hookFunction) {
    const previousBeforeEachHook = this.beforeEachHook;
    this.beforeEachHook = () => hookFunction(previousBeforeEachHook);
    return this;
  }
  afterEach(hookFunction) {
    const previousAfterEachHook = this.afterEachHook;
    this.afterEachHook = () => hookFunction(previousAfterEachHook);
    return this;
  }
};
Property.dummyHook = () => {
};

// ../../node_modules/fast-check/lib/esm/check/property/Property.js
function property(...args2) {
  if (args2.length < 2) {
    throw new Error("property expects at least two parameters");
  }
  const arbs = safeSlice(args2, 0, args2.length - 1);
  const p = args2[args2.length - 1];
  safeForEach(arbs, assertIsArbitrary);
  const mappedArbs = safeMap(arbs, (arb) => new AlwaysShrinkableArbitrary(arb));
  return new Property(tuple4(...mappedArbs), (t) => p(...t));
}

// ../../node_modules/pure-rand/lib/esm/pure-rand-default.js
var pure_rand_default_exports = {};
__export(pure_rand_default_exports, {
  __commitHash: () => __commitHash,
  __type: () => __type,
  __version: () => __version,
  congruential32: () => congruential32,
  generateN: () => generateN,
  mersenne: () => MersenneTwister_default,
  skipN: () => skipN,
  uniformArrayIntDistribution: () => uniformArrayIntDistribution,
  uniformBigIntDistribution: () => uniformBigIntDistribution,
  uniformIntDistribution: () => uniformIntDistribution,
  unsafeGenerateN: () => unsafeGenerateN,
  unsafeSkipN: () => unsafeSkipN,
  unsafeUniformArrayIntDistribution: () => unsafeUniformArrayIntDistribution,
  unsafeUniformBigIntDistribution: () => unsafeUniformBigIntDistribution,
  unsafeUniformIntDistribution: () => unsafeUniformIntDistribution,
  xoroshiro128plus: () => xoroshiro128plus,
  xorshift128plus: () => xorshift128plus
});

// ../../node_modules/pure-rand/lib/esm/generator/RandomGenerator.js
function unsafeGenerateN(rng, num) {
  var out = [];
  for (var idx = 0; idx != num; ++idx) {
    out.push(rng.unsafeNext());
  }
  return out;
}
function generateN(rng, num) {
  var nextRng = rng.clone();
  var out = unsafeGenerateN(nextRng, num);
  return [out, nextRng];
}
function unsafeSkipN(rng, num) {
  for (var idx = 0; idx != num; ++idx) {
    rng.unsafeNext();
  }
}
function skipN(rng, num) {
  var nextRng = rng.clone();
  unsafeSkipN(nextRng, num);
  return nextRng;
}

// ../../node_modules/pure-rand/lib/esm/generator/LinearCongruential.js
var MULTIPLIER = 214013;
var INCREMENT = 2531011;
var MASK = 4294967295;
var MASK_2 = (1 << 31) - 1;
var computeNextSeed = function(seed) {
  return seed * MULTIPLIER + INCREMENT & MASK;
};
var computeValueFromNextSeed = function(nextseed) {
  return (nextseed & MASK_2) >> 16;
};
var LinearCongruential32 = function() {
  function LinearCongruential322(seed) {
    this.seed = seed;
  }
  LinearCongruential322.prototype.clone = function() {
    return new LinearCongruential322(this.seed);
  };
  LinearCongruential322.prototype.next = function() {
    var nextRng = new LinearCongruential322(this.seed);
    var out = nextRng.unsafeNext();
    return [out, nextRng];
  };
  LinearCongruential322.prototype.unsafeNext = function() {
    var s1 = computeNextSeed(this.seed);
    var v1 = computeValueFromNextSeed(s1);
    var s2 = computeNextSeed(s1);
    var v2 = computeValueFromNextSeed(s2);
    this.seed = computeNextSeed(s2);
    var v3 = computeValueFromNextSeed(this.seed);
    var vnext = v3 + (v2 + (v1 << 15) << 15);
    return vnext | 0;
  };
  LinearCongruential322.prototype.getState = function() {
    return [this.seed];
  };
  return LinearCongruential322;
}();
function fromState(state) {
  var valid = state.length === 1;
  if (!valid) {
    throw new Error("The state must have been produced by a congruential32 RandomGenerator");
  }
  return new LinearCongruential32(state[0]);
}
var congruential32 = Object.assign(function(seed) {
  return new LinearCongruential32(seed);
}, { fromState });

// ../../node_modules/pure-rand/lib/esm/generator/MersenneTwister.js
var __read = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error4) {
    e = { error: error4 };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray = function(to, from, pack2) {
  if (pack2 || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var MersenneTwister = function() {
  function MersenneTwister2(states, index) {
    this.states = states;
    this.index = index;
  }
  MersenneTwister2.twist = function(prev) {
    var mt = prev.slice();
    for (var idx = 0; idx !== MersenneTwister2.N - MersenneTwister2.M; ++idx) {
      var y_1 = (mt[idx] & MersenneTwister2.MASK_UPPER) + (mt[idx + 1] & MersenneTwister2.MASK_LOWER);
      mt[idx] = mt[idx + MersenneTwister2.M] ^ y_1 >>> 1 ^ -(y_1 & 1) & MersenneTwister2.A;
    }
    for (var idx = MersenneTwister2.N - MersenneTwister2.M; idx !== MersenneTwister2.N - 1; ++idx) {
      var y_2 = (mt[idx] & MersenneTwister2.MASK_UPPER) + (mt[idx + 1] & MersenneTwister2.MASK_LOWER);
      mt[idx] = mt[idx + MersenneTwister2.M - MersenneTwister2.N] ^ y_2 >>> 1 ^ -(y_2 & 1) & MersenneTwister2.A;
    }
    var y = (mt[MersenneTwister2.N - 1] & MersenneTwister2.MASK_UPPER) + (mt[0] & MersenneTwister2.MASK_LOWER);
    mt[MersenneTwister2.N - 1] = mt[MersenneTwister2.M - 1] ^ y >>> 1 ^ -(y & 1) & MersenneTwister2.A;
    return mt;
  };
  MersenneTwister2.seeded = function(seed) {
    var out = Array(MersenneTwister2.N);
    out[0] = seed;
    for (var idx = 1; idx !== MersenneTwister2.N; ++idx) {
      var xored = out[idx - 1] ^ out[idx - 1] >>> 30;
      out[idx] = Math.imul(MersenneTwister2.F, xored) + idx | 0;
    }
    return out;
  };
  MersenneTwister2.from = function(seed) {
    return new MersenneTwister2(MersenneTwister2.twist(MersenneTwister2.seeded(seed)), 0);
  };
  MersenneTwister2.prototype.clone = function() {
    return new MersenneTwister2(this.states, this.index);
  };
  MersenneTwister2.prototype.next = function() {
    var nextRng = new MersenneTwister2(this.states, this.index);
    var out = nextRng.unsafeNext();
    return [out, nextRng];
  };
  MersenneTwister2.prototype.unsafeNext = function() {
    var y = this.states[this.index];
    y ^= this.states[this.index] >>> MersenneTwister2.U;
    y ^= y << MersenneTwister2.S & MersenneTwister2.B;
    y ^= y << MersenneTwister2.T & MersenneTwister2.C;
    y ^= y >>> MersenneTwister2.L;
    if (++this.index >= MersenneTwister2.N) {
      this.states = MersenneTwister2.twist(this.states);
      this.index = 0;
    }
    return y;
  };
  MersenneTwister2.prototype.getState = function() {
    return __spreadArray([this.index], __read(this.states), false);
  };
  MersenneTwister2.fromState = function(state) {
    var valid = state.length === MersenneTwister2.N + 1 && state[0] >= 0 && state[0] < MersenneTwister2.N;
    if (!valid) {
      throw new Error("The state must have been produced by a mersenne RandomGenerator");
    }
    return new MersenneTwister2(state.slice(1), state[0]);
  };
  MersenneTwister2.N = 624;
  MersenneTwister2.M = 397;
  MersenneTwister2.R = 31;
  MersenneTwister2.A = 2567483615;
  MersenneTwister2.F = 1812433253;
  MersenneTwister2.U = 11;
  MersenneTwister2.S = 7;
  MersenneTwister2.B = 2636928640;
  MersenneTwister2.T = 15;
  MersenneTwister2.C = 4022730752;
  MersenneTwister2.L = 18;
  MersenneTwister2.MASK_LOWER = Math.pow(2, MersenneTwister2.R) - 1;
  MersenneTwister2.MASK_UPPER = Math.pow(2, MersenneTwister2.R);
  return MersenneTwister2;
}();
function fromState2(state) {
  return MersenneTwister.fromState(state);
}
var MersenneTwister_default = Object.assign(function(seed) {
  return MersenneTwister.from(seed);
}, { fromState: fromState2 });

// ../../node_modules/pure-rand/lib/esm/generator/XorShift.js
var XorShift128Plus = function() {
  function XorShift128Plus2(s01, s00, s11, s10) {
    this.s01 = s01;
    this.s00 = s00;
    this.s11 = s11;
    this.s10 = s10;
  }
  XorShift128Plus2.prototype.clone = function() {
    return new XorShift128Plus2(this.s01, this.s00, this.s11, this.s10);
  };
  XorShift128Plus2.prototype.next = function() {
    var nextRng = new XorShift128Plus2(this.s01, this.s00, this.s11, this.s10);
    var out = nextRng.unsafeNext();
    return [out, nextRng];
  };
  XorShift128Plus2.prototype.unsafeNext = function() {
    var a0 = this.s00 ^ this.s00 << 23;
    var a1 = this.s01 ^ (this.s01 << 23 | this.s00 >>> 9);
    var b0 = a0 ^ this.s10 ^ (a0 >>> 18 | a1 << 14) ^ (this.s10 >>> 5 | this.s11 << 27);
    var b1 = a1 ^ this.s11 ^ a1 >>> 18 ^ this.s11 >>> 5;
    var out = this.s00 + this.s10 | 0;
    this.s01 = this.s11;
    this.s00 = this.s10;
    this.s11 = b1;
    this.s10 = b0;
    return out;
  };
  XorShift128Plus2.prototype.jump = function() {
    var nextRng = new XorShift128Plus2(this.s01, this.s00, this.s11, this.s10);
    nextRng.unsafeJump();
    return nextRng;
  };
  XorShift128Plus2.prototype.unsafeJump = function() {
    var ns01 = 0;
    var ns00 = 0;
    var ns11 = 0;
    var ns10 = 0;
    var jump = [1667051007, 2321340297, 1548169110, 304075285];
    for (var i = 0; i !== 4; ++i) {
      for (var mask = 1; mask; mask <<= 1) {
        if (jump[i] & mask) {
          ns01 ^= this.s01;
          ns00 ^= this.s00;
          ns11 ^= this.s11;
          ns10 ^= this.s10;
        }
        this.unsafeNext();
      }
    }
    this.s01 = ns01;
    this.s00 = ns00;
    this.s11 = ns11;
    this.s10 = ns10;
  };
  XorShift128Plus2.prototype.getState = function() {
    return [this.s01, this.s00, this.s11, this.s10];
  };
  return XorShift128Plus2;
}();
function fromState3(state) {
  var valid = state.length === 4;
  if (!valid) {
    throw new Error("The state must have been produced by a xorshift128plus RandomGenerator");
  }
  return new XorShift128Plus(state[0], state[1], state[2], state[3]);
}
var xorshift128plus = Object.assign(function(seed) {
  return new XorShift128Plus(-1, ~seed, seed | 0, 0);
}, { fromState: fromState3 });

// ../../node_modules/pure-rand/lib/esm/generator/XoroShiro.js
var XoroShiro128Plus = function() {
  function XoroShiro128Plus2(s01, s00, s11, s10) {
    this.s01 = s01;
    this.s00 = s00;
    this.s11 = s11;
    this.s10 = s10;
  }
  XoroShiro128Plus2.prototype.clone = function() {
    return new XoroShiro128Plus2(this.s01, this.s00, this.s11, this.s10);
  };
  XoroShiro128Plus2.prototype.next = function() {
    var nextRng = new XoroShiro128Plus2(this.s01, this.s00, this.s11, this.s10);
    var out = nextRng.unsafeNext();
    return [out, nextRng];
  };
  XoroShiro128Plus2.prototype.unsafeNext = function() {
    var out = this.s00 + this.s10 | 0;
    var a0 = this.s10 ^ this.s00;
    var a1 = this.s11 ^ this.s01;
    var s00 = this.s00;
    var s01 = this.s01;
    this.s00 = s00 << 24 ^ s01 >>> 8 ^ a0 ^ a0 << 16;
    this.s01 = s01 << 24 ^ s00 >>> 8 ^ a1 ^ (a1 << 16 | a0 >>> 16);
    this.s10 = a1 << 5 ^ a0 >>> 27;
    this.s11 = a0 << 5 ^ a1 >>> 27;
    return out;
  };
  XoroShiro128Plus2.prototype.jump = function() {
    var nextRng = new XoroShiro128Plus2(this.s01, this.s00, this.s11, this.s10);
    nextRng.unsafeJump();
    return nextRng;
  };
  XoroShiro128Plus2.prototype.unsafeJump = function() {
    var ns01 = 0;
    var ns00 = 0;
    var ns11 = 0;
    var ns10 = 0;
    var jump = [3639956645, 3750757012, 1261568508, 386426335];
    for (var i = 0; i !== 4; ++i) {
      for (var mask = 1; mask; mask <<= 1) {
        if (jump[i] & mask) {
          ns01 ^= this.s01;
          ns00 ^= this.s00;
          ns11 ^= this.s11;
          ns10 ^= this.s10;
        }
        this.unsafeNext();
      }
    }
    this.s01 = ns01;
    this.s00 = ns00;
    this.s11 = ns11;
    this.s10 = ns10;
  };
  XoroShiro128Plus2.prototype.getState = function() {
    return [this.s01, this.s00, this.s11, this.s10];
  };
  return XoroShiro128Plus2;
}();
function fromState4(state) {
  var valid = state.length === 4;
  if (!valid) {
    throw new Error("The state must have been produced by a xoroshiro128plus RandomGenerator");
  }
  return new XoroShiro128Plus(state[0], state[1], state[2], state[3]);
}
var xoroshiro128plus = Object.assign(function(seed) {
  return new XoroShiro128Plus(-1, ~seed, seed | 0, 0);
}, { fromState: fromState4 });

// ../../node_modules/pure-rand/lib/esm/distribution/internals/ArrayInt.js
function addArrayIntToNew(arrayIntA, arrayIntB) {
  if (arrayIntA.sign !== arrayIntB.sign) {
    return substractArrayIntToNew(arrayIntA, { sign: -arrayIntB.sign, data: arrayIntB.data });
  }
  var data = [];
  var reminder = 0;
  var dataA = arrayIntA.data;
  var dataB = arrayIntB.data;
  for (var indexA = dataA.length - 1, indexB = dataB.length - 1; indexA >= 0 || indexB >= 0; --indexA, --indexB) {
    var vA = indexA >= 0 ? dataA[indexA] : 0;
    var vB = indexB >= 0 ? dataB[indexB] : 0;
    var current2 = vA + vB + reminder;
    data.push(current2 >>> 0);
    reminder = ~~(current2 / 4294967296);
  }
  if (reminder !== 0) {
    data.push(reminder);
  }
  return { sign: arrayIntA.sign, data: data.reverse() };
}
function addOneToPositiveArrayInt(arrayInt) {
  arrayInt.sign = 1;
  var data = arrayInt.data;
  for (var index = data.length - 1; index >= 0; --index) {
    if (data[index] === 4294967295) {
      data[index] = 0;
    } else {
      data[index] += 1;
      return arrayInt;
    }
  }
  data.unshift(1);
  return arrayInt;
}
function isStrictlySmaller(dataA, dataB) {
  var maxLength2 = Math.max(dataA.length, dataB.length);
  for (var index = 0; index < maxLength2; ++index) {
    var indexA = index + dataA.length - maxLength2;
    var indexB = index + dataB.length - maxLength2;
    var vA = indexA >= 0 ? dataA[indexA] : 0;
    var vB = indexB >= 0 ? dataB[indexB] : 0;
    if (vA < vB)
      return true;
    if (vA > vB)
      return false;
  }
  return false;
}
function substractArrayIntToNew(arrayIntA, arrayIntB) {
  if (arrayIntA.sign !== arrayIntB.sign) {
    return addArrayIntToNew(arrayIntA, { sign: -arrayIntB.sign, data: arrayIntB.data });
  }
  var dataA = arrayIntA.data;
  var dataB = arrayIntB.data;
  if (isStrictlySmaller(dataA, dataB)) {
    var out = substractArrayIntToNew(arrayIntB, arrayIntA);
    out.sign = -out.sign;
    return out;
  }
  var data = [];
  var reminder = 0;
  for (var indexA = dataA.length - 1, indexB = dataB.length - 1; indexA >= 0 || indexB >= 0; --indexA, --indexB) {
    var vA = indexA >= 0 ? dataA[indexA] : 0;
    var vB = indexB >= 0 ? dataB[indexB] : 0;
    var current2 = vA - vB - reminder;
    data.push(current2 >>> 0);
    reminder = current2 < 0 ? 1 : 0;
  }
  return { sign: arrayIntA.sign, data: data.reverse() };
}
function trimArrayIntInplace(arrayInt) {
  var data = arrayInt.data;
  var firstNonZero = 0;
  for (; firstNonZero !== data.length && data[firstNonZero] === 0; ++firstNonZero) {
  }
  if (firstNonZero === data.length) {
    arrayInt.sign = 1;
    arrayInt.data = [0];
    return arrayInt;
  }
  data.splice(0, firstNonZero);
  return arrayInt;
}
function fromNumberToArrayInt64(out, n) {
  if (n < 0) {
    var posN = -n;
    out.sign = -1;
    out.data[0] = ~~(posN / 4294967296);
    out.data[1] = posN >>> 0;
  } else {
    out.sign = 1;
    out.data[0] = ~~(n / 4294967296);
    out.data[1] = n >>> 0;
  }
  return out;
}
function substractArrayInt64(out, arrayIntA, arrayIntB) {
  var lowA = arrayIntA.data[1];
  var highA = arrayIntA.data[0];
  var signA = arrayIntA.sign;
  var lowB = arrayIntB.data[1];
  var highB = arrayIntB.data[0];
  var signB = arrayIntB.sign;
  out.sign = 1;
  if (signA === 1 && signB === -1) {
    var low_1 = lowA + lowB;
    var high = highA + highB + (low_1 > 4294967295 ? 1 : 0);
    out.data[0] = high >>> 0;
    out.data[1] = low_1 >>> 0;
    return out;
  }
  var lowFirst = lowA;
  var highFirst = highA;
  var lowSecond = lowB;
  var highSecond = highB;
  if (signA === -1) {
    lowFirst = lowB;
    highFirst = highB;
    lowSecond = lowA;
    highSecond = highA;
  }
  var reminderLow = 0;
  var low = lowFirst - lowSecond;
  if (low < 0) {
    reminderLow = 1;
    low = low >>> 0;
  }
  out.data[0] = highFirst - highSecond - reminderLow;
  out.data[1] = low;
  return out;
}

// ../../node_modules/pure-rand/lib/esm/distribution/internals/UnsafeUniformIntDistributionInternal.js
function unsafeUniformIntDistributionInternal(rangeSize, rng) {
  var MaxAllowed = rangeSize > 2 ? ~~(4294967296 / rangeSize) * rangeSize : 4294967296;
  var deltaV = rng.unsafeNext() + 2147483648;
  while (deltaV >= MaxAllowed) {
    deltaV = rng.unsafeNext() + 2147483648;
  }
  return deltaV % rangeSize;
}

// ../../node_modules/pure-rand/lib/esm/distribution/internals/UnsafeUniformArrayIntDistributionInternal.js
function unsafeUniformArrayIntDistributionInternal(out, rangeSize, rng) {
  var rangeLength = rangeSize.length;
  while (true) {
    for (var index = 0; index !== rangeLength; ++index) {
      var indexRangeSize = index === 0 ? rangeSize[0] + 1 : 4294967296;
      var g = unsafeUniformIntDistributionInternal(indexRangeSize, rng);
      out[index] = g;
    }
    for (var index = 0; index !== rangeLength; ++index) {
      var current2 = out[index];
      var currentInRange = rangeSize[index];
      if (current2 < currentInRange) {
        return out;
      } else if (current2 > currentInRange) {
        break;
      }
    }
  }
}

// ../../node_modules/pure-rand/lib/esm/distribution/UnsafeUniformArrayIntDistribution.js
function unsafeUniformArrayIntDistribution(from, to, rng) {
  var rangeSize = trimArrayIntInplace(addOneToPositiveArrayInt(substractArrayIntToNew(to, from)));
  var emptyArrayIntData = rangeSize.data.slice(0);
  var g = unsafeUniformArrayIntDistributionInternal(emptyArrayIntData, rangeSize.data, rng);
  return trimArrayIntInplace(addArrayIntToNew({ sign: 1, data: g }, from));
}

// ../../node_modules/pure-rand/lib/esm/distribution/UniformArrayIntDistribution.js
function uniformArrayIntDistribution(from, to, rng) {
  if (rng != null) {
    var nextRng = rng.clone();
    return [unsafeUniformArrayIntDistribution(from, to, nextRng), nextRng];
  }
  return function(rng2) {
    var nextRng2 = rng2.clone();
    return [unsafeUniformArrayIntDistribution(from, to, nextRng2), nextRng2];
  };
}

// ../../node_modules/pure-rand/lib/esm/distribution/UnsafeUniformBigIntDistribution.js
var SBigInt2 = typeof BigInt !== "undefined" ? BigInt : void 0;
function unsafeUniformBigIntDistribution(from, to, rng) {
  var diff13 = to - from + SBigInt2(1);
  var MinRng = SBigInt2(-2147483648);
  var NumValues = SBigInt2(4294967296);
  var FinalNumValues = NumValues;
  var NumIterations = 1;
  while (FinalNumValues < diff13) {
    FinalNumValues *= NumValues;
    ++NumIterations;
  }
  var MaxAcceptedRandom = FinalNumValues - FinalNumValues % diff13;
  while (true) {
    var value10 = SBigInt2(0);
    for (var num = 0; num !== NumIterations; ++num) {
      var out = rng.unsafeNext();
      value10 = NumValues * value10 + (SBigInt2(out) - MinRng);
    }
    if (value10 < MaxAcceptedRandom) {
      var inDiff = value10 % diff13;
      return inDiff + from;
    }
  }
}

// ../../node_modules/pure-rand/lib/esm/distribution/UniformBigIntDistribution.js
function uniformBigIntDistribution(from, to, rng) {
  if (rng != null) {
    var nextRng = rng.clone();
    return [unsafeUniformBigIntDistribution(from, to, nextRng), nextRng];
  }
  return function(rng2) {
    var nextRng2 = rng2.clone();
    return [unsafeUniformBigIntDistribution(from, to, nextRng2), nextRng2];
  };
}

// ../../node_modules/pure-rand/lib/esm/distribution/UnsafeUniformIntDistribution.js
var safeNumberMaxSafeInteger = Number.MAX_SAFE_INTEGER;
var sharedA = { sign: 1, data: [0, 0] };
var sharedB = { sign: 1, data: [0, 0] };
var sharedC = { sign: 1, data: [0, 0] };
var sharedData = [0, 0];
function uniformLargeIntInternal(from, to, rangeSize, rng) {
  var rangeSizeArrayIntValue = rangeSize <= safeNumberMaxSafeInteger ? fromNumberToArrayInt64(sharedC, rangeSize) : substractArrayInt64(sharedC, fromNumberToArrayInt64(sharedA, to), fromNumberToArrayInt64(sharedB, from));
  if (rangeSizeArrayIntValue.data[1] === 4294967295) {
    rangeSizeArrayIntValue.data[0] += 1;
    rangeSizeArrayIntValue.data[1] = 0;
  } else {
    rangeSizeArrayIntValue.data[1] += 1;
  }
  unsafeUniformArrayIntDistributionInternal(sharedData, rangeSizeArrayIntValue.data, rng);
  return sharedData[0] * 4294967296 + sharedData[1] + from;
}
function unsafeUniformIntDistribution(from, to, rng) {
  var rangeSize = to - from;
  if (rangeSize <= 4294967295) {
    var g = unsafeUniformIntDistributionInternal(rangeSize + 1, rng);
    return g + from;
  }
  return uniformLargeIntInternal(from, to, rangeSize, rng);
}

// ../../node_modules/pure-rand/lib/esm/distribution/UniformIntDistribution.js
function uniformIntDistribution(from, to, rng) {
  if (rng != null) {
    var nextRng = rng.clone();
    return [unsafeUniformIntDistribution(from, to, nextRng), nextRng];
  }
  return function(rng2) {
    var nextRng2 = rng2.clone();
    return [unsafeUniformIntDistribution(from, to, nextRng2), nextRng2];
  };
}

// ../../node_modules/pure-rand/lib/esm/pure-rand-default.js
var __type = "module";
var __version = "6.1.0";
var __commitHash = "a413dd2b721516be2ef29adffb515c5ae67bfbad";

// ../../node_modules/pure-rand/lib/esm/pure-rand.js
var pure_rand_default = pure_rand_default_exports;

// ../../node_modules/fast-check/lib/esm/check/runner/configuration/VerbosityLevel.js
var VerbosityLevel;
(function(VerbosityLevel2) {
  VerbosityLevel2[VerbosityLevel2["None"] = 0] = "None";
  VerbosityLevel2[VerbosityLevel2["Verbose"] = 1] = "Verbose";
  VerbosityLevel2[VerbosityLevel2["VeryVerbose"] = 2] = "VeryVerbose";
})(VerbosityLevel || (VerbosityLevel = {}));

// ../../node_modules/fast-check/lib/esm/check/runner/configuration/QualifiedParameters.js
var safeDateNow = Date.now;
var safeMathMin = Math.min;
var safeMathRandom = Math.random;
var QualifiedParameters = class _QualifiedParameters {
  constructor(op) {
    const p = op || {};
    this.seed = _QualifiedParameters.readSeed(p);
    this.randomType = _QualifiedParameters.readRandomType(p);
    this.numRuns = _QualifiedParameters.readNumRuns(p);
    this.verbose = _QualifiedParameters.readVerbose(p);
    this.maxSkipsPerRun = _QualifiedParameters.readOrDefault(p, "maxSkipsPerRun", 100);
    this.timeout = _QualifiedParameters.safeTimeout(_QualifiedParameters.readOrDefault(p, "timeout", null));
    this.skipAllAfterTimeLimit = _QualifiedParameters.safeTimeout(_QualifiedParameters.readOrDefault(p, "skipAllAfterTimeLimit", null));
    this.interruptAfterTimeLimit = _QualifiedParameters.safeTimeout(_QualifiedParameters.readOrDefault(p, "interruptAfterTimeLimit", null));
    this.markInterruptAsFailure = _QualifiedParameters.readBoolean(p, "markInterruptAsFailure");
    this.skipEqualValues = _QualifiedParameters.readBoolean(p, "skipEqualValues");
    this.ignoreEqualValues = _QualifiedParameters.readBoolean(p, "ignoreEqualValues");
    this.logger = _QualifiedParameters.readOrDefault(p, "logger", (v) => {
      console.log(v);
    });
    this.path = _QualifiedParameters.readOrDefault(p, "path", "");
    this.unbiased = _QualifiedParameters.readBoolean(p, "unbiased");
    this.examples = _QualifiedParameters.readOrDefault(p, "examples", []);
    this.endOnFailure = _QualifiedParameters.readBoolean(p, "endOnFailure");
    this.reporter = _QualifiedParameters.readOrDefault(p, "reporter", null);
    this.asyncReporter = _QualifiedParameters.readOrDefault(p, "asyncReporter", null);
    this.errorWithCause = _QualifiedParameters.readBoolean(p, "errorWithCause");
  }
  toParameters() {
    const orUndefined2 = (value10) => value10 !== null ? value10 : void 0;
    const parameters = {
      seed: this.seed,
      randomType: this.randomType,
      numRuns: this.numRuns,
      maxSkipsPerRun: this.maxSkipsPerRun,
      timeout: orUndefined2(this.timeout),
      skipAllAfterTimeLimit: orUndefined2(this.skipAllAfterTimeLimit),
      interruptAfterTimeLimit: orUndefined2(this.interruptAfterTimeLimit),
      markInterruptAsFailure: this.markInterruptAsFailure,
      skipEqualValues: this.skipEqualValues,
      ignoreEqualValues: this.ignoreEqualValues,
      path: this.path,
      logger: this.logger,
      unbiased: this.unbiased,
      verbose: this.verbose,
      examples: this.examples,
      endOnFailure: this.endOnFailure,
      reporter: orUndefined2(this.reporter),
      asyncReporter: orUndefined2(this.asyncReporter),
      errorWithCause: this.errorWithCause
    };
    return parameters;
  }
  static read(op) {
    return new _QualifiedParameters(op);
  }
};
QualifiedParameters.createQualifiedRandomGenerator = (random4) => {
  return (seed) => {
    const rng = random4(seed);
    if (rng.unsafeJump === void 0) {
      rng.unsafeJump = () => unsafeSkipN(rng, 42);
    }
    return rng;
  };
};
QualifiedParameters.readSeed = (p) => {
  if (p.seed == null)
    return safeDateNow() ^ safeMathRandom() * 4294967296;
  const seed32 = p.seed | 0;
  if (p.seed === seed32)
    return seed32;
  const gap = p.seed - seed32;
  return seed32 ^ gap * 4294967296;
};
QualifiedParameters.readRandomType = (p) => {
  if (p.randomType == null)
    return pure_rand_default.xorshift128plus;
  if (typeof p.randomType === "string") {
    switch (p.randomType) {
      case "mersenne":
        return QualifiedParameters.createQualifiedRandomGenerator(pure_rand_default.mersenne);
      case "congruential":
      case "congruential32":
        return QualifiedParameters.createQualifiedRandomGenerator(pure_rand_default.congruential32);
      case "xorshift128plus":
        return pure_rand_default.xorshift128plus;
      case "xoroshiro128plus":
        return pure_rand_default.xoroshiro128plus;
      default:
        throw new Error(`Invalid random specified: '${p.randomType}'`);
    }
  }
  const mrng = p.randomType(0);
  if ("min" in mrng && mrng.min !== -2147483648) {
    throw new Error(`Invalid random number generator: min must equal -0x80000000, got ${String(mrng.min)}`);
  }
  if ("max" in mrng && mrng.max !== 2147483647) {
    throw new Error(`Invalid random number generator: max must equal 0x7fffffff, got ${String(mrng.max)}`);
  }
  if ("unsafeJump" in mrng) {
    return p.randomType;
  }
  return QualifiedParameters.createQualifiedRandomGenerator(p.randomType);
};
QualifiedParameters.readNumRuns = (p) => {
  const defaultValue = 100;
  if (p.numRuns != null)
    return p.numRuns;
  if (p.num_runs != null)
    return p.num_runs;
  return defaultValue;
};
QualifiedParameters.readVerbose = (p) => {
  if (p.verbose == null)
    return VerbosityLevel.None;
  if (typeof p.verbose === "boolean") {
    return p.verbose === true ? VerbosityLevel.Verbose : VerbosityLevel.None;
  }
  if (p.verbose <= VerbosityLevel.None) {
    return VerbosityLevel.None;
  }
  if (p.verbose >= VerbosityLevel.VeryVerbose) {
    return VerbosityLevel.VeryVerbose;
  }
  return p.verbose | 0;
};
QualifiedParameters.readBoolean = (p, key) => p[key] === true;
QualifiedParameters.readOrDefault = (p, key, defaultValue) => {
  const value10 = p[key];
  return value10 != null ? value10 : defaultValue;
};
QualifiedParameters.safeTimeout = (value10) => {
  if (value10 === null) {
    return null;
  }
  return safeMathMin(value10, 2147483647);
};

// ../../node_modules/fast-check/lib/esm/check/property/SkipAfterProperty.js
function interruptAfter(timeMs, setTimeoutSafe, clearTimeoutSafe) {
  let timeoutHandle = null;
  const promise4 = new Promise((resolve) => {
    timeoutHandle = setTimeoutSafe(() => {
      const preconditionFailure = new PreconditionFailure(true);
      resolve(preconditionFailure);
    }, timeMs);
  });
  return {
    clear: () => clearTimeoutSafe(timeoutHandle),
    promise: promise4
  };
}
var SkipAfterProperty = class {
  constructor(property2, getTime, timeLimit, interruptExecution, setTimeoutSafe, clearTimeoutSafe) {
    this.property = property2;
    this.getTime = getTime;
    this.interruptExecution = interruptExecution;
    this.setTimeoutSafe = setTimeoutSafe;
    this.clearTimeoutSafe = clearTimeoutSafe;
    this.skipAfterTime = this.getTime() + timeLimit;
    if (this.property.runBeforeEach !== void 0 && this.property.runAfterEach !== void 0) {
      this.runBeforeEach = () => this.property.runBeforeEach();
      this.runAfterEach = () => this.property.runAfterEach();
    }
  }
  isAsync() {
    return this.property.isAsync();
  }
  generate(mrng, runId) {
    return this.property.generate(mrng, runId);
  }
  shrink(value10) {
    return this.property.shrink(value10);
  }
  run(v, dontRunHook) {
    const remainingTime = this.skipAfterTime - this.getTime();
    if (remainingTime <= 0) {
      const preconditionFailure = new PreconditionFailure(this.interruptExecution);
      if (this.isAsync()) {
        return Promise.resolve(preconditionFailure);
      } else {
        return preconditionFailure;
      }
    }
    if (this.interruptExecution && this.isAsync()) {
      const t = interruptAfter(remainingTime, this.setTimeoutSafe, this.clearTimeoutSafe);
      const propRun = Promise.race([this.property.run(v, dontRunHook), t.promise]);
      propRun.then(t.clear, t.clear);
      return propRun;
    }
    return this.property.run(v, dontRunHook);
  }
};

// ../../node_modules/fast-check/lib/esm/check/property/TimeoutProperty.js
var timeoutAfter = (timeMs, setTimeoutSafe, clearTimeoutSafe) => {
  let timeoutHandle = null;
  const promise4 = new Promise((resolve) => {
    timeoutHandle = setTimeoutSafe(() => {
      resolve({
        error: new SError(`Property timeout: exceeded limit of ${timeMs} milliseconds`),
        errorMessage: `Property timeout: exceeded limit of ${timeMs} milliseconds`
      });
    }, timeMs);
  });
  return {
    clear: () => clearTimeoutSafe(timeoutHandle),
    promise: promise4
  };
};
var TimeoutProperty = class {
  constructor(property2, timeMs, setTimeoutSafe, clearTimeoutSafe) {
    this.property = property2;
    this.timeMs = timeMs;
    this.setTimeoutSafe = setTimeoutSafe;
    this.clearTimeoutSafe = clearTimeoutSafe;
    if (this.property.runBeforeEach !== void 0 && this.property.runAfterEach !== void 0) {
      this.runBeforeEach = () => Promise.resolve(this.property.runBeforeEach());
      this.runAfterEach = () => Promise.resolve(this.property.runAfterEach());
    }
  }
  isAsync() {
    return true;
  }
  generate(mrng, runId) {
    return this.property.generate(mrng, runId);
  }
  shrink(value10) {
    return this.property.shrink(value10);
  }
  async run(v, dontRunHook) {
    const t = timeoutAfter(this.timeMs, this.setTimeoutSafe, this.clearTimeoutSafe);
    const propRun = Promise.race([this.property.run(v, dontRunHook), t.promise]);
    propRun.then(t.clear, t.clear);
    return propRun;
  }
};

// ../../node_modules/fast-check/lib/esm/check/property/UnbiasedProperty.js
var UnbiasedProperty = class {
  constructor(property2) {
    this.property = property2;
    if (this.property.runBeforeEach !== void 0 && this.property.runAfterEach !== void 0) {
      this.runBeforeEach = () => this.property.runBeforeEach();
      this.runAfterEach = () => this.property.runAfterEach();
    }
  }
  isAsync() {
    return this.property.isAsync();
  }
  generate(mrng, _runId) {
    return this.property.generate(mrng, void 0);
  }
  shrink(value10) {
    return this.property.shrink(value10);
  }
  run(v, dontRunHook) {
    return this.property.run(v, dontRunHook);
  }
};

// ../../node_modules/fast-check/lib/esm/utils/stringify.js
var safeArrayFrom = Array.from;
var safeBufferIsBuffer = typeof Buffer !== "undefined" ? Buffer.isBuffer : void 0;
var safeJsonStringify = JSON.stringify;
var safeNumberIsNaN = Number.isNaN;
var safeObjectKeys = Object.keys;
var safeObjectGetOwnPropertySymbols = Object.getOwnPropertySymbols;
var safeObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var safeObjectGetPrototypeOf = Object.getPrototypeOf;
var safeNegativeInfinity = Number.NEGATIVE_INFINITY;
var safePositiveInfinity = Number.POSITIVE_INFINITY;
var toStringMethod = Symbol.for("fast-check/toStringMethod");
function hasToStringMethod(instance) {
  return instance !== null && (typeof instance === "object" || typeof instance === "function") && toStringMethod in instance && typeof instance[toStringMethod] === "function";
}
var asyncToStringMethod = Symbol.for("fast-check/asyncToStringMethod");
function hasAsyncToStringMethod(instance) {
  return instance !== null && (typeof instance === "object" || typeof instance === "function") && asyncToStringMethod in instance && typeof instance[asyncToStringMethod] === "function";
}
var findSymbolNameRegex = /^Symbol\((.*)\)$/;
function getSymbolDescription(s) {
  if (s.description !== void 0)
    return s.description;
  const m = findSymbolNameRegex.exec(SString(s));
  return m && m[1].length ? m[1] : null;
}
function stringifyNumber(numValue) {
  switch (numValue) {
    case 0:
      return 1 / numValue === safeNegativeInfinity ? "-0" : "0";
    case safeNegativeInfinity:
      return "Number.NEGATIVE_INFINITY";
    case safePositiveInfinity:
      return "Number.POSITIVE_INFINITY";
    default:
      return numValue === numValue ? SString(numValue) : "Number.NaN";
  }
}
function isSparseArray(arr) {
  let previousNumberedIndex = -1;
  for (const index in arr) {
    const numberedIndex = Number(index);
    if (numberedIndex !== previousNumberedIndex + 1)
      return true;
    previousNumberedIndex = numberedIndex;
  }
  return previousNumberedIndex + 1 !== arr.length;
}
function stringifyInternal(value10, previousValues, getAsyncContent) {
  const currentValues = [...previousValues, value10];
  if (typeof value10 === "object") {
    if (safeIndexOf(previousValues, value10) !== -1) {
      return "[cyclic]";
    }
  }
  if (hasAsyncToStringMethod(value10)) {
    const content = getAsyncContent(value10);
    if (content.state === "fulfilled") {
      return content.value;
    }
  }
  if (hasToStringMethod(value10)) {
    try {
      return value10[toStringMethod]();
    } catch (err) {
    }
  }
  switch (safeToString(value10)) {
    case "[object Array]": {
      const arr = value10;
      if (arr.length >= 50 && isSparseArray(arr)) {
        const assignments = [];
        for (const index in arr) {
          if (!safeNumberIsNaN(Number(index)))
            safePush(assignments, `${index}:${stringifyInternal(arr[index], currentValues, getAsyncContent)}`);
        }
        return assignments.length !== 0 ? `Object.assign(Array(${arr.length}),{${safeJoin(assignments, ",")}})` : `Array(${arr.length})`;
      }
      const stringifiedArray = safeJoin(safeMap(arr, (v) => stringifyInternal(v, currentValues, getAsyncContent)), ",");
      return arr.length === 0 || arr.length - 1 in arr ? `[${stringifiedArray}]` : `[${stringifiedArray},]`;
    }
    case "[object BigInt]":
      return `${value10}n`;
    case "[object Boolean]": {
      const unboxedToString = value10 == true ? "true" : "false";
      return typeof value10 === "boolean" ? unboxedToString : `new Boolean(${unboxedToString})`;
    }
    case "[object Date]": {
      const d = value10;
      return safeNumberIsNaN(safeGetTime(d)) ? `new Date(NaN)` : `new Date(${safeJsonStringify(safeToISOString(d))})`;
    }
    case "[object Map]":
      return `new Map(${stringifyInternal(Array.from(value10), currentValues, getAsyncContent)})`;
    case "[object Null]":
      return `null`;
    case "[object Number]":
      return typeof value10 === "number" ? stringifyNumber(value10) : `new Number(${stringifyNumber(Number(value10))})`;
    case "[object Object]": {
      try {
        const toStringAccessor = value10.toString;
        if (typeof toStringAccessor === "function" && toStringAccessor !== Object.prototype.toString) {
          return value10.toString();
        }
      } catch (err) {
        return "[object Object]";
      }
      const mapper = (k) => `${k === "__proto__" ? '["__proto__"]' : typeof k === "symbol" ? `[${stringifyInternal(k, currentValues, getAsyncContent)}]` : safeJsonStringify(k)}:${stringifyInternal(value10[k], currentValues, getAsyncContent)}`;
      const stringifiedProperties = [
        ...safeMap(safeObjectKeys(value10), mapper),
        ...safeMap(safeFilter(safeObjectGetOwnPropertySymbols(value10), (s) => {
          const descriptor3 = safeObjectGetOwnPropertyDescriptor(value10, s);
          return descriptor3 && descriptor3.enumerable;
        }), mapper)
      ];
      const rawRepr = "{" + safeJoin(stringifiedProperties, ",") + "}";
      if (safeObjectGetPrototypeOf(value10) === null) {
        return rawRepr === "{}" ? "Object.create(null)" : `Object.assign(Object.create(null),${rawRepr})`;
      }
      return rawRepr;
    }
    case "[object Set]":
      return `new Set(${stringifyInternal(Array.from(value10), currentValues, getAsyncContent)})`;
    case "[object String]":
      return typeof value10 === "string" ? safeJsonStringify(value10) : `new String(${safeJsonStringify(value10)})`;
    case "[object Symbol]": {
      const s = value10;
      if (SSymbol.keyFor(s) !== void 0) {
        return `Symbol.for(${safeJsonStringify(SSymbol.keyFor(s))})`;
      }
      const desc = getSymbolDescription(s);
      if (desc === null) {
        return "Symbol()";
      }
      const knownSymbol = desc.startsWith("Symbol.") && SSymbol[desc.substring(7)];
      return s === knownSymbol ? desc : `Symbol(${safeJsonStringify(desc)})`;
    }
    case "[object Promise]": {
      const promiseContent = getAsyncContent(value10);
      switch (promiseContent.state) {
        case "fulfilled":
          return `Promise.resolve(${stringifyInternal(promiseContent.value, currentValues, getAsyncContent)})`;
        case "rejected":
          return `Promise.reject(${stringifyInternal(promiseContent.value, currentValues, getAsyncContent)})`;
        case "pending":
          return `new Promise(() => {/*pending*/})`;
        case "unknown":
        default:
          return `new Promise(() => {/*unknown*/})`;
      }
    }
    case "[object Error]":
      if (value10 instanceof Error) {
        return `new Error(${stringifyInternal(value10.message, currentValues, getAsyncContent)})`;
      }
      break;
    case "[object Undefined]":
      return `undefined`;
    case "[object Int8Array]":
    case "[object Uint8Array]":
    case "[object Uint8ClampedArray]":
    case "[object Int16Array]":
    case "[object Uint16Array]":
    case "[object Int32Array]":
    case "[object Uint32Array]":
    case "[object Float32Array]":
    case "[object Float64Array]":
    case "[object BigInt64Array]":
    case "[object BigUint64Array]": {
      if (typeof safeBufferIsBuffer === "function" && safeBufferIsBuffer(value10)) {
        return `Buffer.from(${stringifyInternal(safeArrayFrom(value10.values()), currentValues, getAsyncContent)})`;
      }
      const valuePrototype = safeObjectGetPrototypeOf(value10);
      const className = valuePrototype && valuePrototype.constructor && valuePrototype.constructor.name;
      if (typeof className === "string") {
        const typedArray2 = value10;
        const valuesFromTypedArr = typedArray2.values();
        return `${className}.from(${stringifyInternal(safeArrayFrom(valuesFromTypedArr), currentValues, getAsyncContent)})`;
      }
      break;
    }
  }
  try {
    return value10.toString();
  } catch (_a) {
    return safeToString(value10);
  }
}
function stringify(value10) {
  return stringifyInternal(value10, [], () => ({ state: "unknown", value: void 0 }));
}
function possiblyAsyncStringify(value10) {
  const stillPendingMarker = SSymbol();
  const pendingPromisesForCache = [];
  const cache = new SMap();
  function createDelay0() {
    let handleId = null;
    const cancel = () => {
      if (handleId !== null) {
        clearTimeout(handleId);
      }
    };
    const delay4 = new Promise((resolve) => {
      handleId = setTimeout(() => {
        handleId = null;
        resolve(stillPendingMarker);
      }, 0);
    });
    return { delay: delay4, cancel };
  }
  const unknownState = { state: "unknown", value: void 0 };
  const getAsyncContent = function getAsyncContent2(data) {
    const cacheKey = data;
    if (cache.has(cacheKey)) {
      return cache.get(cacheKey);
    }
    const delay0 = createDelay0();
    const p = asyncToStringMethod in data ? Promise.resolve().then(() => data[asyncToStringMethod]()) : data;
    p.catch(() => {
    });
    pendingPromisesForCache.push(Promise.race([p, delay0.delay]).then((successValue) => {
      if (successValue === stillPendingMarker)
        cache.set(cacheKey, { state: "pending", value: void 0 });
      else
        cache.set(cacheKey, { state: "fulfilled", value: successValue });
      delay0.cancel();
    }, (errorValue) => {
      cache.set(cacheKey, { state: "rejected", value: errorValue });
      delay0.cancel();
    }));
    cache.set(cacheKey, unknownState);
    return unknownState;
  };
  function loop5() {
    const stringifiedValue = stringifyInternal(value10, [], getAsyncContent);
    if (pendingPromisesForCache.length === 0) {
      return stringifiedValue;
    }
    return Promise.all(pendingPromisesForCache.splice(0)).then(loop5);
  }
  return loop5();
}
async function asyncStringify(value10) {
  return Promise.resolve(possiblyAsyncStringify(value10));
}

// ../../node_modules/fast-check/lib/esm/check/property/IgnoreEqualValuesProperty.js
function fromSyncCached(cachedValue) {
  return cachedValue === null ? new PreconditionFailure() : cachedValue;
}
function fromCached(...data) {
  if (data[1])
    return data[0].then(fromSyncCached);
  return fromSyncCached(data[0]);
}
function fromCachedUnsafe(cachedValue, isAsync) {
  return fromCached(cachedValue, isAsync);
}
var IgnoreEqualValuesProperty = class {
  constructor(property2, skipRuns) {
    this.property = property2;
    this.skipRuns = skipRuns;
    this.coveredCases = /* @__PURE__ */ new Map();
    if (this.property.runBeforeEach !== void 0 && this.property.runAfterEach !== void 0) {
      this.runBeforeEach = () => this.property.runBeforeEach();
      this.runAfterEach = () => this.property.runAfterEach();
    }
  }
  isAsync() {
    return this.property.isAsync();
  }
  generate(mrng, runId) {
    return this.property.generate(mrng, runId);
  }
  shrink(value10) {
    return this.property.shrink(value10);
  }
  run(v, dontRunHook) {
    const stringifiedValue = stringify(v);
    if (this.coveredCases.has(stringifiedValue)) {
      const lastOutput = this.coveredCases.get(stringifiedValue);
      if (!this.skipRuns) {
        return lastOutput;
      }
      return fromCachedUnsafe(lastOutput, this.property.isAsync());
    }
    const out = this.property.run(v, dontRunHook);
    this.coveredCases.set(stringifiedValue, out);
    return out;
  }
};

// ../../node_modules/fast-check/lib/esm/check/runner/DecorateProperty.js
var safeDateNow2 = Date.now;
var safeSetTimeout = setTimeout;
var safeClearTimeout = clearTimeout;
function decorateProperty(rawProperty, qParams) {
  let prop = rawProperty;
  if (rawProperty.isAsync() && qParams.timeout != null) {
    prop = new TimeoutProperty(prop, qParams.timeout, safeSetTimeout, safeClearTimeout);
  }
  if (qParams.unbiased) {
    prop = new UnbiasedProperty(prop);
  }
  if (qParams.skipAllAfterTimeLimit != null) {
    prop = new SkipAfterProperty(prop, safeDateNow2, qParams.skipAllAfterTimeLimit, false, safeSetTimeout, safeClearTimeout);
  }
  if (qParams.interruptAfterTimeLimit != null) {
    prop = new SkipAfterProperty(prop, safeDateNow2, qParams.interruptAfterTimeLimit, true, safeSetTimeout, safeClearTimeout);
  }
  if (qParams.skipEqualValues) {
    prop = new IgnoreEqualValuesProperty(prop, true);
  }
  if (qParams.ignoreEqualValues) {
    prop = new IgnoreEqualValuesProperty(prop, false);
  }
  return prop;
}

// ../../node_modules/fast-check/lib/esm/check/runner/reporter/ExecutionStatus.js
var ExecutionStatus;
(function(ExecutionStatus2) {
  ExecutionStatus2[ExecutionStatus2["Success"] = 0] = "Success";
  ExecutionStatus2[ExecutionStatus2["Skipped"] = -1] = "Skipped";
  ExecutionStatus2[ExecutionStatus2["Failure"] = 1] = "Failure";
})(ExecutionStatus || (ExecutionStatus = {}));

// ../../node_modules/fast-check/lib/esm/check/runner/reporter/RunExecution.js
var RunExecution = class _RunExecution {
  constructor(verbosity, interruptedAsFailure) {
    this.verbosity = verbosity;
    this.interruptedAsFailure = interruptedAsFailure;
    this.isSuccess = () => this.pathToFailure == null;
    this.firstFailure = () => this.pathToFailure ? +safeSplit(this.pathToFailure, ":")[0] : -1;
    this.numShrinks = () => this.pathToFailure ? safeSplit(this.pathToFailure, ":").length - 1 : 0;
    this.rootExecutionTrees = [];
    this.currentLevelExecutionTrees = this.rootExecutionTrees;
    this.failure = null;
    this.numSkips = 0;
    this.numSuccesses = 0;
    this.interrupted = false;
  }
  appendExecutionTree(status3, value10) {
    const currentTree = { status: status3, value: value10, children: [] };
    this.currentLevelExecutionTrees.push(currentTree);
    return currentTree;
  }
  fail(value10, id3, failure) {
    if (this.verbosity >= VerbosityLevel.Verbose) {
      const currentTree = this.appendExecutionTree(ExecutionStatus.Failure, value10);
      this.currentLevelExecutionTrees = currentTree.children;
    }
    if (this.pathToFailure == null)
      this.pathToFailure = `${id3}`;
    else
      this.pathToFailure += `:${id3}`;
    this.value = value10;
    this.failure = failure;
  }
  skip(value10) {
    if (this.verbosity >= VerbosityLevel.VeryVerbose) {
      this.appendExecutionTree(ExecutionStatus.Skipped, value10);
    }
    if (this.pathToFailure == null) {
      ++this.numSkips;
    }
  }
  success(value10) {
    if (this.verbosity >= VerbosityLevel.VeryVerbose) {
      this.appendExecutionTree(ExecutionStatus.Success, value10);
    }
    if (this.pathToFailure == null) {
      ++this.numSuccesses;
    }
  }
  interrupt() {
    this.interrupted = true;
  }
  extractFailures() {
    if (this.isSuccess()) {
      return [];
    }
    const failures3 = [];
    let cursor = this.rootExecutionTrees;
    while (cursor.length > 0 && cursor[cursor.length - 1].status === ExecutionStatus.Failure) {
      const failureTree = cursor[cursor.length - 1];
      failures3.push(failureTree.value);
      cursor = failureTree.children;
    }
    return failures3;
  }
  toRunDetails(seed, basePath, maxSkips, qParams) {
    if (!this.isSuccess()) {
      return {
        failed: true,
        interrupted: this.interrupted,
        numRuns: this.firstFailure() + 1 - this.numSkips,
        numSkips: this.numSkips,
        numShrinks: this.numShrinks(),
        seed,
        counterexample: this.value,
        counterexamplePath: _RunExecution.mergePaths(basePath, this.pathToFailure),
        error: this.failure.errorMessage,
        errorInstance: this.failure.error,
        failures: this.extractFailures(),
        executionSummary: this.rootExecutionTrees,
        verbose: this.verbosity,
        runConfiguration: qParams.toParameters()
      };
    }
    const considerInterruptedAsFailure = this.interruptedAsFailure || this.numSuccesses === 0;
    const failed = this.numSkips > maxSkips || this.interrupted && considerInterruptedAsFailure;
    const out = {
      failed,
      interrupted: this.interrupted,
      numRuns: this.numSuccesses,
      numSkips: this.numSkips,
      numShrinks: 0,
      seed,
      counterexample: null,
      counterexamplePath: null,
      error: null,
      errorInstance: null,
      failures: [],
      executionSummary: this.rootExecutionTrees,
      verbose: this.verbosity,
      runConfiguration: qParams.toParameters()
    };
    return out;
  }
};
RunExecution.mergePaths = (offsetPath, path) => {
  if (offsetPath.length === 0)
    return path;
  const offsetItems = offsetPath.split(":");
  const remainingItems = path.split(":");
  const middle = +offsetItems[offsetItems.length - 1] + +remainingItems[0];
  return [...offsetItems.slice(0, offsetItems.length - 1), `${middle}`, ...remainingItems.slice(1)].join(":");
};

// ../../node_modules/fast-check/lib/esm/check/runner/RunnerIterator.js
var RunnerIterator = class {
  constructor(sourceValues, shrink2, verbose, interruptedAsFailure) {
    this.sourceValues = sourceValues;
    this.shrink = shrink2;
    this.runExecution = new RunExecution(verbose, interruptedAsFailure);
    this.currentIdx = -1;
    this.nextValues = sourceValues;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const nextValue = this.nextValues.next();
    if (nextValue.done || this.runExecution.interrupted) {
      return { done: true, value: void 0 };
    }
    this.currentValue = nextValue.value;
    ++this.currentIdx;
    return { done: false, value: nextValue.value.value_ };
  }
  handleResult(result) {
    if (result != null && typeof result === "object" && !PreconditionFailure.isFailure(result)) {
      this.runExecution.fail(this.currentValue.value_, this.currentIdx, result);
      this.currentIdx = -1;
      this.nextValues = this.shrink(this.currentValue);
    } else if (result != null) {
      if (!result.interruptExecution) {
        this.runExecution.skip(this.currentValue.value_);
        this.sourceValues.skippedOne();
      } else {
        this.runExecution.interrupt();
      }
    } else {
      this.runExecution.success(this.currentValue.value_);
    }
  }
};

// ../../node_modules/fast-check/lib/esm/check/runner/SourceValuesIterator.js
var SourceValuesIterator = class {
  constructor(initialValues, maxInitialIterations, remainingSkips) {
    this.initialValues = initialValues;
    this.maxInitialIterations = maxInitialIterations;
    this.remainingSkips = remainingSkips;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    if (--this.maxInitialIterations !== -1 && this.remainingSkips >= 0) {
      const n = this.initialValues.next();
      if (!n.done)
        return { value: n.value, done: false };
    }
    return { value: void 0, done: true };
  }
  skippedOne() {
    --this.remainingSkips;
    ++this.maxInitialIterations;
  }
};

// ../../node_modules/fast-check/lib/esm/random/generator/Random.js
var Random = class _Random {
  constructor(sourceRng) {
    this.internalRng = sourceRng.clone();
  }
  clone() {
    return new _Random(this.internalRng);
  }
  next(bits) {
    return unsafeUniformIntDistribution(0, (1 << bits) - 1, this.internalRng);
  }
  nextBoolean() {
    return unsafeUniformIntDistribution(0, 1, this.internalRng) == 1;
  }
  nextInt(min11, max13) {
    return unsafeUniformIntDistribution(min11 == null ? _Random.MIN_INT : min11, max13 == null ? _Random.MAX_INT : max13, this.internalRng);
  }
  nextBigInt(min11, max13) {
    return unsafeUniformBigIntDistribution(min11, max13, this.internalRng);
  }
  nextArrayInt(min11, max13) {
    return unsafeUniformArrayIntDistribution(min11, max13, this.internalRng);
  }
  nextDouble() {
    const a = this.next(26);
    const b = this.next(27);
    return (a * _Random.DBL_FACTOR + b) * _Random.DBL_DIVISOR;
  }
  getState() {
    if ("getState" in this.internalRng && typeof this.internalRng.getState === "function") {
      return this.internalRng.getState();
    }
    return void 0;
  }
};
Random.MIN_INT = 2147483648 | 0;
Random.MAX_INT = 2147483647 | 0;
Random.DBL_FACTOR = Math.pow(2, 27);
Random.DBL_DIVISOR = Math.pow(2, -53);

// ../../node_modules/fast-check/lib/esm/check/runner/Tosser.js
function tossNext(generator, rng, index) {
  rng.unsafeJump();
  return generator.generate(new Random(rng), index);
}
function* toss(generator, seed, random4, examples) {
  for (let idx = 0; idx !== examples.length; ++idx) {
    yield new Value(examples[idx], void 0);
  }
  for (let idx = 0, rng = random4(seed); ; ++idx) {
    yield tossNext(generator, rng, idx);
  }
}
function lazyGenerate(generator, rng, idx) {
  return () => generator.generate(new Random(rng), idx);
}
function* lazyToss(generator, seed, random4, examples) {
  yield* safeMap(examples, (e) => () => new Value(e, void 0));
  let idx = 0;
  let rng = random4(seed);
  for (; ; ) {
    rng = rng.jump ? rng.jump() : skipN(rng, 42);
    yield lazyGenerate(generator, rng, idx++);
  }
}

// ../../node_modules/fast-check/lib/esm/check/runner/utils/PathWalker.js
function produce(producer) {
  return producer();
}
function pathWalk(path, initialProducers, shrink2) {
  const producers = initialProducers;
  const segments = path.split(":").map((text) => +text);
  if (segments.length === 0) {
    return producers.map(produce);
  }
  if (!segments.every((v) => !Number.isNaN(v))) {
    throw new Error(`Unable to replay, got invalid path=${path}`);
  }
  let values15 = producers.drop(segments[0]).map(produce);
  for (const s of segments.slice(1)) {
    const valueToShrink = values15.getNthOrLast(0);
    if (valueToShrink === null) {
      throw new Error(`Unable to replay, got wrong path=${path}`);
    }
    values15 = shrink2(valueToShrink).drop(s);
  }
  return values15;
}

// ../../node_modules/fast-check/lib/esm/check/runner/utils/RunDetailsFormatter.js
var safeObjectAssign2 = Object.assign;
function formatHints(hints) {
  if (hints.length === 1) {
    return `Hint: ${hints[0]}`;
  }
  return hints.map((h2, idx) => `Hint (${idx + 1}): ${h2}`).join("\n");
}
function formatFailures(failures3, stringifyOne) {
  return `Encountered failures were:
- ${failures3.map(stringifyOne).join("\n- ")}`;
}
function formatExecutionSummary(executionTrees, stringifyOne) {
  const summaryLines = [];
  const remainingTreesAndDepth = [];
  for (const tree of executionTrees.slice().reverse()) {
    remainingTreesAndDepth.push({ depth: 1, tree });
  }
  while (remainingTreesAndDepth.length !== 0) {
    const currentTreeAndDepth = remainingTreesAndDepth.pop();
    const currentTree = currentTreeAndDepth.tree;
    const currentDepth = currentTreeAndDepth.depth;
    const statusIcon = currentTree.status === ExecutionStatus.Success ? "\x1B[32m√\x1B[0m" : currentTree.status === ExecutionStatus.Failure ? "\x1B[31m×\x1B[0m" : "\x1B[33m!\x1B[0m";
    const leftPadding = Array(currentDepth).join(". ");
    summaryLines.push(`${leftPadding}${statusIcon} ${stringifyOne(currentTree.value)}`);
    for (const tree of currentTree.children.slice().reverse()) {
      remainingTreesAndDepth.push({ depth: currentDepth + 1, tree });
    }
  }
  return `Execution summary:
${summaryLines.join("\n")}`;
}
function preFormatTooManySkipped(out, stringifyOne) {
  const message = `Failed to run property, too many pre-condition failures encountered
{ seed: ${out.seed} }

Ran ${out.numRuns} time(s)
Skipped ${out.numSkips} time(s)`;
  let details = null;
  const hints = [
    "Try to reduce the number of rejected values by combining map, flatMap and built-in arbitraries",
    "Increase failure tolerance by setting maxSkipsPerRun to an higher value"
  ];
  if (out.verbose >= VerbosityLevel.VeryVerbose) {
    details = formatExecutionSummary(out.executionSummary, stringifyOne);
  } else {
    safePush(hints, "Enable verbose mode at level VeryVerbose in order to check all generated values and their associated status");
  }
  return { message, details, hints };
}
function preFormatFailure(out, stringifyOne) {
  const noErrorInMessage = out.runConfiguration.errorWithCause;
  const messageErrorPart = noErrorInMessage ? "" : `
Got ${safeReplace(out.error, /^Error: /, "error: ")}`;
  const message = `Property failed after ${out.numRuns} tests
{ seed: ${out.seed}, path: "${out.counterexamplePath}", endOnFailure: true }
Counterexample: ${stringifyOne(out.counterexample)}
Shrunk ${out.numShrinks} time(s)${messageErrorPart}`;
  let details = null;
  const hints = [];
  if (out.verbose >= VerbosityLevel.VeryVerbose) {
    details = formatExecutionSummary(out.executionSummary, stringifyOne);
  } else if (out.verbose === VerbosityLevel.Verbose) {
    details = formatFailures(out.failures, stringifyOne);
  } else {
    safePush(hints, "Enable verbose mode in order to have the list of all failing values encountered during the run");
  }
  return { message, details, hints };
}
function preFormatEarlyInterrupted(out, stringifyOne) {
  const message = `Property interrupted after ${out.numRuns} tests
{ seed: ${out.seed} }`;
  let details = null;
  const hints = [];
  if (out.verbose >= VerbosityLevel.VeryVerbose) {
    details = formatExecutionSummary(out.executionSummary, stringifyOne);
  } else {
    safePush(hints, "Enable verbose mode at level VeryVerbose in order to check all generated values and their associated status");
  }
  return { message, details, hints };
}
function defaultReportMessageInternal(out, stringifyOne) {
  if (!out.failed)
    return;
  const { message, details, hints } = out.counterexamplePath === null ? out.interrupted ? preFormatEarlyInterrupted(out, stringifyOne) : preFormatTooManySkipped(out, stringifyOne) : preFormatFailure(out, stringifyOne);
  let errorMessage = message;
  if (details != null)
    errorMessage += `

${details}`;
  if (hints.length > 0)
    errorMessage += `

${formatHints(hints)}`;
  return errorMessage;
}
function defaultReportMessage(out) {
  return defaultReportMessageInternal(out, stringify);
}
async function asyncDefaultReportMessage(out) {
  const pendingStringifieds = [];
  function stringifyOne(value10) {
    const stringified = possiblyAsyncStringify(value10);
    if (typeof stringified === "string") {
      return stringified;
    }
    pendingStringifieds.push(Promise.all([value10, stringified]));
    return "…";
  }
  const firstTryMessage = defaultReportMessageInternal(out, stringifyOne);
  if (pendingStringifieds.length === 0) {
    return firstTryMessage;
  }
  const registeredValues = new SMap(await Promise.all(pendingStringifieds));
  function stringifySecond(value10) {
    const asyncStringifiedIfRegistered = safeMapGet(registeredValues, value10);
    if (asyncStringifiedIfRegistered !== void 0) {
      return asyncStringifiedIfRegistered;
    }
    return stringify(value10);
  }
  return defaultReportMessageInternal(out, stringifySecond);
}
function buildError(errorMessage, out) {
  if (!out.runConfiguration.errorWithCause) {
    throw new SError(errorMessage);
  }
  const ErrorWithCause = SError;
  const error4 = new ErrorWithCause(errorMessage, { cause: out.errorInstance });
  if (!("cause" in error4)) {
    safeObjectAssign2(error4, { cause: out.errorInstance });
  }
  return error4;
}
function throwIfFailed(out) {
  if (!out.failed)
    return;
  throw buildError(defaultReportMessage(out), out);
}
async function asyncThrowIfFailed(out) {
  if (!out.failed)
    return;
  throw buildError(await asyncDefaultReportMessage(out), out);
}
function reportRunDetails(out) {
  if (out.runConfiguration.asyncReporter)
    return out.runConfiguration.asyncReporter(out);
  else if (out.runConfiguration.reporter)
    return out.runConfiguration.reporter(out);
  else
    return throwIfFailed(out);
}
async function asyncReportRunDetails(out) {
  if (out.runConfiguration.asyncReporter)
    return out.runConfiguration.asyncReporter(out);
  else if (out.runConfiguration.reporter)
    return out.runConfiguration.reporter(out);
  else
    return asyncThrowIfFailed(out);
}

// ../../node_modules/fast-check/lib/esm/check/runner/Runner.js
var safeObjectAssign3 = Object.assign;
function runIt(property2, shrink2, sourceValues, verbose, interruptedAsFailure) {
  const isModernProperty = property2.runBeforeEach !== void 0 && property2.runAfterEach !== void 0;
  const runner = new RunnerIterator(sourceValues, shrink2, verbose, interruptedAsFailure);
  for (const v of runner) {
    if (isModernProperty) {
      property2.runBeforeEach();
    }
    const out = property2.run(v, isModernProperty);
    if (isModernProperty) {
      property2.runAfterEach();
    }
    runner.handleResult(out);
  }
  return runner.runExecution;
}
async function asyncRunIt(property2, shrink2, sourceValues, verbose, interruptedAsFailure) {
  const isModernProperty = property2.runBeforeEach !== void 0 && property2.runAfterEach !== void 0;
  const runner = new RunnerIterator(sourceValues, shrink2, verbose, interruptedAsFailure);
  for (const v of runner) {
    if (isModernProperty) {
      await property2.runBeforeEach();
    }
    const out = await property2.run(v, isModernProperty);
    if (isModernProperty) {
      await property2.runAfterEach();
    }
    runner.handleResult(out);
  }
  return runner.runExecution;
}
function check(rawProperty, params) {
  if (rawProperty == null || rawProperty.generate == null)
    throw new Error("Invalid property encountered, please use a valid property");
  if (rawProperty.run == null)
    throw new Error("Invalid property encountered, please use a valid property not an arbitrary");
  const qParams = QualifiedParameters.read(safeObjectAssign3(safeObjectAssign3({}, readConfigureGlobal()), params));
  if (qParams.reporter !== null && qParams.asyncReporter !== null)
    throw new Error("Invalid parameters encountered, reporter and asyncReporter cannot be specified together");
  if (qParams.asyncReporter !== null && !rawProperty.isAsync())
    throw new Error("Invalid parameters encountered, only asyncProperty can be used when asyncReporter specified");
  const property2 = decorateProperty(rawProperty, qParams);
  const maxInitialIterations = qParams.path.length === 0 || qParams.path.indexOf(":") === -1 ? qParams.numRuns : -1;
  const maxSkips = qParams.numRuns * qParams.maxSkipsPerRun;
  const shrink2 = (...args2) => property2.shrink(...args2);
  const initialValues = qParams.path.length === 0 ? toss(property2, qParams.seed, qParams.randomType, qParams.examples) : pathWalk(qParams.path, stream(lazyToss(property2, qParams.seed, qParams.randomType, qParams.examples)), shrink2);
  const sourceValues = new SourceValuesIterator(initialValues, maxInitialIterations, maxSkips);
  const finalShrink = !qParams.endOnFailure ? shrink2 : Stream.nil;
  return property2.isAsync() ? asyncRunIt(property2, finalShrink, sourceValues, qParams.verbose, qParams.markInterruptAsFailure).then((e) => e.toRunDetails(qParams.seed, qParams.path, maxSkips, qParams)) : runIt(property2, finalShrink, sourceValues, qParams.verbose, qParams.markInterruptAsFailure).toRunDetails(qParams.seed, qParams.path, maxSkips, qParams);
}
function assert(property2, params) {
  const out = check(property2, params);
  if (property2.isAsync())
    return out.then(asyncReportRunDetails);
  else
    reportRunDetails(out);
}

// ../../node_modules/fast-check/lib/esm/check/runner/Sampler.js
function toProperty(generator, qParams) {
  const prop = !Object.prototype.hasOwnProperty.call(generator, "isAsync") ? new Property(generator, () => true) : generator;
  return qParams.unbiased === true ? new UnbiasedProperty(prop) : prop;
}
function streamSample(generator, params) {
  const extendedParams = typeof params === "number" ? Object.assign(Object.assign({}, readConfigureGlobal()), { numRuns: params }) : Object.assign(Object.assign({}, readConfigureGlobal()), params);
  const qParams = QualifiedParameters.read(extendedParams);
  const nextProperty = toProperty(generator, qParams);
  const shrink2 = nextProperty.shrink.bind(nextProperty);
  const tossedValues = qParams.path.length === 0 ? stream(toss(nextProperty, qParams.seed, qParams.randomType, qParams.examples)) : pathWalk(qParams.path, stream(lazyToss(nextProperty, qParams.seed, qParams.randomType, qParams.examples)), shrink2);
  return tossedValues.take(qParams.numRuns).map((s) => s.value_);
}
function sample(generator, params) {
  return [...streamSample(generator, params)];
}
function round2(n) {
  return (Math.round(n * 100) / 100).toFixed(2);
}
function statistics(generator, classify, params) {
  const extendedParams = typeof params === "number" ? Object.assign(Object.assign({}, readConfigureGlobal()), { numRuns: params }) : Object.assign(Object.assign({}, readConfigureGlobal()), params);
  const qParams = QualifiedParameters.read(extendedParams);
  const recorded = {};
  for (const g of streamSample(generator, params)) {
    const out = classify(g);
    const categories = Array.isArray(out) ? out : [out];
    for (const c of categories) {
      recorded[c] = (recorded[c] || 0) + 1;
    }
  }
  const data = Object.entries(recorded).sort((a, b) => b[1] - a[1]).map((i) => [i[0], `${round2(i[1] * 100 / qParams.numRuns)}%`]);
  const longestName = data.map((i) => i[0].length).reduce((p, c) => Math.max(p, c), 0);
  const longestPercent = data.map((i) => i[1].length).reduce((p, c) => Math.max(p, c), 0);
  for (const item of data) {
    qParams.logger(`${item[0].padEnd(longestName, ".")}..${item[1].padStart(longestPercent, ".")}`);
  }
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/builders/GeneratorValueBuilder.js
var safeObjectAssign4 = Object.assign;
function buildGeneratorValue(mrng, biasFactor, computePreBuiltValues, arbitraryCache) {
  const preBuiltValues = computePreBuiltValues();
  let localMrng = mrng.clone();
  const context15 = { mrng: mrng.clone(), biasFactor, history: [] };
  const valueFunction = (arb) => {
    const preBuiltValue = preBuiltValues[context15.history.length];
    if (preBuiltValue !== void 0 && preBuiltValue.arb === arb) {
      const value11 = preBuiltValue.value;
      safePush(context15.history, { arb, value: value11, context: preBuiltValue.context, mrng: preBuiltValue.mrng });
      localMrng = preBuiltValue.mrng.clone();
      return value11;
    }
    const g = arb.generate(localMrng, biasFactor);
    safePush(context15.history, { arb, value: g.value_, context: g.context, mrng: localMrng.clone() });
    return g.value;
  };
  const memoedValueFunction = (arb, ...args2) => {
    return valueFunction(arbitraryCache(arb, args2));
  };
  const valueMethods = {
    values() {
      return safeMap(context15.history, (c) => c.value);
    },
    [cloneMethod]() {
      return buildGeneratorValue(mrng, biasFactor, computePreBuiltValues, arbitraryCache).value;
    },
    [toStringMethod]() {
      return stringify(safeMap(context15.history, (c) => c.value));
    }
  };
  const value10 = safeObjectAssign4(memoedValueFunction, valueMethods);
  return new Value(value10, context15);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/builders/StableArbitraryGeneratorCache.js
var safeArrayIsArray2 = Array.isArray;
var safeObjectKeys2 = Object.keys;
var safeObjectIs = Object.is;
function buildStableArbitraryGeneratorCache(isEqual2) {
  const previousCallsPerBuilder = new SMap();
  return function stableArbitraryGeneratorCache(builder, args2) {
    const entriesForBuilder = safeMapGet(previousCallsPerBuilder, builder);
    if (entriesForBuilder === void 0) {
      const newValue2 = builder(...args2);
      safeMapSet(previousCallsPerBuilder, builder, [{ args: args2, value: newValue2 }]);
      return newValue2;
    }
    const safeEntriesForBuilder = entriesForBuilder;
    for (const entry of safeEntriesForBuilder) {
      if (isEqual2(args2, entry.args)) {
        return entry.value;
      }
    }
    const newValue = builder(...args2);
    safePush(safeEntriesForBuilder, { args: args2, value: newValue });
    return newValue;
  };
}
function naiveIsEqual(v1, v2) {
  if (v1 !== null && typeof v1 === "object" && v2 !== null && typeof v2 === "object") {
    if (safeArrayIsArray2(v1)) {
      if (!safeArrayIsArray2(v2))
        return false;
      if (v1.length !== v2.length)
        return false;
    } else if (safeArrayIsArray2(v2)) {
      return false;
    }
    if (safeObjectKeys2(v1).length !== safeObjectKeys2(v2).length) {
      return false;
    }
    for (const index in v1) {
      if (!(index in v2)) {
        return false;
      }
      if (!naiveIsEqual(v1[index], v2[index])) {
        return false;
      }
    }
    return true;
  } else {
    return safeObjectIs(v1, v2);
  }
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/GeneratorArbitrary.js
var GeneratorArbitrary = class extends Arbitrary {
  constructor() {
    super(...arguments);
    this.arbitraryCache = buildStableArbitraryGeneratorCache(naiveIsEqual);
  }
  generate(mrng, biasFactor) {
    return buildGeneratorValue(mrng, biasFactor, () => [], this.arbitraryCache);
  }
  canShrinkWithoutContext(value10) {
    return false;
  }
  shrink(_value, context15) {
    if (context15 === void 0) {
      return Stream.nil();
    }
    const safeContext = context15;
    const mrng = safeContext.mrng;
    const biasFactor = safeContext.biasFactor;
    const history = safeContext.history;
    return tupleShrink(history.map((c) => c.arb), history.map((c) => c.value), history.map((c) => c.context)).map((shrink2) => {
      function computePreBuiltValues() {
        const subValues = shrink2.value;
        const subContexts = shrink2.context;
        return safeMap(history, (entry, index) => ({
          arb: entry.arb,
          value: subValues[index],
          context: subContexts[index],
          mrng: entry.mrng
        }));
      }
      return buildGeneratorValue(mrng, biasFactor, computePreBuiltValues, this.arbitraryCache);
    });
  }
};

// ../../node_modules/fast-check/lib/esm/arbitrary/gen.js
function gen3() {
  return new GeneratorArbitrary();
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/BiasNumericRange.js
var safeMathFloor = Math.floor;
var safeMathLog2 = Math.log;
function integerLogLike(v) {
  return safeMathFloor(safeMathLog2(v) / safeMathLog2(2));
}
function bigIntLogLike(v) {
  if (v === SBigInt(0))
    return SBigInt(0);
  return SBigInt(SString(v).length);
}
function biasNumericRange(min11, max13, logLike) {
  if (min11 === max13) {
    return [{ min: min11, max: max13 }];
  }
  if (min11 < 0 && max13 > 0) {
    const logMin = logLike(-min11);
    const logMax = logLike(max13);
    return [
      { min: -logMin, max: logMax },
      { min: max13 - logMax, max: max13 },
      { min: min11, max: min11 + logMin }
    ];
  }
  const logGap = logLike(max13 - min11);
  const arbCloseToMin = { min: min11, max: min11 + logGap };
  const arbCloseToMax = { min: max13 - logGap, max: max13 };
  return min11 < 0 ? [arbCloseToMax, arbCloseToMin] : [arbCloseToMin, arbCloseToMax];
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ShrinkInteger.js
var safeMathCeil = Math.ceil;
var safeMathFloor2 = Math.floor;
function halvePosInteger(n) {
  return safeMathFloor2(n / 2);
}
function halveNegInteger(n) {
  return safeMathCeil(n / 2);
}
function shrinkInteger(current2, target, tryTargetAsap) {
  const realGap = current2 - target;
  function* shrinkDecr() {
    let previous2 = tryTargetAsap ? void 0 : target;
    const gap = tryTargetAsap ? realGap : halvePosInteger(realGap);
    for (let toremove = gap; toremove > 0; toremove = halvePosInteger(toremove)) {
      const next6 = toremove === realGap ? target : current2 - toremove;
      yield new Value(next6, previous2);
      previous2 = next6;
    }
  }
  function* shrinkIncr() {
    let previous2 = tryTargetAsap ? void 0 : target;
    const gap = tryTargetAsap ? realGap : halveNegInteger(realGap);
    for (let toremove = gap; toremove < 0; toremove = halveNegInteger(toremove)) {
      const next6 = toremove === realGap ? target : current2 - toremove;
      yield new Value(next6, previous2);
      previous2 = next6;
    }
  }
  return realGap > 0 ? stream(shrinkDecr()) : stream(shrinkIncr());
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/IntegerArbitrary.js
var safeMathSign = Math.sign;
var safeNumberIsInteger = Number.isInteger;
var safeObjectIs2 = Object.is;
var IntegerArbitrary = class _IntegerArbitrary extends Arbitrary {
  constructor(min11, max13) {
    super();
    this.min = min11;
    this.max = max13;
  }
  generate(mrng, biasFactor) {
    const range6 = this.computeGenerateRange(mrng, biasFactor);
    return new Value(mrng.nextInt(range6.min, range6.max), void 0);
  }
  canShrinkWithoutContext(value10) {
    return typeof value10 === "number" && safeNumberIsInteger(value10) && !safeObjectIs2(value10, -0) && this.min <= value10 && value10 <= this.max;
  }
  shrink(current2, context15) {
    if (!_IntegerArbitrary.isValidContext(current2, context15)) {
      const target = this.defaultTarget();
      return shrinkInteger(current2, target, true);
    }
    if (this.isLastChanceTry(current2, context15)) {
      return Stream.of(new Value(context15, void 0));
    }
    return shrinkInteger(current2, context15, false);
  }
  defaultTarget() {
    if (this.min <= 0 && this.max >= 0) {
      return 0;
    }
    return this.min < 0 ? this.max : this.min;
  }
  computeGenerateRange(mrng, biasFactor) {
    if (biasFactor === void 0 || mrng.nextInt(1, biasFactor) !== 1) {
      return { min: this.min, max: this.max };
    }
    const ranges = biasNumericRange(this.min, this.max, integerLogLike);
    if (ranges.length === 1) {
      return ranges[0];
    }
    const id3 = mrng.nextInt(-2 * (ranges.length - 1), ranges.length - 2);
    return id3 < 0 ? ranges[0] : ranges[id3 + 1];
  }
  isLastChanceTry(current2, context15) {
    if (current2 > 0)
      return current2 === context15 + 1 && current2 > this.min;
    if (current2 < 0)
      return current2 === context15 - 1 && current2 < this.max;
    return false;
  }
  static isValidContext(current2, context15) {
    if (context15 === void 0) {
      return false;
    }
    if (typeof context15 !== "number") {
      throw new Error(`Invalid context type passed to IntegerArbitrary (#1)`);
    }
    if (context15 !== 0 && safeMathSign(current2) !== safeMathSign(context15)) {
      throw new Error(`Invalid context value passed to IntegerArbitrary (#2)`);
    }
    return true;
  }
};

// ../../node_modules/fast-check/lib/esm/arbitrary/integer.js
var safeNumberIsInteger2 = Number.isInteger;
function buildCompleteIntegerConstraints(constraints) {
  const min11 = constraints.min !== void 0 ? constraints.min : -2147483648;
  const max13 = constraints.max !== void 0 ? constraints.max : 2147483647;
  return { min: min11, max: max13 };
}
function integer(constraints = {}) {
  const fullConstraints = buildCompleteIntegerConstraints(constraints);
  if (fullConstraints.min > fullConstraints.max) {
    throw new Error("fc.integer maximum value should be equal or greater than the minimum one");
  }
  if (!safeNumberIsInteger2(fullConstraints.min)) {
    throw new Error("fc.integer minimum value should be an integer");
  }
  if (!safeNumberIsInteger2(fullConstraints.max)) {
    throw new Error("fc.integer maximum value should be an integer");
  }
  return new IntegerArbitrary(fullConstraints.min, fullConstraints.max);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/DepthContext.js
var depthContextCache = /* @__PURE__ */ new Map();
function getDepthContextFor(contextMeta) {
  if (contextMeta === void 0) {
    return { depth: 0 };
  }
  if (typeof contextMeta !== "string") {
    return contextMeta;
  }
  const cachedContext = safeMapGet(depthContextCache, contextMeta);
  if (cachedContext !== void 0) {
    return cachedContext;
  }
  const context15 = { depth: 0 };
  safeMapSet(depthContextCache, contextMeta, context15);
  return context15;
}
function createDepthIdentifier() {
  const identifier2 = { depth: 0 };
  return identifier2;
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/implementations/NoopSlicedGenerator.js
var NoopSlicedGenerator = class {
  constructor(arb, mrng, biasFactor) {
    this.arb = arb;
    this.mrng = mrng;
    this.biasFactor = biasFactor;
  }
  attemptExact() {
    return;
  }
  next() {
    return this.arb.generate(this.mrng, this.biasFactor);
  }
};

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/implementations/SlicedBasedGenerator.js
var safeMathMin2 = Math.min;
var safeMathMax = Math.max;
var SlicedBasedGenerator = class {
  constructor(arb, mrng, slices, biasFactor) {
    this.arb = arb;
    this.mrng = mrng;
    this.slices = slices;
    this.biasFactor = biasFactor;
    this.activeSliceIndex = 0;
    this.nextIndexInSlice = 0;
    this.lastIndexInSlice = -1;
  }
  attemptExact(targetLength) {
    if (targetLength !== 0 && this.mrng.nextInt(1, this.biasFactor) === 1) {
      const eligibleIndices = [];
      for (let index = 0; index !== this.slices.length; ++index) {
        const slice2 = this.slices[index];
        if (slice2.length === targetLength) {
          safePush(eligibleIndices, index);
        }
      }
      if (eligibleIndices.length === 0) {
        return;
      }
      this.activeSliceIndex = eligibleIndices[this.mrng.nextInt(0, eligibleIndices.length - 1)];
      this.nextIndexInSlice = 0;
      this.lastIndexInSlice = targetLength - 1;
    }
  }
  next() {
    if (this.nextIndexInSlice <= this.lastIndexInSlice) {
      return new Value(this.slices[this.activeSliceIndex][this.nextIndexInSlice++], void 0);
    }
    if (this.mrng.nextInt(1, this.biasFactor) !== 1) {
      return this.arb.generate(this.mrng, this.biasFactor);
    }
    this.activeSliceIndex = this.mrng.nextInt(0, this.slices.length - 1);
    const slice2 = this.slices[this.activeSliceIndex];
    if (this.mrng.nextInt(1, this.biasFactor) !== 1) {
      this.nextIndexInSlice = 1;
      this.lastIndexInSlice = slice2.length - 1;
      return new Value(slice2[0], void 0);
    }
    const rangeBoundaryA = this.mrng.nextInt(0, slice2.length - 1);
    const rangeBoundaryB = this.mrng.nextInt(0, slice2.length - 1);
    this.nextIndexInSlice = safeMathMin2(rangeBoundaryA, rangeBoundaryB);
    this.lastIndexInSlice = safeMathMax(rangeBoundaryA, rangeBoundaryB);
    return new Value(slice2[this.nextIndexInSlice++], void 0);
  }
};

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/BuildSlicedGenerator.js
function buildSlicedGenerator(arb, mrng, slices, biasFactor) {
  if (biasFactor === void 0 || slices.length === 0 || mrng.nextInt(1, biasFactor) !== 1) {
    return new NoopSlicedGenerator(arb, mrng, biasFactor);
  }
  return new SlicedBasedGenerator(arb, mrng, slices, biasFactor);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/ArrayArbitrary.js
var safeMathFloor3 = Math.floor;
var safeMathLog3 = Math.log;
var safeMathMax2 = Math.max;
var safeArrayIsArray3 = Array.isArray;
function biasedMaxLength(minLength2, maxLength2) {
  if (minLength2 === maxLength2) {
    return minLength2;
  }
  return minLength2 + safeMathFloor3(safeMathLog3(maxLength2 - minLength2) / safeMathLog3(2));
}
var ArrayArbitrary = class _ArrayArbitrary extends Arbitrary {
  constructor(arb, minLength2, maxGeneratedLength, maxLength2, depthIdentifier, setBuilder, customSlices) {
    super();
    this.arb = arb;
    this.minLength = minLength2;
    this.maxGeneratedLength = maxGeneratedLength;
    this.maxLength = maxLength2;
    this.setBuilder = setBuilder;
    this.customSlices = customSlices;
    this.lengthArb = integer({ min: minLength2, max: maxGeneratedLength });
    this.depthContext = getDepthContextFor(depthIdentifier);
  }
  preFilter(tab) {
    if (this.setBuilder === void 0) {
      return tab;
    }
    const s = this.setBuilder();
    for (let index = 0; index !== tab.length; ++index) {
      s.tryAdd(tab[index]);
    }
    return s.getData();
  }
  static makeItCloneable(vs, shrinkables) {
    vs[cloneMethod] = () => {
      const cloned = [];
      for (let idx = 0; idx !== shrinkables.length; ++idx) {
        safePush(cloned, shrinkables[idx].value);
      }
      this.makeItCloneable(cloned, shrinkables);
      return cloned;
    };
    return vs;
  }
  generateNItemsNoDuplicates(setBuilder, N, mrng, biasFactorItems) {
    let numSkippedInRow = 0;
    const s = setBuilder();
    const slicedGenerator = buildSlicedGenerator(this.arb, mrng, this.customSlices, biasFactorItems);
    while (s.size() < N && numSkippedInRow < this.maxGeneratedLength) {
      const current2 = slicedGenerator.next();
      if (s.tryAdd(current2)) {
        numSkippedInRow = 0;
      } else {
        numSkippedInRow += 1;
      }
    }
    return s.getData();
  }
  safeGenerateNItemsNoDuplicates(setBuilder, N, mrng, biasFactorItems) {
    const depthImpact = safeMathMax2(0, N - biasedMaxLength(this.minLength, this.maxGeneratedLength));
    this.depthContext.depth += depthImpact;
    try {
      return this.generateNItemsNoDuplicates(setBuilder, N, mrng, biasFactorItems);
    } finally {
      this.depthContext.depth -= depthImpact;
    }
  }
  generateNItems(N, mrng, biasFactorItems) {
    const items = [];
    const slicedGenerator = buildSlicedGenerator(this.arb, mrng, this.customSlices, biasFactorItems);
    slicedGenerator.attemptExact(N);
    for (let index = 0; index !== N; ++index) {
      const current2 = slicedGenerator.next();
      safePush(items, current2);
    }
    return items;
  }
  safeGenerateNItems(N, mrng, biasFactorItems) {
    const depthImpact = safeMathMax2(0, N - biasedMaxLength(this.minLength, this.maxGeneratedLength));
    this.depthContext.depth += depthImpact;
    try {
      return this.generateNItems(N, mrng, biasFactorItems);
    } finally {
      this.depthContext.depth -= depthImpact;
    }
  }
  wrapper(itemsRaw, shrunkOnce, itemsRawLengthContext, startIndex) {
    const items = shrunkOnce ? this.preFilter(itemsRaw) : itemsRaw;
    let cloneable = false;
    const vs = [];
    const itemsContexts = [];
    for (let idx = 0; idx !== items.length; ++idx) {
      const s = items[idx];
      cloneable = cloneable || s.hasToBeCloned;
      safePush(vs, s.value);
      safePush(itemsContexts, s.context);
    }
    if (cloneable) {
      _ArrayArbitrary.makeItCloneable(vs, items);
    }
    const context15 = {
      shrunkOnce,
      lengthContext: itemsRaw.length === items.length && itemsRawLengthContext !== void 0 ? itemsRawLengthContext : void 0,
      itemsContexts,
      startIndex
    };
    return new Value(vs, context15);
  }
  generate(mrng, biasFactor) {
    const biasMeta = this.applyBias(mrng, biasFactor);
    const targetSize = biasMeta.size;
    const items = this.setBuilder !== void 0 ? this.safeGenerateNItemsNoDuplicates(this.setBuilder, targetSize, mrng, biasMeta.biasFactorItems) : this.safeGenerateNItems(targetSize, mrng, biasMeta.biasFactorItems);
    return this.wrapper(items, false, void 0, 0);
  }
  applyBias(mrng, biasFactor) {
    if (biasFactor === void 0) {
      return { size: this.lengthArb.generate(mrng, void 0).value };
    }
    if (this.minLength === this.maxGeneratedLength) {
      return { size: this.lengthArb.generate(mrng, void 0).value, biasFactorItems: biasFactor };
    }
    if (mrng.nextInt(1, biasFactor) !== 1) {
      return { size: this.lengthArb.generate(mrng, void 0).value };
    }
    if (mrng.nextInt(1, biasFactor) !== 1 || this.minLength === this.maxGeneratedLength) {
      return { size: this.lengthArb.generate(mrng, void 0).value, biasFactorItems: biasFactor };
    }
    const maxBiasedLength = biasedMaxLength(this.minLength, this.maxGeneratedLength);
    const targetSizeValue = integer({ min: this.minLength, max: maxBiasedLength }).generate(mrng, void 0);
    return { size: targetSizeValue.value, biasFactorItems: biasFactor };
  }
  canShrinkWithoutContext(value10) {
    if (!safeArrayIsArray3(value10) || this.minLength > value10.length || value10.length > this.maxLength) {
      return false;
    }
    for (let index = 0; index !== value10.length; ++index) {
      if (!(index in value10)) {
        return false;
      }
      if (!this.arb.canShrinkWithoutContext(value10[index])) {
        return false;
      }
    }
    const filtered = this.preFilter(safeMap(value10, (item) => new Value(item, void 0)));
    return filtered.length === value10.length;
  }
  shrinkItemByItem(value10, safeContext, endIndex) {
    const shrinks2 = [];
    for (let index = safeContext.startIndex; index < endIndex; ++index) {
      safePush(shrinks2, makeLazy(() => this.arb.shrink(value10[index], safeContext.itemsContexts[index]).map((v) => {
        const beforeCurrent = safeMap(safeSlice(value10, 0, index), (v2, i) => new Value(cloneIfNeeded(v2), safeContext.itemsContexts[i]));
        const afterCurrent = safeMap(safeSlice(value10, index + 1), (v2, i) => new Value(cloneIfNeeded(v2), safeContext.itemsContexts[i + index + 1]));
        return [
          [...beforeCurrent, v, ...afterCurrent],
          void 0,
          index
        ];
      })));
    }
    return Stream.nil().join(...shrinks2);
  }
  shrinkImpl(value10, context15) {
    if (value10.length === 0) {
      return Stream.nil();
    }
    const safeContext = context15 !== void 0 ? context15 : { shrunkOnce: false, lengthContext: void 0, itemsContexts: [], startIndex: 0 };
    return this.lengthArb.shrink(value10.length, safeContext.lengthContext).drop(safeContext.shrunkOnce && safeContext.lengthContext === void 0 && value10.length > this.minLength + 1 ? 1 : 0).map((lengthValue) => {
      const sliceStart = value10.length - lengthValue.value;
      return [
        safeMap(safeSlice(value10, sliceStart), (v, index) => new Value(cloneIfNeeded(v), safeContext.itemsContexts[index + sliceStart])),
        lengthValue.context,
        0
      ];
    }).join(makeLazy(() => value10.length > this.minLength ? this.shrinkItemByItem(value10, safeContext, 1) : this.shrinkItemByItem(value10, safeContext, value10.length))).join(value10.length > this.minLength ? makeLazy(() => {
      const subContext = {
        shrunkOnce: false,
        lengthContext: void 0,
        itemsContexts: safeSlice(safeContext.itemsContexts, 1),
        startIndex: 0
      };
      return this.shrinkImpl(safeSlice(value10, 1), subContext).filter((v) => this.minLength <= v[0].length + 1).map((v) => {
        return [[new Value(cloneIfNeeded(value10[0]), safeContext.itemsContexts[0]), ...v[0]], void 0, 0];
      });
    }) : Stream.nil());
  }
  shrink(value10, context15) {
    return this.shrinkImpl(value10, context15).map((contextualValue) => this.wrapper(contextualValue[0], true, contextualValue[1], contextualValue[2]));
  }
};

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/MaxLengthFromMinLength.js
var safeMathFloor4 = Math.floor;
var safeMathMin3 = Math.min;
var MaxLengthUpperBound = 2147483647;
var orderedSize = ["xsmall", "small", "medium", "large", "xlarge"];
var orderedRelativeSize = ["-4", "-3", "-2", "-1", "=", "+1", "+2", "+3", "+4"];
var DefaultSize = "small";
function maxLengthFromMinLength(minLength2, size40) {
  switch (size40) {
    case "xsmall":
      return safeMathFloor4(1.1 * minLength2) + 1;
    case "small":
      return 2 * minLength2 + 10;
    case "medium":
      return 11 * minLength2 + 100;
    case "large":
      return 101 * minLength2 + 1e3;
    case "xlarge":
      return 1001 * minLength2 + 1e4;
    default:
      throw new Error(`Unable to compute lengths based on received size: ${size40}`);
  }
}
function relativeSizeToSize(size40, defaultSize) {
  const sizeInRelative = safeIndexOf(orderedRelativeSize, size40);
  if (sizeInRelative === -1) {
    return size40;
  }
  const defaultSizeInSize = safeIndexOf(orderedSize, defaultSize);
  if (defaultSizeInSize === -1) {
    throw new Error(`Unable to offset size based on the unknown defaulted one: ${defaultSize}`);
  }
  const resultingSizeInSize = defaultSizeInSize + sizeInRelative - 4;
  return resultingSizeInSize < 0 ? orderedSize[0] : resultingSizeInSize >= orderedSize.length ? orderedSize[orderedSize.length - 1] : orderedSize[resultingSizeInSize];
}
function maxGeneratedLengthFromSizeForArbitrary(size40, minLength2, maxLength2, specifiedMaxLength) {
  const { baseSize: defaultSize = DefaultSize, defaultSizeToMaxWhenMaxSpecified } = readConfigureGlobal() || {};
  const definedSize = size40 !== void 0 ? size40 : specifiedMaxLength && defaultSizeToMaxWhenMaxSpecified ? "max" : defaultSize;
  if (definedSize === "max") {
    return maxLength2;
  }
  const finalSize = relativeSizeToSize(definedSize, defaultSize);
  return safeMathMin3(maxLengthFromMinLength(minLength2, finalSize), maxLength2);
}
function depthBiasFromSizeForArbitrary(depthSizeOrSize, specifiedMaxDepth) {
  if (typeof depthSizeOrSize === "number") {
    return 1 / depthSizeOrSize;
  }
  const { baseSize: defaultSize = DefaultSize, defaultSizeToMaxWhenMaxSpecified } = readConfigureGlobal() || {};
  const definedSize = depthSizeOrSize !== void 0 ? depthSizeOrSize : specifiedMaxDepth && defaultSizeToMaxWhenMaxSpecified ? "max" : defaultSize;
  if (definedSize === "max") {
    return 0;
  }
  const finalSize = relativeSizeToSize(definedSize, defaultSize);
  switch (finalSize) {
    case "xsmall":
      return 1;
    case "small":
      return 0.5;
    case "medium":
      return 0.25;
    case "large":
      return 0.125;
    case "xlarge":
      return 0.0625;
  }
}
function resolveSize(size40) {
  const { baseSize: defaultSize = DefaultSize } = readConfigureGlobal() || {};
  if (size40 === void 0) {
    return defaultSize;
  }
  return relativeSizeToSize(size40, defaultSize);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/array.js
function array4(arb, constraints = {}) {
  const size40 = constraints.size;
  const minLength2 = constraints.minLength || 0;
  const maxLengthOrUnset = constraints.maxLength;
  const depthIdentifier = constraints.depthIdentifier;
  const maxLength2 = maxLengthOrUnset !== void 0 ? maxLengthOrUnset : MaxLengthUpperBound;
  const specifiedMaxLength = maxLengthOrUnset !== void 0;
  const maxGeneratedLength = maxGeneratedLengthFromSizeForArbitrary(size40, minLength2, maxLength2, specifiedMaxLength);
  const customSlices = constraints.experimentalCustomSlices || [];
  return new ArrayArbitrary(arb, minLength2, maxGeneratedLength, maxLength2, depthIdentifier, void 0, customSlices);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ShrinkBigInt.js
function halveBigInt(n) {
  return n / SBigInt(2);
}
function shrinkBigInt(current2, target, tryTargetAsap) {
  const realGap = current2 - target;
  function* shrinkDecr() {
    let previous2 = tryTargetAsap ? void 0 : target;
    const gap = tryTargetAsap ? realGap : halveBigInt(realGap);
    for (let toremove = gap; toremove > 0; toremove = halveBigInt(toremove)) {
      const next6 = current2 - toremove;
      yield new Value(next6, previous2);
      previous2 = next6;
    }
  }
  function* shrinkIncr() {
    let previous2 = tryTargetAsap ? void 0 : target;
    const gap = tryTargetAsap ? realGap : halveBigInt(realGap);
    for (let toremove = gap; toremove < 0; toremove = halveBigInt(toremove)) {
      const next6 = current2 - toremove;
      yield new Value(next6, previous2);
      previous2 = next6;
    }
  }
  return realGap > 0 ? stream(shrinkDecr()) : stream(shrinkIncr());
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/BigIntArbitrary.js
var BigIntArbitrary = class _BigIntArbitrary extends Arbitrary {
  constructor(min11, max13) {
    super();
    this.min = min11;
    this.max = max13;
  }
  generate(mrng, biasFactor) {
    const range6 = this.computeGenerateRange(mrng, biasFactor);
    return new Value(mrng.nextBigInt(range6.min, range6.max), void 0);
  }
  computeGenerateRange(mrng, biasFactor) {
    if (biasFactor === void 0 || mrng.nextInt(1, biasFactor) !== 1) {
      return { min: this.min, max: this.max };
    }
    const ranges = biasNumericRange(this.min, this.max, bigIntLogLike);
    if (ranges.length === 1) {
      return ranges[0];
    }
    const id3 = mrng.nextInt(-2 * (ranges.length - 1), ranges.length - 2);
    return id3 < 0 ? ranges[0] : ranges[id3 + 1];
  }
  canShrinkWithoutContext(value10) {
    return typeof value10 === "bigint" && this.min <= value10 && value10 <= this.max;
  }
  shrink(current2, context15) {
    if (!_BigIntArbitrary.isValidContext(current2, context15)) {
      const target = this.defaultTarget();
      return shrinkBigInt(current2, target, true);
    }
    if (this.isLastChanceTry(current2, context15)) {
      return Stream.of(new Value(context15, void 0));
    }
    return shrinkBigInt(current2, context15, false);
  }
  defaultTarget() {
    if (this.min <= 0 && this.max >= 0) {
      return SBigInt(0);
    }
    return this.min < 0 ? this.max : this.min;
  }
  isLastChanceTry(current2, context15) {
    if (current2 > 0)
      return current2 === context15 + SBigInt(1) && current2 > this.min;
    if (current2 < 0)
      return current2 === context15 - SBigInt(1) && current2 < this.max;
    return false;
  }
  static isValidContext(current2, context15) {
    if (context15 === void 0) {
      return false;
    }
    if (typeof context15 !== "bigint") {
      throw new Error(`Invalid context type passed to BigIntArbitrary (#1)`);
    }
    const differentSigns = current2 > 0 && context15 < 0 || current2 < 0 && context15 > 0;
    if (context15 !== SBigInt(0) && differentSigns) {
      throw new Error(`Invalid context value passed to BigIntArbitrary (#2)`);
    }
    return true;
  }
};

// ../../node_modules/fast-check/lib/esm/arbitrary/bigInt.js
function buildCompleteBigIntConstraints(constraints) {
  const DefaultPow = 256;
  const DefaultMin = SBigInt(-1) << SBigInt(DefaultPow - 1);
  const DefaultMax = (SBigInt(1) << SBigInt(DefaultPow - 1)) - SBigInt(1);
  const min11 = constraints.min;
  const max13 = constraints.max;
  return {
    min: min11 !== void 0 ? min11 : DefaultMin - (max13 !== void 0 && max13 < SBigInt(0) ? max13 * max13 : SBigInt(0)),
    max: max13 !== void 0 ? max13 : DefaultMax + (min11 !== void 0 && min11 > SBigInt(0) ? min11 * min11 : SBigInt(0))
  };
}
function extractBigIntConstraints(args2) {
  if (args2[0] === void 0) {
    return {};
  }
  if (args2[1] === void 0) {
    const constraints = args2[0];
    return constraints;
  }
  return { min: args2[0], max: args2[1] };
}
function bigInt(...args2) {
  const constraints = buildCompleteBigIntConstraints(extractBigIntConstraints(args2));
  if (constraints.min > constraints.max) {
    throw new Error("fc.bigInt expects max to be greater than or equal to min");
  }
  return new BigIntArbitrary(constraints.min, constraints.max);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/bigIntN.js
function bigIntN(n) {
  if (n < 1) {
    throw new Error("fc.bigIntN expects requested number of bits to be superior or equal to 1");
  }
  const min11 = SBigInt(-1) << SBigInt(n - 1);
  const max13 = (SBigInt(1) << SBigInt(n - 1)) - SBigInt(1);
  return new BigIntArbitrary(min11, max13);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/bigUint.js
function computeDefaultMax() {
  return (SBigInt(1) << SBigInt(256)) - SBigInt(1);
}
function bigUint(constraints) {
  const requestedMax = typeof constraints === "object" ? constraints.max : constraints;
  const max13 = requestedMax !== void 0 ? requestedMax : computeDefaultMax();
  if (max13 < 0) {
    throw new Error("fc.bigUint expects max to be greater than or equal to zero");
  }
  return new BigIntArbitrary(SBigInt(0), max13);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/bigUintN.js
function bigUintN(n) {
  if (n < 0) {
    throw new Error("fc.bigUintN expects requested number of bits to be superior or equal to 0");
  }
  const min11 = SBigInt(0);
  const max13 = (SBigInt(1) << SBigInt(n)) - SBigInt(1);
  return new BigIntArbitrary(min11, max13);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/noBias.js
function noBias(arb) {
  return arb.noBias();
}

// ../../node_modules/fast-check/lib/esm/arbitrary/boolean.js
function booleanMapper(v) {
  return v === 1;
}
function booleanUnmapper(v) {
  if (typeof v !== "boolean")
    throw new Error("Unsupported input type");
  return v === true ? 1 : 0;
}
function boolean3() {
  return noBias(integer({ min: 0, max: 1 }).map(booleanMapper, booleanUnmapper));
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/ConstantArbitrary.js
var safeObjectIs3 = Object.is;
var ConstantArbitrary = class extends Arbitrary {
  constructor(values15) {
    super();
    this.values = values15;
  }
  generate(mrng, _biasFactor) {
    const idx = this.values.length === 1 ? 0 : mrng.nextInt(0, this.values.length - 1);
    const value10 = this.values[idx];
    if (!hasCloneMethod(value10)) {
      return new Value(value10, idx);
    }
    return new Value(value10, idx, () => value10[cloneMethod]());
  }
  canShrinkWithoutContext(value10) {
    if (this.values.length === 1) {
      return safeObjectIs3(this.values[0], value10);
    }
    if (this.fastValues === void 0) {
      this.fastValues = new FastConstantValuesLookup(this.values);
    }
    return this.fastValues.has(value10);
  }
  shrink(value10, context15) {
    if (context15 === 0 || safeObjectIs3(value10, this.values[0])) {
      return Stream.nil();
    }
    return Stream.of(new Value(this.values[0], 0));
  }
};
var FastConstantValuesLookup = class {
  constructor(values15) {
    this.values = values15;
    this.fastValues = new SSet(this.values);
    let hasMinusZero = false;
    let hasPlusZero = false;
    if (safeHas(this.fastValues, 0)) {
      for (let idx = 0; idx !== this.values.length; ++idx) {
        const value10 = this.values[idx];
        hasMinusZero = hasMinusZero || safeObjectIs3(value10, -0);
        hasPlusZero = hasPlusZero || safeObjectIs3(value10, 0);
      }
    }
    this.hasMinusZero = hasMinusZero;
    this.hasPlusZero = hasPlusZero;
  }
  has(value10) {
    if (value10 === 0) {
      if (safeObjectIs3(value10, 0)) {
        return this.hasPlusZero;
      }
      return this.hasMinusZero;
    }
    return safeHas(this.fastValues, value10);
  }
};

// ../../node_modules/fast-check/lib/esm/arbitrary/constantFrom.js
function constantFrom(...values15) {
  if (values15.length === 0) {
    throw new Error("fc.constantFrom expects at least one parameter");
  }
  return new ConstantArbitrary(values15);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/falsy.js
function falsy(constraints) {
  if (!constraints || !constraints.withBigInt) {
    return constantFrom(false, null, void 0, 0, "", NaN);
  }
  return constantFrom(false, null, void 0, 0, "", NaN, SBigInt(0));
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/IndexToCharString.js
var indexToCharStringMapper = String.fromCodePoint;
function indexToCharStringUnmapper(c) {
  if (typeof c !== "string") {
    throw new Error("Cannot unmap non-string");
  }
  if (c.length === 0 || c.length > 2) {
    throw new Error("Cannot unmap string with more or less than one character");
  }
  const c1 = safeCharCodeAt(c, 0);
  if (c.length === 1) {
    return c1;
  }
  const c2 = safeCharCodeAt(c, 1);
  if (c1 < 55296 || c1 > 56319 || c2 < 56320 || c2 > 57343) {
    throw new Error("Cannot unmap invalid surrogate pairs");
  }
  return c.codePointAt(0);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/builders/CharacterArbitraryBuilder.js
function buildCharacterArbitrary(min11, max13, mapToCode, unmapFromCode) {
  return integer({ min: min11, max: max13 }).map((n) => indexToCharStringMapper(mapToCode(n)), (c) => unmapFromCode(indexToCharStringUnmapper(c)));
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/IndexToPrintableIndex.js
function indexToPrintableIndexMapper(v) {
  if (v < 95)
    return v + 32;
  if (v <= 126)
    return v - 95;
  return v;
}
function indexToPrintableIndexUnmapper(v) {
  if (v >= 32 && v <= 126)
    return v - 32;
  if (v >= 0 && v <= 31)
    return v + 95;
  return v;
}

// ../../node_modules/fast-check/lib/esm/arbitrary/ascii.js
function ascii() {
  return buildCharacterArbitrary(0, 127, indexToPrintableIndexMapper, indexToPrintableIndexUnmapper);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/base64.js
function base64Mapper(v) {
  if (v < 26)
    return v + 65;
  if (v < 52)
    return v + 97 - 26;
  if (v < 62)
    return v + 48 - 52;
  return v === 62 ? 43 : 47;
}
function base64Unmapper(v) {
  if (v >= 65 && v <= 90)
    return v - 65;
  if (v >= 97 && v <= 122)
    return v - 97 + 26;
  if (v >= 48 && v <= 57)
    return v - 48 + 52;
  return v === 43 ? 62 : v === 47 ? 63 : -1;
}
function base64() {
  return buildCharacterArbitrary(0, 63, base64Mapper, base64Unmapper);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/char.js
function identity2(v) {
  return v;
}
function char() {
  return buildCharacterArbitrary(32, 126, identity2, identity2);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/char16bits.js
function char16bits() {
  return buildCharacterArbitrary(0, 65535, indexToPrintableIndexMapper, indexToPrintableIndexUnmapper);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/fullUnicode.js
var gapSize = 57343 + 1 - 55296;
function unicodeMapper(v) {
  if (v < 55296)
    return indexToPrintableIndexMapper(v);
  return v + gapSize;
}
function unicodeUnmapper(v) {
  if (v < 55296)
    return indexToPrintableIndexUnmapper(v);
  if (v <= 57343)
    return -1;
  return v - gapSize;
}
function fullUnicode() {
  return buildCharacterArbitrary(0, 1114111 - gapSize, unicodeMapper, unicodeUnmapper);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/hexa.js
function hexaMapper(v) {
  return v < 10 ? v + 48 : v + 97 - 10;
}
function hexaUnmapper(v) {
  return v < 58 ? v - 48 : v >= 97 && v < 103 ? v - 97 + 10 : -1;
}
function hexa() {
  return buildCharacterArbitrary(0, 15, hexaMapper, hexaUnmapper);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/unicode.js
var gapSize2 = 57343 + 1 - 55296;
function unicodeMapper2(v) {
  if (v < 55296)
    return indexToPrintableIndexMapper(v);
  return v + gapSize2;
}
function unicodeUnmapper2(v) {
  if (v < 55296)
    return indexToPrintableIndexUnmapper(v);
  if (v <= 57343)
    return -1;
  return v - gapSize2;
}
function unicode() {
  return buildCharacterArbitrary(0, 65535 - gapSize2, unicodeMapper2, unicodeUnmapper2);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/constant.js
function constant2(value10) {
  return new ConstantArbitrary([value10]);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/context.js
var ContextImplem = class _ContextImplem {
  constructor() {
    this.receivedLogs = [];
  }
  log(data) {
    this.receivedLogs.push(data);
  }
  size() {
    return this.receivedLogs.length;
  }
  toString() {
    return JSON.stringify({ logs: this.receivedLogs });
  }
  [cloneMethod]() {
    return new _ContextImplem();
  }
};
function context() {
  return constant2(new ContextImplem());
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/TimeToDate.js
var safeNaN = Number.NaN;
var safeNumberIsNaN2 = Number.isNaN;
function timeToDateMapper(time3) {
  return new SDate(time3);
}
function timeToDateUnmapper(value10) {
  if (!(value10 instanceof SDate) || value10.constructor !== SDate) {
    throw new SError("Not a valid value for date unmapper");
  }
  return safeGetTime(value10);
}
function timeToDateMapperWithNaN(valueForNaN) {
  return (time3) => {
    return time3 === valueForNaN ? new SDate(safeNaN) : timeToDateMapper(time3);
  };
}
function timeToDateUnmapperWithNaN(valueForNaN) {
  return (value10) => {
    const time3 = timeToDateUnmapper(value10);
    return safeNumberIsNaN2(time3) ? valueForNaN : time3;
  };
}

// ../../node_modules/fast-check/lib/esm/arbitrary/date.js
var safeNumberIsNaN3 = Number.isNaN;
function date(constraints = {}) {
  const intMin = constraints.min !== void 0 ? safeGetTime(constraints.min) : -864e13;
  const intMax = constraints.max !== void 0 ? safeGetTime(constraints.max) : 864e13;
  const noInvalidDate = constraints.noInvalidDate === void 0 || constraints.noInvalidDate;
  if (safeNumberIsNaN3(intMin))
    throw new Error("fc.date min must be valid instance of Date");
  if (safeNumberIsNaN3(intMax))
    throw new Error("fc.date max must be valid instance of Date");
  if (intMin > intMax)
    throw new Error("fc.date max must be greater or equal to min");
  if (noInvalidDate) {
    return integer({ min: intMin, max: intMax }).map(timeToDateMapper, timeToDateUnmapper);
  }
  const valueForNaN = intMax + 1;
  return integer({ min: intMin, max: intMax + 1 }).map(timeToDateMapperWithNaN(valueForNaN), timeToDateUnmapperWithNaN(valueForNaN));
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/CloneArbitrary.js
var safeSymbolIterator2 = Symbol.iterator;
var safeIsArray = Array.isArray;
var safeObjectIs4 = Object.is;
var CloneArbitrary = class _CloneArbitrary extends Arbitrary {
  constructor(arb, numValues) {
    super();
    this.arb = arb;
    this.numValues = numValues;
  }
  generate(mrng, biasFactor) {
    const items = [];
    if (this.numValues <= 0) {
      return this.wrapper(items);
    }
    for (let idx = 0; idx !== this.numValues - 1; ++idx) {
      safePush(items, this.arb.generate(mrng.clone(), biasFactor));
    }
    safePush(items, this.arb.generate(mrng, biasFactor));
    return this.wrapper(items);
  }
  canShrinkWithoutContext(value10) {
    if (!safeIsArray(value10) || value10.length !== this.numValues) {
      return false;
    }
    if (value10.length === 0) {
      return true;
    }
    for (let index = 1; index < value10.length; ++index) {
      if (!safeObjectIs4(value10[0], value10[index])) {
        return false;
      }
    }
    return this.arb.canShrinkWithoutContext(value10[0]);
  }
  shrink(value10, context15) {
    if (value10.length === 0) {
      return Stream.nil();
    }
    return new Stream(this.shrinkImpl(value10, context15 !== void 0 ? context15 : [])).map((v) => this.wrapper(v));
  }
  *shrinkImpl(value10, contexts) {
    const its = safeMap(value10, (v, idx) => this.arb.shrink(v, contexts[idx])[safeSymbolIterator2]());
    let cur = safeMap(its, (it) => it.next());
    while (!cur[0].done) {
      yield safeMap(cur, (c) => c.value);
      cur = safeMap(its, (it) => it.next());
    }
  }
  static makeItCloneable(vs, shrinkables) {
    vs[cloneMethod] = () => {
      const cloned = [];
      for (let idx = 0; idx !== shrinkables.length; ++idx) {
        safePush(cloned, shrinkables[idx].value);
      }
      this.makeItCloneable(cloned, shrinkables);
      return cloned;
    };
    return vs;
  }
  wrapper(items) {
    let cloneable = false;
    const vs = [];
    const contexts = [];
    for (let idx = 0; idx !== items.length; ++idx) {
      const s = items[idx];
      cloneable = cloneable || s.hasToBeCloned;
      safePush(vs, s.value);
      safePush(contexts, s.context);
    }
    if (cloneable) {
      _CloneArbitrary.makeItCloneable(vs, items);
    }
    return new Value(vs, contexts);
  }
};

// ../../node_modules/fast-check/lib/esm/arbitrary/clone.js
function clone(arb, numValues) {
  return new CloneArbitrary(arb, numValues);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/CustomEqualSet.js
var CustomEqualSet = class {
  constructor(isEqual2) {
    this.isEqual = isEqual2;
    this.data = [];
  }
  tryAdd(value10) {
    for (let idx = 0; idx !== this.data.length; ++idx) {
      if (this.isEqual(this.data[idx], value10)) {
        return false;
      }
    }
    safePush(this.data, value10);
    return true;
  }
  size() {
    return this.data.length;
  }
  getData() {
    return this.data;
  }
};

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/StrictlyEqualSet.js
var safeNumberIsNaN4 = Number.isNaN;
var StrictlyEqualSet = class {
  constructor(selector) {
    this.selector = selector;
    this.selectedItemsExceptNaN = new SSet();
    this.data = [];
  }
  tryAdd(value10) {
    const selected = this.selector(value10);
    if (safeNumberIsNaN4(selected)) {
      safePush(this.data, value10);
      return true;
    }
    const sizeBefore = this.selectedItemsExceptNaN.size;
    safeAdd(this.selectedItemsExceptNaN, selected);
    if (sizeBefore !== this.selectedItemsExceptNaN.size) {
      safePush(this.data, value10);
      return true;
    }
    return false;
  }
  size() {
    return this.data.length;
  }
  getData() {
    return this.data;
  }
};

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/SameValueSet.js
var safeObjectIs5 = Object.is;
var SameValueSet = class {
  constructor(selector) {
    this.selector = selector;
    this.selectedItemsExceptMinusZero = new SSet();
    this.data = [];
    this.hasMinusZero = false;
  }
  tryAdd(value10) {
    const selected = this.selector(value10);
    if (safeObjectIs5(selected, -0)) {
      if (this.hasMinusZero) {
        return false;
      }
      safePush(this.data, value10);
      this.hasMinusZero = true;
      return true;
    }
    const sizeBefore = this.selectedItemsExceptMinusZero.size;
    safeAdd(this.selectedItemsExceptMinusZero, selected);
    if (sizeBefore !== this.selectedItemsExceptMinusZero.size) {
      safePush(this.data, value10);
      return true;
    }
    return false;
  }
  size() {
    return this.data.length;
  }
  getData() {
    return this.data;
  }
};

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/SameValueZeroSet.js
var SameValueZeroSet = class {
  constructor(selector) {
    this.selector = selector;
    this.selectedItems = new SSet();
    this.data = [];
  }
  tryAdd(value10) {
    const selected = this.selector(value10);
    const sizeBefore = this.selectedItems.size;
    safeAdd(this.selectedItems, selected);
    if (sizeBefore !== this.selectedItems.size) {
      safePush(this.data, value10);
      return true;
    }
    return false;
  }
  size() {
    return this.data.length;
  }
  getData() {
    return this.data;
  }
};

// ../../node_modules/fast-check/lib/esm/arbitrary/uniqueArray.js
function buildUniqueArraySetBuilder(constraints) {
  if (typeof constraints.comparator === "function") {
    if (constraints.selector === void 0) {
      const comparator2 = constraints.comparator;
      const isEqualForBuilder2 = (nextA, nextB) => comparator2(nextA.value_, nextB.value_);
      return () => new CustomEqualSet(isEqualForBuilder2);
    }
    const comparator = constraints.comparator;
    const selector2 = constraints.selector;
    const refinedSelector2 = (next6) => selector2(next6.value_);
    const isEqualForBuilder = (nextA, nextB) => comparator(refinedSelector2(nextA), refinedSelector2(nextB));
    return () => new CustomEqualSet(isEqualForBuilder);
  }
  const selector = constraints.selector || ((v) => v);
  const refinedSelector = (next6) => selector(next6.value_);
  switch (constraints.comparator) {
    case "IsStrictlyEqual":
      return () => new StrictlyEqualSet(refinedSelector);
    case "SameValueZero":
      return () => new SameValueZeroSet(refinedSelector);
    case "SameValue":
    case void 0:
      return () => new SameValueSet(refinedSelector);
  }
}
function uniqueArray(arb, constraints = {}) {
  const minLength2 = constraints.minLength !== void 0 ? constraints.minLength : 0;
  const maxLength2 = constraints.maxLength !== void 0 ? constraints.maxLength : MaxLengthUpperBound;
  const maxGeneratedLength = maxGeneratedLengthFromSizeForArbitrary(constraints.size, minLength2, maxLength2, constraints.maxLength !== void 0);
  const depthIdentifier = constraints.depthIdentifier;
  const setBuilder = buildUniqueArraySetBuilder(constraints);
  const arrayArb = new ArrayArbitrary(arb, minLength2, maxGeneratedLength, maxLength2, depthIdentifier, setBuilder, []);
  if (minLength2 === 0)
    return arrayArb;
  return arrayArb.filter((tab) => tab.length >= minLength2);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/KeyValuePairsToObject.js
var safeObjectCreate = Object.create;
var safeObjectDefineProperty3 = Object.defineProperty;
var safeObjectGetOwnPropertyDescriptor2 = Object.getOwnPropertyDescriptor;
var safeObjectGetPrototypeOf2 = Object.getPrototypeOf;
var safeObjectGetOwnPropertySymbols2 = Object.getOwnPropertySymbols;
var safeObjectGetOwnPropertyNames = Object.getOwnPropertyNames;
var safeObjectEntries = Object.entries;
function keyValuePairsToObjectMapper(definition) {
  const obj = definition[1] ? safeObjectCreate(null) : {};
  for (const keyValue of definition[0]) {
    safeObjectDefineProperty3(obj, keyValue[0], {
      enumerable: true,
      configurable: true,
      writable: true,
      value: keyValue[1]
    });
  }
  return obj;
}
function buildIsValidPropertyNameFilter(obj) {
  return function isValidPropertyNameFilter(key) {
    const descriptor3 = safeObjectGetOwnPropertyDescriptor2(obj, key);
    return descriptor3 !== void 0 && !!descriptor3.configurable && !!descriptor3.enumerable && !!descriptor3.writable && descriptor3.get === void 0 && descriptor3.set === void 0;
  };
}
function keyValuePairsToObjectUnmapper(value10) {
  if (typeof value10 !== "object" || value10 === null) {
    throw new SError("Incompatible instance received: should be a non-null object");
  }
  const hasNullPrototype = safeObjectGetPrototypeOf2(value10) === null;
  const hasObjectPrototype = "constructor" in value10 && value10.constructor === Object;
  if (!hasNullPrototype && !hasObjectPrototype) {
    throw new SError("Incompatible instance received: should be of exact type Object");
  }
  if (safeObjectGetOwnPropertySymbols2(value10).length > 0) {
    throw new SError("Incompatible instance received: should contain symbols");
  }
  if (!safeEvery(safeObjectGetOwnPropertyNames(value10), buildIsValidPropertyNameFilter(value10))) {
    throw new SError("Incompatible instance received: should contain only c/e/w properties without get/set");
  }
  return [safeObjectEntries(value10), hasNullPrototype];
}

// ../../node_modules/fast-check/lib/esm/arbitrary/dictionary.js
function dictionaryKeyExtractor(entry) {
  return entry[0];
}
function dictionary(keyArb, valueArb, constraints = {}) {
  const noNullPrototype = constraints.noNullPrototype !== false;
  return tuple4(uniqueArray(tuple4(keyArb, valueArb), {
    minLength: constraints.minKeys,
    maxLength: constraints.maxKeys,
    size: constraints.size,
    selector: dictionaryKeyExtractor,
    depthIdentifier: constraints.depthIdentifier
  }), noNullPrototype ? constant2(false) : boolean3()).map(keyValuePairsToObjectMapper, keyValuePairsToObjectUnmapper);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/FrequencyArbitrary.js
var safePositiveInfinity2 = Number.POSITIVE_INFINITY;
var safeMaxSafeInteger = Number.MAX_SAFE_INTEGER;
var safeNumberIsInteger3 = Number.isInteger;
var safeMathFloor5 = Math.floor;
var safeMathPow = Math.pow;
var safeMathMin4 = Math.min;
var FrequencyArbitrary = class _FrequencyArbitrary extends Arbitrary {
  static from(warbs, constraints, label) {
    if (warbs.length === 0) {
      throw new Error(`${label} expects at least one weighted arbitrary`);
    }
    let totalWeight = 0;
    for (let idx = 0; idx !== warbs.length; ++idx) {
      const currentArbitrary = warbs[idx].arbitrary;
      if (currentArbitrary === void 0) {
        throw new Error(`${label} expects arbitraries to be specified`);
      }
      const currentWeight = warbs[idx].weight;
      totalWeight += currentWeight;
      if (!safeNumberIsInteger3(currentWeight)) {
        throw new Error(`${label} expects weights to be integer values`);
      }
      if (currentWeight < 0) {
        throw new Error(`${label} expects weights to be superior or equal to 0`);
      }
    }
    if (totalWeight <= 0) {
      throw new Error(`${label} expects the sum of weights to be strictly superior to 0`);
    }
    const sanitizedConstraints = {
      depthBias: depthBiasFromSizeForArbitrary(constraints.depthSize, constraints.maxDepth !== void 0),
      maxDepth: constraints.maxDepth != void 0 ? constraints.maxDepth : safePositiveInfinity2,
      withCrossShrink: !!constraints.withCrossShrink
    };
    return new _FrequencyArbitrary(warbs, sanitizedConstraints, getDepthContextFor(constraints.depthIdentifier));
  }
  constructor(warbs, constraints, context15) {
    super();
    this.warbs = warbs;
    this.constraints = constraints;
    this.context = context15;
    let currentWeight = 0;
    this.cumulatedWeights = [];
    for (let idx = 0; idx !== warbs.length; ++idx) {
      currentWeight += warbs[idx].weight;
      safePush(this.cumulatedWeights, currentWeight);
    }
    this.totalWeight = currentWeight;
  }
  generate(mrng, biasFactor) {
    if (this.mustGenerateFirst()) {
      return this.safeGenerateForIndex(mrng, 0, biasFactor);
    }
    const selected = mrng.nextInt(this.computeNegDepthBenefit(), this.totalWeight - 1);
    for (let idx = 0; idx !== this.cumulatedWeights.length; ++idx) {
      if (selected < this.cumulatedWeights[idx]) {
        return this.safeGenerateForIndex(mrng, idx, biasFactor);
      }
    }
    throw new Error(`Unable to generate from fc.frequency`);
  }
  canShrinkWithoutContext(value10) {
    return this.canShrinkWithoutContextIndex(value10) !== -1;
  }
  shrink(value10, context15) {
    if (context15 !== void 0) {
      const safeContext = context15;
      const selectedIndex = safeContext.selectedIndex;
      const originalBias = safeContext.originalBias;
      const originalArbitrary = this.warbs[selectedIndex].arbitrary;
      const originalShrinks = originalArbitrary.shrink(value10, safeContext.originalContext).map((v) => this.mapIntoValue(selectedIndex, v, null, originalBias));
      if (safeContext.clonedMrngForFallbackFirst !== null) {
        if (safeContext.cachedGeneratedForFirst === void 0) {
          safeContext.cachedGeneratedForFirst = this.safeGenerateForIndex(safeContext.clonedMrngForFallbackFirst, 0, originalBias);
        }
        const valueFromFirst = safeContext.cachedGeneratedForFirst;
        return Stream.of(valueFromFirst).join(originalShrinks);
      }
      return originalShrinks;
    }
    const potentialSelectedIndex = this.canShrinkWithoutContextIndex(value10);
    if (potentialSelectedIndex === -1) {
      return Stream.nil();
    }
    return this.defaultShrinkForFirst(potentialSelectedIndex).join(this.warbs[potentialSelectedIndex].arbitrary.shrink(value10, void 0).map((v) => this.mapIntoValue(potentialSelectedIndex, v, null, void 0)));
  }
  defaultShrinkForFirst(selectedIndex) {
    ++this.context.depth;
    try {
      if (!this.mustFallbackToFirstInShrink(selectedIndex) || this.warbs[0].fallbackValue === void 0) {
        return Stream.nil();
      }
    } finally {
      --this.context.depth;
    }
    const rawShrinkValue = new Value(this.warbs[0].fallbackValue.default, void 0);
    return Stream.of(this.mapIntoValue(0, rawShrinkValue, null, void 0));
  }
  canShrinkWithoutContextIndex(value10) {
    if (this.mustGenerateFirst()) {
      return this.warbs[0].arbitrary.canShrinkWithoutContext(value10) ? 0 : -1;
    }
    try {
      ++this.context.depth;
      for (let idx = 0; idx !== this.warbs.length; ++idx) {
        const warb = this.warbs[idx];
        if (warb.weight !== 0 && warb.arbitrary.canShrinkWithoutContext(value10)) {
          return idx;
        }
      }
      return -1;
    } finally {
      --this.context.depth;
    }
  }
  mapIntoValue(idx, value10, clonedMrngForFallbackFirst, biasFactor) {
    const context15 = {
      selectedIndex: idx,
      originalBias: biasFactor,
      originalContext: value10.context,
      clonedMrngForFallbackFirst
    };
    return new Value(value10.value, context15);
  }
  safeGenerateForIndex(mrng, idx, biasFactor) {
    ++this.context.depth;
    try {
      const value10 = this.warbs[idx].arbitrary.generate(mrng, biasFactor);
      const clonedMrngForFallbackFirst = this.mustFallbackToFirstInShrink(idx) ? mrng.clone() : null;
      return this.mapIntoValue(idx, value10, clonedMrngForFallbackFirst, biasFactor);
    } finally {
      --this.context.depth;
    }
  }
  mustGenerateFirst() {
    return this.constraints.maxDepth <= this.context.depth;
  }
  mustFallbackToFirstInShrink(idx) {
    return idx !== 0 && this.constraints.withCrossShrink && this.warbs[0].weight !== 0;
  }
  computeNegDepthBenefit() {
    const depthBias = this.constraints.depthBias;
    if (depthBias <= 0 || this.warbs[0].weight === 0) {
      return 0;
    }
    const depthBenefit = safeMathFloor5(safeMathPow(1 + depthBias, this.context.depth)) - 1;
    return -safeMathMin4(this.totalWeight * depthBenefit, safeMaxSafeInteger) || 0;
  }
};

// ../../node_modules/fast-check/lib/esm/arbitrary/oneof.js
function isOneOfContraints(param) {
  return param != null && typeof param === "object" && !("generate" in param) && !("arbitrary" in param) && !("weight" in param);
}
function toWeightedArbitrary(maybeWeightedArbitrary) {
  if (isArbitrary(maybeWeightedArbitrary)) {
    return { arbitrary: maybeWeightedArbitrary, weight: 1 };
  }
  return maybeWeightedArbitrary;
}
function oneof(...args2) {
  const constraints = args2[0];
  if (isOneOfContraints(constraints)) {
    const weightedArbs2 = safeMap(safeSlice(args2, 1), toWeightedArbitrary);
    return FrequencyArbitrary.from(weightedArbs2, constraints, "fc.oneof");
  }
  const weightedArbs = safeMap(args2, toWeightedArbitrary);
  return FrequencyArbitrary.from(weightedArbs, {}, "fc.oneof");
}

// ../../node_modules/fast-check/lib/esm/arbitrary/nat.js
var safeNumberIsInteger4 = Number.isInteger;
function nat(arg) {
  const max13 = typeof arg === "number" ? arg : arg && arg.max !== void 0 ? arg.max : 2147483647;
  if (max13 < 0) {
    throw new Error("fc.nat value should be greater than or equal to 0");
  }
  if (!safeNumberIsInteger4(max13)) {
    throw new Error("fc.nat maximum value should be an integer");
  }
  return new IntegerArbitrary(0, max13);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/IndexToMappedConstant.js
var safeObjectIs6 = Object.is;
function buildDichotomyEntries(entries7) {
  let currentFrom = 0;
  const dichotomyEntries = [];
  for (const entry of entries7) {
    const from = currentFrom;
    currentFrom = from + entry.num;
    const to = currentFrom - 1;
    dichotomyEntries.push({ from, to, entry });
  }
  return dichotomyEntries;
}
function findDichotomyEntry(dichotomyEntries, choiceIndex) {
  let min11 = 0;
  let max13 = dichotomyEntries.length;
  while (max13 - min11 > 1) {
    const mid = ~~((min11 + max13) / 2);
    if (choiceIndex < dichotomyEntries[mid].from) {
      max13 = mid;
    } else {
      min11 = mid;
    }
  }
  return dichotomyEntries[min11];
}
function indexToMappedConstantMapperFor(entries7) {
  const dichotomyEntries = buildDichotomyEntries(entries7);
  return function indexToMappedConstantMapper(choiceIndex) {
    const dichotomyEntry = findDichotomyEntry(dichotomyEntries, choiceIndex);
    return dichotomyEntry.entry.build(choiceIndex - dichotomyEntry.from);
  };
}
function buildReverseMapping(entries7) {
  const reverseMapping = { mapping: new SMap(), negativeZeroIndex: void 0 };
  let choiceIndex = 0;
  for (let entryIdx = 0; entryIdx !== entries7.length; ++entryIdx) {
    const entry = entries7[entryIdx];
    for (let idxInEntry = 0; idxInEntry !== entry.num; ++idxInEntry) {
      const value10 = entry.build(idxInEntry);
      if (value10 === 0 && 1 / value10 === SNumber.NEGATIVE_INFINITY) {
        reverseMapping.negativeZeroIndex = choiceIndex;
      } else {
        safeMapSet(reverseMapping.mapping, value10, choiceIndex);
      }
      ++choiceIndex;
    }
  }
  return reverseMapping;
}
function indexToMappedConstantUnmapperFor(entries7) {
  let reverseMapping = null;
  return function indexToMappedConstantUnmapper(value10) {
    if (reverseMapping === null) {
      reverseMapping = buildReverseMapping(entries7);
    }
    const choiceIndex = safeObjectIs6(value10, -0) ? reverseMapping.negativeZeroIndex : safeMapGet(reverseMapping.mapping, value10);
    if (choiceIndex === void 0) {
      throw new SError("Unknown value encountered cannot be built using this mapToConstant");
    }
    return choiceIndex;
  };
}

// ../../node_modules/fast-check/lib/esm/arbitrary/mapToConstant.js
function computeNumChoices(options) {
  if (options.length === 0)
    throw new SError(`fc.mapToConstant expects at least one option`);
  let numChoices = 0;
  for (let idx = 0; idx !== options.length; ++idx) {
    if (options[idx].num < 0)
      throw new SError(`fc.mapToConstant expects all options to have a number of entries greater or equal to zero`);
    numChoices += options[idx].num;
  }
  if (numChoices === 0)
    throw new SError(`fc.mapToConstant expects at least one choice among options`);
  return numChoices;
}
function mapToConstant(...entries7) {
  const numChoices = computeNumChoices(entries7);
  return nat({ max: numChoices - 1 }).map(indexToMappedConstantMapperFor(entries7), indexToMappedConstantUnmapperFor(entries7));
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/builders/CharacterRangeArbitraryBuilder.js
var SMap2 = Map;
var safeStringFromCharCode = String.fromCharCode;
var lowerCaseMapper = { num: 26, build: (v) => safeStringFromCharCode(v + 97) };
var upperCaseMapper = { num: 26, build: (v) => safeStringFromCharCode(v + 65) };
var numericMapper = { num: 10, build: (v) => safeStringFromCharCode(v + 48) };
function percentCharArbMapper(c) {
  const encoded = SencodeURIComponent(c);
  return c !== encoded ? encoded : `%${safeNumberToString(safeCharCodeAt(c, 0), 16)}`;
}
function percentCharArbUnmapper(value10) {
  if (typeof value10 !== "string") {
    throw new Error("Unsupported");
  }
  const decoded = decodeURIComponent(value10);
  return decoded;
}
var percentCharArb = fullUnicode().map(percentCharArbMapper, percentCharArbUnmapper);
var lowerAlphaArbitrary = void 0;
function getOrCreateLowerAlphaArbitrary() {
  if (lowerAlphaArbitrary === void 0) {
    lowerAlphaArbitrary = mapToConstant(lowerCaseMapper);
  }
  return lowerAlphaArbitrary;
}
var lowerAlphaNumericArbitraries = void 0;
function getOrCreateLowerAlphaNumericArbitrary(others) {
  if (lowerAlphaNumericArbitraries === void 0) {
    lowerAlphaNumericArbitraries = new SMap2();
  }
  let match43 = safeMapGet(lowerAlphaNumericArbitraries, others);
  if (match43 === void 0) {
    match43 = mapToConstant(lowerCaseMapper, numericMapper, {
      num: others.length,
      build: (v) => others[v]
    });
    safeMapSet(lowerAlphaNumericArbitraries, others, match43);
  }
  return match43;
}
function buildAlphaNumericArbitrary(others) {
  return mapToConstant(lowerCaseMapper, upperCaseMapper, numericMapper, {
    num: others.length,
    build: (v) => others[v]
  });
}
var alphaNumericPercentArbitraries = void 0;
function getOrCreateAlphaNumericPercentArbitrary(others) {
  if (alphaNumericPercentArbitraries === void 0) {
    alphaNumericPercentArbitraries = new SMap2();
  }
  let match43 = safeMapGet(alphaNumericPercentArbitraries, others);
  if (match43 === void 0) {
    match43 = oneof({ weight: 10, arbitrary: buildAlphaNumericArbitrary(others) }, { weight: 1, arbitrary: percentCharArb });
    safeMapSet(alphaNumericPercentArbitraries, others, match43);
  }
  return match43;
}

// ../../node_modules/fast-check/lib/esm/arbitrary/option.js
function option(arb, constraints = {}) {
  const freq = constraints.freq == null ? 5 : constraints.freq;
  const nilValue = safeHasOwnProperty(constraints, "nil") ? constraints.nil : null;
  const nilArb = constant2(nilValue);
  const weightedArbs = [
    { arbitrary: nilArb, weight: 1, fallbackValue: { default: nilValue } },
    { arbitrary: arb, weight: freq }
  ];
  const frequencyConstraints = {
    withCrossShrink: true,
    depthSize: constraints.depthSize,
    maxDepth: constraints.maxDepth,
    depthIdentifier: constraints.depthIdentifier
  };
  return FrequencyArbitrary.from(weightedArbs, frequencyConstraints, "fc.option");
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/TokenizeString.js
function tokenizeString(patternsArb, value10, minLength2, maxLength2) {
  if (value10.length === 0) {
    if (minLength2 > 0) {
      return void 0;
    }
    return [];
  }
  if (maxLength2 <= 0) {
    return void 0;
  }
  const stack = [{ endIndexChunks: 0, nextStartIndex: 1, chunks: [] }];
  while (stack.length > 0) {
    const last8 = safePop(stack);
    for (let index = last8.nextStartIndex; index <= value10.length; ++index) {
      const chunk7 = safeSubstring(value10, last8.endIndexChunks, index);
      if (patternsArb.canShrinkWithoutContext(chunk7)) {
        const newChunks = [...last8.chunks, chunk7];
        if (index === value10.length) {
          if (newChunks.length < minLength2) {
            break;
          }
          return newChunks;
        }
        safePush(stack, { endIndexChunks: last8.endIndexChunks, nextStartIndex: index + 1, chunks: last8.chunks });
        if (newChunks.length < maxLength2) {
          safePush(stack, { endIndexChunks: index, nextStartIndex: index + 1, chunks: newChunks });
        }
        break;
      }
    }
  }
  return void 0;
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/PatternsToString.js
function patternsToStringMapper(tab) {
  return safeJoin(tab, "");
}
function minLengthFrom(constraints) {
  return constraints.minLength !== void 0 ? constraints.minLength : 0;
}
function maxLengthFrom(constraints) {
  return constraints.maxLength !== void 0 ? constraints.maxLength : MaxLengthUpperBound;
}
function patternsToStringUnmapperIsValidLength(tokens, constraints) {
  return minLengthFrom(constraints) <= tokens.length && tokens.length <= maxLengthFrom(constraints);
}
function patternsToStringUnmapperFor(patternsArb, constraints) {
  return function patternsToStringUnmapper(value10) {
    if (typeof value10 !== "string") {
      throw new SError("Unsupported value");
    }
    const tokens = tokenizeString(patternsArb, value10, minLengthFrom(constraints), maxLengthFrom(constraints));
    if (tokens === void 0) {
      throw new SError("Unable to unmap received string");
    }
    return tokens;
  };
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/SlicesForStringBuilder.js
var dangerousStrings = [
  "__defineGetter__",
  "__defineSetter__",
  "__lookupGetter__",
  "__lookupSetter__",
  "__proto__",
  "constructor",
  "hasOwnProperty",
  "isPrototypeOf",
  "propertyIsEnumerable",
  "toLocaleString",
  "toString",
  "valueOf",
  "apply",
  "arguments",
  "bind",
  "call",
  "caller",
  "length",
  "name",
  "prototype",
  "key",
  "ref"
];
function computeCandidateStringLegacy(dangerous, charArbitrary, stringSplitter) {
  let candidate;
  try {
    candidate = stringSplitter(dangerous);
  } catch (err) {
    return void 0;
  }
  for (const entry of candidate) {
    if (!charArbitrary.canShrinkWithoutContext(entry)) {
      return void 0;
    }
  }
  return candidate;
}
function createSlicesForStringLegacy(charArbitrary, stringSplitter) {
  const slicesForString = [];
  for (const dangerous of dangerousStrings) {
    const candidate = computeCandidateStringLegacy(dangerous, charArbitrary, stringSplitter);
    if (candidate !== void 0) {
      safePush(slicesForString, candidate);
    }
  }
  return slicesForString;
}
var slicesPerArbitrary = /* @__PURE__ */ new WeakMap();
function createSlicesForStringNoConstraints(charArbitrary) {
  const slicesForString = [];
  for (const dangerous of dangerousStrings) {
    const candidate = tokenizeString(charArbitrary, dangerous, 0, MaxLengthUpperBound);
    if (candidate !== void 0) {
      safePush(slicesForString, candidate);
    }
  }
  return slicesForString;
}
function createSlicesForString(charArbitrary, constraints) {
  let slices = safeGet(slicesPerArbitrary, charArbitrary);
  if (slices === void 0) {
    slices = createSlicesForStringNoConstraints(charArbitrary);
    safeSet(slicesPerArbitrary, charArbitrary, slices);
  }
  const slicesForConstraints = [];
  for (const slice2 of slices) {
    if (patternsToStringUnmapperIsValidLength(slice2, constraints)) {
      safePush(slicesForConstraints, slice2);
    }
  }
  return slicesForConstraints;
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/data/GraphemeRanges.js
var asciiAlphabetRanges = [[0, 127]];
var fullAlphabetRanges = [
  [0, 55295],
  [57344, 1114111]
];
var autonomousGraphemeRanges = [
  [32, 126],
  [160, 172],
  [174, 767],
  [880, 887],
  [890, 895],
  [900, 906],
  [908],
  [910, 929],
  [931, 1154],
  [1162, 1327],
  [1329, 1366],
  [1369, 1418],
  [1421, 1423],
  [1470],
  [1472],
  [1475],
  [1478],
  [1488, 1514],
  [1519, 1524],
  [1542, 1551],
  [1563],
  [1565, 1610],
  [1632, 1647],
  [1649, 1749],
  [1758],
  [1765, 1766],
  [1769],
  [1774, 1805],
  [1808],
  [1810, 1839],
  [1869, 1957],
  [1969],
  [1984, 2026],
  [2036, 2042],
  [2046, 2069],
  [2074],
  [2084],
  [2088],
  [2096, 2110],
  [2112, 2136],
  [2142],
  [2144, 2154],
  [2160, 2190],
  [2208, 2249],
  [2308, 2361],
  [2365],
  [2384],
  [2392, 2401],
  [2404, 2432],
  [2437, 2444],
  [2447, 2448],
  [2451, 2472],
  [2474, 2480],
  [2482],
  [2486, 2489],
  [2493],
  [2510],
  [2524, 2525],
  [2527, 2529],
  [2534, 2557],
  [2565, 2570],
  [2575, 2576],
  [2579, 2600],
  [2602, 2608],
  [2610, 2611],
  [2613, 2614],
  [2616, 2617],
  [2649, 2652],
  [2654],
  [2662, 2671],
  [2674, 2676],
  [2678],
  [2693, 2701],
  [2703, 2705],
  [2707, 2728],
  [2730, 2736],
  [2738, 2739],
  [2741, 2745],
  [2749],
  [2768],
  [2784, 2785],
  [2790, 2801],
  [2809],
  [2821, 2828],
  [2831, 2832],
  [2835, 2856],
  [2858, 2864],
  [2866, 2867],
  [2869, 2873],
  [2877],
  [2908, 2909],
  [2911, 2913],
  [2918, 2935],
  [2947],
  [2949, 2954],
  [2958, 2960],
  [2962, 2965],
  [2969, 2970],
  [2972],
  [2974, 2975],
  [2979, 2980],
  [2984, 2986],
  [2990, 3001],
  [3024],
  [3046, 3066],
  [3077, 3084],
  [3086, 3088],
  [3090, 3112],
  [3114, 3129],
  [3133],
  [3160, 3162],
  [3165],
  [3168, 3169],
  [3174, 3183],
  [3191, 3200],
  [3204, 3212],
  [3214, 3216],
  [3218, 3240],
  [3242, 3251],
  [3253, 3257],
  [3261],
  [3293, 3294],
  [3296, 3297],
  [3302, 3311],
  [3313, 3314],
  [3332, 3340],
  [3342, 3344],
  [3346, 3386],
  [3389],
  [3407],
  [3412, 3414],
  [3416, 3425],
  [3430, 3455],
  [3461, 3478],
  [3482, 3505],
  [3507, 3515],
  [3517],
  [3520, 3526],
  [3558, 3567],
  [3572],
  [3585, 3632],
  [3634],
  [3647, 3654],
  [3663, 3675],
  [3713, 3714],
  [3716],
  [3718, 3722],
  [3724, 3747],
  [3749],
  [3751, 3760],
  [3762],
  [3773],
  [3776, 3780],
  [3782],
  [3792, 3801],
  [3804, 3807],
  [3840, 3863],
  [3866, 3892],
  [3894],
  [3896],
  [3898, 3901],
  [3904, 3911],
  [3913, 3948],
  [3973],
  [3976, 3980],
  [4030, 4037],
  [4039, 4044],
  [4046, 4058],
  [4096, 4138],
  [4159, 4181],
  [4186, 4189],
  [4193],
  [4197, 4198],
  [4206, 4208],
  [4213, 4225],
  [4238],
  [4240, 4249],
  [4254, 4293],
  [4295],
  [4301],
  [4304, 4351],
  [4608, 4680],
  [4682, 4685],
  [4688, 4694],
  [4696],
  [4698, 4701],
  [4704, 4744],
  [4746, 4749],
  [4752, 4784],
  [4786, 4789],
  [4792, 4798],
  [4800],
  [4802, 4805],
  [4808, 4822],
  [4824, 4880],
  [4882, 4885],
  [4888, 4954],
  [4960, 4988],
  [4992, 5017],
  [5024, 5109],
  [5112, 5117],
  [5120, 5788],
  [5792, 5880],
  [5888, 5905],
  [5919, 5937],
  [5941, 5942],
  [5952, 5969],
  [5984, 5996],
  [5998, 6e3],
  [6016, 6067],
  [6100, 6108],
  [6112, 6121],
  [6128, 6137],
  [6144, 6154],
  [6160, 6169],
  [6176, 6264],
  [6272, 6276],
  [6279, 6312],
  [6314],
  [6320, 6389],
  [6400, 6430],
  [6464],
  [6468, 6509],
  [6512, 6516],
  [6528, 6571],
  [6576, 6601],
  [6608, 6618],
  [6622, 6678],
  [6686, 6740],
  [6784, 6793],
  [6800, 6809],
  [6816, 6829],
  [6917, 6963],
  [6981, 6988],
  [6992, 7018],
  [7028, 7038],
  [7043, 7072],
  [7086, 7141],
  [7164, 7203],
  [7227, 7241],
  [7245, 7304],
  [7312, 7354],
  [7357, 7367],
  [7379],
  [7401, 7404],
  [7406, 7411],
  [7413, 7414],
  [7418],
  [7424, 7615],
  [7680, 7957],
  [7960, 7965],
  [7968, 8005],
  [8008, 8013],
  [8016, 8023],
  [8025],
  [8027],
  [8029],
  [8031, 8061],
  [8064, 8116],
  [8118, 8132],
  [8134, 8147],
  [8150, 8155],
  [8157, 8175],
  [8178, 8180],
  [8182, 8190],
  [8192, 8202],
  [8208, 8233],
  [8239, 8287],
  [8304, 8305],
  [8308, 8334],
  [8336, 8348],
  [8352, 8384],
  [8448, 8587],
  [8592, 9254],
  [9280, 9290],
  [9312, 11123],
  [11126, 11157],
  [11159, 11502],
  [11506, 11507],
  [11513, 11557],
  [11559],
  [11565],
  [11568, 11623],
  [11631, 11632],
  [11648, 11670],
  [11680, 11686],
  [11688, 11694],
  [11696, 11702],
  [11704, 11710],
  [11712, 11718],
  [11720, 11726],
  [11728, 11734],
  [11736, 11742],
  [11776, 11869],
  [11904, 11929],
  [11931, 12019],
  [12032, 12245],
  [12272, 12329],
  [12336, 12351],
  [12353, 12438],
  [12443, 12543],
  [12549, 12591],
  [12593, 12686],
  [12688, 12771],
  [12783, 12830],
  [12832, 13312],
  [19903, 19968],
  [40959, 42124],
  [42128, 42182],
  [42192, 42539],
  [42560, 42606],
  [42611],
  [42622, 42653],
  [42656, 42735],
  [42738, 42743],
  [42752, 42954],
  [42960, 42961],
  [42963],
  [42965, 42969],
  [42994, 43009],
  [43011, 43013],
  [43015, 43018],
  [43020, 43042],
  [43048, 43051],
  [43056, 43065],
  [43072, 43127],
  [43138, 43187],
  [43214, 43225],
  [43250, 43262],
  [43264, 43301],
  [43310, 43334],
  [43359],
  [43396, 43442],
  [43457, 43469],
  [43471, 43481],
  [43486, 43492],
  [43494, 43518],
  [43520, 43560],
  [43584, 43586],
  [43588, 43595],
  [43600, 43609],
  [43612, 43642],
  [43646, 43695],
  [43697],
  [43701, 43702],
  [43705, 43709],
  [43712],
  [43714],
  [43739, 43754],
  [43760, 43764],
  [43777, 43782],
  [43785, 43790],
  [43793, 43798],
  [43808, 43814],
  [43816, 43822],
  [43824, 43883],
  [43888, 44002],
  [44011],
  [44016, 44025],
  [44032],
  [55203],
  [63744, 64109],
  [64112, 64217],
  [64256, 64262],
  [64275, 64279],
  [64285],
  [64287, 64310],
  [64312, 64316],
  [64318],
  [64320, 64321],
  [64323, 64324],
  [64326, 64450],
  [64467, 64911],
  [64914, 64967],
  [64975],
  [65008, 65023],
  [65040, 65049],
  [65072, 65106],
  [65108, 65126],
  [65128, 65131],
  [65136, 65140],
  [65142, 65276],
  [65281, 65437],
  [65440, 65470],
  [65474, 65479],
  [65482, 65487],
  [65490, 65495],
  [65498, 65500],
  [65504, 65510],
  [65512, 65518],
  [65532, 65533],
  [65536, 65547],
  [65549, 65574],
  [65576, 65594],
  [65596, 65597],
  [65599, 65613],
  [65616, 65629],
  [65664, 65786],
  [65792, 65794],
  [65799, 65843],
  [65847, 65934],
  [65936, 65948],
  [65952],
  [66e3, 66044],
  [66176, 66204],
  [66208, 66256],
  [66273, 66299],
  [66304, 66339],
  [66349, 66378],
  [66384, 66421],
  [66432, 66461],
  [66463, 66499],
  [66504, 66517],
  [66560, 66717],
  [66720, 66729],
  [66736, 66771],
  [66776, 66811],
  [66816, 66855],
  [66864, 66915],
  [66927, 66938],
  [66940, 66954],
  [66956, 66962],
  [66964, 66965],
  [66967, 66977],
  [66979, 66993],
  [66995, 67001],
  [67003, 67004],
  [67072, 67382],
  [67392, 67413],
  [67424, 67431],
  [67456, 67461],
  [67463, 67504],
  [67506, 67514],
  [67584, 67589],
  [67592],
  [67594, 67637],
  [67639, 67640],
  [67644],
  [67647, 67669],
  [67671, 67742],
  [67751, 67759],
  [67808, 67826],
  [67828, 67829],
  [67835, 67867],
  [67871, 67897],
  [67903],
  [67968, 68023],
  [68028, 68047],
  [68050, 68096],
  [68112, 68115],
  [68117, 68119],
  [68121, 68149],
  [68160, 68168],
  [68176, 68184],
  [68192, 68255],
  [68288, 68324],
  [68331, 68342],
  [68352, 68405],
  [68409, 68437],
  [68440, 68466],
  [68472, 68497],
  [68505, 68508],
  [68521, 68527],
  [68608, 68680],
  [68736, 68786],
  [68800, 68850],
  [68858, 68899],
  [68912, 68921],
  [69216, 69246],
  [69248, 69289],
  [69293],
  [69296, 69297],
  [69376, 69415],
  [69424, 69445],
  [69457, 69465],
  [69488, 69505],
  [69510, 69513],
  [69552, 69579],
  [69600, 69622],
  [69635, 69687],
  [69703, 69709],
  [69714, 69743],
  [69745, 69746],
  [69749],
  [69763, 69807],
  [69819, 69820],
  [69822, 69825],
  [69840, 69864],
  [69872, 69881],
  [69891, 69926],
  [69942, 69956],
  [69959],
  [69968, 70002],
  [70004, 70006],
  [70019, 70066],
  [70081],
  [70084, 70088],
  [70093],
  [70096, 70111],
  [70113, 70132],
  [70144, 70161],
  [70163, 70187],
  [70200, 70205],
  [70207, 70208],
  [70272, 70278],
  [70280],
  [70282, 70285],
  [70287, 70301],
  [70303, 70313],
  [70320, 70366],
  [70384, 70393],
  [70405, 70412],
  [70415, 70416],
  [70419, 70440],
  [70442, 70448],
  [70450, 70451],
  [70453, 70457],
  [70461],
  [70480],
  [70493, 70497],
  [70656, 70708],
  [70727, 70747],
  [70749],
  [70751, 70753],
  [70784, 70831],
  [70852, 70855],
  [70864, 70873],
  [71040, 71086],
  [71105, 71131],
  [71168, 71215],
  [71233, 71236],
  [71248, 71257],
  [71264, 71276],
  [71296, 71338],
  [71352, 71353],
  [71360, 71369],
  [71424, 71450],
  [71472, 71494],
  [71680, 71723],
  [71739],
  [71840, 71922],
  [71935, 71942],
  [71945],
  [71948, 71955],
  [71957, 71958],
  [71960, 71983],
  [72004, 72006],
  [72016, 72025],
  [72096, 72103],
  [72106, 72144],
  [72161, 72163],
  [72192],
  [72203, 72242],
  [72255, 72262],
  [72272],
  [72284, 72323],
  [72346, 72354],
  [72368, 72440],
  [72448, 72457],
  [72704, 72712],
  [72714, 72750],
  [72768, 72773],
  [72784, 72812],
  [72816, 72847],
  [72960, 72966],
  [72968, 72969],
  [72971, 73008],
  [73040, 73049],
  [73056, 73061],
  [73063, 73064],
  [73066, 73097],
  [73112],
  [73120, 73129],
  [73440, 73458],
  [73463, 73464],
  [73476, 73488],
  [73490, 73523],
  [73539, 73561],
  [73648],
  [73664, 73713],
  [73727, 74649],
  [74752, 74862],
  [74864, 74868],
  [74880, 75075],
  [77712, 77810],
  [77824, 78895],
  [78913, 78918],
  [82944, 83526],
  [92160, 92728],
  [92736, 92766],
  [92768, 92777],
  [92782, 92862],
  [92864, 92873],
  [92880, 92909],
  [92917],
  [92928, 92975],
  [92983, 92997],
  [93008, 93017],
  [93019, 93025],
  [93027, 93047],
  [93053, 93071],
  [93760, 93850],
  [93952, 94026],
  [94032],
  [94099, 94111],
  [94176, 94179],
  [94208],
  [100343],
  [100352, 101589],
  [101632],
  [101640],
  [110576, 110579],
  [110581, 110587],
  [110589, 110590],
  [110592, 110882],
  [110898],
  [110928, 110930],
  [110933],
  [110948, 110951],
  [110960, 111355],
  [113664, 113770],
  [113776, 113788],
  [113792, 113800],
  [113808, 113817],
  [113820],
  [113823],
  [118608, 118723],
  [118784, 119029],
  [119040, 119078],
  [119081, 119140],
  [119146, 119148],
  [119171, 119172],
  [119180, 119209],
  [119214, 119274],
  [119296, 119361],
  [119365],
  [119488, 119507],
  [119520, 119539],
  [119552, 119638],
  [119648, 119672],
  [119808, 119892],
  [119894, 119964],
  [119966, 119967],
  [119970],
  [119973, 119974],
  [119977, 119980],
  [119982, 119993],
  [119995],
  [119997, 120003],
  [120005, 120069],
  [120071, 120074],
  [120077, 120084],
  [120086, 120092],
  [120094, 120121],
  [120123, 120126],
  [120128, 120132],
  [120134],
  [120138, 120144],
  [120146, 120485],
  [120488, 120779],
  [120782, 121343],
  [121399, 121402],
  [121453, 121460],
  [121462, 121475],
  [121477, 121483],
  [122624, 122654],
  [122661, 122666],
  [122928, 122989],
  [123136, 123180],
  [123191, 123197],
  [123200, 123209],
  [123214, 123215],
  [123536, 123565],
  [123584, 123627],
  [123632, 123641],
  [123647],
  [124112, 124139],
  [124144, 124153],
  [124896, 124902],
  [124904, 124907],
  [124909, 124910],
  [124912, 124926],
  [124928, 125124],
  [125127, 125135],
  [125184, 125251],
  [125259],
  [125264, 125273],
  [125278, 125279],
  [126065, 126132],
  [126209, 126269],
  [126464, 126467],
  [126469, 126495],
  [126497, 126498],
  [126500],
  [126503],
  [126505, 126514],
  [126516, 126519],
  [126521],
  [126523],
  [126530],
  [126535],
  [126537],
  [126539],
  [126541, 126543],
  [126545, 126546],
  [126548],
  [126551],
  [126553],
  [126555],
  [126557],
  [126559],
  [126561, 126562],
  [126564],
  [126567, 126570],
  [126572, 126578],
  [126580, 126583],
  [126585, 126588],
  [126590],
  [126592, 126601],
  [126603, 126619],
  [126625, 126627],
  [126629, 126633],
  [126635, 126651],
  [126704, 126705],
  [126976, 127019],
  [127024, 127123],
  [127136, 127150],
  [127153, 127167],
  [127169, 127183],
  [127185, 127221],
  [127232, 127405],
  [127488, 127490],
  [127504, 127547],
  [127552, 127560],
  [127568, 127569],
  [127584, 127589],
  [127744, 127994],
  [128e3, 128727],
  [128732, 128748],
  [128752, 128764],
  [128768, 128886],
  [128891, 128985],
  [128992, 129003],
  [129008],
  [129024, 129035],
  [129040, 129095],
  [129104, 129113],
  [129120, 129159],
  [129168, 129197],
  [129200, 129201],
  [129280, 129619],
  [129632, 129645],
  [129648, 129660],
  [129664, 129672],
  [129680, 129725],
  [129727, 129733],
  [129742, 129755],
  [129760, 129768],
  [129776, 129784],
  [129792, 129938],
  [129940, 129994],
  [130032, 130041],
  [131072],
  [173791],
  [173824],
  [177977],
  [177984],
  [178205],
  [178208],
  [183969],
  [183984],
  [191456],
  [191472],
  [192093],
  [194560, 195101],
  [196608],
  [201546],
  [201552],
  [205743]
];
var autonomousDecomposableGraphemeRanges = [
  [192, 197],
  [199, 207],
  [209, 214],
  [217, 221],
  [224, 229],
  [231, 239],
  [241, 246],
  [249, 253],
  [255, 271],
  [274, 293],
  [296, 304],
  [308, 311],
  [313, 318],
  [323, 328],
  [332, 337],
  [340, 357],
  [360, 382],
  [416, 417],
  [431, 432],
  [461, 476],
  [478, 483],
  [486, 496],
  [500, 501],
  [504, 539],
  [542, 543],
  [550, 563],
  [901, 902],
  [904, 906],
  [908],
  [910, 912],
  [938, 944],
  [970, 974],
  [979, 980],
  [1024, 1025],
  [1027],
  [1031],
  [1036, 1038],
  [1049],
  [1081],
  [1104, 1105],
  [1107],
  [1111],
  [1116, 1118],
  [1142, 1143],
  [1217, 1218],
  [1232, 1235],
  [1238, 1239],
  [1242, 1247],
  [1250, 1255],
  [1258, 1269],
  [1272, 1273],
  [1570, 1574],
  [1728],
  [1730],
  [1747],
  [2345],
  [2353],
  [2356],
  [2392, 2399],
  [2524, 2525],
  [2527],
  [2611],
  [2614],
  [2649, 2651],
  [2654],
  [2908, 2909],
  [2964],
  [3907],
  [3917],
  [3922],
  [3927],
  [3932],
  [3945],
  [4134],
  [6918],
  [6920],
  [6922],
  [6924],
  [6926],
  [6930],
  [7680, 7833],
  [7835],
  [7840, 7929],
  [7936, 7957],
  [7960, 7965],
  [7968, 8005],
  [8008, 8013],
  [8016, 8023],
  [8025],
  [8027],
  [8029],
  [8031, 8048],
  [8050],
  [8052],
  [8054],
  [8056],
  [8058],
  [8060],
  [8064, 8116],
  [8118, 8122],
  [8124],
  [8129, 8132],
  [8134, 8136],
  [8138],
  [8140, 8146],
  [8150, 8154],
  [8157, 8162],
  [8164, 8170],
  [8172, 8173],
  [8178, 8180],
  [8182, 8184],
  [8186],
  [8188],
  [8602, 8603],
  [8622],
  [8653, 8655],
  [8708],
  [8713],
  [8716],
  [8740],
  [8742],
  [8769],
  [8772],
  [8775],
  [8777],
  [8800],
  [8802],
  [8813, 8817],
  [8820, 8821],
  [8824, 8825],
  [8832, 8833],
  [8836, 8837],
  [8840, 8841],
  [8876, 8879],
  [8928, 8931],
  [8938, 8941],
  [10972],
  [12364],
  [12366],
  [12368],
  [12370],
  [12372],
  [12374],
  [12376],
  [12378],
  [12380],
  [12382],
  [12384],
  [12386],
  [12389],
  [12391],
  [12393],
  [12400, 12401],
  [12403, 12404],
  [12406, 12407],
  [12409, 12410],
  [12412, 12413],
  [12436],
  [12446],
  [12460],
  [12462],
  [12464],
  [12466],
  [12468],
  [12470],
  [12472],
  [12474],
  [12476],
  [12478],
  [12480],
  [12482],
  [12485],
  [12487],
  [12489],
  [12496, 12497],
  [12499, 12500],
  [12502, 12503],
  [12505, 12506],
  [12508, 12509],
  [12532],
  [12535, 12538],
  [12542],
  [44032],
  [55203],
  [64285],
  [64287],
  [64298, 64310],
  [64312, 64316],
  [64318],
  [64320, 64321],
  [64323, 64324],
  [64326, 64334],
  [69786],
  [69788],
  [69803],
  [119134, 119140],
  [119227, 119232]
];

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/GraphemeRangesHelpers.js
var safeStringFromCodePoint = String.fromCodePoint;
var safeMathMin5 = Math.min;
var safeMathMax3 = Math.max;
function convertGraphemeRangeToMapToConstantEntry(range6) {
  if (range6.length === 1) {
    const codePointString = safeStringFromCodePoint(range6[0]);
    return { num: 1, build: () => codePointString };
  }
  const rangeStart = range6[0];
  return { num: range6[1] - range6[0] + 1, build: (idInGroup) => safeStringFromCodePoint(rangeStart + idInGroup) };
}
function intersectGraphemeRanges(rangesA, rangesB) {
  const mergedRanges = [];
  let cursorA = 0;
  let cursorB = 0;
  while (cursorA < rangesA.length && cursorB < rangesB.length) {
    const rangeA = rangesA[cursorA];
    const rangeAMin = rangeA[0];
    const rangeAMax = rangeA.length === 1 ? rangeA[0] : rangeA[1];
    const rangeB = rangesB[cursorB];
    const rangeBMin = rangeB[0];
    const rangeBMax = rangeB.length === 1 ? rangeB[0] : rangeB[1];
    if (rangeAMax < rangeBMin) {
      cursorA += 1;
    } else if (rangeBMax < rangeAMin) {
      cursorB += 1;
    } else {
      let min11 = safeMathMax3(rangeAMin, rangeBMin);
      const max13 = safeMathMin5(rangeAMax, rangeBMax);
      if (mergedRanges.length >= 1) {
        const lastMergedRange = mergedRanges[mergedRanges.length - 1];
        const lastMergedRangeMax = lastMergedRange.length === 1 ? lastMergedRange[0] : lastMergedRange[1];
        if (lastMergedRangeMax + 1 === min11) {
          min11 = lastMergedRange[0];
          safePop(mergedRanges);
        }
      }
      safePush(mergedRanges, min11 === max13 ? [min11] : [min11, max13]);
      if (rangeAMax <= max13) {
        cursorA += 1;
      }
      if (rangeBMax <= max13) {
        cursorB += 1;
      }
    }
  }
  return mergedRanges;
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/StringUnitArbitrary.js
var registeredStringUnitInstancesMap = /* @__PURE__ */ Object.create(null);
function getAlphabetRanges(alphabet) {
  switch (alphabet) {
    case "full":
      return fullAlphabetRanges;
    case "ascii":
      return asciiAlphabetRanges;
  }
}
function getOrCreateStringUnitInstance(type3, alphabet) {
  const key = `${type3}:${alphabet}`;
  const registered = registeredStringUnitInstancesMap[key];
  if (registered !== void 0) {
    return registered;
  }
  const alphabetRanges = getAlphabetRanges(alphabet);
  const ranges = type3 === "binary" ? alphabetRanges : intersectGraphemeRanges(alphabetRanges, autonomousGraphemeRanges);
  const entries7 = [];
  for (const range6 of ranges) {
    safePush(entries7, convertGraphemeRangeToMapToConstantEntry(range6));
  }
  if (type3 === "grapheme") {
    const decomposedRanges = intersectGraphemeRanges(alphabetRanges, autonomousDecomposableGraphemeRanges);
    for (const range6 of decomposedRanges) {
      const rawEntry = convertGraphemeRangeToMapToConstantEntry(range6);
      safePush(entries7, {
        num: rawEntry.num,
        build: (idInGroup) => safeNormalize(rawEntry.build(idInGroup), "NFD")
      });
    }
  }
  const stringUnitInstance = mapToConstant(...entries7);
  registeredStringUnitInstancesMap[key] = stringUnitInstance;
  return stringUnitInstance;
}
function stringUnit(type3, alphabet) {
  return getOrCreateStringUnitInstance(type3, alphabet);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/string.js
var safeObjectAssign5 = Object.assign;
function extractUnitArbitrary(constraints) {
  if (typeof constraints.unit === "object") {
    return constraints.unit;
  }
  switch (constraints.unit) {
    case "grapheme":
      return stringUnit("grapheme", "full");
    case "grapheme-composite":
      return stringUnit("composite", "full");
    case "grapheme-ascii":
    case void 0:
      return stringUnit("grapheme", "ascii");
    case "binary":
      return stringUnit("binary", "full");
    case "binary-ascii":
      return stringUnit("binary", "ascii");
  }
}
function string4(constraints = {}) {
  const charArbitrary = extractUnitArbitrary(constraints);
  const unmapper = patternsToStringUnmapperFor(charArbitrary, constraints);
  const experimentalCustomSlices = createSlicesForString(charArbitrary, constraints);
  const enrichedConstraints = safeObjectAssign5(safeObjectAssign5({}, constraints), {
    experimentalCustomSlices
  });
  return array4(charArbitrary, enrichedConstraints).map(patternsToStringMapper, unmapper);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/InvalidSubdomainLabelFiIter.js
function filterInvalidSubdomainLabel(subdomainLabel2) {
  if (subdomainLabel2.length > 63) {
    return false;
  }
  return subdomainLabel2.length < 4 || subdomainLabel2[0] !== "x" || subdomainLabel2[1] !== "n" || subdomainLabel2[2] !== "-" || subdomainLabel2[3] !== "-";
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/AdapterArbitrary.js
var AdaptedValue = Symbol("adapted-value");
function toAdapterValue(rawValue, adapter5) {
  const adapted = adapter5(rawValue.value_);
  if (!adapted.adapted) {
    return rawValue;
  }
  return new Value(adapted.value, AdaptedValue);
}
var AdapterArbitrary = class extends Arbitrary {
  constructor(sourceArb, adapter5) {
    super();
    this.sourceArb = sourceArb;
    this.adapter = adapter5;
    this.adaptValue = (rawValue) => toAdapterValue(rawValue, adapter5);
  }
  generate(mrng, biasFactor) {
    const rawValue = this.sourceArb.generate(mrng, biasFactor);
    return this.adaptValue(rawValue);
  }
  canShrinkWithoutContext(value10) {
    return this.sourceArb.canShrinkWithoutContext(value10) && !this.adapter(value10).adapted;
  }
  shrink(value10, context15) {
    if (context15 === AdaptedValue) {
      if (!this.sourceArb.canShrinkWithoutContext(value10)) {
        return Stream.nil();
      }
      return this.sourceArb.shrink(value10, void 0).map(this.adaptValue);
    }
    return this.sourceArb.shrink(value10, context15).map(this.adaptValue);
  }
};
function adapter4(sourceArb, adapter5) {
  return new AdapterArbitrary(sourceArb, adapter5);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/domain.js
function toSubdomainLabelMapper([f, d]) {
  return d === null ? f : `${f}${d[0]}${d[1]}`;
}
function toSubdomainLabelUnmapper(value10) {
  if (typeof value10 !== "string" || value10.length === 0) {
    throw new Error("Unsupported");
  }
  if (value10.length === 1) {
    return [value10[0], null];
  }
  return [value10[0], [safeSubstring(value10, 1, value10.length - 1), value10[value10.length - 1]]];
}
function subdomainLabel(size40) {
  const alphaNumericArb = getOrCreateLowerAlphaNumericArbitrary("");
  const alphaNumericHyphenArb = getOrCreateLowerAlphaNumericArbitrary("-");
  return tuple4(alphaNumericArb, option(tuple4(string4({ unit: alphaNumericHyphenArb, size: size40, maxLength: 61 }), alphaNumericArb))).map(toSubdomainLabelMapper, toSubdomainLabelUnmapper).filter(filterInvalidSubdomainLabel);
}
function labelsMapper(elements) {
  return `${safeJoin(elements[0], ".")}.${elements[1]}`;
}
function labelsUnmapper(value10) {
  if (typeof value10 !== "string") {
    throw new Error("Unsupported type");
  }
  const lastDotIndex = value10.lastIndexOf(".");
  return [safeSplit(safeSubstring(value10, 0, lastDotIndex), "."), safeSubstring(value10, lastDotIndex + 1)];
}
function labelsAdapter(labels) {
  const [subDomains, suffix] = labels;
  let lengthNotIncludingIndex = suffix.length;
  for (let index = 0; index !== subDomains.length; ++index) {
    lengthNotIncludingIndex += 1 + subDomains[index].length;
    if (lengthNotIncludingIndex > 255) {
      return { adapted: true, value: [safeSlice(subDomains, 0, index), suffix] };
    }
  }
  return { adapted: false, value: labels };
}
function domain(constraints = {}) {
  const resolvedSize = resolveSize(constraints.size);
  const resolvedSizeMinusOne = relativeSizeToSize("-1", resolvedSize);
  const lowerAlphaArb = getOrCreateLowerAlphaArbitrary();
  const publicSuffixArb = string4({ unit: lowerAlphaArb, minLength: 2, maxLength: 63, size: resolvedSizeMinusOne });
  return adapter4(tuple4(array4(subdomainLabel(resolvedSize), { size: resolvedSizeMinusOne, minLength: 1, maxLength: 127 }), publicSuffixArb), labelsAdapter).map(labelsMapper, labelsUnmapper);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/emailAddress.js
function dotAdapter(a) {
  let currentLength = a[0].length;
  for (let index = 1; index !== a.length; ++index) {
    currentLength += 1 + a[index].length;
    if (currentLength > 64) {
      return { adapted: true, value: safeSlice(a, 0, index) };
    }
  }
  return { adapted: false, value: a };
}
function dotMapper(a) {
  return safeJoin(a, ".");
}
function dotUnmapper(value10) {
  if (typeof value10 !== "string") {
    throw new Error("Unsupported");
  }
  return safeSplit(value10, ".");
}
function atMapper(data) {
  return `${data[0]}@${data[1]}`;
}
function atUnmapper(value10) {
  if (typeof value10 !== "string") {
    throw new Error("Unsupported");
  }
  return safeSplit(value10, "@", 2);
}
function emailAddress(constraints = {}) {
  const atextArb = getOrCreateLowerAlphaNumericArbitrary("!#$%&'*+-/=?^_`{|}~");
  const localPartArb = adapter4(array4(string4({
    unit: atextArb,
    minLength: 1,
    maxLength: 64,
    size: constraints.size
  }), { minLength: 1, maxLength: 32, size: constraints.size }), dotAdapter).map(dotMapper, dotUnmapper);
  return tuple4(localPartArb, domain({ size: constraints.size })).map(atMapper, atUnmapper);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ArrayInt64.js
var Zero64 = { sign: 1, data: [0, 0] };
var Unit64 = { sign: 1, data: [0, 1] };
function isZero64(a) {
  return a.data[0] === 0 && a.data[1] === 0;
}
function isStrictlyNegative64(a) {
  return a.sign === -1 && !isZero64(a);
}
function isStrictlyPositive64(a) {
  return a.sign === 1 && !isZero64(a);
}
function isEqual64(a, b) {
  if (a.data[0] === b.data[0] && a.data[1] === b.data[1]) {
    return a.sign === b.sign || a.data[0] === 0 && a.data[1] === 0;
  }
  return false;
}
function isStrictlySmaller64Internal(a, b) {
  return a[0] < b[0] || a[0] === b[0] && a[1] < b[1];
}
function isStrictlySmaller64(a, b) {
  if (a.sign === b.sign) {
    return a.sign === 1 ? isStrictlySmaller64Internal(a.data, b.data) : isStrictlySmaller64Internal(b.data, a.data);
  }
  return a.sign === -1 && (!isZero64(a) || !isZero64(b));
}
function clone64(a) {
  return { sign: a.sign, data: [a.data[0], a.data[1]] };
}
function substract64DataInternal(a, b) {
  let reminderLow = 0;
  let low = a[1] - b[1];
  if (low < 0) {
    reminderLow = 1;
    low = low >>> 0;
  }
  return [a[0] - b[0] - reminderLow, low];
}
function substract64Internal(a, b) {
  if (a.sign === 1 && b.sign === -1) {
    const low = a.data[1] + b.data[1];
    const high = a.data[0] + b.data[0] + (low > 4294967295 ? 1 : 0);
    return { sign: 1, data: [high >>> 0, low >>> 0] };
  }
  return {
    sign: 1,
    data: a.sign === 1 ? substract64DataInternal(a.data, b.data) : substract64DataInternal(b.data, a.data)
  };
}
function substract64(arrayIntA, arrayIntB) {
  if (isStrictlySmaller64(arrayIntA, arrayIntB)) {
    const out = substract64Internal(arrayIntB, arrayIntA);
    out.sign = -1;
    return out;
  }
  return substract64Internal(arrayIntA, arrayIntB);
}
function negative64(arrayIntA) {
  return {
    sign: -arrayIntA.sign,
    data: [arrayIntA.data[0], arrayIntA.data[1]]
  };
}
function add642(arrayIntA, arrayIntB) {
  if (isZero64(arrayIntB)) {
    if (isZero64(arrayIntA)) {
      return clone64(Zero64);
    }
    return clone64(arrayIntA);
  }
  return substract64(arrayIntA, negative64(arrayIntB));
}
function halve64(a) {
  return {
    sign: a.sign,
    data: [Math.floor(a.data[0] / 2), (a.data[0] % 2 === 1 ? 2147483648 : 0) + Math.floor(a.data[1] / 2)]
  };
}
function logLike64(a) {
  return {
    sign: a.sign,
    data: [0, Math.floor(Math.log(a.data[0] * 4294967296 + a.data[1]) / Math.log(2))]
  };
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/ArrayInt64Arbitrary.js
var ArrayInt64Arbitrary = class _ArrayInt64Arbitrary extends Arbitrary {
  constructor(min11, max13) {
    super();
    this.min = min11;
    this.max = max13;
    this.biasedRanges = null;
  }
  generate(mrng, biasFactor) {
    const range6 = this.computeGenerateRange(mrng, biasFactor);
    const uncheckedValue = mrng.nextArrayInt(range6.min, range6.max);
    if (uncheckedValue.data.length === 1) {
      uncheckedValue.data.unshift(0);
    }
    return new Value(uncheckedValue, void 0);
  }
  computeGenerateRange(mrng, biasFactor) {
    if (biasFactor === void 0 || mrng.nextInt(1, biasFactor) !== 1) {
      return { min: this.min, max: this.max };
    }
    const ranges = this.retrieveBiasedRanges();
    if (ranges.length === 1) {
      return ranges[0];
    }
    const id3 = mrng.nextInt(-2 * (ranges.length - 1), ranges.length - 2);
    return id3 < 0 ? ranges[0] : ranges[id3 + 1];
  }
  canShrinkWithoutContext(value10) {
    const unsafeValue = value10;
    return typeof value10 === "object" && value10 !== null && (unsafeValue.sign === -1 || unsafeValue.sign === 1) && Array.isArray(unsafeValue.data) && unsafeValue.data.length === 2 && (isStrictlySmaller64(this.min, unsafeValue) && isStrictlySmaller64(unsafeValue, this.max) || isEqual64(this.min, unsafeValue) || isEqual64(this.max, unsafeValue));
  }
  shrinkArrayInt64(value10, target, tryTargetAsap) {
    const realGap = substract64(value10, target);
    function* shrinkGen() {
      let previous2 = tryTargetAsap ? void 0 : target;
      const gap = tryTargetAsap ? realGap : halve64(realGap);
      for (let toremove = gap; !isZero64(toremove); toremove = halve64(toremove)) {
        const next6 = substract64(value10, toremove);
        yield new Value(next6, previous2);
        previous2 = next6;
      }
    }
    return stream(shrinkGen());
  }
  shrink(current2, context15) {
    if (!_ArrayInt64Arbitrary.isValidContext(current2, context15)) {
      const target = this.defaultTarget();
      return this.shrinkArrayInt64(current2, target, true);
    }
    if (this.isLastChanceTry(current2, context15)) {
      return Stream.of(new Value(context15, void 0));
    }
    return this.shrinkArrayInt64(current2, context15, false);
  }
  defaultTarget() {
    if (!isStrictlyPositive64(this.min) && !isStrictlyNegative64(this.max)) {
      return Zero64;
    }
    return isStrictlyNegative64(this.min) ? this.max : this.min;
  }
  isLastChanceTry(current2, context15) {
    if (isZero64(current2)) {
      return false;
    }
    if (current2.sign === 1) {
      return isEqual64(current2, add642(context15, Unit64)) && isStrictlyPositive64(substract64(current2, this.min));
    } else {
      return isEqual64(current2, substract64(context15, Unit64)) && isStrictlyNegative64(substract64(current2, this.max));
    }
  }
  static isValidContext(_current, context15) {
    if (context15 === void 0) {
      return false;
    }
    if (typeof context15 !== "object" || context15 === null || !("sign" in context15) || !("data" in context15)) {
      throw new Error(`Invalid context type passed to ArrayInt64Arbitrary (#1)`);
    }
    return true;
  }
  retrieveBiasedRanges() {
    if (this.biasedRanges != null) {
      return this.biasedRanges;
    }
    if (isEqual64(this.min, this.max)) {
      this.biasedRanges = [{ min: this.min, max: this.max }];
      return this.biasedRanges;
    }
    const minStrictlySmallerZero = isStrictlyNegative64(this.min);
    const maxStrictlyGreaterZero = isStrictlyPositive64(this.max);
    if (minStrictlySmallerZero && maxStrictlyGreaterZero) {
      const logMin = logLike64(this.min);
      const logMax = logLike64(this.max);
      this.biasedRanges = [
        { min: logMin, max: logMax },
        { min: substract64(this.max, logMax), max: this.max },
        { min: this.min, max: substract64(this.min, logMin) }
      ];
    } else {
      const logGap = logLike64(substract64(this.max, this.min));
      const arbCloseToMin = { min: this.min, max: add642(this.min, logGap) };
      const arbCloseToMax = { min: substract64(this.max, logGap), max: this.max };
      this.biasedRanges = minStrictlySmallerZero ? [arbCloseToMax, arbCloseToMin] : [arbCloseToMin, arbCloseToMax];
    }
    return this.biasedRanges;
  }
};
function arrayInt64(min11, max13) {
  const arb = new ArrayInt64Arbitrary(min11, max13);
  return arb;
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/DoubleHelpers.js
var safeNegativeInfinity2 = Number.NEGATIVE_INFINITY;
var safePositiveInfinity3 = Number.POSITIVE_INFINITY;
var safeEpsilon = Number.EPSILON;
var INDEX_POSITIVE_INFINITY = { sign: 1, data: [2146435072, 0] };
var INDEX_NEGATIVE_INFINITY = { sign: -1, data: [2146435072, 1] };
var f64 = new Float64Array(1);
var u32 = new Uint32Array(f64.buffer, f64.byteOffset);
function bitCastDoubleToUInt64(f) {
  f64[0] = f;
  return [u32[1], u32[0]];
}
function decomposeDouble(d) {
  const { 0: hi, 1: lo } = bitCastDoubleToUInt64(d);
  const signBit = hi >>> 31;
  const exponentBits = hi >>> 20 & 2047;
  const significandBits = (hi & 1048575) * 4294967296 + lo;
  const exponent = exponentBits === 0 ? -1022 : exponentBits - 1023;
  let significand = exponentBits === 0 ? 0 : 1;
  significand += significandBits / 2 ** 52;
  significand *= signBit === 0 ? 1 : -1;
  return { exponent, significand };
}
function positiveNumberToInt64(n) {
  return [~~(n / 4294967296), n >>> 0];
}
function indexInDoubleFromDecomp(exponent, significand) {
  if (exponent === -1022) {
    const rescaledSignificand2 = significand * 2 ** 52;
    return positiveNumberToInt64(rescaledSignificand2);
  }
  const rescaledSignificand = (significand - 1) * 2 ** 52;
  const exponentOnlyHigh = (exponent + 1023) * 2 ** 20;
  const index = positiveNumberToInt64(rescaledSignificand);
  index[0] += exponentOnlyHigh;
  return index;
}
function doubleToIndex(d) {
  if (d === safePositiveInfinity3) {
    return clone64(INDEX_POSITIVE_INFINITY);
  }
  if (d === safeNegativeInfinity2) {
    return clone64(INDEX_NEGATIVE_INFINITY);
  }
  const decomp = decomposeDouble(d);
  const exponent = decomp.exponent;
  const significand = decomp.significand;
  if (d > 0 || d === 0 && 1 / d === safePositiveInfinity3) {
    return { sign: 1, data: indexInDoubleFromDecomp(exponent, significand) };
  } else {
    const indexOpposite = indexInDoubleFromDecomp(exponent, -significand);
    if (indexOpposite[1] === 4294967295) {
      indexOpposite[0] += 1;
      indexOpposite[1] = 0;
    } else {
      indexOpposite[1] += 1;
    }
    return { sign: -1, data: indexOpposite };
  }
}
function indexToDouble(index) {
  if (index.sign === -1) {
    const indexOpposite = { sign: 1, data: [index.data[0], index.data[1]] };
    if (indexOpposite.data[1] === 0) {
      indexOpposite.data[0] -= 1;
      indexOpposite.data[1] = 4294967295;
    } else {
      indexOpposite.data[1] -= 1;
    }
    return -indexToDouble(indexOpposite);
  }
  if (isEqual64(index, INDEX_POSITIVE_INFINITY)) {
    return safePositiveInfinity3;
  }
  if (index.data[0] < 2097152) {
    return (index.data[0] * 4294967296 + index.data[1]) * 2 ** -1074;
  }
  const postIndexHigh = index.data[0] - 2097152;
  const exponent = -1021 + (postIndexHigh >> 20);
  const significand = 1 + ((postIndexHigh & 1048575) * 2 ** 32 + index.data[1]) * safeEpsilon;
  return significand * 2 ** exponent;
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/FloatingOnlyHelpers.js
var safeNumberIsInteger5 = Number.isInteger;
var safeObjectIs7 = Object.is;
var safeNegativeInfinity3 = Number.NEGATIVE_INFINITY;
var safePositiveInfinity4 = Number.POSITIVE_INFINITY;
function refineConstraintsForFloatingOnly(constraints, maxValue, maxNonIntegerValue3, onlyIntegersAfterThisValue3) {
  const { noDefaultInfinity = false, minExcluded = false, maxExcluded = false, min: min11 = noDefaultInfinity ? -maxValue : safeNegativeInfinity3, max: max13 = noDefaultInfinity ? maxValue : safePositiveInfinity4 } = constraints;
  const effectiveMin = minExcluded ? min11 < -maxNonIntegerValue3 ? -onlyIntegersAfterThisValue3 : Math.max(min11, -maxNonIntegerValue3) : min11 === safeNegativeInfinity3 ? Math.max(min11, -onlyIntegersAfterThisValue3) : Math.max(min11, -maxNonIntegerValue3);
  const effectiveMax = maxExcluded ? max13 > maxNonIntegerValue3 ? onlyIntegersAfterThisValue3 : Math.min(max13, maxNonIntegerValue3) : max13 === safePositiveInfinity4 ? Math.min(max13, onlyIntegersAfterThisValue3) : Math.min(max13, maxNonIntegerValue3);
  const fullConstraints = {
    noDefaultInfinity: false,
    minExcluded: minExcluded || (min11 !== safeNegativeInfinity3 || minExcluded) && safeNumberIsInteger5(effectiveMin),
    maxExcluded: maxExcluded || (max13 !== safePositiveInfinity4 || maxExcluded) && safeNumberIsInteger5(effectiveMax),
    min: safeObjectIs7(effectiveMin, -0) ? 0 : effectiveMin,
    max: safeObjectIs7(effectiveMax, 0) ? -0 : effectiveMax,
    noNaN: constraints.noNaN || false
  };
  return fullConstraints;
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/DoubleOnlyHelpers.js
var safeNegativeInfinity4 = Number.NEGATIVE_INFINITY;
var safePositiveInfinity5 = Number.POSITIVE_INFINITY;
var safeMaxValue = Number.MAX_VALUE;
var maxNonIntegerValue = 45035996273704955e-1;
var onlyIntegersAfterThisValue = 4503599627370496;
function refineConstraintsForDoubleOnly(constraints) {
  return refineConstraintsForFloatingOnly(constraints, safeMaxValue, maxNonIntegerValue, onlyIntegersAfterThisValue);
}
function doubleOnlyMapper(value10) {
  return value10 === onlyIntegersAfterThisValue ? safePositiveInfinity5 : value10 === -onlyIntegersAfterThisValue ? safeNegativeInfinity4 : value10;
}
function doubleOnlyUnmapper(value10) {
  if (typeof value10 !== "number")
    throw new Error("Unsupported type");
  return value10 === safePositiveInfinity5 ? onlyIntegersAfterThisValue : value10 === safeNegativeInfinity4 ? -onlyIntegersAfterThisValue : value10;
}

// ../../node_modules/fast-check/lib/esm/arbitrary/double.js
var safeNumberIsInteger6 = Number.isInteger;
var safeNumberIsNaN5 = Number.isNaN;
var safeNegativeInfinity5 = Number.NEGATIVE_INFINITY;
var safePositiveInfinity6 = Number.POSITIVE_INFINITY;
var safeMaxValue2 = Number.MAX_VALUE;
var safeNaN2 = Number.NaN;
function safeDoubleToIndex(d, constraintsLabel) {
  if (safeNumberIsNaN5(d)) {
    throw new Error("fc.double constraints." + constraintsLabel + " must be a 64-bit float");
  }
  return doubleToIndex(d);
}
function unmapperDoubleToIndex(value10) {
  if (typeof value10 !== "number")
    throw new Error("Unsupported type");
  return doubleToIndex(value10);
}
function numberIsNotInteger(value10) {
  return !safeNumberIsInteger6(value10);
}
function anyDouble(constraints) {
  const { noDefaultInfinity = false, noNaN = false, minExcluded = false, maxExcluded = false, min: min11 = noDefaultInfinity ? -safeMaxValue2 : safeNegativeInfinity5, max: max13 = noDefaultInfinity ? safeMaxValue2 : safePositiveInfinity6 } = constraints;
  const minIndexRaw = safeDoubleToIndex(min11, "min");
  const minIndex = minExcluded ? add642(minIndexRaw, Unit64) : minIndexRaw;
  const maxIndexRaw = safeDoubleToIndex(max13, "max");
  const maxIndex = maxExcluded ? substract64(maxIndexRaw, Unit64) : maxIndexRaw;
  if (isStrictlySmaller64(maxIndex, minIndex)) {
    throw new Error("fc.double constraints.min must be smaller or equal to constraints.max");
  }
  if (noNaN) {
    return arrayInt64(minIndex, maxIndex).map(indexToDouble, unmapperDoubleToIndex);
  }
  const positiveMaxIdx = isStrictlyPositive64(maxIndex);
  const minIndexWithNaN = positiveMaxIdx ? minIndex : substract64(minIndex, Unit64);
  const maxIndexWithNaN = positiveMaxIdx ? add642(maxIndex, Unit64) : maxIndex;
  return arrayInt64(minIndexWithNaN, maxIndexWithNaN).map((index) => {
    if (isStrictlySmaller64(maxIndex, index) || isStrictlySmaller64(index, minIndex))
      return safeNaN2;
    else
      return indexToDouble(index);
  }, (value10) => {
    if (typeof value10 !== "number")
      throw new Error("Unsupported type");
    if (safeNumberIsNaN5(value10))
      return !isEqual64(maxIndex, maxIndexWithNaN) ? maxIndexWithNaN : minIndexWithNaN;
    return doubleToIndex(value10);
  });
}
function double(constraints = {}) {
  if (!constraints.noInteger) {
    return anyDouble(constraints);
  }
  return anyDouble(refineConstraintsForDoubleOnly(constraints)).map(doubleOnlyMapper, doubleOnlyUnmapper).filter(numberIsNotInteger);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/FloatHelpers.js
var safeNegativeInfinity6 = Number.NEGATIVE_INFINITY;
var safePositiveInfinity7 = Number.POSITIVE_INFINITY;
var MIN_VALUE_32 = 2 ** -126 * 2 ** -23;
var MAX_VALUE_32 = 2 ** 127 * (1 + (2 ** 23 - 1) / 2 ** 23);
var EPSILON_32 = 2 ** -23;
var INDEX_POSITIVE_INFINITY2 = 2139095040;
var INDEX_NEGATIVE_INFINITY2 = -2139095041;
var f32 = new Float32Array(1);
var u322 = new Uint32Array(f32.buffer, f32.byteOffset);
function bitCastFloatToUInt32(f) {
  f32[0] = f;
  return u322[0];
}
function decomposeFloat(f) {
  const bits = bitCastFloatToUInt32(f);
  const signBit = bits >>> 31;
  const exponentBits = bits >>> 23 & 255;
  const significandBits = bits & 8388607;
  const exponent = exponentBits === 0 ? -126 : exponentBits - 127;
  let significand = exponentBits === 0 ? 0 : 1;
  significand += significandBits / 2 ** 23;
  significand *= signBit === 0 ? 1 : -1;
  return { exponent, significand };
}
function indexInFloatFromDecomp(exponent, significand) {
  if (exponent === -126) {
    return significand * 8388608;
  }
  return (exponent + 127) * 8388608 + (significand - 1) * 8388608;
}
function floatToIndex(f) {
  if (f === safePositiveInfinity7) {
    return INDEX_POSITIVE_INFINITY2;
  }
  if (f === safeNegativeInfinity6) {
    return INDEX_NEGATIVE_INFINITY2;
  }
  const decomp = decomposeFloat(f);
  const exponent = decomp.exponent;
  const significand = decomp.significand;
  if (f > 0 || f === 0 && 1 / f === safePositiveInfinity7) {
    return indexInFloatFromDecomp(exponent, significand);
  } else {
    return -indexInFloatFromDecomp(exponent, -significand) - 1;
  }
}
function indexToFloat(index) {
  if (index < 0) {
    return -indexToFloat(-index - 1);
  }
  if (index === INDEX_POSITIVE_INFINITY2) {
    return safePositiveInfinity7;
  }
  if (index < 16777216) {
    return index * 2 ** -149;
  }
  const postIndex = index - 16777216;
  const exponent = -125 + (postIndex >> 23);
  const significand = 1 + (postIndex & 8388607) / 8388608;
  return significand * 2 ** exponent;
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/FloatOnlyHelpers.js
var safeNegativeInfinity7 = Number.NEGATIVE_INFINITY;
var safePositiveInfinity8 = Number.POSITIVE_INFINITY;
var safeMaxValue3 = MAX_VALUE_32;
var maxNonIntegerValue2 = 83886075e-1;
var onlyIntegersAfterThisValue2 = 8388608;
function refineConstraintsForFloatOnly(constraints) {
  return refineConstraintsForFloatingOnly(constraints, safeMaxValue3, maxNonIntegerValue2, onlyIntegersAfterThisValue2);
}
function floatOnlyMapper(value10) {
  return value10 === onlyIntegersAfterThisValue2 ? safePositiveInfinity8 : value10 === -onlyIntegersAfterThisValue2 ? safeNegativeInfinity7 : value10;
}
function floatOnlyUnmapper(value10) {
  if (typeof value10 !== "number")
    throw new Error("Unsupported type");
  return value10 === safePositiveInfinity8 ? onlyIntegersAfterThisValue2 : value10 === safeNegativeInfinity7 ? -onlyIntegersAfterThisValue2 : value10;
}

// ../../node_modules/fast-check/lib/esm/arbitrary/float.js
var safeNumberIsInteger7 = Number.isInteger;
var safeNumberIsNaN6 = Number.isNaN;
var safeMathFround = Math.fround;
var safeNegativeInfinity8 = Number.NEGATIVE_INFINITY;
var safePositiveInfinity9 = Number.POSITIVE_INFINITY;
var safeNaN3 = Number.NaN;
function safeFloatToIndex(f, constraintsLabel) {
  const conversionTrick = "you can convert any double to a 32-bit float by using `Math.fround(myDouble)`";
  const errorMessage = "fc.float constraints." + constraintsLabel + " must be a 32-bit float - " + conversionTrick;
  if (safeNumberIsNaN6(f) || safeMathFround(f) !== f) {
    throw new Error(errorMessage);
  }
  return floatToIndex(f);
}
function unmapperFloatToIndex(value10) {
  if (typeof value10 !== "number")
    throw new Error("Unsupported type");
  return floatToIndex(value10);
}
function numberIsNotInteger2(value10) {
  return !safeNumberIsInteger7(value10);
}
function anyFloat(constraints) {
  const { noDefaultInfinity = false, noNaN = false, minExcluded = false, maxExcluded = false, min: min11 = noDefaultInfinity ? -MAX_VALUE_32 : safeNegativeInfinity8, max: max13 = noDefaultInfinity ? MAX_VALUE_32 : safePositiveInfinity9 } = constraints;
  const minIndexRaw = safeFloatToIndex(min11, "min");
  const minIndex = minExcluded ? minIndexRaw + 1 : minIndexRaw;
  const maxIndexRaw = safeFloatToIndex(max13, "max");
  const maxIndex = maxExcluded ? maxIndexRaw - 1 : maxIndexRaw;
  if (minIndex > maxIndex) {
    throw new Error("fc.float constraints.min must be smaller or equal to constraints.max");
  }
  if (noNaN) {
    return integer({ min: minIndex, max: maxIndex }).map(indexToFloat, unmapperFloatToIndex);
  }
  const minIndexWithNaN = maxIndex > 0 ? minIndex : minIndex - 1;
  const maxIndexWithNaN = maxIndex > 0 ? maxIndex + 1 : maxIndex;
  return integer({ min: minIndexWithNaN, max: maxIndexWithNaN }).map((index) => {
    if (index > maxIndex || index < minIndex)
      return safeNaN3;
    else
      return indexToFloat(index);
  }, (value10) => {
    if (typeof value10 !== "number")
      throw new Error("Unsupported type");
    if (safeNumberIsNaN6(value10))
      return maxIndex !== maxIndexWithNaN ? maxIndexWithNaN : minIndexWithNaN;
    return floatToIndex(value10);
  });
}
function float(constraints = {}) {
  if (!constraints.noInteger) {
    return anyFloat(constraints);
  }
  return anyFloat(refineConstraintsForFloatOnly(constraints)).map(floatOnlyMapper, floatOnlyUnmapper).filter(numberIsNotInteger2);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/TextEscaper.js
function escapeForTemplateString(originalText) {
  return originalText.replace(/([$`\\])/g, "\\$1").replace(/\r/g, "\\r");
}
function escapeForMultilineComments(originalText) {
  return originalText.replace(/\*\//g, "*\\/");
}

// ../../node_modules/fast-check/lib/esm/utils/hash.js
var crc32Table = [
  0,
  1996959894,
  3993919788,
  2567524794,
  124634137,
  1886057615,
  3915621685,
  2657392035,
  249268274,
  2044508324,
  3772115230,
  2547177864,
  162941995,
  2125561021,
  3887607047,
  2428444049,
  498536548,
  1789927666,
  4089016648,
  2227061214,
  450548861,
  1843258603,
  4107580753,
  2211677639,
  325883990,
  1684777152,
  4251122042,
  2321926636,
  335633487,
  1661365465,
  4195302755,
  2366115317,
  997073096,
  1281953886,
  3579855332,
  2724688242,
  1006888145,
  1258607687,
  3524101629,
  2768942443,
  901097722,
  1119000684,
  3686517206,
  2898065728,
  853044451,
  1172266101,
  3705015759,
  2882616665,
  651767980,
  1373503546,
  3369554304,
  3218104598,
  565507253,
  1454621731,
  3485111705,
  3099436303,
  671266974,
  1594198024,
  3322730930,
  2970347812,
  795835527,
  1483230225,
  3244367275,
  3060149565,
  1994146192,
  31158534,
  2563907772,
  4023717930,
  1907459465,
  112637215,
  2680153253,
  3904427059,
  2013776290,
  251722036,
  2517215374,
  3775830040,
  2137656763,
  141376813,
  2439277719,
  3865271297,
  1802195444,
  476864866,
  2238001368,
  4066508878,
  1812370925,
  453092731,
  2181625025,
  4111451223,
  1706088902,
  314042704,
  2344532202,
  4240017532,
  1658658271,
  366619977,
  2362670323,
  4224994405,
  1303535960,
  984961486,
  2747007092,
  3569037538,
  1256170817,
  1037604311,
  2765210733,
  3554079995,
  1131014506,
  879679996,
  2909243462,
  3663771856,
  1141124467,
  855842277,
  2852801631,
  3708648649,
  1342533948,
  654459306,
  3188396048,
  3373015174,
  1466479909,
  544179635,
  3110523913,
  3462522015,
  1591671054,
  702138776,
  2966460450,
  3352799412,
  1504918807,
  783551873,
  3082640443,
  3233442989,
  3988292384,
  2596254646,
  62317068,
  1957810842,
  3939845945,
  2647816111,
  81470997,
  1943803523,
  3814918930,
  2489596804,
  225274430,
  2053790376,
  3826175755,
  2466906013,
  167816743,
  2097651377,
  4027552580,
  2265490386,
  503444072,
  1762050814,
  4150417245,
  2154129355,
  426522225,
  1852507879,
  4275313526,
  2312317920,
  282753626,
  1742555852,
  4189708143,
  2394877945,
  397917763,
  1622183637,
  3604390888,
  2714866558,
  953729732,
  1340076626,
  3518719985,
  2797360999,
  1068828381,
  1219638859,
  3624741850,
  2936675148,
  906185462,
  1090812512,
  3747672003,
  2825379669,
  829329135,
  1181335161,
  3412177804,
  3160834842,
  628085408,
  1382605366,
  3423369109,
  3138078467,
  570562233,
  1426400815,
  3317316542,
  2998733608,
  733239954,
  1555261956,
  3268935591,
  3050360625,
  752459403,
  1541320221,
  2607071920,
  3965973030,
  1969922972,
  40735498,
  2617837225,
  3943577151,
  1913087877,
  83908371,
  2512341634,
  3803740692,
  2075208622,
  213261112,
  2463272603,
  3855990285,
  2094854071,
  198958881,
  2262029012,
  4057260610,
  1759359992,
  534414190,
  2176718541,
  4139329115,
  1873836001,
  414664567,
  2282248934,
  4279200368,
  1711684554,
  285281116,
  2405801727,
  4167216745,
  1634467795,
  376229701,
  2685067896,
  3608007406,
  1308918612,
  956543938,
  2808555105,
  3495958263,
  1231636301,
  1047427035,
  2932959818,
  3654703836,
  1088359270,
  936918e3,
  2847714899,
  3736837829,
  1202900863,
  817233897,
  3183342108,
  3401237130,
  1404277552,
  615818150,
  3134207493,
  3453421203,
  1423857449,
  601450431,
  3009837614,
  3294710456,
  1567103746,
  711928724,
  3020668471,
  3272380065,
  1510334235,
  755167117
];
function hash2(repr) {
  let crc = 4294967295;
  for (let idx = 0; idx < repr.length; ++idx) {
    const c = safeCharCodeAt(repr, idx);
    if (c < 128) {
      crc = crc32Table[crc & 255 ^ c] ^ crc >> 8;
    } else if (c < 2048) {
      crc = crc32Table[crc & 255 ^ (192 | c >> 6 & 31)] ^ crc >> 8;
      crc = crc32Table[crc & 255 ^ (128 | c & 63)] ^ crc >> 8;
    } else if (c >= 55296 && c < 57344) {
      const cNext = safeCharCodeAt(repr, ++idx);
      if (c >= 56320 || cNext < 56320 || cNext > 57343 || Number.isNaN(cNext)) {
        idx -= 1;
        crc = crc32Table[crc & 255 ^ 239] ^ crc >> 8;
        crc = crc32Table[crc & 255 ^ 191] ^ crc >> 8;
        crc = crc32Table[crc & 255 ^ 189] ^ crc >> 8;
      } else {
        const c1 = (c & 1023) + 64;
        const c2 = cNext & 1023;
        crc = crc32Table[crc & 255 ^ (240 | c1 >> 8 & 7)] ^ crc >> 8;
        crc = crc32Table[crc & 255 ^ (128 | c1 >> 2 & 63)] ^ crc >> 8;
        crc = crc32Table[crc & 255 ^ (128 | c2 >> 6 & 15 | (c1 & 3) << 4)] ^ crc >> 8;
        crc = crc32Table[crc & 255 ^ (128 | c2 & 63)] ^ crc >> 8;
      }
    } else {
      crc = crc32Table[crc & 255 ^ (224 | c >> 12 & 15)] ^ crc >> 8;
      crc = crc32Table[crc & 255 ^ (128 | c >> 6 & 63)] ^ crc >> 8;
      crc = crc32Table[crc & 255 ^ (128 | c & 63)] ^ crc >> 8;
    }
  }
  return (crc | 0) + 2147483648;
}

// ../../node_modules/fast-check/lib/esm/arbitrary/noShrink.js
function noShrink(arb) {
  return arb.noShrink();
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/builders/CompareFunctionArbitraryBuilder.js
var safeObjectAssign6 = Object.assign;
var safeObjectKeys3 = Object.keys;
function buildCompareFunctionArbitrary(cmp) {
  return tuple4(noShrink(integer()), noShrink(integer({ min: 1, max: 4294967295 }))).map(([seed, hashEnvSize]) => {
    const producer = () => {
      const recorded = {};
      const f = (a, b) => {
        const reprA = stringify(a);
        const reprB = stringify(b);
        const hA = hash2(`${seed}${reprA}`) % hashEnvSize;
        const hB = hash2(`${seed}${reprB}`) % hashEnvSize;
        const val = cmp(hA, hB);
        recorded[`[${reprA},${reprB}]`] = val;
        return val;
      };
      return safeObjectAssign6(f, {
        toString: () => {
          const seenValues = safeObjectKeys3(recorded).sort().map((k) => `${k} => ${stringify(recorded[k])}`).map((line) => `/* ${escapeForMultilineComments(line)} */`);
          return `function(a, b) {
  // With hash and stringify coming from fast-check${seenValues.length !== 0 ? `
  ${safeJoin(seenValues, "\n  ")}` : ""}
  const cmp = ${cmp};
  const hA = hash('${seed}' + stringify(a)) % ${hashEnvSize};
  const hB = hash('${seed}' + stringify(b)) % ${hashEnvSize};
  return cmp(hA, hB);
}`;
        },
        [cloneMethod]: producer
      });
    };
    return producer();
  });
}

// ../../node_modules/fast-check/lib/esm/arbitrary/compareBooleanFunc.js
var safeObjectAssign7 = Object.assign;
function compareBooleanFunc() {
  return buildCompareFunctionArbitrary(safeObjectAssign7((hA, hB) => hA < hB, {
    toString() {
      return "(hA, hB) => hA < hB";
    }
  }));
}

// ../../node_modules/fast-check/lib/esm/arbitrary/compareFunc.js
var safeObjectAssign8 = Object.assign;
function compareFunc() {
  return buildCompareFunctionArbitrary(safeObjectAssign8((hA, hB) => hA - hB, {
    toString() {
      return "(hA, hB) => hA - hB";
    }
  }));
}

// ../../node_modules/fast-check/lib/esm/arbitrary/func.js
var safeObjectDefineProperties = Object.defineProperties;
var safeObjectKeys4 = Object.keys;
function func(arb) {
  return tuple4(array4(arb, { minLength: 1 }), noShrink(integer())).map(([outs, seed]) => {
    const producer = () => {
      const recorded = {};
      const f = (...args2) => {
        const repr = stringify(args2);
        const val = outs[hash2(`${seed}${repr}`) % outs.length];
        recorded[repr] = val;
        return hasCloneMethod(val) ? val[cloneMethod]() : val;
      };
      function prettyPrint2(stringifiedOuts) {
        const seenValues = safeMap(safeMap(safeSort(safeObjectKeys4(recorded)), (k) => `${k} => ${stringify(recorded[k])}`), (line) => `/* ${escapeForMultilineComments(line)} */`);
        return `function(...args) {
  // With hash and stringify coming from fast-check${seenValues.length !== 0 ? `
  ${seenValues.join("\n  ")}` : ""}
  const outs = ${stringifiedOuts};
  return outs[hash('${seed}' + stringify(args)) % outs.length];
}`;
      }
      return safeObjectDefineProperties(f, {
        toString: { value: () => prettyPrint2(stringify(outs)) },
        [toStringMethod]: { value: () => prettyPrint2(stringify(outs)) },
        [asyncToStringMethod]: { value: async () => prettyPrint2(await asyncStringify(outs)) },
        [cloneMethod]: { value: producer, configurable: true }
      });
    };
    return producer();
  });
}

// ../../node_modules/fast-check/lib/esm/arbitrary/maxSafeInteger.js
var safeMinSafeInteger = Number.MIN_SAFE_INTEGER;
var safeMaxSafeInteger2 = Number.MAX_SAFE_INTEGER;
function maxSafeInteger() {
  return new IntegerArbitrary(safeMinSafeInteger, safeMaxSafeInteger2);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/maxSafeNat.js
var safeMaxSafeInteger3 = Number.MAX_SAFE_INTEGER;
function maxSafeNat() {
  return new IntegerArbitrary(0, safeMaxSafeInteger3);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/NatToStringifiedNat.js
var safeNumberParseInt = Number.parseInt;
function natToStringifiedNatMapper(options) {
  const [style, v] = options;
  switch (style) {
    case "oct":
      return `0${safeNumberToString(v, 8)}`;
    case "hex":
      return `0x${safeNumberToString(v, 16)}`;
    case "dec":
    default:
      return `${v}`;
  }
}
function tryParseStringifiedNat(stringValue, radix) {
  const parsedNat = safeNumberParseInt(stringValue, radix);
  if (safeNumberToString(parsedNat, radix) !== stringValue) {
    throw new Error("Invalid value");
  }
  return parsedNat;
}
function natToStringifiedNatUnmapper(value10) {
  if (typeof value10 !== "string") {
    throw new Error("Invalid type");
  }
  if (value10.length >= 2 && value10[0] === "0") {
    if (value10[1] === "x") {
      return ["hex", tryParseStringifiedNat(safeSubstring(value10, 2), 16)];
    }
    return ["oct", tryParseStringifiedNat(safeSubstring(value10, 1), 8)];
  }
  return ["dec", tryParseStringifiedNat(value10, 10)];
}

// ../../node_modules/fast-check/lib/esm/arbitrary/ipV4.js
function dotJoinerMapper(data) {
  return safeJoin(data, ".");
}
function dotJoinerUnmapper(value10) {
  if (typeof value10 !== "string") {
    throw new Error("Invalid type");
  }
  return safeMap(safeSplit(value10, "."), (v) => tryParseStringifiedNat(v, 10));
}
function ipV4() {
  return tuple4(nat(255), nat(255), nat(255), nat(255)).map(dotJoinerMapper, dotJoinerUnmapper);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/builders/StringifiedNatArbitraryBuilder.js
function buildStringifiedNatArbitrary(maxValue) {
  return tuple4(constantFrom("dec", "oct", "hex"), nat(maxValue)).map(natToStringifiedNatMapper, natToStringifiedNatUnmapper);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/ipV4Extended.js
function dotJoinerMapper2(data) {
  return safeJoin(data, ".");
}
function dotJoinerUnmapper2(value10) {
  if (typeof value10 !== "string") {
    throw new Error("Invalid type");
  }
  return safeSplit(value10, ".");
}
function ipV4Extended() {
  return oneof(tuple4(buildStringifiedNatArbitrary(255), buildStringifiedNatArbitrary(255), buildStringifiedNatArbitrary(255), buildStringifiedNatArbitrary(255)).map(dotJoinerMapper2, dotJoinerUnmapper2), tuple4(buildStringifiedNatArbitrary(255), buildStringifiedNatArbitrary(255), buildStringifiedNatArbitrary(65535)).map(dotJoinerMapper2, dotJoinerUnmapper2), tuple4(buildStringifiedNatArbitrary(255), buildStringifiedNatArbitrary(16777215)).map(dotJoinerMapper2, dotJoinerUnmapper2), buildStringifiedNatArbitrary(4294967295));
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/CodePointsToString.js
function codePointsToStringMapper(tab) {
  return safeJoin(tab, "");
}
function codePointsToStringUnmapper(value10) {
  if (typeof value10 !== "string") {
    throw new Error("Cannot unmap the passed value");
  }
  return [...value10];
}

// ../../node_modules/fast-check/lib/esm/arbitrary/hexaString.js
var safeObjectAssign9 = Object.assign;
function hexaString(constraints = {}) {
  const charArbitrary = hexa();
  const experimentalCustomSlices = createSlicesForStringLegacy(charArbitrary, codePointsToStringUnmapper);
  const enrichedConstraints = safeObjectAssign9(safeObjectAssign9({}, constraints), {
    experimentalCustomSlices
  });
  return array4(charArbitrary, enrichedConstraints).map(codePointsToStringMapper, codePointsToStringUnmapper);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/EntitiesToIPv6.js
function readBh(value10) {
  if (value10.length === 0)
    return [];
  else
    return safeSplit(value10, ":");
}
function extractEhAndL(value10) {
  const valueSplits = safeSplit(value10, ":");
  if (valueSplits.length >= 2 && valueSplits[valueSplits.length - 1].length <= 4) {
    return [
      safeSlice(valueSplits, 0, valueSplits.length - 2),
      `${valueSplits[valueSplits.length - 2]}:${valueSplits[valueSplits.length - 1]}`
    ];
  }
  return [safeSlice(valueSplits, 0, valueSplits.length - 1), valueSplits[valueSplits.length - 1]];
}
function fullySpecifiedMapper(data) {
  return `${safeJoin(data[0], ":")}:${data[1]}`;
}
function fullySpecifiedUnmapper(value10) {
  if (typeof value10 !== "string")
    throw new Error("Invalid type");
  return extractEhAndL(value10);
}
function onlyTrailingMapper(data) {
  return `::${safeJoin(data[0], ":")}:${data[1]}`;
}
function onlyTrailingUnmapper(value10) {
  if (typeof value10 !== "string")
    throw new Error("Invalid type");
  if (!safeStartsWith(value10, "::"))
    throw new Error("Invalid value");
  return extractEhAndL(safeSubstring(value10, 2));
}
function multiTrailingMapper(data) {
  return `${safeJoin(data[0], ":")}::${safeJoin(data[1], ":")}:${data[2]}`;
}
function multiTrailingUnmapper(value10) {
  if (typeof value10 !== "string")
    throw new Error("Invalid type");
  const [bhString, trailingString] = safeSplit(value10, "::", 2);
  const [eh, l] = extractEhAndL(trailingString);
  return [readBh(bhString), eh, l];
}
function multiTrailingMapperOne(data) {
  return multiTrailingMapper([data[0], [data[1]], data[2]]);
}
function multiTrailingUnmapperOne(value10) {
  const out = multiTrailingUnmapper(value10);
  return [out[0], safeJoin(out[1], ":"), out[2]];
}
function singleTrailingMapper(data) {
  return `${safeJoin(data[0], ":")}::${data[1]}`;
}
function singleTrailingUnmapper(value10) {
  if (typeof value10 !== "string")
    throw new Error("Invalid type");
  const [bhString, trailing] = safeSplit(value10, "::", 2);
  return [readBh(bhString), trailing];
}
function noTrailingMapper(data) {
  return `${safeJoin(data[0], ":")}::`;
}
function noTrailingUnmapper(value10) {
  if (typeof value10 !== "string")
    throw new Error("Invalid type");
  if (!safeEndsWith(value10, "::"))
    throw new Error("Invalid value");
  return [readBh(safeSubstring(value10, 0, value10.length - 2))];
}

// ../../node_modules/fast-check/lib/esm/arbitrary/ipV6.js
function h16sTol32Mapper([a, b]) {
  return `${a}:${b}`;
}
function h16sTol32Unmapper(value10) {
  if (typeof value10 !== "string")
    throw new Error("Invalid type");
  if (!value10.includes(":"))
    throw new Error("Invalid value");
  return value10.split(":", 2);
}
function ipV6() {
  const h16Arb = hexaString({ minLength: 1, maxLength: 4, size: "max" });
  const ls32Arb = oneof(tuple4(h16Arb, h16Arb).map(h16sTol32Mapper, h16sTol32Unmapper), ipV4());
  return oneof(tuple4(array4(h16Arb, { minLength: 6, maxLength: 6, size: "max" }), ls32Arb).map(fullySpecifiedMapper, fullySpecifiedUnmapper), tuple4(array4(h16Arb, { minLength: 5, maxLength: 5, size: "max" }), ls32Arb).map(onlyTrailingMapper, onlyTrailingUnmapper), tuple4(array4(h16Arb, { minLength: 0, maxLength: 1, size: "max" }), array4(h16Arb, { minLength: 4, maxLength: 4, size: "max" }), ls32Arb).map(multiTrailingMapper, multiTrailingUnmapper), tuple4(array4(h16Arb, { minLength: 0, maxLength: 2, size: "max" }), array4(h16Arb, { minLength: 3, maxLength: 3, size: "max" }), ls32Arb).map(multiTrailingMapper, multiTrailingUnmapper), tuple4(array4(h16Arb, { minLength: 0, maxLength: 3, size: "max" }), array4(h16Arb, { minLength: 2, maxLength: 2, size: "max" }), ls32Arb).map(multiTrailingMapper, multiTrailingUnmapper), tuple4(array4(h16Arb, { minLength: 0, maxLength: 4, size: "max" }), h16Arb, ls32Arb).map(multiTrailingMapperOne, multiTrailingUnmapperOne), tuple4(array4(h16Arb, { minLength: 0, maxLength: 5, size: "max" }), ls32Arb).map(singleTrailingMapper, singleTrailingUnmapper), tuple4(array4(h16Arb, { minLength: 0, maxLength: 6, size: "max" }), h16Arb).map(singleTrailingMapper, singleTrailingUnmapper), tuple4(array4(h16Arb, { minLength: 0, maxLength: 7, size: "max" })).map(noTrailingMapper, noTrailingUnmapper));
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/LazyArbitrary.js
var LazyArbitrary = class extends Arbitrary {
  constructor(name) {
    super();
    this.name = name;
    this.underlying = null;
  }
  generate(mrng, biasFactor) {
    if (!this.underlying) {
      throw new Error(`Lazy arbitrary ${JSON.stringify(this.name)} not correctly initialized`);
    }
    return this.underlying.generate(mrng, biasFactor);
  }
  canShrinkWithoutContext(value10) {
    if (!this.underlying) {
      throw new Error(`Lazy arbitrary ${JSON.stringify(this.name)} not correctly initialized`);
    }
    return this.underlying.canShrinkWithoutContext(value10);
  }
  shrink(value10, context15) {
    if (!this.underlying) {
      throw new Error(`Lazy arbitrary ${JSON.stringify(this.name)} not correctly initialized`);
    }
    return this.underlying.shrink(value10, context15);
  }
};

// ../../node_modules/fast-check/lib/esm/arbitrary/letrec.js
var safeObjectCreate2 = Object.create;
function letrec(builder) {
  const lazyArbs = safeObjectCreate2(null);
  const tie = (key) => {
    if (!safeHasOwnProperty(lazyArbs, key)) {
      lazyArbs[key] = new LazyArbitrary(String(key));
    }
    return lazyArbs[key];
  };
  const strictArbs = builder(tie);
  for (const key in strictArbs) {
    if (!safeHasOwnProperty(strictArbs, key)) {
      continue;
    }
    const lazyAtKey = lazyArbs[key];
    const lazyArb = lazyAtKey !== void 0 ? lazyAtKey : new LazyArbitrary(key);
    lazyArb.underlying = strictArbs[key];
    lazyArbs[key] = lazyArb;
  }
  return strictArbs;
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/WordsToLorem.js
function wordsToJoinedStringMapper(words) {
  return safeJoin(safeMap(words, (w) => w[w.length - 1] === "," ? safeSubstring(w, 0, w.length - 1) : w), " ");
}
function wordsToJoinedStringUnmapperFor(wordsArbitrary) {
  return function wordsToJoinedStringUnmapper(value10) {
    if (typeof value10 !== "string") {
      throw new Error("Unsupported type");
    }
    const words = [];
    for (const candidate of safeSplit(value10, " ")) {
      if (wordsArbitrary.canShrinkWithoutContext(candidate))
        safePush(words, candidate);
      else if (wordsArbitrary.canShrinkWithoutContext(candidate + ","))
        safePush(words, candidate + ",");
      else
        throw new Error("Unsupported word");
    }
    return words;
  };
}
function wordsToSentenceMapper(words) {
  let sentence = safeJoin(words, " ");
  if (sentence[sentence.length - 1] === ",") {
    sentence = safeSubstring(sentence, 0, sentence.length - 1);
  }
  return safeToUpperCase(sentence[0]) + safeSubstring(sentence, 1) + ".";
}
function wordsToSentenceUnmapperFor(wordsArbitrary) {
  return function wordsToSentenceUnmapper(value10) {
    if (typeof value10 !== "string") {
      throw new Error("Unsupported type");
    }
    if (value10.length < 2 || value10[value10.length - 1] !== "." || value10[value10.length - 2] === "," || safeToUpperCase(safeToLowerCase(value10[0])) !== value10[0]) {
      throw new Error("Unsupported value");
    }
    const adaptedValue = safeToLowerCase(value10[0]) + safeSubstring(value10, 1, value10.length - 1);
    const words = [];
    const candidates = safeSplit(adaptedValue, " ");
    for (let idx = 0; idx !== candidates.length; ++idx) {
      const candidate = candidates[idx];
      if (wordsArbitrary.canShrinkWithoutContext(candidate))
        safePush(words, candidate);
      else if (idx === candidates.length - 1 && wordsArbitrary.canShrinkWithoutContext(candidate + ","))
        safePush(words, candidate + ",");
      else
        throw new Error("Unsupported word");
    }
    return words;
  };
}
function sentencesToParagraphMapper(sentences) {
  return safeJoin(sentences, " ");
}
function sentencesToParagraphUnmapper(value10) {
  if (typeof value10 !== "string") {
    throw new Error("Unsupported type");
  }
  const sentences = safeSplit(value10, ". ");
  for (let idx = 0; idx < sentences.length - 1; ++idx) {
    sentences[idx] += ".";
  }
  return sentences;
}

// ../../node_modules/fast-check/lib/esm/arbitrary/lorem.js
var h = (v, w) => {
  return { arbitrary: constant2(v), weight: w };
};
function loremWord() {
  return oneof(h("non", 6), h("adipiscing", 5), h("ligula", 5), h("enim", 5), h("pellentesque", 5), h("in", 5), h("augue", 5), h("et", 5), h("nulla", 5), h("lorem", 4), h("sit", 4), h("sed", 4), h("diam", 4), h("fermentum", 4), h("ut", 4), h("eu", 4), h("aliquam", 4), h("mauris", 4), h("vitae", 4), h("felis", 4), h("ipsum", 3), h("dolor", 3), h("amet,", 3), h("elit", 3), h("euismod", 3), h("mi", 3), h("orci", 3), h("erat", 3), h("praesent", 3), h("egestas", 3), h("leo", 3), h("vel", 3), h("sapien", 3), h("integer", 3), h("curabitur", 3), h("convallis", 3), h("purus", 3), h("risus", 2), h("suspendisse", 2), h("lectus", 2), h("nec,", 2), h("ultricies", 2), h("sed,", 2), h("cras", 2), h("elementum", 2), h("ultrices", 2), h("maecenas", 2), h("massa,", 2), h("varius", 2), h("a,", 2), h("semper", 2), h("proin", 2), h("nec", 2), h("nisl", 2), h("amet", 2), h("duis", 2), h("congue", 2), h("libero", 2), h("vestibulum", 2), h("pede", 2), h("blandit", 2), h("sodales", 2), h("ante", 2), h("nibh", 2), h("ac", 2), h("aenean", 2), h("massa", 2), h("suscipit", 2), h("sollicitudin", 2), h("fusce", 2), h("tempus", 2), h("aliquam,", 2), h("nunc", 2), h("ullamcorper", 2), h("rhoncus", 2), h("metus", 2), h("faucibus,", 2), h("justo", 2), h("magna", 2), h("at", 2), h("tincidunt", 2), h("consectetur", 1), h("tortor,", 1), h("dignissim", 1), h("congue,", 1), h("non,", 1), h("porttitor,", 1), h("nonummy", 1), h("molestie,", 1), h("est", 1), h("eleifend", 1), h("mi,", 1), h("arcu", 1), h("scelerisque", 1), h("vitae,", 1), h("consequat", 1), h("in,", 1), h("pretium", 1), h("volutpat", 1), h("pharetra", 1), h("tempor", 1), h("bibendum", 1), h("odio", 1), h("dui", 1), h("primis", 1), h("faucibus", 1), h("luctus", 1), h("posuere", 1), h("cubilia", 1), h("curae,", 1), h("hendrerit", 1), h("velit", 1), h("mauris,", 1), h("gravida", 1), h("ornare", 1), h("ut,", 1), h("pulvinar", 1), h("varius,", 1), h("turpis", 1), h("nibh,", 1), h("eros", 1), h("id", 1), h("aliquet", 1), h("quis", 1), h("lobortis", 1), h("consectetuer", 1), h("morbi", 1), h("vehicula", 1), h("tortor", 1), h("tellus,", 1), h("id,", 1), h("eu,", 1), h("quam", 1), h("feugiat,", 1), h("posuere,", 1), h("iaculis", 1), h("lectus,", 1), h("tristique", 1), h("mollis,", 1), h("nisl,", 1), h("vulputate", 1), h("sem", 1), h("vivamus", 1), h("placerat", 1), h("imperdiet", 1), h("cursus", 1), h("rutrum", 1), h("iaculis,", 1), h("augue,", 1), h("lacus", 1));
}
function lorem(constraints = {}) {
  const { maxCount, mode = "words", size: size40 } = constraints;
  if (maxCount !== void 0 && maxCount < 1) {
    throw new Error(`lorem has to produce at least one word/sentence`);
  }
  const wordArbitrary = loremWord();
  if (mode === "sentences") {
    const sentence = array4(wordArbitrary, { minLength: 1, size: "small" }).map(wordsToSentenceMapper, wordsToSentenceUnmapperFor(wordArbitrary));
    return array4(sentence, { minLength: 1, maxLength: maxCount, size: size40 }).map(sentencesToParagraphMapper, sentencesToParagraphUnmapper);
  } else {
    return array4(wordArbitrary, { minLength: 1, maxLength: maxCount, size: size40 }).map(wordsToJoinedStringMapper, wordsToJoinedStringUnmapperFor(wordArbitrary));
  }
}

// ../../node_modules/fast-check/lib/esm/arbitrary/memo.js
var contextRemainingDepth = 10;
function memo(builder) {
  const previous2 = {};
  return (maxDepth) => {
    const n = maxDepth !== void 0 ? maxDepth : contextRemainingDepth;
    if (!safeHasOwnProperty(previous2, n)) {
      const prev = contextRemainingDepth;
      contextRemainingDepth = n - 1;
      previous2[n] = builder(n);
      contextRemainingDepth = prev;
    }
    return previous2[n];
  };
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ToggleFlags.js
function countToggledBits(n) {
  let count9 = 0;
  while (n > SBigInt(0)) {
    if (n & SBigInt(1))
      ++count9;
    n >>= SBigInt(1);
  }
  return count9;
}
function computeNextFlags(flags, nextSize) {
  const allowedMask = (SBigInt(1) << SBigInt(nextSize)) - SBigInt(1);
  const preservedFlags = flags & allowedMask;
  let numMissingFlags = countToggledBits(flags - preservedFlags);
  let nFlags = preservedFlags;
  for (let mask = SBigInt(1); mask <= allowedMask && numMissingFlags !== 0; mask <<= SBigInt(1)) {
    if (!(nFlags & mask)) {
      nFlags |= mask;
      --numMissingFlags;
    }
  }
  return nFlags;
}
function computeTogglePositions(chars, toggleCase) {
  const positions = [];
  for (let idx = chars.length - 1; idx !== -1; --idx) {
    if (toggleCase(chars[idx]) !== chars[idx])
      safePush(positions, idx);
  }
  return positions;
}
function computeFlagsFromChars(untoggledChars, toggledChars, togglePositions) {
  let flags = SBigInt(0);
  for (let idx = 0, mask = SBigInt(1); idx !== togglePositions.length; ++idx, mask <<= SBigInt(1)) {
    if (untoggledChars[togglePositions[idx]] !== toggledChars[togglePositions[idx]]) {
      flags |= mask;
    }
  }
  return flags;
}
function applyFlagsOnChars(chars, flags, togglePositions, toggleCase) {
  for (let idx = 0, mask = SBigInt(1); idx !== togglePositions.length; ++idx, mask <<= SBigInt(1)) {
    if (flags & mask)
      chars[togglePositions[idx]] = toggleCase(chars[togglePositions[idx]]);
  }
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/MixedCaseArbitrary.js
var MixedCaseArbitrary = class extends Arbitrary {
  constructor(stringArb, toggleCase, untoggleAll) {
    super();
    this.stringArb = stringArb;
    this.toggleCase = toggleCase;
    this.untoggleAll = untoggleAll;
  }
  buildContextFor(rawStringValue, flagsValue) {
    return {
      rawString: rawStringValue.value,
      rawStringContext: rawStringValue.context,
      flags: flagsValue.value,
      flagsContext: flagsValue.context
    };
  }
  generate(mrng, biasFactor) {
    const rawStringValue = this.stringArb.generate(mrng, biasFactor);
    const chars = [...rawStringValue.value];
    const togglePositions = computeTogglePositions(chars, this.toggleCase);
    const flagsArb = bigUintN(togglePositions.length);
    const flagsValue = flagsArb.generate(mrng, void 0);
    applyFlagsOnChars(chars, flagsValue.value, togglePositions, this.toggleCase);
    return new Value(safeJoin(chars, ""), this.buildContextFor(rawStringValue, flagsValue));
  }
  canShrinkWithoutContext(value10) {
    if (typeof value10 !== "string") {
      return false;
    }
    return this.untoggleAll !== void 0 ? this.stringArb.canShrinkWithoutContext(this.untoggleAll(value10)) : this.stringArb.canShrinkWithoutContext(value10);
  }
  shrink(value10, context15) {
    let contextSafe;
    if (context15 !== void 0) {
      contextSafe = context15;
    } else {
      if (this.untoggleAll !== void 0) {
        const untoggledValue = this.untoggleAll(value10);
        const valueChars = [...value10];
        const untoggledValueChars = [...untoggledValue];
        const togglePositions = computeTogglePositions(untoggledValueChars, this.toggleCase);
        contextSafe = {
          rawString: untoggledValue,
          rawStringContext: void 0,
          flags: computeFlagsFromChars(untoggledValueChars, valueChars, togglePositions),
          flagsContext: void 0
        };
      } else {
        contextSafe = {
          rawString: value10,
          rawStringContext: void 0,
          flags: SBigInt(0),
          flagsContext: void 0
        };
      }
    }
    const rawString = contextSafe.rawString;
    const flags = contextSafe.flags;
    return this.stringArb.shrink(rawString, contextSafe.rawStringContext).map((nRawStringValue) => {
      const nChars = [...nRawStringValue.value];
      const nTogglePositions = computeTogglePositions(nChars, this.toggleCase);
      const nFlags = computeNextFlags(flags, nTogglePositions.length);
      applyFlagsOnChars(nChars, nFlags, nTogglePositions, this.toggleCase);
      return new Value(safeJoin(nChars, ""), this.buildContextFor(nRawStringValue, new Value(nFlags, void 0)));
    }).join(makeLazy(() => {
      const chars = [...rawString];
      const togglePositions = computeTogglePositions(chars, this.toggleCase);
      return bigUintN(togglePositions.length).shrink(flags, contextSafe.flagsContext).map((nFlagsValue) => {
        const nChars = safeSlice(chars);
        applyFlagsOnChars(nChars, nFlagsValue.value, togglePositions, this.toggleCase);
        return new Value(safeJoin(nChars, ""), this.buildContextFor(new Value(rawString, contextSafe.rawStringContext), nFlagsValue));
      });
    }));
  }
};

// ../../node_modules/fast-check/lib/esm/arbitrary/mixedCase.js
function defaultToggleCase(rawChar) {
  const upper = safeToUpperCase(rawChar);
  if (upper !== rawChar)
    return upper;
  return safeToLowerCase(rawChar);
}
function mixedCase(stringArb, constraints) {
  if (typeof SBigInt === "undefined") {
    throw new SError(`mixedCase requires BigInt support`);
  }
  const toggleCase = constraints && constraints.toggleCase || defaultToggleCase;
  const untoggleAll = constraints && constraints.untoggleAll;
  return new MixedCaseArbitrary(stringArb, toggleCase, untoggleAll);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/float32Array.js
function toTypedMapper(data) {
  return SFloat32Array.from(data);
}
function fromTypedUnmapper(value10) {
  if (!(value10 instanceof SFloat32Array))
    throw new Error("Unexpected type");
  return [...value10];
}
function float32Array(constraints = {}) {
  return array4(float(constraints), constraints).map(toTypedMapper, fromTypedUnmapper);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/float64Array.js
function toTypedMapper2(data) {
  return SFloat64Array.from(data);
}
function fromTypedUnmapper2(value10) {
  if (!(value10 instanceof SFloat64Array))
    throw new Error("Unexpected type");
  return [...value10];
}
function float64Array(constraints = {}) {
  return array4(double(constraints), constraints).map(toTypedMapper2, fromTypedUnmapper2);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/builders/TypedIntArrayArbitraryBuilder.js
var __rest = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
function typedIntArrayArbitraryArbitraryBuilder(constraints, defaultMin, defaultMax, TypedArrayClass, arbitraryBuilder) {
  const generatorName = TypedArrayClass.name;
  const { min: min11 = defaultMin, max: max13 = defaultMax } = constraints, arrayConstraints = __rest(constraints, ["min", "max"]);
  if (min11 > max13) {
    throw new Error(`Invalid range passed to ${generatorName}: min must be lower than or equal to max`);
  }
  if (min11 < defaultMin) {
    throw new Error(`Invalid min value passed to ${generatorName}: min must be greater than or equal to ${defaultMin}`);
  }
  if (max13 > defaultMax) {
    throw new Error(`Invalid max value passed to ${generatorName}: max must be lower than or equal to ${defaultMax}`);
  }
  return array4(arbitraryBuilder({ min: min11, max: max13 }), arrayConstraints).map((data) => TypedArrayClass.from(data), (value10) => {
    if (!(value10 instanceof TypedArrayClass))
      throw new Error("Invalid type");
    return [...value10];
  });
}

// ../../node_modules/fast-check/lib/esm/arbitrary/int16Array.js
function int16Array(constraints = {}) {
  return typedIntArrayArbitraryArbitraryBuilder(constraints, -32768, 32767, SInt16Array, integer);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/int32Array.js
function int32Array(constraints = {}) {
  return typedIntArrayArbitraryArbitraryBuilder(constraints, -2147483648, 2147483647, SInt32Array, integer);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/int8Array.js
function int8Array(constraints = {}) {
  return typedIntArrayArbitraryArbitraryBuilder(constraints, -128, 127, SInt8Array, integer);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/uint16Array.js
function uint16Array(constraints = {}) {
  return typedIntArrayArbitraryArbitraryBuilder(constraints, 0, 65535, SUint16Array, integer);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/uint32Array.js
function uint32Array(constraints = {}) {
  return typedIntArrayArbitraryArbitraryBuilder(constraints, 0, 4294967295, SUint32Array, integer);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/uint8Array.js
function uint8Array(constraints = {}) {
  return typedIntArrayArbitraryArbitraryBuilder(constraints, 0, 255, SUint8Array, integer);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/uint8ClampedArray.js
function uint8ClampedArray(constraints = {}) {
  return typedIntArrayArbitraryArbitraryBuilder(constraints, 0, 255, SUint8ClampedArray, integer);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/WithShrinkFromOtherArbitrary.js
function isSafeContext(context15) {
  return context15 !== void 0;
}
function toGeneratorValue(value10) {
  if (value10.hasToBeCloned) {
    return new Value(value10.value_, { generatorContext: value10.context }, () => value10.value);
  }
  return new Value(value10.value_, { generatorContext: value10.context });
}
function toShrinkerValue(value10) {
  if (value10.hasToBeCloned) {
    return new Value(value10.value_, { shrinkerContext: value10.context }, () => value10.value);
  }
  return new Value(value10.value_, { shrinkerContext: value10.context });
}
var WithShrinkFromOtherArbitrary = class extends Arbitrary {
  constructor(generatorArbitrary, shrinkerArbitrary) {
    super();
    this.generatorArbitrary = generatorArbitrary;
    this.shrinkerArbitrary = shrinkerArbitrary;
  }
  generate(mrng, biasFactor) {
    return toGeneratorValue(this.generatorArbitrary.generate(mrng, biasFactor));
  }
  canShrinkWithoutContext(value10) {
    return this.shrinkerArbitrary.canShrinkWithoutContext(value10);
  }
  shrink(value10, context15) {
    if (!isSafeContext(context15)) {
      return this.shrinkerArbitrary.shrink(value10, void 0).map(toShrinkerValue);
    }
    if ("generatorContext" in context15) {
      return this.generatorArbitrary.shrink(value10, context15.generatorContext).map(toGeneratorValue);
    }
    return this.shrinkerArbitrary.shrink(value10, context15.shrinkerContext).map(toShrinkerValue);
  }
};

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/builders/RestrictedIntegerArbitraryBuilder.js
function restrictedIntegerArbitraryBuilder(min11, maxGenerated, max13) {
  const generatorArbitrary = integer({ min: min11, max: maxGenerated });
  if (maxGenerated === max13) {
    return generatorArbitrary;
  }
  const shrinkerArbitrary = integer({ min: min11, max: max13 });
  return new WithShrinkFromOtherArbitrary(generatorArbitrary, shrinkerArbitrary);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/sparseArray.js
var safeMathMin6 = Math.min;
var safeMathMax4 = Math.max;
var safeArrayIsArray4 = SArray.isArray;
var safeObjectEntries2 = Object.entries;
function extractMaxIndex(indexesAndValues) {
  let maxIndex = -1;
  for (let index = 0; index !== indexesAndValues.length; ++index) {
    maxIndex = safeMathMax4(maxIndex, indexesAndValues[index][0]);
  }
  return maxIndex;
}
function arrayFromItems(length6, indexesAndValues) {
  const array8 = SArray(length6);
  for (let index = 0; index !== indexesAndValues.length; ++index) {
    const it = indexesAndValues[index];
    if (it[0] < length6)
      array8[it[0]] = it[1];
  }
  return array8;
}
function sparseArray(arb, constraints = {}) {
  const { size: size40, minNumElements = 0, maxLength: maxLength2 = MaxLengthUpperBound, maxNumElements = maxLength2, noTrailingHole, depthIdentifier } = constraints;
  const maxGeneratedNumElements = maxGeneratedLengthFromSizeForArbitrary(size40, minNumElements, maxNumElements, constraints.maxNumElements !== void 0);
  const maxGeneratedLength = maxGeneratedLengthFromSizeForArbitrary(size40, maxGeneratedNumElements, maxLength2, constraints.maxLength !== void 0);
  if (minNumElements > maxLength2) {
    throw new Error(`The minimal number of non-hole elements cannot be higher than the maximal length of the array`);
  }
  if (minNumElements > maxNumElements) {
    throw new Error(`The minimal number of non-hole elements cannot be higher than the maximal number of non-holes`);
  }
  const resultedMaxNumElements = safeMathMin6(maxNumElements, maxLength2);
  const resultedSizeMaxNumElements = constraints.maxNumElements !== void 0 || size40 !== void 0 ? size40 : "=";
  const maxGeneratedIndexAuthorized = safeMathMax4(maxGeneratedLength - 1, 0);
  const maxIndexAuthorized = safeMathMax4(maxLength2 - 1, 0);
  const sparseArrayNoTrailingHole = uniqueArray(tuple4(restrictedIntegerArbitraryBuilder(0, maxGeneratedIndexAuthorized, maxIndexAuthorized), arb), {
    size: resultedSizeMaxNumElements,
    minLength: minNumElements,
    maxLength: resultedMaxNumElements,
    selector: (item) => item[0],
    depthIdentifier
  }).map((items) => {
    const lastIndex = extractMaxIndex(items);
    return arrayFromItems(lastIndex + 1, items);
  }, (value10) => {
    if (!safeArrayIsArray4(value10)) {
      throw new Error("Not supported entry type");
    }
    if (noTrailingHole && value10.length !== 0 && !(value10.length - 1 in value10)) {
      throw new Error("No trailing hole");
    }
    return safeMap(safeObjectEntries2(value10), (entry) => [Number(entry[0]), entry[1]]);
  });
  if (noTrailingHole || maxLength2 === minNumElements) {
    return sparseArrayNoTrailingHole;
  }
  return tuple4(sparseArrayNoTrailingHole, restrictedIntegerArbitraryBuilder(minNumElements, maxGeneratedLength, maxLength2)).map((data) => {
    const sparse = data[0];
    const targetLength = data[1];
    if (sparse.length >= targetLength) {
      return sparse;
    }
    const longerSparse = safeSlice(sparse);
    longerSparse.length = targetLength;
    return longerSparse;
  }, (value10) => {
    if (!safeArrayIsArray4(value10)) {
      throw new Error("Not supported entry type");
    }
    return [value10, value10.length];
  });
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/ArrayToMap.js
function arrayToMapMapper(data) {
  return new Map(data);
}
function arrayToMapUnmapper(value10) {
  if (typeof value10 !== "object" || value10 === null) {
    throw new Error("Incompatible instance received: should be a non-null object");
  }
  if (!("constructor" in value10) || value10.constructor !== Map) {
    throw new Error("Incompatible instance received: should be of exact type Map");
  }
  return Array.from(value10);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/ArrayToSet.js
function arrayToSetMapper(data) {
  return new Set(data);
}
function arrayToSetUnmapper(value10) {
  if (typeof value10 !== "object" || value10 === null) {
    throw new Error("Incompatible instance received: should be a non-null object");
  }
  if (!("constructor" in value10) || value10.constructor !== Set) {
    throw new Error("Incompatible instance received: should be of exact type Set");
  }
  return Array.from(value10);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/builders/AnyArbitraryBuilder.js
function mapOf(ka, va, maxKeys, size40, depthIdentifier) {
  return uniqueArray(tuple4(ka, va), {
    maxLength: maxKeys,
    size: size40,
    comparator: "SameValueZero",
    selector: (t) => t[0],
    depthIdentifier
  }).map(arrayToMapMapper, arrayToMapUnmapper);
}
function dictOf(ka, va, maxKeys, size40, depthIdentifier, withNullPrototype) {
  return dictionary(ka, va, {
    maxKeys,
    noNullPrototype: !withNullPrototype,
    size: size40,
    depthIdentifier
  });
}
function setOf(va, maxKeys, size40, depthIdentifier) {
  return uniqueArray(va, { maxLength: maxKeys, size: size40, comparator: "SameValueZero", depthIdentifier }).map(arrayToSetMapper, arrayToSetUnmapper);
}
function typedArray(constraints) {
  return oneof(int8Array(constraints), uint8Array(constraints), uint8ClampedArray(constraints), int16Array(constraints), uint16Array(constraints), int32Array(constraints), uint32Array(constraints), float32Array(constraints), float64Array(constraints));
}
function anyArbitraryBuilder(constraints) {
  const arbitrariesForBase = constraints.values;
  const depthSize = constraints.depthSize;
  const depthIdentifier = createDepthIdentifier();
  const maxDepth = constraints.maxDepth;
  const maxKeys = constraints.maxKeys;
  const size40 = constraints.size;
  const baseArb = oneof(...arbitrariesForBase, ...constraints.withBigInt ? [bigInt()] : [], ...constraints.withDate ? [date()] : []);
  return letrec((tie) => ({
    anything: oneof({ maxDepth, depthSize, depthIdentifier }, baseArb, tie("array"), tie("object"), ...constraints.withMap ? [tie("map")] : [], ...constraints.withSet ? [tie("set")] : [], ...constraints.withObjectString ? [tie("anything").map((o) => stringify(o))] : [], ...constraints.withTypedArray ? [typedArray({ maxLength: maxKeys, size: size40 })] : [], ...constraints.withSparseArray ? [sparseArray(tie("anything"), { maxNumElements: maxKeys, size: size40, depthIdentifier })] : []),
    keys: constraints.withObjectString ? oneof({ arbitrary: constraints.key, weight: 10 }, { arbitrary: tie("anything").map((o) => stringify(o)), weight: 1 }) : constraints.key,
    array: array4(tie("anything"), { maxLength: maxKeys, size: size40, depthIdentifier }),
    set: setOf(tie("anything"), maxKeys, size40, depthIdentifier),
    map: oneof(mapOf(tie("keys"), tie("anything"), maxKeys, size40, depthIdentifier), mapOf(tie("anything"), tie("anything"), maxKeys, size40, depthIdentifier)),
    object: dictOf(tie("keys"), tie("anything"), maxKeys, size40, depthIdentifier, constraints.withNullPrototype)
  })).anything;
}

// ../../node_modules/fast-check/lib/esm/arbitrary/fullUnicodeString.js
var safeObjectAssign10 = Object.assign;
function fullUnicodeString(constraints = {}) {
  const charArbitrary = fullUnicode();
  const experimentalCustomSlices = createSlicesForStringLegacy(charArbitrary, codePointsToStringUnmapper);
  const enrichedConstraints = safeObjectAssign10(safeObjectAssign10({}, constraints), {
    experimentalCustomSlices
  });
  return array4(charArbitrary, enrichedConstraints).map(codePointsToStringMapper, codePointsToStringUnmapper);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/UnboxedToBoxed.js
function unboxedToBoxedMapper(value10) {
  switch (typeof value10) {
    case "boolean":
      return new SBoolean(value10);
    case "number":
      return new SNumber(value10);
    case "string":
      return new SString(value10);
    default:
      return value10;
  }
}
function unboxedToBoxedUnmapper(value10) {
  if (typeof value10 !== "object" || value10 === null || !("constructor" in value10)) {
    return value10;
  }
  return value10.constructor === SBoolean || value10.constructor === SNumber || value10.constructor === SString ? value10.valueOf() : value10;
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/builders/BoxedArbitraryBuilder.js
function boxedArbitraryBuilder(arb) {
  return arb.map(unboxedToBoxedMapper, unboxedToBoxedUnmapper);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/QualifiedObjectConstraints.js
function defaultValues(constraints, stringArbitrary) {
  return [
    boolean3(),
    maxSafeInteger(),
    double(),
    stringArbitrary(constraints),
    oneof(stringArbitrary(constraints), constant2(null), constant2(void 0))
  ];
}
function boxArbitraries(arbs) {
  return arbs.map((arb) => boxedArbitraryBuilder(arb));
}
function boxArbitrariesIfNeeded(arbs, boxEnabled) {
  return boxEnabled ? boxArbitraries(arbs).concat(arbs) : arbs;
}
function toQualifiedObjectConstraints(settings = {}) {
  function orDefault(optionalValue, defaultValue) {
    return optionalValue !== void 0 ? optionalValue : defaultValue;
  }
  const stringArbitrary = "stringUnit" in settings ? string4 : settings.withUnicodeString ? fullUnicodeString : string4;
  const valueConstraints = { size: settings.size, unit: settings.stringUnit };
  return {
    key: orDefault(settings.key, stringArbitrary(valueConstraints)),
    values: boxArbitrariesIfNeeded(orDefault(settings.values, defaultValues(valueConstraints, stringArbitrary)), orDefault(settings.withBoxedValues, false)),
    depthSize: settings.depthSize,
    maxDepth: settings.maxDepth,
    maxKeys: settings.maxKeys,
    size: settings.size,
    withSet: orDefault(settings.withSet, false),
    withMap: orDefault(settings.withMap, false),
    withObjectString: orDefault(settings.withObjectString, false),
    withNullPrototype: orDefault(settings.withNullPrototype, false),
    withBigInt: orDefault(settings.withBigInt, false),
    withDate: orDefault(settings.withDate, false),
    withTypedArray: orDefault(settings.withTypedArray, false),
    withSparseArray: orDefault(settings.withSparseArray, false)
  };
}

// ../../node_modules/fast-check/lib/esm/arbitrary/object.js
function objectInternal(constraints) {
  return dictionary(constraints.key, anyArbitraryBuilder(constraints), {
    maxKeys: constraints.maxKeys,
    noNullPrototype: !constraints.withNullPrototype,
    size: constraints.size
  });
}
function object(constraints) {
  return objectInternal(toQualifiedObjectConstraints(constraints));
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/JsonConstraintsBuilder.js
function jsonConstraintsBuilder(stringArbitrary, constraints) {
  const { depthSize, maxDepth } = constraints;
  const key = stringArbitrary;
  const values15 = [
    boolean3(),
    double({ noDefaultInfinity: true, noNaN: true }),
    stringArbitrary,
    constant2(null)
  ];
  return { key, values: values15, depthSize, maxDepth };
}

// ../../node_modules/fast-check/lib/esm/arbitrary/anything.js
function anything(constraints) {
  return anyArbitraryBuilder(toQualifiedObjectConstraints(constraints));
}

// ../../node_modules/fast-check/lib/esm/arbitrary/jsonValue.js
function jsonValue(constraints = {}) {
  const noUnicodeString = constraints.noUnicodeString === void 0 || constraints.noUnicodeString === true;
  const stringArbitrary = "stringUnit" in constraints ? string4({ unit: constraints.stringUnit }) : noUnicodeString ? string4() : fullUnicodeString();
  return anything(jsonConstraintsBuilder(stringArbitrary, constraints));
}

// ../../node_modules/fast-check/lib/esm/arbitrary/json.js
function json(constraints = {}) {
  const arb = jsonValue(constraints);
  return arb.map(JSON.stringify);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/unicodeString.js
var safeObjectAssign11 = Object.assign;
function unicodeString(constraints = {}) {
  const charArbitrary = unicode();
  const experimentalCustomSlices = createSlicesForStringLegacy(charArbitrary, codePointsToStringUnmapper);
  const enrichedConstraints = safeObjectAssign11(safeObjectAssign11({}, constraints), {
    experimentalCustomSlices
  });
  return array4(charArbitrary, enrichedConstraints).map(codePointsToStringMapper, codePointsToStringUnmapper);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/unicodeJsonValue.js
function unicodeJsonValue(constraints = {}) {
  return anything(jsonConstraintsBuilder(unicodeString(), constraints));
}

// ../../node_modules/fast-check/lib/esm/arbitrary/unicodeJson.js
function unicodeJson(constraints = {}) {
  const arb = unicodeJsonValue(constraints);
  return arb.map(JSON.stringify);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/EnumerableKeysExtractor.js
var safeObjectKeys5 = Object.keys;
var safeObjectGetOwnPropertySymbols3 = Object.getOwnPropertySymbols;
var safeObjectGetOwnPropertyDescriptor3 = Object.getOwnPropertyDescriptor;
function extractEnumerableKeys(instance) {
  const keys15 = safeObjectKeys5(instance);
  const symbols = safeObjectGetOwnPropertySymbols3(instance);
  for (let index = 0; index !== symbols.length; ++index) {
    const symbol6 = symbols[index];
    const descriptor3 = safeObjectGetOwnPropertyDescriptor3(instance, symbol6);
    if (descriptor3 && descriptor3.enumerable) {
      keys15.push(symbol6);
    }
  }
  return keys15;
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/ValuesAndSeparateKeysToObject.js
var safeObjectCreate3 = Object.create;
var safeObjectDefineProperty4 = Object.defineProperty;
var safeObjectGetOwnPropertyDescriptor4 = Object.getOwnPropertyDescriptor;
var safeObjectGetOwnPropertyNames2 = Object.getOwnPropertyNames;
var safeObjectGetOwnPropertySymbols4 = Object.getOwnPropertySymbols;
function buildValuesAndSeparateKeysToObjectMapper(keys15, noKeyValue2) {
  return function valuesAndSeparateKeysToObjectMapper(definition) {
    const obj = definition[1] ? safeObjectCreate3(null) : {};
    for (let idx = 0; idx !== keys15.length; ++idx) {
      const valueWrapper = definition[0][idx];
      if (valueWrapper !== noKeyValue2) {
        safeObjectDefineProperty4(obj, keys15[idx], {
          value: valueWrapper,
          configurable: true,
          enumerable: true,
          writable: true
        });
      }
    }
    return obj;
  };
}
function buildValuesAndSeparateKeysToObjectUnmapper(keys15, noKeyValue2) {
  return function valuesAndSeparateKeysToObjectUnmapper(value10) {
    if (typeof value10 !== "object" || value10 === null) {
      throw new Error("Incompatible instance received: should be a non-null object");
    }
    const hasNullPrototype = Object.getPrototypeOf(value10) === null;
    const hasObjectPrototype = "constructor" in value10 && value10.constructor === Object;
    if (!hasNullPrototype && !hasObjectPrototype) {
      throw new Error("Incompatible instance received: should be of exact type Object");
    }
    let extractedPropertiesCount = 0;
    const extractedValues = [];
    for (let idx = 0; idx !== keys15.length; ++idx) {
      const descriptor3 = safeObjectGetOwnPropertyDescriptor4(value10, keys15[idx]);
      if (descriptor3 !== void 0) {
        if (!descriptor3.configurable || !descriptor3.enumerable || !descriptor3.writable) {
          throw new Error("Incompatible instance received: should contain only c/e/w properties");
        }
        if (descriptor3.get !== void 0 || descriptor3.set !== void 0) {
          throw new Error("Incompatible instance received: should contain only no get/set properties");
        }
        ++extractedPropertiesCount;
        safePush(extractedValues, descriptor3.value);
      } else {
        safePush(extractedValues, noKeyValue2);
      }
    }
    const namePropertiesCount = safeObjectGetOwnPropertyNames2(value10).length;
    const symbolPropertiesCount = safeObjectGetOwnPropertySymbols4(value10).length;
    if (extractedPropertiesCount !== namePropertiesCount + symbolPropertiesCount) {
      throw new Error("Incompatible instance received: should not contain extra properties");
    }
    return [extractedValues, hasNullPrototype];
  };
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/builders/PartialRecordArbitraryBuilder.js
var noKeyValue = Symbol("no-key");
function buildPartialRecordArbitrary(recordModel, requiredKeys, noNullPrototype) {
  const keys15 = extractEnumerableKeys(recordModel);
  const arbs = [];
  for (let index = 0; index !== keys15.length; ++index) {
    const k = keys15[index];
    const requiredArbitrary = recordModel[k];
    if (requiredKeys === void 0 || safeIndexOf(requiredKeys, k) !== -1) {
      safePush(arbs, requiredArbitrary);
    } else {
      safePush(arbs, option(requiredArbitrary, { nil: noKeyValue }));
    }
  }
  return tuple4(tuple4(...arbs), noNullPrototype ? constant2(false) : boolean3()).map(buildValuesAndSeparateKeysToObjectMapper(keys15, noKeyValue), buildValuesAndSeparateKeysToObjectUnmapper(keys15, noKeyValue));
}

// ../../node_modules/fast-check/lib/esm/arbitrary/record.js
function record(recordModel, constraints) {
  const noNullPrototype = constraints === void 0 || constraints.noNullPrototype === void 0 || constraints.noNullPrototype;
  if (constraints == null) {
    return buildPartialRecordArbitrary(recordModel, void 0, noNullPrototype);
  }
  if ("withDeletedKeys" in constraints && "requiredKeys" in constraints) {
    throw new Error(`requiredKeys and withDeletedKeys cannot be used together in fc.record`);
  }
  const requireDeletedKeys = "requiredKeys" in constraints && constraints.requiredKeys !== void 0 || "withDeletedKeys" in constraints && !!constraints.withDeletedKeys;
  if (!requireDeletedKeys) {
    return buildPartialRecordArbitrary(recordModel, void 0, noNullPrototype);
  }
  const requiredKeys = ("requiredKeys" in constraints ? constraints.requiredKeys : void 0) || [];
  for (let idx = 0; idx !== requiredKeys.length; ++idx) {
    const descriptor3 = Object.getOwnPropertyDescriptor(recordModel, requiredKeys[idx]);
    if (descriptor3 === void 0) {
      throw new Error(`requiredKeys cannot reference keys that have not been defined in recordModel`);
    }
    if (!descriptor3.enumerable) {
      throw new Error(`requiredKeys cannot reference keys that have are enumerable in recordModel`);
    }
  }
  return buildPartialRecordArbitrary(recordModel, requiredKeys, noNullPrototype);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/StreamArbitrary.js
var safeObjectDefineProperties2 = Object.defineProperties;
function prettyPrint(seenValuesStrings) {
  return `Stream(${safeJoin(seenValuesStrings, ",")}…)`;
}
var StreamArbitrary = class extends Arbitrary {
  constructor(arb) {
    super();
    this.arb = arb;
  }
  generate(mrng, biasFactor) {
    const appliedBiasFactor = biasFactor !== void 0 && mrng.nextInt(1, biasFactor) === 1 ? biasFactor : void 0;
    const enrichedProducer = () => {
      const seenValues = [];
      const g = function* (arb, clonedMrng) {
        while (true) {
          const value10 = arb.generate(clonedMrng, appliedBiasFactor).value;
          safePush(seenValues, value10);
          yield value10;
        }
      };
      const s = new Stream(g(this.arb, mrng.clone()));
      return safeObjectDefineProperties2(s, {
        toString: { value: () => prettyPrint(seenValues.map(stringify)) },
        [toStringMethod]: { value: () => prettyPrint(seenValues.map(stringify)) },
        [asyncToStringMethod]: { value: async () => prettyPrint(await Promise.all(seenValues.map(asyncStringify))) },
        [cloneMethod]: { value: enrichedProducer, enumerable: true }
      });
    };
    return new Value(enrichedProducer(), void 0);
  }
  canShrinkWithoutContext(value10) {
    return false;
  }
  shrink(_value, _context) {
    return Stream.nil();
  }
};

// ../../node_modules/fast-check/lib/esm/arbitrary/infiniteStream.js
function infiniteStream(arb) {
  return new StreamArbitrary(arb);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/asciiString.js
var safeObjectAssign12 = Object.assign;
function asciiString(constraints = {}) {
  const charArbitrary = ascii();
  const experimentalCustomSlices = createSlicesForStringLegacy(charArbitrary, codePointsToStringUnmapper);
  const enrichedConstraints = safeObjectAssign12(safeObjectAssign12({}, constraints), {
    experimentalCustomSlices
  });
  return array4(charArbitrary, enrichedConstraints).map(codePointsToStringMapper, codePointsToStringUnmapper);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/StringToBase64.js
function stringToBase64Mapper(s) {
  switch (s.length % 4) {
    case 0:
      return s;
    case 3:
      return `${s}=`;
    case 2:
      return `${s}==`;
    default:
      return safeSubstring(s, 1);
  }
}
function stringToBase64Unmapper(value10) {
  if (typeof value10 !== "string" || value10.length % 4 !== 0) {
    throw new Error("Invalid string received");
  }
  const lastTrailingIndex = value10.indexOf("=");
  if (lastTrailingIndex === -1) {
    return value10;
  }
  const numTrailings = value10.length - lastTrailingIndex;
  if (numTrailings > 2) {
    throw new Error("Cannot unmap the passed value");
  }
  return safeSubstring(value10, 0, lastTrailingIndex);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/base64String.js
function base64String(constraints = {}) {
  const { minLength: unscaledMinLength = 0, maxLength: unscaledMaxLength = MaxLengthUpperBound, size: size40 } = constraints;
  const minLength2 = unscaledMinLength + 3 - (unscaledMinLength + 3) % 4;
  const maxLength2 = unscaledMaxLength - unscaledMaxLength % 4;
  const requestedSize = constraints.maxLength === void 0 && size40 === void 0 ? "=" : size40;
  if (minLength2 > maxLength2)
    throw new Error("Minimal length should be inferior or equal to maximal length");
  if (minLength2 % 4 !== 0)
    throw new Error("Minimal length of base64 strings must be a multiple of 4");
  if (maxLength2 % 4 !== 0)
    throw new Error("Maximal length of base64 strings must be a multiple of 4");
  const charArbitrary = base64();
  const experimentalCustomSlices = createSlicesForStringLegacy(charArbitrary, codePointsToStringUnmapper);
  const enrichedConstraints = {
    minLength: minLength2,
    maxLength: maxLength2,
    size: requestedSize,
    experimentalCustomSlices
  };
  return array4(charArbitrary, enrichedConstraints).map(codePointsToStringMapper, codePointsToStringUnmapper).map(stringToBase64Mapper, stringToBase64Unmapper);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/CharsToString.js
function charsToStringMapper(tab) {
  return safeJoin(tab, "");
}
function charsToStringUnmapper(value10) {
  if (typeof value10 !== "string") {
    throw new Error("Cannot unmap the passed value");
  }
  return safeSplit(value10, "");
}

// ../../node_modules/fast-check/lib/esm/arbitrary/string16bits.js
var safeObjectAssign13 = Object.assign;
function string16bits(constraints = {}) {
  const charArbitrary = char16bits();
  const experimentalCustomSlices = createSlicesForStringLegacy(charArbitrary, charsToStringUnmapper);
  const enrichedConstraints = safeObjectAssign13(safeObjectAssign13({}, constraints), {
    experimentalCustomSlices
  });
  return array4(charArbitrary, enrichedConstraints).map(charsToStringMapper, charsToStringUnmapper);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/stringOf.js
var safeObjectAssign14 = Object.assign;
function stringOf(charArb, constraints = {}) {
  const unmapper = patternsToStringUnmapperFor(charArb, constraints);
  const experimentalCustomSlices = createSlicesForStringLegacy(charArb, unmapper);
  const enrichedConstraints = safeObjectAssign14(safeObjectAssign14({}, constraints), {
    experimentalCustomSlices
  });
  return array4(charArb, enrichedConstraints).map(patternsToStringMapper, unmapper);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/IsSubarrayOf.js
var safeObjectIs8 = Object.is;
function isSubarrayOf(source, small) {
  const countMap = new SMap();
  let countMinusZero = 0;
  for (const sourceEntry of source) {
    if (safeObjectIs8(sourceEntry, -0)) {
      ++countMinusZero;
    } else {
      const oldCount = safeMapGet(countMap, sourceEntry) || 0;
      safeMapSet(countMap, sourceEntry, oldCount + 1);
    }
  }
  for (let index = 0; index !== small.length; ++index) {
    if (!(index in small)) {
      return false;
    }
    const smallEntry = small[index];
    if (safeObjectIs8(smallEntry, -0)) {
      if (countMinusZero === 0)
        return false;
      --countMinusZero;
    } else {
      const oldCount = safeMapGet(countMap, smallEntry) || 0;
      if (oldCount === 0)
        return false;
      safeMapSet(countMap, smallEntry, oldCount - 1);
    }
  }
  return true;
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/SubarrayArbitrary.js
var safeMathFloor6 = Math.floor;
var safeMathLog4 = Math.log;
var safeArrayIsArray5 = Array.isArray;
var SubarrayArbitrary = class extends Arbitrary {
  constructor(originalArray, isOrdered, minLength2, maxLength2) {
    super();
    this.originalArray = originalArray;
    this.isOrdered = isOrdered;
    this.minLength = minLength2;
    this.maxLength = maxLength2;
    if (minLength2 < 0 || minLength2 > originalArray.length)
      throw new Error("fc.*{s|S}ubarrayOf expects the minimal length to be between 0 and the size of the original array");
    if (maxLength2 < 0 || maxLength2 > originalArray.length)
      throw new Error("fc.*{s|S}ubarrayOf expects the maximal length to be between 0 and the size of the original array");
    if (minLength2 > maxLength2)
      throw new Error("fc.*{s|S}ubarrayOf expects the minimal length to be inferior or equal to the maximal length");
    this.lengthArb = new IntegerArbitrary(minLength2, maxLength2);
    this.biasedLengthArb = minLength2 !== maxLength2 ? new IntegerArbitrary(minLength2, minLength2 + safeMathFloor6(safeMathLog4(maxLength2 - minLength2) / safeMathLog4(2))) : this.lengthArb;
  }
  generate(mrng, biasFactor) {
    const lengthArb = biasFactor !== void 0 && mrng.nextInt(1, biasFactor) === 1 ? this.biasedLengthArb : this.lengthArb;
    const size40 = lengthArb.generate(mrng, void 0);
    const sizeValue = size40.value;
    const remainingElements = safeMap(this.originalArray, (_v, idx) => idx);
    const ids3 = [];
    for (let index = 0; index !== sizeValue; ++index) {
      const selectedIdIndex = mrng.nextInt(0, remainingElements.length - 1);
      safePush(ids3, remainingElements[selectedIdIndex]);
      safeSplice(remainingElements, selectedIdIndex, 1);
    }
    if (this.isOrdered) {
      safeSort(ids3, (a, b) => a - b);
    }
    return new Value(safeMap(ids3, (i) => this.originalArray[i]), size40.context);
  }
  canShrinkWithoutContext(value10) {
    if (!safeArrayIsArray5(value10)) {
      return false;
    }
    if (!this.lengthArb.canShrinkWithoutContext(value10.length)) {
      return false;
    }
    return isSubarrayOf(this.originalArray, value10);
  }
  shrink(value10, context15) {
    if (value10.length === 0) {
      return Stream.nil();
    }
    return this.lengthArb.shrink(value10.length, context15).map((newSize) => {
      return new Value(safeSlice(value10, value10.length - newSize.value), newSize.context);
    }).join(value10.length > this.minLength ? makeLazy(() => this.shrink(safeSlice(value10, 1), void 0).filter((newValue) => this.minLength <= newValue.value.length + 1).map((newValue) => new Value([value10[0], ...newValue.value], void 0))) : Stream.nil());
  }
};

// ../../node_modules/fast-check/lib/esm/arbitrary/subarray.js
function subarray(originalArray, constraints = {}) {
  const { minLength: minLength2 = 0, maxLength: maxLength2 = originalArray.length } = constraints;
  return new SubarrayArbitrary(originalArray, true, minLength2, maxLength2);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/shuffledSubarray.js
function shuffledSubarray(originalArray, constraints = {}) {
  const { minLength: minLength2 = 0, maxLength: maxLength2 = originalArray.length } = constraints;
  return new SubarrayArbitrary(originalArray, false, minLength2, maxLength2);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/UintToBase32String.js
var encodeSymbolLookupTable = {
  10: "A",
  11: "B",
  12: "C",
  13: "D",
  14: "E",
  15: "F",
  16: "G",
  17: "H",
  18: "J",
  19: "K",
  20: "M",
  21: "N",
  22: "P",
  23: "Q",
  24: "R",
  25: "S",
  26: "T",
  27: "V",
  28: "W",
  29: "X",
  30: "Y",
  31: "Z"
};
var decodeSymbolLookupTable = {
  "0": 0,
  "1": 1,
  "2": 2,
  "3": 3,
  "4": 4,
  "5": 5,
  "6": 6,
  "7": 7,
  "8": 8,
  "9": 9,
  A: 10,
  B: 11,
  C: 12,
  D: 13,
  E: 14,
  F: 15,
  G: 16,
  H: 17,
  J: 18,
  K: 19,
  M: 20,
  N: 21,
  P: 22,
  Q: 23,
  R: 24,
  S: 25,
  T: 26,
  V: 27,
  W: 28,
  X: 29,
  Y: 30,
  Z: 31
};
function encodeSymbol(symbol6) {
  return symbol6 < 10 ? SString(symbol6) : encodeSymbolLookupTable[symbol6];
}
function pad2(value10, paddingLength) {
  let extraPadding = "";
  while (value10.length + extraPadding.length < paddingLength) {
    extraPadding += "0";
  }
  return extraPadding + value10;
}
function smallUintToBase32StringMapper(num) {
  let base32Str = "";
  for (let remaining = num; remaining !== 0; ) {
    const next6 = remaining >> 5;
    const current2 = remaining - (next6 << 5);
    base32Str = encodeSymbol(current2) + base32Str;
    remaining = next6;
  }
  return base32Str;
}
function uintToBase32StringMapper(num, paddingLength) {
  const head13 = ~~(num / 1073741824);
  const tail5 = num & 1073741823;
  return pad2(smallUintToBase32StringMapper(head13), paddingLength - 6) + pad2(smallUintToBase32StringMapper(tail5), 6);
}
function paddedUintToBase32StringMapper(paddingLength) {
  return function padded(num) {
    return uintToBase32StringMapper(num, paddingLength);
  };
}
function uintToBase32StringUnmapper(value10) {
  if (typeof value10 !== "string") {
    throw new SError("Unsupported type");
  }
  let accumulated = 0;
  let power = 1;
  for (let index = value10.length - 1; index >= 0; --index) {
    const char2 = value10[index];
    const numericForChar = decodeSymbolLookupTable[char2];
    if (numericForChar === void 0) {
      throw new SError("Unsupported type");
    }
    accumulated += numericForChar * power;
    power *= 32;
  }
  return accumulated;
}

// ../../node_modules/fast-check/lib/esm/arbitrary/ulid.js
var padded10Mapper = paddedUintToBase32StringMapper(10);
var padded8Mapper = paddedUintToBase32StringMapper(8);
function ulidMapper(parts2) {
  return padded10Mapper(parts2[0]) + padded8Mapper(parts2[1]) + padded8Mapper(parts2[2]);
}
function ulidUnmapper(value10) {
  if (typeof value10 !== "string" || value10.length !== 26) {
    throw new Error("Unsupported type");
  }
  return [
    uintToBase32StringUnmapper(value10.slice(0, 10)),
    uintToBase32StringUnmapper(value10.slice(10, 18)),
    uintToBase32StringUnmapper(value10.slice(18))
  ];
}
function ulid() {
  const timestampPartArbitrary = integer({ min: 0, max: 281474976710655 });
  const randomnessPartOneArbitrary = integer({ min: 0, max: 1099511627775 });
  const randomnessPartTwoArbitrary = integer({ min: 0, max: 1099511627775 });
  return tuple4(timestampPartArbitrary, randomnessPartOneArbitrary, randomnessPartTwoArbitrary).map(ulidMapper, ulidUnmapper);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/NumberToPaddedEight.js
function numberToPaddedEightMapper(n) {
  return safePadStart(safeNumberToString(n, 16), 8, "0");
}
function numberToPaddedEightUnmapper(value10) {
  if (typeof value10 !== "string") {
    throw new Error("Unsupported type");
  }
  if (value10.length !== 8) {
    throw new Error("Unsupported value: invalid length");
  }
  const n = parseInt(value10, 16);
  if (value10 !== numberToPaddedEightMapper(n)) {
    throw new Error("Unsupported value: invalid content");
  }
  return n;
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/builders/PaddedNumberArbitraryBuilder.js
function buildPaddedNumberArbitrary(min11, max13) {
  return integer({ min: min11, max: max13 }).map(numberToPaddedEightMapper, numberToPaddedEightUnmapper);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/PaddedEightsToUuid.js
function paddedEightsToUuidMapper(t) {
  return `${t[0]}-${safeSubstring(t[1], 4)}-${safeSubstring(t[1], 0, 4)}-${safeSubstring(t[2], 0, 4)}-${safeSubstring(t[2], 4)}${t[3]}`;
}
var UuidRegex = /^([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/;
function paddedEightsToUuidUnmapper(value10) {
  if (typeof value10 !== "string") {
    throw new Error("Unsupported type");
  }
  const m = UuidRegex.exec(value10);
  if (m === null) {
    throw new Error("Unsupported type");
  }
  return [m[1], m[3] + m[2], m[4] + safeSubstring(m[5], 0, 4), safeSubstring(m[5], 4)];
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/VersionsApplierForUuid.js
var quickNumberToHexaString = "0123456789abcdef";
function buildVersionsAppliersForUuid(versions) {
  const mapping = {};
  const reversedMapping = {};
  for (let index = 0; index !== versions.length; ++index) {
    const from = quickNumberToHexaString[index];
    const to = quickNumberToHexaString[versions[index]];
    mapping[from] = to;
    reversedMapping[to] = from;
  }
  function versionsApplierMapper(value10) {
    return mapping[value10[0]] + safeSubstring(value10, 1);
  }
  function versionsApplierUnmapper(value10) {
    if (typeof value10 !== "string") {
      throw new SError("Cannot produce non-string values");
    }
    const rev = reversedMapping[value10[0]];
    if (rev === void 0) {
      throw new SError("Cannot produce strings not starting by the version in hexa code");
    }
    return rev + safeSubstring(value10, 1);
  }
  return { versionsApplierMapper, versionsApplierUnmapper };
}

// ../../node_modules/fast-check/lib/esm/arbitrary/uuid.js
function assertValidVersions(versions) {
  const found = {};
  for (const version of versions) {
    if (found[version]) {
      throw new SError(`Version ${version} has been requested at least twice for uuid`);
    }
    found[version] = true;
    if (version < 1 || version > 15) {
      throw new SError(`Version must be a value in [1-15] for uuid, but received ${version}`);
    }
    if (~~version !== version) {
      throw new SError(`Version must be an integer value for uuid, but received ${version}`);
    }
  }
  if (versions.length === 0) {
    throw new SError(`Must provide at least one version for uuid`);
  }
}
function uuid(constraints = {}) {
  const padded = buildPaddedNumberArbitrary(0, 4294967295);
  const version = constraints.version !== void 0 ? typeof constraints.version === "number" ? [constraints.version] : constraints.version : [1, 2, 3, 4, 5];
  assertValidVersions(version);
  const { versionsApplierMapper, versionsApplierUnmapper } = buildVersionsAppliersForUuid(version);
  const secondPadded = buildPaddedNumberArbitrary(0, 268435456 * version.length - 1).map(versionsApplierMapper, versionsApplierUnmapper);
  const thirdPadded = buildPaddedNumberArbitrary(2147483648, 3221225471);
  return tuple4(padded, secondPadded, thirdPadded, padded).map(paddedEightsToUuidMapper, paddedEightsToUuidUnmapper);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/uuidV.js
function uuidV(versionNumber) {
  const padded = buildPaddedNumberArbitrary(0, 4294967295);
  const offsetSecond = versionNumber * 268435456;
  const secondPadded = buildPaddedNumberArbitrary(offsetSecond, offsetSecond + 268435455);
  const thirdPadded = buildPaddedNumberArbitrary(2147483648, 3221225471);
  return tuple4(padded, secondPadded, thirdPadded, padded).map(paddedEightsToUuidMapper, paddedEightsToUuidUnmapper);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/webAuthority.js
function hostUserInfo(size40) {
  return string4({ unit: getOrCreateAlphaNumericPercentArbitrary("-._~!$&'()*+,;=:"), size: size40 });
}
function userHostPortMapper([u, h2, p]) {
  return (u === null ? "" : `${u}@`) + h2 + (p === null ? "" : `:${p}`);
}
function userHostPortUnmapper(value10) {
  if (typeof value10 !== "string") {
    throw new Error("Unsupported");
  }
  const atPosition = value10.indexOf("@");
  const user = atPosition !== -1 ? value10.substring(0, atPosition) : null;
  const portRegex = /:(\d+)$/;
  const m = portRegex.exec(value10);
  const port3 = m !== null ? Number(m[1]) : null;
  const host = m !== null ? value10.substring(atPosition + 1, value10.length - m[1].length - 1) : value10.substring(atPosition + 1);
  return [user, host, port3];
}
function bracketedMapper(s) {
  return `[${s}]`;
}
function bracketedUnmapper(value10) {
  if (typeof value10 !== "string" || value10[0] !== "[" || value10[value10.length - 1] !== "]") {
    throw new Error("Unsupported");
  }
  return value10.substring(1, value10.length - 1);
}
function webAuthority(constraints) {
  const c = constraints || {};
  const size40 = c.size;
  const hostnameArbs = [
    domain({ size: size40 }),
    ...c.withIPv4 === true ? [ipV4()] : [],
    ...c.withIPv6 === true ? [ipV6().map(bracketedMapper, bracketedUnmapper)] : [],
    ...c.withIPv4Extended === true ? [ipV4Extended()] : []
  ];
  return tuple4(c.withUserInfo === true ? option(hostUserInfo(size40)) : constant2(null), oneof(...hostnameArbs), c.withPort === true ? option(nat(65535)) : constant2(null)).map(userHostPortMapper, userHostPortUnmapper);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/builders/UriQueryOrFragmentArbitraryBuilder.js
function buildUriQueryOrFragmentArbitrary(size40) {
  return string4({ unit: getOrCreateAlphaNumericPercentArbitrary("-._~!$&'()*+,;=:@/?"), size: size40 });
}

// ../../node_modules/fast-check/lib/esm/arbitrary/webFragments.js
function webFragments(constraints = {}) {
  return buildUriQueryOrFragmentArbitrary(constraints.size);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/webSegment.js
function webSegment(constraints = {}) {
  return string4({ unit: getOrCreateAlphaNumericPercentArbitrary("-._~!$&'()*+,;=:@"), size: constraints.size });
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/SegmentsToPath.js
function segmentsToPathMapper(segments) {
  return safeJoin(safeMap(segments, (v) => `/${v}`), "");
}
function segmentsToPathUnmapper(value10) {
  if (typeof value10 !== "string") {
    throw new Error("Incompatible value received: type");
  }
  if (value10.length !== 0 && value10[0] !== "/") {
    throw new Error("Incompatible value received: start");
  }
  return safeSplice(safeSplit(value10, "/"), 1);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/builders/UriPathArbitraryBuilder.js
function sqrtSize(size40) {
  switch (size40) {
    case "xsmall":
      return ["xsmall", "xsmall"];
    case "small":
      return ["small", "xsmall"];
    case "medium":
      return ["small", "small"];
    case "large":
      return ["medium", "small"];
    case "xlarge":
      return ["medium", "medium"];
  }
}
function buildUriPathArbitraryInternal(segmentSize, numSegmentSize) {
  return array4(webSegment({ size: segmentSize }), { size: numSegmentSize }).map(segmentsToPathMapper, segmentsToPathUnmapper);
}
function buildUriPathArbitrary(resolvedSize) {
  const [segmentSize, numSegmentSize] = sqrtSize(resolvedSize);
  if (segmentSize === numSegmentSize) {
    return buildUriPathArbitraryInternal(segmentSize, numSegmentSize);
  }
  return oneof(buildUriPathArbitraryInternal(segmentSize, numSegmentSize), buildUriPathArbitraryInternal(numSegmentSize, segmentSize));
}

// ../../node_modules/fast-check/lib/esm/arbitrary/webPath.js
function webPath(constraints) {
  const c = constraints || {};
  const resolvedSize = resolveSize(c.size);
  return buildUriPathArbitrary(resolvedSize);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/webQueryParameters.js
function webQueryParameters(constraints = {}) {
  return buildUriQueryOrFragmentArbitrary(constraints.size);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/PartsToUrl.js
function partsToUrlMapper(data) {
  const [scheme, authority, path] = data;
  const query = data[3] === null ? "" : `?${data[3]}`;
  const fragments = data[4] === null ? "" : `#${data[4]}`;
  return `${scheme}://${authority}${path}${query}${fragments}`;
}
var UrlSplitRegex = /^([[A-Za-z][A-Za-z0-9+.-]*):\/\/([^/?#]*)([^?#]*)(\?[A-Za-z0-9\-._~!$&'()*+,;=:@/?%]*)?(#[A-Za-z0-9\-._~!$&'()*+,;=:@/?%]*)?$/;
function partsToUrlUnmapper(value10) {
  if (typeof value10 !== "string") {
    throw new Error("Incompatible value received: type");
  }
  const m = UrlSplitRegex.exec(value10);
  if (m === null) {
    throw new Error("Incompatible value received");
  }
  const scheme = m[1];
  const authority = m[2];
  const path = m[3];
  const query = m[4];
  const fragments = m[5];
  return [
    scheme,
    authority,
    path,
    query !== void 0 ? query.substring(1) : null,
    fragments !== void 0 ? fragments.substring(1) : null
  ];
}

// ../../node_modules/fast-check/lib/esm/arbitrary/webUrl.js
var safeObjectAssign15 = Object.assign;
function webUrl(constraints) {
  const c = constraints || {};
  const resolvedSize = resolveSize(c.size);
  const resolvedAuthoritySettingsSize = c.authoritySettings !== void 0 && c.authoritySettings.size !== void 0 ? relativeSizeToSize(c.authoritySettings.size, resolvedSize) : resolvedSize;
  const resolvedAuthoritySettings = safeObjectAssign15(safeObjectAssign15({}, c.authoritySettings), {
    size: resolvedAuthoritySettingsSize
  });
  const validSchemes = c.validSchemes || ["http", "https"];
  const schemeArb = constantFrom(...validSchemes);
  const authorityArb = webAuthority(resolvedAuthoritySettings);
  return tuple4(schemeArb, authorityArb, webPath({ size: resolvedSize }), c.withQueryParameters === true ? option(webQueryParameters({ size: resolvedSize })) : constant2(null), c.withFragments === true ? option(webFragments({ size: resolvedSize })) : constant2(null)).map(partsToUrlMapper, partsToUrlUnmapper);
}

// ../../node_modules/fast-check/lib/esm/check/model/commands/CommandsIterable.js
var CommandsIterable = class _CommandsIterable {
  constructor(commands2, metadataForReplay) {
    this.commands = commands2;
    this.metadataForReplay = metadataForReplay;
  }
  [Symbol.iterator]() {
    return this.commands[Symbol.iterator]();
  }
  [cloneMethod]() {
    return new _CommandsIterable(this.commands.map((c) => c.clone()), this.metadataForReplay);
  }
  toString() {
    const serializedCommands = this.commands.filter((c) => c.hasRan).map((c) => c.toString()).join(",");
    const metadata = this.metadataForReplay();
    return metadata.length !== 0 ? `${serializedCommands} /*${metadata}*/` : serializedCommands;
  }
};

// ../../node_modules/fast-check/lib/esm/check/model/commands/CommandWrapper.js
var CommandWrapper = class _CommandWrapper {
  constructor(cmd) {
    this.cmd = cmd;
    this.hasRan = false;
    if (hasToStringMethod(cmd)) {
      const method = cmd[toStringMethod];
      this[toStringMethod] = function toStringMethod2() {
        return method.call(cmd);
      };
    }
    if (hasAsyncToStringMethod(cmd)) {
      const method = cmd[asyncToStringMethod];
      this[asyncToStringMethod] = function asyncToStringMethod2() {
        return method.call(cmd);
      };
    }
  }
  check(m) {
    return this.cmd.check(m);
  }
  run(m, r) {
    this.hasRan = true;
    return this.cmd.run(m, r);
  }
  clone() {
    if (hasCloneMethod(this.cmd))
      return new _CommandWrapper(this.cmd[cloneMethod]());
    return new _CommandWrapper(this.cmd);
  }
  toString() {
    return this.cmd.toString();
  }
};

// ../../node_modules/fast-check/lib/esm/check/model/ReplayPath.js
var ReplayPath = class {
  static parse(replayPathStr) {
    const [serializedCount, serializedChanges] = replayPathStr.split(":");
    const counts = this.parseCounts(serializedCount);
    const changes4 = this.parseChanges(serializedChanges);
    return this.parseOccurences(counts, changes4);
  }
  static stringify(replayPath) {
    const occurences = this.countOccurences(replayPath);
    const serializedCount = this.stringifyCounts(occurences);
    const serializedChanges = this.stringifyChanges(occurences);
    return `${serializedCount}:${serializedChanges}`;
  }
  static intToB64(n) {
    if (n < 26)
      return String.fromCharCode(n + 65);
    if (n < 52)
      return String.fromCharCode(n + 97 - 26);
    if (n < 62)
      return String.fromCharCode(n + 48 - 52);
    return String.fromCharCode(n === 62 ? 43 : 47);
  }
  static b64ToInt(c) {
    if (c >= "a")
      return c.charCodeAt(0) - 97 + 26;
    if (c >= "A")
      return c.charCodeAt(0) - 65;
    if (c >= "0")
      return c.charCodeAt(0) - 48 + 52;
    return c === "+" ? 62 : 63;
  }
  static countOccurences(replayPath) {
    return replayPath.reduce((counts, cur) => {
      if (counts.length === 0 || counts[counts.length - 1].count === 64 || counts[counts.length - 1].value !== cur)
        counts.push({ value: cur, count: 1 });
      else
        counts[counts.length - 1].count += 1;
      return counts;
    }, []);
  }
  static parseOccurences(counts, changes4) {
    const replayPath = [];
    for (let idx = 0; idx !== counts.length; ++idx) {
      const count9 = counts[idx];
      const value10 = changes4[idx];
      for (let num = 0; num !== count9; ++num)
        replayPath.push(value10);
    }
    return replayPath;
  }
  static stringifyChanges(occurences) {
    let serializedChanges = "";
    for (let idx = 0; idx < occurences.length; idx += 6) {
      const changesInt = occurences.slice(idx, idx + 6).reduceRight((prev, cur) => prev * 2 + (cur.value ? 1 : 0), 0);
      serializedChanges += this.intToB64(changesInt);
    }
    return serializedChanges;
  }
  static parseChanges(serializedChanges) {
    const changesInt = serializedChanges.split("").map((c) => this.b64ToInt(c));
    const changes4 = [];
    for (let idx = 0; idx !== changesInt.length; ++idx) {
      let current2 = changesInt[idx];
      for (let n = 0; n !== 6; ++n, current2 >>= 1) {
        changes4.push(current2 % 2 === 1);
      }
    }
    return changes4;
  }
  static stringifyCounts(occurences) {
    return occurences.map(({ count: count9 }) => this.intToB64(count9 - 1)).join("");
  }
  static parseCounts(serializedCount) {
    return serializedCount.split("").map((c) => this.b64ToInt(c) + 1);
  }
};

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/CommandsArbitrary.js
var CommandsArbitrary = class extends Arbitrary {
  constructor(commandArbs, maxGeneratedCommands, maxCommands, sourceReplayPath, disableReplayLog) {
    super();
    this.sourceReplayPath = sourceReplayPath;
    this.disableReplayLog = disableReplayLog;
    this.oneCommandArb = oneof(...commandArbs).map((c) => new CommandWrapper(c));
    this.lengthArb = restrictedIntegerArbitraryBuilder(0, maxGeneratedCommands, maxCommands);
    this.replayPath = [];
    this.replayPathPosition = 0;
  }
  metadataForReplay() {
    return this.disableReplayLog ? "" : `replayPath=${JSON.stringify(ReplayPath.stringify(this.replayPath))}`;
  }
  buildValueFor(items, shrunkOnce) {
    const commands2 = items.map((item) => item.value_);
    const context15 = { shrunkOnce, items };
    return new Value(new CommandsIterable(commands2, () => this.metadataForReplay()), context15);
  }
  generate(mrng) {
    const size40 = this.lengthArb.generate(mrng, void 0);
    const sizeValue = size40.value;
    const items = Array(sizeValue);
    for (let idx = 0; idx !== sizeValue; ++idx) {
      const item = this.oneCommandArb.generate(mrng, void 0);
      items[idx] = item;
    }
    this.replayPathPosition = 0;
    return this.buildValueFor(items, false);
  }
  canShrinkWithoutContext(value10) {
    return false;
  }
  filterOnExecution(itemsRaw) {
    const items = [];
    for (const c of itemsRaw) {
      if (c.value_.hasRan) {
        this.replayPath.push(true);
        items.push(c);
      } else
        this.replayPath.push(false);
    }
    return items;
  }
  filterOnReplay(itemsRaw) {
    return itemsRaw.filter((c, idx) => {
      const state = this.replayPath[this.replayPathPosition + idx];
      if (state === void 0)
        throw new Error(`Too short replayPath`);
      if (!state && c.value_.hasRan)
        throw new Error(`Mismatch between replayPath and real execution`);
      return state;
    });
  }
  filterForShrinkImpl(itemsRaw) {
    if (this.replayPathPosition === 0) {
      this.replayPath = this.sourceReplayPath !== null ? ReplayPath.parse(this.sourceReplayPath) : [];
    }
    const items = this.replayPathPosition < this.replayPath.length ? this.filterOnReplay(itemsRaw) : this.filterOnExecution(itemsRaw);
    this.replayPathPosition += itemsRaw.length;
    return items;
  }
  shrink(_value, context15) {
    if (context15 === void 0) {
      return Stream.nil();
    }
    const safeContext = context15;
    const shrunkOnce = safeContext.shrunkOnce;
    const itemsRaw = safeContext.items;
    const items = this.filterForShrinkImpl(itemsRaw);
    if (items.length === 0) {
      return Stream.nil();
    }
    const rootShrink = shrunkOnce ? Stream.nil() : new Stream([[]][Symbol.iterator]());
    const nextShrinks = [];
    for (let numToKeep = 0; numToKeep !== items.length; ++numToKeep) {
      nextShrinks.push(makeLazy(() => {
        const fixedStart = items.slice(0, numToKeep);
        return this.lengthArb.shrink(items.length - 1 - numToKeep, void 0).map((l) => fixedStart.concat(items.slice(items.length - (l.value + 1))));
      }));
    }
    for (let itemAt = 0; itemAt !== items.length; ++itemAt) {
      nextShrinks.push(makeLazy(() => this.oneCommandArb.shrink(items[itemAt].value_, items[itemAt].context).map((v) => items.slice(0, itemAt).concat([v], items.slice(itemAt + 1)))));
    }
    return rootShrink.join(...nextShrinks).map((shrinkables) => {
      return this.buildValueFor(shrinkables.map((c) => new Value(c.value_.clone(), c.context)), true);
    });
  }
};

// ../../node_modules/fast-check/lib/esm/arbitrary/commands.js
function commands(commandArbs, constraints = {}) {
  const { size: size40, maxCommands = MaxLengthUpperBound, disableReplayLog = false, replayPath = null } = constraints;
  const specifiedMaxCommands = constraints.maxCommands !== void 0;
  const maxGeneratedCommands = maxGeneratedLengthFromSizeForArbitrary(size40, 0, maxCommands, specifiedMaxCommands);
  return new CommandsArbitrary(commandArbs, maxGeneratedCommands, maxCommands, replayPath, disableReplayLog);
}

// ../../node_modules/fast-check/lib/esm/check/model/commands/ScheduledCommand.js
var ScheduledCommand = class {
  constructor(s, cmd) {
    this.s = s;
    this.cmd = cmd;
  }
  async check(m) {
    let error4 = null;
    let checkPassed = false;
    const status3 = await this.s.scheduleSequence([
      {
        label: `check@${this.cmd.toString()}`,
        builder: async () => {
          try {
            checkPassed = await Promise.resolve(this.cmd.check(m));
          } catch (err) {
            error4 = err;
            throw err;
          }
        }
      }
    ]).task;
    if (status3.faulty) {
      throw error4;
    }
    return checkPassed;
  }
  async run(m, r) {
    let error4 = null;
    const status3 = await this.s.scheduleSequence([
      {
        label: `run@${this.cmd.toString()}`,
        builder: async () => {
          try {
            await this.cmd.run(m, r);
          } catch (err) {
            error4 = err;
            throw err;
          }
        }
      }
    ]).task;
    if (status3.faulty) {
      throw error4;
    }
  }
};
var scheduleCommands = function* (s, cmds) {
  for (const cmd of cmds) {
    yield new ScheduledCommand(s, cmd);
  }
};

// ../../node_modules/fast-check/lib/esm/check/model/ModelRunner.js
var genericModelRun = (s, cmds, initialValue, runCmd, then) => {
  return s.then((o) => {
    const { model, real } = o;
    let state = initialValue;
    for (const c of cmds) {
      state = then(state, () => {
        return runCmd(c, model, real);
      });
    }
    return state;
  });
};
var internalModelRun = (s, cmds) => {
  const then = (_p, c) => c();
  const setupProducer = {
    then: (fun) => {
      fun(s());
      return void 0;
    }
  };
  const runSync4 = (cmd, m, r) => {
    if (cmd.check(m))
      cmd.run(m, r);
    return void 0;
  };
  return genericModelRun(setupProducer, cmds, void 0, runSync4, then);
};
var isAsyncSetup = (s) => {
  return typeof s.then === "function";
};
var internalAsyncModelRun = async (s, cmds, defaultPromise = Promise.resolve()) => {
  const then = (p, c) => p.then(c);
  const setupProducer = {
    then: (fun) => {
      const out = s();
      if (isAsyncSetup(out))
        return out.then(fun);
      else
        return fun(out);
    }
  };
  const runAsync = async (cmd, m, r) => {
    if (await cmd.check(m))
      await cmd.run(m, r);
  };
  return await genericModelRun(setupProducer, cmds, defaultPromise, runAsync, then);
};
function modelRun(s, cmds) {
  internalModelRun(s, cmds);
}
async function asyncModelRun(s, cmds) {
  await internalAsyncModelRun(s, cmds);
}
async function scheduledModelRun(scheduler2, s, cmds) {
  const scheduledCommands = scheduleCommands(scheduler2, cmds);
  const out = internalAsyncModelRun(s, scheduledCommands, scheduler2.schedule(Promise.resolve(), "startModel"));
  await scheduler2.waitFor(out);
  await scheduler2.waitAll();
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/implementations/SchedulerImplem.js
var defaultSchedulerAct = (f) => f();
var SchedulerImplem = class _SchedulerImplem {
  constructor(act, taskSelector) {
    this.act = act;
    this.taskSelector = taskSelector;
    this.lastTaskId = 0;
    this.sourceTaskSelector = taskSelector.clone();
    this.scheduledTasks = [];
    this.triggeredTasks = [];
    this.scheduledWatchers = [];
  }
  static buildLog(reportItem) {
    return `[task\${${reportItem.taskId}}] ${reportItem.label.length !== 0 ? `${reportItem.schedulingType}::${reportItem.label}` : reportItem.schedulingType} ${reportItem.status}${reportItem.outputValue !== void 0 ? ` with value ${escapeForTemplateString(reportItem.outputValue)}` : ""}`;
  }
  log(schedulingType, taskId, label, metadata, status3, data) {
    this.triggeredTasks.push({
      status: status3,
      schedulingType,
      taskId,
      label,
      metadata,
      outputValue: data !== void 0 ? stringify(data) : void 0
    });
  }
  scheduleInternal(schedulingType, label, task, metadata, customAct, thenTaskToBeAwaited) {
    let trigger = null;
    const taskId = ++this.lastTaskId;
    const scheduledPromise = new Promise((resolve, reject3) => {
      trigger = () => {
        (thenTaskToBeAwaited ? task.then(() => thenTaskToBeAwaited()) : task).then((data) => {
          this.log(schedulingType, taskId, label, metadata, "resolved", data);
          return resolve(data);
        }, (err) => {
          this.log(schedulingType, taskId, label, metadata, "rejected", err);
          return reject3(err);
        });
      };
    });
    this.scheduledTasks.push({
      original: task,
      scheduled: scheduledPromise,
      trigger,
      schedulingType,
      taskId,
      label,
      metadata,
      customAct
    });
    if (this.scheduledWatchers.length !== 0) {
      this.scheduledWatchers[0]();
    }
    return scheduledPromise;
  }
  schedule(task, label, metadata, customAct) {
    return this.scheduleInternal("promise", label || "", task, metadata, customAct || defaultSchedulerAct);
  }
  scheduleFunction(asyncFunction, customAct) {
    return (...args2) => this.scheduleInternal("function", `${asyncFunction.name}(${args2.map(stringify).join(",")})`, asyncFunction(...args2), void 0, customAct || defaultSchedulerAct);
  }
  scheduleSequence(sequenceBuilders, customAct) {
    const status3 = { done: false, faulty: false };
    const dummyResolvedPromise = { then: (f) => f() };
    let resolveSequenceTask = () => {
    };
    const sequenceTask = new Promise((resolve) => resolveSequenceTask = resolve);
    sequenceBuilders.reduce((previouslyScheduled, item) => {
      const [builder, label, metadata] = typeof item === "function" ? [item, item.name, void 0] : [item.builder, item.label, item.metadata];
      return previouslyScheduled.then(() => {
        const scheduled = this.scheduleInternal("sequence", label, dummyResolvedPromise, metadata, customAct || defaultSchedulerAct, () => builder());
        scheduled.catch(() => {
          status3.faulty = true;
          resolveSequenceTask();
        });
        return scheduled;
      });
    }, dummyResolvedPromise).then(() => {
      status3.done = true;
      resolveSequenceTask();
    }, () => {
    });
    return Object.assign(status3, {
      task: Promise.resolve(sequenceTask).then(() => {
        return { done: status3.done, faulty: status3.faulty };
      })
    });
  }
  count() {
    return this.scheduledTasks.length;
  }
  internalWaitOne() {
    if (this.scheduledTasks.length === 0) {
      throw new Error("No task scheduled");
    }
    const taskIndex = this.taskSelector.nextTaskIndex(this.scheduledTasks);
    const [scheduledTask] = this.scheduledTasks.splice(taskIndex, 1);
    return scheduledTask.customAct(async () => {
      scheduledTask.trigger();
      try {
        await scheduledTask.scheduled;
      } catch (_err) {
      }
    });
  }
  async waitOne(customAct) {
    const waitAct = customAct || defaultSchedulerAct;
    await this.act(() => waitAct(async () => await this.internalWaitOne()));
  }
  async waitAll(customAct) {
    while (this.scheduledTasks.length > 0) {
      await this.waitOne(customAct);
    }
  }
  async waitFor(unscheduledTask, customAct) {
    let taskResolved = false;
    let awaiterPromise = null;
    const awaiter = async () => {
      while (!taskResolved && this.scheduledTasks.length > 0) {
        await this.waitOne(customAct);
      }
      awaiterPromise = null;
    };
    const handleNotified = () => {
      if (awaiterPromise !== null) {
        return;
      }
      awaiterPromise = Promise.resolve().then(awaiter);
    };
    const clearAndReplaceWatcher = () => {
      const handleNotifiedIndex = this.scheduledWatchers.indexOf(handleNotified);
      if (handleNotifiedIndex !== -1) {
        this.scheduledWatchers.splice(handleNotifiedIndex, 1);
      }
      if (handleNotifiedIndex === 0 && this.scheduledWatchers.length !== 0) {
        this.scheduledWatchers[0]();
      }
    };
    const rewrappedTask = unscheduledTask.then((ret) => {
      taskResolved = true;
      if (awaiterPromise === null) {
        clearAndReplaceWatcher();
        return ret;
      }
      return awaiterPromise.then(() => {
        clearAndReplaceWatcher();
        return ret;
      });
    }, (err) => {
      taskResolved = true;
      if (awaiterPromise === null) {
        clearAndReplaceWatcher();
        throw err;
      }
      return awaiterPromise.then(() => {
        clearAndReplaceWatcher();
        throw err;
      });
    });
    if (this.scheduledTasks.length > 0 && this.scheduledWatchers.length === 0) {
      handleNotified();
    }
    this.scheduledWatchers.push(handleNotified);
    return rewrappedTask;
  }
  report() {
    return [
      ...this.triggeredTasks,
      ...this.scheduledTasks.map((t) => ({
        status: "pending",
        schedulingType: t.schedulingType,
        taskId: t.taskId,
        label: t.label,
        metadata: t.metadata
      }))
    ];
  }
  toString() {
    return "schedulerFor()`\n" + this.report().map(_SchedulerImplem.buildLog).map((log5) => `-> ${log5}`).join("\n") + "`";
  }
  [cloneMethod]() {
    return new _SchedulerImplem(this.act, this.sourceTaskSelector);
  }
};

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/BuildSchedulerFor.js
function buildNextTaskIndex(ordering) {
  let numTasks = 0;
  return {
    clone: () => buildNextTaskIndex(ordering),
    nextTaskIndex: (scheduledTasks) => {
      if (ordering.length <= numTasks) {
        throw new Error(`Invalid schedulerFor defined: too many tasks have been scheduled`);
      }
      const taskIndex = scheduledTasks.findIndex((t) => t.taskId === ordering[numTasks]);
      if (taskIndex === -1) {
        throw new Error(`Invalid schedulerFor defined: unable to find next task`);
      }
      ++numTasks;
      return taskIndex;
    }
  };
}
function buildSchedulerFor(act, ordering) {
  return new SchedulerImplem(act, buildNextTaskIndex(ordering));
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/SchedulerArbitrary.js
function buildNextTaskIndex2(mrng) {
  const clonedMrng = mrng.clone();
  return {
    clone: () => buildNextTaskIndex2(clonedMrng),
    nextTaskIndex: (scheduledTasks) => {
      return mrng.nextInt(0, scheduledTasks.length - 1);
    }
  };
}
var SchedulerArbitrary = class extends Arbitrary {
  constructor(act) {
    super();
    this.act = act;
  }
  generate(mrng, _biasFactor) {
    return new Value(new SchedulerImplem(this.act, buildNextTaskIndex2(mrng.clone())), void 0);
  }
  canShrinkWithoutContext(value10) {
    return false;
  }
  shrink(_value, _context) {
    return Stream.nil();
  }
};

// ../../node_modules/fast-check/lib/esm/arbitrary/scheduler.js
function scheduler(constraints) {
  const { act = (f) => f() } = constraints || {};
  return new SchedulerArbitrary(act);
}
function schedulerFor(customOrderingOrConstraints, constraintsOrUndefined) {
  const { act = (f) => f() } = Array.isArray(customOrderingOrConstraints) ? constraintsOrUndefined || {} : customOrderingOrConstraints || {};
  if (Array.isArray(customOrderingOrConstraints)) {
    return buildSchedulerFor(act, customOrderingOrConstraints);
  }
  return function(_strs, ...ordering) {
    return buildSchedulerFor(act, ordering);
  };
}

// ../../node_modules/fast-check/lib/esm/arbitrary/bigInt64Array.js
function bigInt64Array(constraints = {}) {
  return typedIntArrayArbitraryArbitraryBuilder(constraints, SBigInt("-9223372036854775808"), SBigInt("9223372036854775807"), SBigInt64Array, bigInt);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/bigUint64Array.js
function bigUint64Array(constraints = {}) {
  return typedIntArrayArbitraryArbitraryBuilder(constraints, SBigInt(0), SBigInt("18446744073709551615"), SBigUint64Array, bigInt);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/SanitizeRegexAst.js
function raiseUnsupportedASTNode(astNode) {
  return new Error(`Unsupported AST node! Received: ${stringify(astNode)}`);
}
function addMissingDotStarTraversalAddMissing(astNode, isFirst, isLast) {
  if (!isFirst && !isLast) {
    return astNode;
  }
  const traversalResults = { hasStart: false, hasEnd: false };
  const revampedNode = addMissingDotStarTraversal(astNode, isFirst, isLast, traversalResults);
  const missingStart = isFirst && !traversalResults.hasStart;
  const missingEnd = isLast && !traversalResults.hasEnd;
  if (!missingStart && !missingEnd) {
    return revampedNode;
  }
  const expressions = [];
  if (missingStart) {
    expressions.push({ type: "Assertion", kind: "^" });
    expressions.push({
      type: "Repetition",
      quantifier: { type: "Quantifier", kind: "*", greedy: true },
      expression: { type: "Char", kind: "meta", symbol: ".", value: ".", codePoint: Number.NaN }
    });
  }
  expressions.push(revampedNode);
  if (missingEnd) {
    expressions.push({
      type: "Repetition",
      quantifier: { type: "Quantifier", kind: "*", greedy: true },
      expression: { type: "Char", kind: "meta", symbol: ".", value: ".", codePoint: Number.NaN }
    });
    expressions.push({ type: "Assertion", kind: "$" });
  }
  return { type: "Group", capturing: false, expression: { type: "Alternative", expressions } };
}
function addMissingDotStarTraversal(astNode, isFirst, isLast, traversalResults) {
  switch (astNode.type) {
    case "Char":
      return astNode;
    case "Repetition":
      return astNode;
    case "Quantifier":
      throw new Error(`Wrongly defined AST tree, Quantifier nodes not supposed to be scanned!`);
    case "Alternative":
      traversalResults.hasStart = true;
      traversalResults.hasEnd = true;
      return Object.assign(Object.assign({}, astNode), { expressions: astNode.expressions.map((node, index) => addMissingDotStarTraversalAddMissing(node, isFirst && index === 0, isLast && index === astNode.expressions.length - 1)) });
    case "CharacterClass":
      return astNode;
    case "ClassRange":
      return astNode;
    case "Group": {
      return Object.assign(Object.assign({}, astNode), { expression: addMissingDotStarTraversal(astNode.expression, isFirst, isLast, traversalResults) });
    }
    case "Disjunction": {
      traversalResults.hasStart = true;
      traversalResults.hasEnd = true;
      return Object.assign(Object.assign({}, astNode), { left: astNode.left !== null ? addMissingDotStarTraversalAddMissing(astNode.left, isFirst, isLast) : null, right: astNode.right !== null ? addMissingDotStarTraversalAddMissing(astNode.right, isFirst, isLast) : null });
    }
    case "Assertion": {
      if (astNode.kind === "^" || astNode.kind === "Lookahead") {
        traversalResults.hasStart = true;
        return astNode;
      } else if (astNode.kind === "$" || astNode.kind === "Lookbehind") {
        traversalResults.hasEnd = true;
        return astNode;
      } else {
        throw new Error(`Assertions of kind ${astNode.kind} not implemented yet!`);
      }
    }
    case "Backreference":
      return astNode;
    default:
      throw raiseUnsupportedASTNode(astNode);
  }
}
function addMissingDotStar(astNode) {
  return addMissingDotStarTraversalAddMissing(astNode, true, true);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ReadRegex.js
function charSizeAt(text, pos) {
  return text[pos] >= "\uD800" && text[pos] <= "\uDBFF" && text[pos + 1] >= "\uDC00" && text[pos + 1] <= "\uDFFF" ? 2 : 1;
}
function isHexaDigit(char2) {
  return char2 >= "0" && char2 <= "9" || char2 >= "a" && char2 <= "f" || char2 >= "A" && char2 <= "F";
}
function isDigit(char2) {
  return char2 >= "0" && char2 <= "9";
}
function squaredBracketBlockContentEndFrom(text, from) {
  for (let index = from; index !== text.length; ++index) {
    const char2 = text[index];
    if (char2 === "\\") {
      index += 1;
    } else if (char2 === "]") {
      return index;
    }
  }
  throw new Error(`Missing closing ']'`);
}
function parenthesisBlockContentEndFrom(text, from) {
  let numExtraOpened = 0;
  for (let index = from; index !== text.length; ++index) {
    const char2 = text[index];
    if (char2 === "\\") {
      index += 1;
    } else if (char2 === ")") {
      if (numExtraOpened === 0) {
        return index;
      }
      numExtraOpened -= 1;
    } else if (char2 === "[") {
      index = squaredBracketBlockContentEndFrom(text, index);
    } else if (char2 === "(") {
      numExtraOpened += 1;
    }
  }
  throw new Error(`Missing closing ')'`);
}
function curlyBracketBlockContentEndFrom(text, from) {
  let foundComma = false;
  for (let index = from; index !== text.length; ++index) {
    const char2 = text[index];
    if (isDigit(char2)) {
    } else if (from === index) {
      return -1;
    } else if (char2 === ",") {
      if (foundComma) {
        return -1;
      }
      foundComma = true;
    } else if (char2 === "}") {
      return index;
    } else {
      return -1;
    }
  }
  return -1;
}
var TokenizerBlockMode;
(function(TokenizerBlockMode2) {
  TokenizerBlockMode2[TokenizerBlockMode2["Full"] = 0] = "Full";
  TokenizerBlockMode2[TokenizerBlockMode2["Character"] = 1] = "Character";
})(TokenizerBlockMode || (TokenizerBlockMode = {}));
function blockEndFrom(text, from, unicodeMode, mode) {
  switch (text[from]) {
    case "[": {
      if (mode === TokenizerBlockMode.Character) {
        return from + 1;
      }
      return squaredBracketBlockContentEndFrom(text, from + 1) + 1;
    }
    case "{": {
      if (mode === TokenizerBlockMode.Character) {
        return from + 1;
      }
      const foundEnd = curlyBracketBlockContentEndFrom(text, from + 1);
      if (foundEnd === -1) {
        return from + 1;
      }
      return foundEnd + 1;
    }
    case "(": {
      if (mode === TokenizerBlockMode.Character) {
        return from + 1;
      }
      return parenthesisBlockContentEndFrom(text, from + 1) + 1;
    }
    case "]":
    case "}":
    case ")":
      return from + 1;
    case "\\": {
      const next1 = text[from + 1];
      switch (next1) {
        case "x":
          if (isHexaDigit(text[from + 2]) && isHexaDigit(text[from + 3])) {
            return from + 4;
          }
          throw new Error(`Unexpected token '${text.substring(from, from + 4)}' found`);
        case "u":
          if (text[from + 2] === "{") {
            if (!unicodeMode) {
              return from + 2;
            }
            if (text[from + 4] === "}") {
              if (isHexaDigit(text[from + 3])) {
                return from + 5;
              }
              throw new Error(`Unexpected token '${text.substring(from, from + 5)}' found`);
            }
            if (text[from + 5] === "}") {
              if (isHexaDigit(text[from + 3]) && isHexaDigit(text[from + 4])) {
                return from + 6;
              }
              throw new Error(`Unexpected token '${text.substring(from, from + 6)}' found`);
            }
            if (text[from + 6] === "}") {
              if (isHexaDigit(text[from + 3]) && isHexaDigit(text[from + 4]) && isHexaDigit(text[from + 5])) {
                return from + 7;
              }
              throw new Error(`Unexpected token '${text.substring(from, from + 7)}' found`);
            }
            if (text[from + 7] === "}") {
              if (isHexaDigit(text[from + 3]) && isHexaDigit(text[from + 4]) && isHexaDigit(text[from + 5]) && isHexaDigit(text[from + 6])) {
                return from + 8;
              }
              throw new Error(`Unexpected token '${text.substring(from, from + 8)}' found`);
            }
            if (text[from + 8] === "}" && isHexaDigit(text[from + 3]) && isHexaDigit(text[from + 4]) && isHexaDigit(text[from + 5]) && isHexaDigit(text[from + 6]) && isHexaDigit(text[from + 7])) {
              return from + 9;
            }
            throw new Error(`Unexpected token '${text.substring(from, from + 9)}' found`);
          }
          if (isHexaDigit(text[from + 2]) && isHexaDigit(text[from + 3]) && isHexaDigit(text[from + 4]) && isHexaDigit(text[from + 5])) {
            return from + 6;
          }
          throw new Error(`Unexpected token '${text.substring(from, from + 6)}' found`);
        case "p":
        case "P": {
          if (!unicodeMode) {
            return from + 2;
          }
          let subIndex = from + 2;
          for (; subIndex < text.length && text[subIndex] !== "}"; subIndex += text[subIndex] === "\\" ? 2 : 1) {
          }
          if (text[subIndex] !== "}") {
            throw new Error(`Invalid \\P definition`);
          }
          return subIndex + 1;
        }
        case "k": {
          let subIndex = from + 2;
          for (; subIndex < text.length && text[subIndex] !== ">"; ++subIndex) {
          }
          if (text[subIndex] !== ">") {
            if (!unicodeMode) {
              return from + 2;
            }
            throw new Error(`Invalid \\k definition`);
          }
          return subIndex + 1;
        }
        default: {
          if (isDigit(next1)) {
            const maxIndex = unicodeMode ? text.length : Math.min(from + 4, text.length);
            let subIndex = from + 2;
            for (; subIndex < maxIndex && isDigit(text[subIndex]); ++subIndex) {
            }
            return subIndex;
          }
          const charSize = unicodeMode ? charSizeAt(text, from + 1) : 1;
          return from + charSize + 1;
        }
      }
    }
    default: {
      const charSize = unicodeMode ? charSizeAt(text, from) : 1;
      return from + charSize;
    }
  }
}
function readFrom(text, from, unicodeMode, mode) {
  const to = blockEndFrom(text, from, unicodeMode, mode);
  return text.substring(from, to);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/TokenizeRegex.js
var safeStringFromCodePoint2 = String.fromCodePoint;
function safePop2(tokens) {
  const previous2 = tokens.pop();
  if (previous2 === void 0) {
    throw new Error("Unable to extract token preceeding the currently parsed one");
  }
  return previous2;
}
function isDigit2(char2) {
  return char2 >= "0" && char2 <= "9";
}
function simpleChar(char2, escaped) {
  return {
    type: "Char",
    kind: "simple",
    symbol: char2,
    value: char2,
    codePoint: char2.codePointAt(0) || -1,
    escaped
  };
}
function metaEscapedChar(block, symbol6) {
  return {
    type: "Char",
    kind: "meta",
    symbol: symbol6,
    value: block,
    codePoint: symbol6.codePointAt(0) || -1
  };
}
function toSingleToken(tokens, allowEmpty) {
  if (tokens.length > 1) {
    return {
      type: "Alternative",
      expressions: tokens
    };
  }
  if (!allowEmpty && tokens.length === 0) {
    throw new Error(`Unsupported no token`);
  }
  return tokens[0];
}
function blockToCharToken(block) {
  if (block[0] === "\\") {
    const next6 = block[1];
    switch (next6) {
      case "x": {
        const allDigits = block.substring(2);
        const codePoint = Number.parseInt(allDigits, 16);
        const symbol6 = safeStringFromCodePoint2(codePoint);
        return { type: "Char", kind: "hex", symbol: symbol6, value: block, codePoint };
      }
      case "u": {
        if (block === "\\u") {
          return simpleChar("u", true);
        }
        const allDigits = block[2] === "{" ? block.substring(3, block.length - 1) : block.substring(2);
        const codePoint = Number.parseInt(allDigits, 16);
        const symbol6 = safeStringFromCodePoint2(codePoint);
        return { type: "Char", kind: "unicode", symbol: symbol6, value: block, codePoint };
      }
      case "0": {
        return metaEscapedChar(block, "\0");
      }
      case "n": {
        return metaEscapedChar(block, "\n");
      }
      case "f": {
        return metaEscapedChar(block, "\f");
      }
      case "r": {
        return metaEscapedChar(block, "\r");
      }
      case "t": {
        return metaEscapedChar(block, "	");
      }
      case "v": {
        return metaEscapedChar(block, "\v");
      }
      case "w":
      case "W":
      case "d":
      case "D":
      case "s":
      case "S":
      case "b":
      case "B": {
        return { type: "Char", kind: "meta", symbol: void 0, value: block, codePoint: Number.NaN };
      }
      default: {
        if (isDigit2(next6)) {
          const allDigits = block.substring(1);
          const codePoint = Number(allDigits);
          const symbol6 = safeStringFromCodePoint2(codePoint);
          return { type: "Char", kind: "decimal", symbol: symbol6, value: block, codePoint };
        }
        if (block.length > 2 && (next6 === "p" || next6 === "P")) {
          throw new Error(`UnicodeProperty not implemented yet!`);
        }
        const char2 = block.substring(1);
        return simpleChar(char2, true);
      }
    }
  }
  return simpleChar(block);
}
function pushTokens(tokens, regexSource, unicodeMode, groups) {
  let disjunctions = null;
  for (let index = 0, block = readFrom(regexSource, index, unicodeMode, TokenizerBlockMode.Full); index !== regexSource.length; index += block.length, block = readFrom(regexSource, index, unicodeMode, TokenizerBlockMode.Full)) {
    const firstInBlock = block[0];
    switch (firstInBlock) {
      case "|": {
        if (disjunctions === null) {
          disjunctions = [];
        }
        disjunctions.push(toSingleToken(tokens.splice(0), true) || null);
        break;
      }
      case ".": {
        tokens.push({ type: "Char", kind: "meta", symbol: block, value: block, codePoint: Number.NaN });
        break;
      }
      case "*":
      case "+": {
        const previous2 = safePop2(tokens);
        tokens.push({
          type: "Repetition",
          expression: previous2,
          quantifier: { type: "Quantifier", kind: firstInBlock, greedy: true }
        });
        break;
      }
      case "?": {
        const previous2 = safePop2(tokens);
        if (previous2.type === "Repetition") {
          previous2.quantifier.greedy = false;
          tokens.push(previous2);
        } else {
          tokens.push({
            type: "Repetition",
            expression: previous2,
            quantifier: { type: "Quantifier", kind: firstInBlock, greedy: true }
          });
        }
        break;
      }
      case "{": {
        if (block === "{") {
          tokens.push(simpleChar(block));
          break;
        }
        const previous2 = safePop2(tokens);
        const quantifierText = block.substring(1, block.length - 1);
        const quantifierTokens = quantifierText.split(",");
        const from = Number(quantifierTokens[0]);
        const to = quantifierTokens.length === 1 ? from : quantifierTokens[1].length !== 0 ? Number(quantifierTokens[1]) : void 0;
        tokens.push({
          type: "Repetition",
          expression: previous2,
          quantifier: { type: "Quantifier", kind: "Range", greedy: true, from, to }
        });
        break;
      }
      case "[": {
        const blockContent = block.substring(1, block.length - 1);
        const subTokens = [];
        let negative2 = void 0;
        let previousWasSimpleDash = false;
        for (let subIndex = 0, subBlock = readFrom(blockContent, subIndex, unicodeMode, TokenizerBlockMode.Character); subIndex !== blockContent.length; subIndex += subBlock.length, subBlock = readFrom(blockContent, subIndex, unicodeMode, TokenizerBlockMode.Character)) {
          if (subIndex === 0 && subBlock === "^") {
            negative2 = true;
            continue;
          }
          const newToken = blockToCharToken(subBlock);
          if (subBlock === "-") {
            subTokens.push(newToken);
            previousWasSimpleDash = true;
          } else {
            const operand1Token = subTokens.length >= 2 ? subTokens[subTokens.length - 2] : void 0;
            if (previousWasSimpleDash && operand1Token !== void 0 && operand1Token.type === "Char") {
              subTokens.pop();
              subTokens.pop();
              subTokens.push({ type: "ClassRange", from: operand1Token, to: newToken });
            } else {
              subTokens.push(newToken);
            }
            previousWasSimpleDash = false;
          }
        }
        tokens.push({ type: "CharacterClass", expressions: subTokens, negative: negative2 });
        break;
      }
      case "(": {
        const blockContent = block.substring(1, block.length - 1);
        const subTokens = [];
        if (blockContent[0] === "?") {
          if (blockContent[1] === ":") {
            pushTokens(subTokens, blockContent.substring(2), unicodeMode, groups);
            tokens.push({
              type: "Group",
              capturing: false,
              expression: toSingleToken(subTokens)
            });
          } else if (blockContent[1] === "=" || blockContent[1] === "!") {
            pushTokens(subTokens, blockContent.substring(2), unicodeMode, groups);
            tokens.push({
              type: "Assertion",
              kind: "Lookahead",
              negative: blockContent[1] === "!" ? true : void 0,
              assertion: toSingleToken(subTokens)
            });
          } else if (blockContent[1] === "<" && (blockContent[2] === "=" || blockContent[2] === "!")) {
            pushTokens(subTokens, blockContent.substring(3), unicodeMode, groups);
            tokens.push({
              type: "Assertion",
              kind: "Lookbehind",
              negative: blockContent[2] === "!" ? true : void 0,
              assertion: toSingleToken(subTokens)
            });
          } else {
            const chunks3 = blockContent.split(">");
            if (chunks3.length < 2 || chunks3[0][1] !== "<") {
              throw new Error(`Unsupported regex content found at ${JSON.stringify(block)}`);
            }
            const groupIndex = ++groups.lastIndex;
            const nameRaw = chunks3[0].substring(2);
            groups.named.set(nameRaw, groupIndex);
            pushTokens(subTokens, chunks3.slice(1).join(">"), unicodeMode, groups);
            tokens.push({
              type: "Group",
              capturing: true,
              nameRaw,
              name: nameRaw,
              number: groupIndex,
              expression: toSingleToken(subTokens)
            });
          }
        } else {
          const groupIndex = ++groups.lastIndex;
          pushTokens(subTokens, blockContent, unicodeMode, groups);
          tokens.push({
            type: "Group",
            capturing: true,
            number: groupIndex,
            expression: toSingleToken(subTokens)
          });
        }
        break;
      }
      default: {
        if (block === "^") {
          tokens.push({ type: "Assertion", kind: block });
        } else if (block === "$") {
          tokens.push({ type: "Assertion", kind: block });
        } else if (block[0] === "\\" && isDigit2(block[1])) {
          const reference = Number(block.substring(1));
          if (unicodeMode || reference <= groups.lastIndex) {
            tokens.push({ type: "Backreference", kind: "number", number: reference, reference });
          } else {
            tokens.push(blockToCharToken(block));
          }
        } else if (block[0] === "\\" && block[1] === "k" && block.length !== 2) {
          const referenceRaw = block.substring(3, block.length - 1);
          tokens.push({
            type: "Backreference",
            kind: "name",
            number: groups.named.get(referenceRaw) || 0,
            referenceRaw,
            reference: referenceRaw
          });
        } else {
          tokens.push(blockToCharToken(block));
        }
        break;
      }
    }
  }
  if (disjunctions !== null) {
    disjunctions.push(toSingleToken(tokens.splice(0), true) || null);
    let currentDisjunction = {
      type: "Disjunction",
      left: disjunctions[0],
      right: disjunctions[1]
    };
    for (let index = 2; index < disjunctions.length; ++index) {
      currentDisjunction = {
        type: "Disjunction",
        left: currentDisjunction,
        right: disjunctions[index]
      };
    }
    tokens.push(currentDisjunction);
  }
}
function tokenizeRegex(regex) {
  const unicodeMode = safeIndexOf([...regex.flags], "u") !== -1;
  const regexSource = regex.source;
  const tokens = [];
  pushTokens(tokens, regexSource, unicodeMode, { lastIndex: 0, named: /* @__PURE__ */ new Map() });
  return toSingleToken(tokens);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/stringMatching.js
var safeStringFromCodePoint3 = String.fromCodePoint;
var wordChars = [..."abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_"];
var digitChars = [..."0123456789"];
var spaceChars = [..." 	\r\n\v\f"];
var newLineChars = [..."\r\n"];
var terminatorChars = [...""];
var newLineAndTerminatorChars = [...newLineChars, ...terminatorChars];
var defaultChar = char();
function raiseUnsupportedASTNode2(astNode) {
  return new SError(`Unsupported AST node! Received: ${stringify(astNode)}`);
}
function toMatchingArbitrary(astNode, constraints, flags) {
  switch (astNode.type) {
    case "Char": {
      if (astNode.kind === "meta") {
        switch (astNode.value) {
          case "\\w": {
            return constantFrom(...wordChars);
          }
          case "\\W": {
            return defaultChar.filter((c) => safeIndexOf(wordChars, c) === -1);
          }
          case "\\d": {
            return constantFrom(...digitChars);
          }
          case "\\D": {
            return defaultChar.filter((c) => safeIndexOf(digitChars, c) === -1);
          }
          case "\\s": {
            return constantFrom(...spaceChars);
          }
          case "\\S": {
            return defaultChar.filter((c) => safeIndexOf(spaceChars, c) === -1);
          }
          case "\\b":
          case "\\B": {
            throw new SError(`Meta character ${astNode.value} not implemented yet!`);
          }
          case ".": {
            const forbiddenChars = flags.dotAll ? terminatorChars : newLineAndTerminatorChars;
            return defaultChar.filter((c) => safeIndexOf(forbiddenChars, c) === -1);
          }
        }
      }
      if (astNode.symbol === void 0) {
        throw new SError(`Unexpected undefined symbol received for non-meta Char! Received: ${stringify(astNode)}`);
      }
      return constant2(astNode.symbol);
    }
    case "Repetition": {
      const node = toMatchingArbitrary(astNode.expression, constraints, flags);
      switch (astNode.quantifier.kind) {
        case "*": {
          return stringOf(node, constraints);
        }
        case "+": {
          return stringOf(node, Object.assign(Object.assign({}, constraints), { minLength: 1 }));
        }
        case "?": {
          return stringOf(node, Object.assign(Object.assign({}, constraints), { minLength: 0, maxLength: 1 }));
        }
        case "Range": {
          return stringOf(node, Object.assign(Object.assign({}, constraints), { minLength: astNode.quantifier.from, maxLength: astNode.quantifier.to }));
        }
        default: {
          throw raiseUnsupportedASTNode2(astNode.quantifier);
        }
      }
    }
    case "Quantifier": {
      throw new SError(`Wrongly defined AST tree, Quantifier nodes not supposed to be scanned!`);
    }
    case "Alternative": {
      return tuple4(...safeMap(astNode.expressions, (n) => toMatchingArbitrary(n, constraints, flags))).map((vs) => safeJoin(vs, ""));
    }
    case "CharacterClass":
      if (astNode.negative) {
        const childrenArbitraries = safeMap(astNode.expressions, (n) => toMatchingArbitrary(n, constraints, flags));
        return defaultChar.filter((c) => safeEvery(childrenArbitraries, (arb) => !arb.canShrinkWithoutContext(c)));
      }
      return oneof(...safeMap(astNode.expressions, (n) => toMatchingArbitrary(n, constraints, flags)));
    case "ClassRange": {
      const min11 = astNode.from.codePoint;
      const max13 = astNode.to.codePoint;
      return integer({ min: min11, max: max13 }).map((n) => safeStringFromCodePoint3(n), (c) => {
        if (typeof c !== "string")
          throw new SError("Invalid type");
        if ([...c].length !== 1)
          throw new SError("Invalid length");
        return safeCharCodeAt(c, 0);
      });
    }
    case "Group": {
      return toMatchingArbitrary(astNode.expression, constraints, flags);
    }
    case "Disjunction": {
      const left3 = astNode.left !== null ? toMatchingArbitrary(astNode.left, constraints, flags) : constant2("");
      const right3 = astNode.right !== null ? toMatchingArbitrary(astNode.right, constraints, flags) : constant2("");
      return oneof(left3, right3);
    }
    case "Assertion": {
      if (astNode.kind === "^" || astNode.kind === "$") {
        if (flags.multiline) {
          if (astNode.kind === "^") {
            return oneof(constant2(""), tuple4(stringOf(defaultChar), constantFrom(...newLineChars)).map((t) => `${t[0]}${t[1]}`, (value10) => {
              if (typeof value10 !== "string" || value10.length === 0)
                throw new SError("Invalid type");
              return [safeSubstring(value10, 0, value10.length - 1), value10[value10.length - 1]];
            }));
          } else {
            return oneof(constant2(""), tuple4(constantFrom(...newLineChars), stringOf(defaultChar)).map((t) => `${t[0]}${t[1]}`, (value10) => {
              if (typeof value10 !== "string" || value10.length === 0)
                throw new SError("Invalid type");
              return [value10[0], safeSubstring(value10, 1)];
            }));
          }
        }
        return constant2("");
      }
      throw new SError(`Assertions of kind ${astNode.kind} not implemented yet!`);
    }
    case "Backreference": {
      throw new SError(`Backreference nodes not implemented yet!`);
    }
    default: {
      throw raiseUnsupportedASTNode2(astNode);
    }
  }
}
function stringMatching(regex, constraints = {}) {
  for (const flag of regex.flags) {
    if (flag !== "d" && flag !== "g" && flag !== "m" && flag !== "s" && flag !== "u") {
      throw new SError(`Unable to use "stringMatching" against a regex using the flag ${flag}`);
    }
  }
  const sanitizedConstraints = { size: constraints.size };
  const flags = { multiline: regex.multiline, dotAll: regex.dotAll };
  const regexRootToken = addMissingDotStar(tokenizeRegex(regex));
  return toMatchingArbitrary(regexRootToken, sanitizedConstraints, flags);
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ZipIterableIterators.js
function initZippedValues(its) {
  const vs = [];
  for (let index = 0; index !== its.length; ++index) {
    vs.push(its[index].next());
  }
  return vs;
}
function nextZippedValues(its, vs) {
  for (let index = 0; index !== its.length; ++index) {
    vs[index] = its[index].next();
  }
}
function isDoneZippedValues(vs) {
  for (let index = 0; index !== vs.length; ++index) {
    if (vs[index].done) {
      return true;
    }
  }
  return false;
}
function* zipIterableIterators(...its) {
  const vs = initZippedValues(its);
  while (!isDoneZippedValues(vs)) {
    yield vs.map((v) => v.value);
    nextZippedValues(its, vs);
  }
}

// ../../node_modules/fast-check/lib/esm/arbitrary/_internals/LimitedShrinkArbitrary.js
function* iotaFrom(startValue) {
  let value10 = startValue;
  while (true) {
    yield value10;
    ++value10;
  }
}
var LimitedShrinkArbitrary = class extends Arbitrary {
  constructor(arb, maxShrinks) {
    super();
    this.arb = arb;
    this.maxShrinks = maxShrinks;
  }
  generate(mrng, biasFactor) {
    const value10 = this.arb.generate(mrng, biasFactor);
    return this.valueMapper(value10, 0);
  }
  canShrinkWithoutContext(value10) {
    return this.arb.canShrinkWithoutContext(value10);
  }
  shrink(value10, context15) {
    if (this.isSafeContext(context15)) {
      return this.safeShrink(value10, context15.originalContext, context15.length);
    }
    return this.safeShrink(value10, void 0, 0);
  }
  safeShrink(value10, originalContext, currentLength) {
    const remaining = this.maxShrinks - currentLength;
    if (remaining <= 0) {
      return Stream.nil();
    }
    return new Stream(zipIterableIterators(this.arb.shrink(value10, originalContext), iotaFrom(currentLength + 1))).take(remaining).map((valueAndLength) => this.valueMapper(valueAndLength[0], valueAndLength[1]));
  }
  valueMapper(v, newLength) {
    const context15 = { originalContext: v.context, length: newLength };
    return new Value(v.value, context15);
  }
  isSafeContext(context15) {
    return context15 != null && typeof context15 === "object" && "originalContext" in context15 && "length" in context15;
  }
};

// ../../node_modules/fast-check/lib/esm/arbitrary/limitShrink.js
function limitShrink(arbitrary, maxShrinks) {
  return new LimitedShrinkArbitrary(arbitrary, maxShrinks);
}

// ../../node_modules/fast-check/lib/esm/fast-check-default.js
var __type2 = "module";
var __version2 = "3.23.2";
var __commitHash2 = "a4a600eaa08c833707067a877db144289a724b91";

// ../../node_modules/effect/dist/esm/internal/schema/util.js
var getKeysForIndexSignature = (input, parameter) => {
  switch (parameter._tag) {
    case "StringKeyword":
    case "TemplateLiteral":
      return Object.keys(input);
    case "SymbolKeyword":
      return Object.getOwnPropertySymbols(input);
    case "Refinement":
      return getKeysForIndexSignature(input, parameter.from);
  }
};
var ownKeys = (o) => Object.keys(o).concat(Object.getOwnPropertySymbols(o));
var memoizeThunk = (f) => {
  let done17 = false;
  let a;
  return () => {
    if (done17) {
      return a;
    }
    a = f();
    done17 = true;
    return a;
  };
};
var formatDate = (date5) => {
  try {
    return date5.toISOString();
  } catch {
    return String(date5);
  }
};
var formatUnknown = (u, checkCircular = true) => {
  if (Array.isArray(u)) {
    return `[${u.map((i) => formatUnknown(i, checkCircular)).join(",")}]`;
  }
  if (isDate(u)) {
    return formatDate(u);
  }
  if (hasProperty(u, "toString") && isFunction2(u["toString"]) && u["toString"] !== Object.prototype.toString) {
    return u["toString"]();
  }
  if (isString(u)) {
    return JSON.stringify(u);
  }
  if (isNumber(u) || u == null || isBoolean(u) || isSymbol(u)) {
    return String(u);
  }
  if (isBigInt(u)) {
    return String(u) + "n";
  }
  if (isIterable(u)) {
    return `${u.constructor.name}(${formatUnknown(Array.from(u), checkCircular)})`;
  }
  try {
    if (checkCircular) {
      JSON.stringify(u);
    }
    const pojo = `{${ownKeys(u).map((k) => `${isString(k) ? JSON.stringify(k) : String(k)}:${formatUnknown(u[k], false)}`).join(",")}}`;
    const name = u.constructor.name;
    return u.constructor !== Object.prototype.constructor ? `${name}(${pojo})` : pojo;
  } catch {
    return "<circular structure>";
  }
};
var formatPropertyKey = (name) => typeof name === "string" ? JSON.stringify(name) : String(name);
var isNonEmpty = (x) => Array.isArray(x);
var isSingle = (x) => !Array.isArray(x);
var formatPathKey = (key) => `[${formatPropertyKey(key)}]`;
var formatPath = (path) => isNonEmpty(path) ? path.map(formatPathKey).join("") : formatPathKey(path);

// ../../node_modules/effect/dist/esm/internal/schema/errors.js
var getErrorMessage = (reason, details, path, ast) => {
  let out = reason;
  if (path && isNonEmptyReadonlyArray(path)) {
    out += `
at path: ${formatPath(path)}`;
  }
  if (details !== void 0) {
    out += `
details: ${details}`;
  }
  if (ast) {
    out += `
schema (${ast._tag}): ${ast}`;
  }
  return out;
};
var getInvalidArgumentErrorMessage = (details) => getErrorMessage("Invalid Argument", details);
var getUnsupportedSchemaErrorMessage = (details, path, ast) => getErrorMessage("Unsupported schema", details, path, ast);
var getMissingAnnotationErrorMessage = (details, path, ast) => getErrorMessage("Missing annotation", details, path, ast);
var getArbitraryMissingAnnotationErrorMessage = (path, ast) => getMissingAnnotationErrorMessage(`Generating an Arbitrary for this schema requires an "arbitrary" annotation`, path, ast);
var getArbitraryEmptyEnumErrorMessage = (path) => getErrorMessage("Empty Enums schema", "Generating an Arbitrary for this schema requires at least one enum", path);
var getEquivalenceUnsupportedErrorMessage = (ast, path) => getUnsupportedSchemaErrorMessage("Cannot build an Equivalence", path, ast);
var getJSONSchemaMissingAnnotationErrorMessage = (path, ast) => getMissingAnnotationErrorMessage(`Generating a JSON Schema for this schema requires a "jsonSchema" annotation`, path, ast);
var getJSONSchemaMissingIdentifierAnnotationErrorMessage = (path, ast) => getMissingAnnotationErrorMessage(`Generating a JSON Schema for this schema requires an "identifier" annotation`, path, ast);
var getJSONSchemaUnsupportedPostRestElementsErrorMessage = (path) => getErrorMessage("Generating a JSON Schema for post-rest elements is not currently supported. You're welcome to contribute by submitting a Pull Request", void 0, path);
var getJSONSchemaUnsupportedKeyErrorMessage = (key, path) => getErrorMessage("Unsupported key", `Cannot encode ${formatPropertyKey(key)} key to JSON Schema`, path);
var getPrettyMissingAnnotationErrorMessage = (path, ast) => getMissingAnnotationErrorMessage(`Generating a Pretty for this schema requires a "pretty" annotation`, path, ast);
var getPrettyNeverErrorMessage = "Cannot pretty print a `never` value";
var getPrettyNoMatchingSchemaErrorMessage = (actual, path, ast) => getErrorMessage("Unexpected Error", `Cannot find a matching schema for ${formatUnknown(actual)}`, path, ast);
var getSchemaExtendErrorMessage = (x, y, path) => getErrorMessage("Unsupported schema or overlapping types", `cannot extend ${x} with ${y}`, path);
var getSchemaUnsupportedLiteralSpanErrorMessage = (ast) => getErrorMessage("Unsupported template literal span", void 0, void 0, ast);
var getASTUnsupportedSchemaErrorMessage = (ast) => getUnsupportedSchemaErrorMessage(void 0, void 0, ast);
var getASTUnsupportedKeySchemaErrorMessage = (ast) => getErrorMessage("Unsupported key schema", void 0, void 0, ast);
var getASTUnsupportedLiteralErrorMessage = (literal3) => getErrorMessage("Unsupported literal", `literal value: ${formatUnknown(literal3)}`);
var getASTDuplicateIndexSignatureErrorMessage = (type3) => getErrorMessage("Duplicate index signature", `${type3} index signature`);
var getASTIndexSignatureParameterErrorMessage = getErrorMessage("Unsupported index signature parameter", "An index signature parameter type must be `string`, `symbol`, a template literal type or a refinement of the previous types");
var getASTRequiredElementFollowinAnOptionalElementErrorMessage = getErrorMessage("Invalid element", "A required element cannot follow an optional element. ts(1257)");
var getASTDuplicatePropertySignatureTransformationErrorMessage = (key) => getErrorMessage("Duplicate property signature transformation", `Duplicate key ${formatUnknown(key)}`);
var getASTUnsupportedRenameSchemaErrorMessage = (ast) => getUnsupportedSchemaErrorMessage(void 0, void 0, ast);
var getASTDuplicatePropertySignatureErrorMessage = (key) => getErrorMessage("Duplicate property signature", `Duplicate key ${formatUnknown(key)}`);

// ../../node_modules/effect/dist/esm/internal/schema/schemaId.js
var DateFromSelfSchemaId = Symbol.for("effect/SchemaId/DateFromSelf");
var GreaterThanSchemaId = Symbol.for("effect/SchemaId/GreaterThan");
var GreaterThanOrEqualToSchemaId = Symbol.for("effect/SchemaId/GreaterThanOrEqualTo");
var LessThanSchemaId = Symbol.for("effect/SchemaId/LessThan");
var LessThanOrEqualToSchemaId = Symbol.for("effect/SchemaId/LessThanOrEqualTo");
var IntSchemaId = Symbol.for("effect/SchemaId/Int");
var NonNaNSchemaId = Symbol.for("effect/SchemaId/NonNaN");
var FiniteSchemaId = Symbol.for("effect/SchemaId/Finite");
var JsonNumberSchemaId = Symbol.for("effect/SchemaId/JsonNumber");
var BetweenSchemaId = Symbol.for("effect/SchemaId/Between");
var GreaterThanBigintSchemaId = Symbol.for("effect/SchemaId/GreaterThanBigint");
var GreaterThanOrEqualToBigIntSchemaId = Symbol.for("effect/SchemaId/GreaterThanOrEqualToBigint");
var LessThanBigIntSchemaId = Symbol.for("effect/SchemaId/LessThanBigint");
var LessThanOrEqualToBigIntSchemaId = Symbol.for("effect/SchemaId/LessThanOrEqualToBigint");
var BetweenBigintSchemaId = Symbol.for("effect/SchemaId/BetweenBigint");
var MinLengthSchemaId = Symbol.for("effect/SchemaId/MinLength");
var MaxLengthSchemaId = Symbol.for("effect/SchemaId/MaxLength");
var LengthSchemaId = Symbol.for("effect/SchemaId/Length");
var MinItemsSchemaId = Symbol.for("effect/SchemaId/MinItems");
var MaxItemsSchemaId = Symbol.for("effect/SchemaId/MaxItems");
var ItemsCountSchemaId = Symbol.for("effect/SchemaId/ItemsCount");

// ../../node_modules/effect/dist/esm/SchemaAST.js
var SchemaAST_exports = {};
__export(SchemaAST_exports, {
  AnyKeyword: () => AnyKeyword,
  ArbitraryAnnotationId: () => ArbitraryAnnotationId,
  AutoTitleAnnotationId: () => AutoTitleAnnotationId,
  BatchingAnnotationId: () => BatchingAnnotationId,
  BigIntKeyword: () => BigIntKeyword,
  BooleanKeyword: () => BooleanKeyword,
  BrandAnnotationId: () => BrandAnnotationId,
  ComposeTransformation: () => ComposeTransformation,
  ConcurrencyAnnotationId: () => ConcurrencyAnnotationId,
  Declaration: () => Declaration,
  DecodingFallbackAnnotationId: () => DecodingFallbackAnnotationId,
  DefaultAnnotationId: () => DefaultAnnotationId,
  DescriptionAnnotationId: () => DescriptionAnnotationId,
  DocumentationAnnotationId: () => DocumentationAnnotationId,
  Enums: () => Enums,
  EquivalenceAnnotationId: () => EquivalenceAnnotationId,
  ExamplesAnnotationId: () => ExamplesAnnotationId,
  FinalTransformation: () => FinalTransformation,
  IdentifierAnnotationId: () => IdentifierAnnotationId,
  IndexSignature: () => IndexSignature,
  JSONIdentifierAnnotationId: () => JSONIdentifierAnnotationId,
  JSONSchemaAnnotationId: () => JSONSchemaAnnotationId,
  Literal: () => Literal,
  MessageAnnotationId: () => MessageAnnotationId,
  MissingMessageAnnotationId: () => MissingMessageAnnotationId,
  NeverKeyword: () => NeverKeyword,
  NumberKeyword: () => NumberKeyword,
  ObjectKeyword: () => ObjectKeyword,
  OptionalType: () => OptionalType,
  ParseIssueTitleAnnotationId: () => ParseIssueTitleAnnotationId,
  ParseJsonSchemaId: () => ParseJsonSchemaId,
  ParseOptionsAnnotationId: () => ParseOptionsAnnotationId,
  PrettyAnnotationId: () => PrettyAnnotationId,
  PropertySignature: () => PropertySignature,
  PropertySignatureTransformation: () => PropertySignatureTransformation,
  Refinement: () => Refinement,
  SchemaIdAnnotationId: () => SchemaIdAnnotationId,
  StableFilterAnnotationId: () => StableFilterAnnotationId,
  StringKeyword: () => StringKeyword,
  SurrogateAnnotationId: () => SurrogateAnnotationId,
  Suspend: () => Suspend,
  SymbolKeyword: () => SymbolKeyword,
  TemplateLiteral: () => TemplateLiteral,
  TemplateLiteralSpan: () => TemplateLiteralSpan,
  TitleAnnotationId: () => TitleAnnotationId,
  Transformation: () => Transformation,
  TupleType: () => TupleType,
  Type: () => Type,
  TypeLiteral: () => TypeLiteral,
  TypeLiteralTransformation: () => TypeLiteralTransformation,
  UndefinedKeyword: () => UndefinedKeyword,
  Union: () => Union,
  UniqueSymbol: () => UniqueSymbol,
  UnknownKeyword: () => UnknownKeyword,
  VoidKeyword: () => VoidKeyword,
  annotations: () => annotations,
  anyKeyword: () => anyKeyword,
  bigIntKeyword: () => bigIntKeyword,
  booleanKeyword: () => booleanKeyword,
  compose: () => compose3,
  composeTransformation: () => composeTransformation,
  defaultParseOption: () => defaultParseOption,
  encodedAST: () => encodedAST,
  encodedBoundAST: () => encodedBoundAST,
  equals: () => equals2,
  flatten: () => flatten4,
  getAnnotation: () => getAnnotation,
  getAutoTitleAnnotation: () => getAutoTitleAnnotation,
  getBatchingAnnotation: () => getBatchingAnnotation,
  getBrandAnnotation: () => getBrandAnnotation,
  getCompiler: () => getCompiler,
  getConcurrencyAnnotation: () => getConcurrencyAnnotation,
  getDecodingFallbackAnnotation: () => getDecodingFallbackAnnotation,
  getDefaultAnnotation: () => getDefaultAnnotation,
  getDescriptionAnnotation: () => getDescriptionAnnotation,
  getDocumentationAnnotation: () => getDocumentationAnnotation,
  getEncodedParameter: () => getEncodedParameter,
  getExamplesAnnotation: () => getExamplesAnnotation,
  getIdentifierAnnotation: () => getIdentifierAnnotation,
  getJSONIdentifier: () => getJSONIdentifier,
  getJSONIdentifierAnnotation: () => getJSONIdentifierAnnotation,
  getJSONSchemaAnnotation: () => getJSONSchemaAnnotation,
  getMessageAnnotation: () => getMessageAnnotation,
  getMissingMessageAnnotation: () => getMissingMessageAnnotation,
  getNumberIndexedAccess: () => getNumberIndexedAccess,
  getParseIssueTitleAnnotation: () => getParseIssueTitleAnnotation,
  getParseOptionsAnnotation: () => getParseOptionsAnnotation,
  getPropertyKeyIndexedAccess: () => getPropertyKeyIndexedAccess,
  getPropertySignatures: () => getPropertySignatures,
  getSchemaIdAnnotation: () => getSchemaIdAnnotation,
  getSurrogateAnnotation: () => getSurrogateAnnotation,
  getTemplateLiteralCapturingRegExp: () => getTemplateLiteralCapturingRegExp,
  getTemplateLiteralRegExp: () => getTemplateLiteralRegExp,
  getTitleAnnotation: () => getTitleAnnotation,
  getTransformationFrom: () => getTransformationFrom,
  hasStableFilter: () => hasStableFilter,
  isAnyKeyword: () => isAnyKeyword,
  isBigIntKeyword: () => isBigIntKeyword,
  isBooleanKeyword: () => isBooleanKeyword,
  isComposeTransformation: () => isComposeTransformation,
  isDeclaration: () => isDeclaration,
  isEnums: () => isEnums,
  isFinalTransformation: () => isFinalTransformation,
  isLiteral: () => isLiteral,
  isMembers: () => isMembers,
  isNeverKeyword: () => isNeverKeyword,
  isNumberKeyword: () => isNumberKeyword,
  isObjectKeyword: () => isObjectKeyword,
  isParameter: () => isParameter,
  isRefinement: () => isRefinement,
  isStringKeyword: () => isStringKeyword,
  isSuspend: () => isSuspend,
  isSymbolKeyword: () => isSymbolKeyword,
  isTemplateLiteral: () => isTemplateLiteral,
  isTransformation: () => isTransformation,
  isTupleType: () => isTupleType,
  isTypeLiteral: () => isTypeLiteral,
  isTypeLiteralTransformation: () => isTypeLiteralTransformation,
  isUndefinedKeyword: () => isUndefinedKeyword,
  isUnion: () => isUnion,
  isUniqueSymbol: () => isUniqueSymbol,
  isUnknownKeyword: () => isUnknownKeyword,
  isVoidKeyword: () => isVoidKeyword,
  keyof: () => keyof,
  mapMembers: () => mapMembers,
  mutable: () => mutable,
  neverKeyword: () => neverKeyword,
  null: () => $null,
  numberKeyword: () => numberKeyword,
  objectKeyword: () => objectKeyword,
  omit: () => omit,
  omitAnnotations: () => omitAnnotations,
  orUndefined: () => orUndefined,
  partial: () => partial,
  pick: () => pick,
  pickAnnotations: () => pickAnnotations,
  pruneUndefined: () => pruneUndefined,
  record: () => record2,
  rename: () => rename,
  required: () => required,
  stringKeyword: () => stringKeyword,
  symbolKeyword: () => symbolKeyword,
  typeAST: () => typeAST,
  undefinedKeyword: () => undefinedKeyword,
  unify: () => unify,
  unknownKeyword: () => unknownKeyword,
  voidKeyword: () => voidKeyword
});

// ../../node_modules/effect/dist/esm/Number.js
var Number_exports = {};
__export(Number_exports, {
  Equivalence: () => Equivalence,
  Order: () => Order,
  between: () => between2,
  clamp: () => clamp3,
  decrement: () => decrement,
  divide: () => divide,
  greaterThan: () => greaterThan2,
  greaterThanOrEqualTo: () => greaterThanOrEqualTo2,
  increment: () => increment,
  isNumber: () => isNumber2,
  lessThan: () => lessThan2,
  lessThanOrEqualTo: () => lessThanOrEqualTo2,
  max: () => max3,
  min: () => min3,
  multiply: () => multiply,
  multiplyAll: () => multiplyAll,
  negate: () => negate,
  nextPow2: () => nextPow2,
  parse: () => parse,
  remainder: () => remainder,
  round: () => round,
  sign: () => sign,
  subtract: () => subtract,
  sum: () => sum,
  sumAll: () => sumAll,
  unsafeDivide: () => unsafeDivide
});
var isNumber2 = isNumber;
var negate = (n) => multiply(n, -1);
var sum = dual(2, (self, that) => self + that);
var sumAll = (collection) => reduce(collection, 0, sum);
var subtract = dual(2, (minuend, subtrahend) => minuend - subtrahend);
var multiply = dual(2, (multiplier, multiplicand) => multiplier * multiplicand);
var multiplyAll = (collection) => {
  let out = 1;
  for (const n of collection) {
    if (n === 0) {
      return 0;
    }
    out *= n;
  }
  return out;
};
var divide = dual(2, (dividend, divisor) => divisor === 0 ? none : some2(dividend / divisor));
var unsafeDivide = dual(2, (dividend, divisor) => dividend / divisor);
var increment = (n) => sum(n, 1);
var decrement = (n) => subtract(n, 1);
var Equivalence = number;
var Order = number3;
var lessThan2 = lessThan(Order);
var lessThanOrEqualTo2 = lessThanOrEqualTo(Order);
var greaterThan2 = greaterThan(Order);
var greaterThanOrEqualTo2 = greaterThanOrEqualTo(Order);
var between2 = between(Order);
var clamp3 = clamp(Order);
var min3 = min(Order);
var max3 = max(Order);
var sign = (n) => Order(n, 0);
var remainder = dual(2, (dividend, divisor) => {
  const selfDecCount = (dividend.toString().split(".")[1] || "").length;
  const divisorDecCount = (divisor.toString().split(".")[1] || "").length;
  const decCount = selfDecCount > divisorDecCount ? selfDecCount : divisorDecCount;
  const selfInt = parseInt(dividend.toFixed(decCount).replace(".", ""));
  const divisorInt = parseInt(divisor.toFixed(decCount).replace(".", ""));
  return selfInt % divisorInt / Math.pow(10, decCount);
});
var nextPow2 = (n) => {
  const nextPow = Math.ceil(Math.log(n) / Math.log(2));
  return Math.max(Math.pow(2, nextPow), 2);
};
var parse = (s) => {
  if (s === "NaN") {
    return some2(NaN);
  }
  if (s === "Infinity") {
    return some2(Infinity);
  }
  if (s === "-Infinity") {
    return some2(-Infinity);
  }
  if (s.trim() === "") {
    return none;
  }
  const n = Number(s);
  return Number.isNaN(n) ? none : some2(n);
};
var round = dual(2, (self, precision) => {
  const factor = Math.pow(10, precision);
  return Math.round(self * factor) / factor;
});

// ../../node_modules/effect/dist/esm/RegExp.js
var RegExp_exports = {};
__export(RegExp_exports, {
  escape: () => escape,
  isRegExp: () => isRegExp2
});
var isRegExp2 = isRegExp;
var escape = (string8) => string8.replace(/[/\\^$*+?.()|[\]{}]/g, "\\$&");

// ../../node_modules/effect/dist/esm/SchemaAST.js
var BrandAnnotationId = Symbol.for("effect/annotation/Brand");
var SchemaIdAnnotationId = Symbol.for("effect/annotation/SchemaId");
var MessageAnnotationId = Symbol.for("effect/annotation/Message");
var MissingMessageAnnotationId = Symbol.for("effect/annotation/MissingMessage");
var IdentifierAnnotationId = Symbol.for("effect/annotation/Identifier");
var TitleAnnotationId = Symbol.for("effect/annotation/Title");
var AutoTitleAnnotationId = Symbol.for("effect/annotation/AutoTitle");
var DescriptionAnnotationId = Symbol.for("effect/annotation/Description");
var ExamplesAnnotationId = Symbol.for("effect/annotation/Examples");
var DefaultAnnotationId = Symbol.for("effect/annotation/Default");
var JSONSchemaAnnotationId = Symbol.for("effect/annotation/JSONSchema");
var ArbitraryAnnotationId = Symbol.for("effect/annotation/Arbitrary");
var PrettyAnnotationId = Symbol.for("effect/annotation/Pretty");
var EquivalenceAnnotationId = Symbol.for("effect/annotation/Equivalence");
var DocumentationAnnotationId = Symbol.for("effect/annotation/Documentation");
var ConcurrencyAnnotationId = Symbol.for("effect/annotation/Concurrency");
var BatchingAnnotationId = Symbol.for("effect/annotation/Batching");
var ParseIssueTitleAnnotationId = Symbol.for("effect/annotation/ParseIssueTitle");
var ParseOptionsAnnotationId = Symbol.for("effect/annotation/ParseOptions");
var DecodingFallbackAnnotationId = Symbol.for("effect/annotation/DecodingFallback");
var SurrogateAnnotationId = Symbol.for("effect/annotation/Surrogate");
var StableFilterAnnotationId = Symbol.for("effect/annotation/StableFilter");
var getAnnotation = dual(2, (annotated, key) => Object.prototype.hasOwnProperty.call(annotated.annotations, key) ? some3(annotated.annotations[key]) : none2());
var getBrandAnnotation = getAnnotation(BrandAnnotationId);
var getSchemaIdAnnotation = getAnnotation(SchemaIdAnnotationId);
var getMessageAnnotation = getAnnotation(MessageAnnotationId);
var getMissingMessageAnnotation = getAnnotation(MissingMessageAnnotationId);
var getTitleAnnotation = getAnnotation(TitleAnnotationId);
var getAutoTitleAnnotation = getAnnotation(AutoTitleAnnotationId);
var getIdentifierAnnotation = getAnnotation(IdentifierAnnotationId);
var getDescriptionAnnotation = getAnnotation(DescriptionAnnotationId);
var getExamplesAnnotation = getAnnotation(ExamplesAnnotationId);
var getDefaultAnnotation = getAnnotation(DefaultAnnotationId);
var getJSONSchemaAnnotation = getAnnotation(JSONSchemaAnnotationId);
var getDocumentationAnnotation = getAnnotation(DocumentationAnnotationId);
var getConcurrencyAnnotation = getAnnotation(ConcurrencyAnnotationId);
var getBatchingAnnotation = getAnnotation(BatchingAnnotationId);
var getParseIssueTitleAnnotation = getAnnotation(ParseIssueTitleAnnotationId);
var getParseOptionsAnnotation = getAnnotation(ParseOptionsAnnotationId);
var getDecodingFallbackAnnotation = getAnnotation(DecodingFallbackAnnotationId);
var getSurrogateAnnotation = getAnnotation(SurrogateAnnotationId);
var getStableFilterAnnotation = getAnnotation(StableFilterAnnotationId);
var hasStableFilter = (annotated) => exists(getStableFilterAnnotation(annotated), (b) => b === true);
var JSONIdentifierAnnotationId = Symbol.for("effect/annotation/JSONIdentifier");
var getJSONIdentifierAnnotation = getAnnotation(JSONIdentifierAnnotationId);
var getJSONIdentifier = (annotated) => orElse2(getJSONIdentifierAnnotation(annotated), () => getIdentifierAnnotation(annotated));
var ParseJsonSchemaId = Symbol.for("effect/schema/ParseJson");
var Declaration = class {
  typeParameters;
  decodeUnknown;
  encodeUnknown;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "Declaration";
  constructor(typeParameters, decodeUnknown4, encodeUnknown3, annotations4 = {}) {
    this.typeParameters = typeParameters;
    this.decodeUnknown = decodeUnknown4;
    this.encodeUnknown = encodeUnknown3;
    this.annotations = annotations4;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse2(getExpected(this), () => "<declaration schema>");
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      typeParameters: this.typeParameters.map((ast) => ast.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var createASTGuard = (tag5) => (ast) => ast._tag === tag5;
var isDeclaration = createASTGuard("Declaration");
var Literal = class {
  literal;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "Literal";
  constructor(literal3, annotations4 = {}) {
    this.literal = literal3;
    this.annotations = annotations4;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse2(getExpected(this), () => formatUnknown(this.literal));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      literal: isBigInt(this.literal) ? String(this.literal) : this.literal,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var isLiteral = createASTGuard("Literal");
var $null = new Literal(null);
var UniqueSymbol = class {
  symbol;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "UniqueSymbol";
  constructor(symbol6, annotations4 = {}) {
    this.symbol = symbol6;
    this.annotations = annotations4;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse2(getExpected(this), () => formatUnknown(this.symbol));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      symbol: String(this.symbol),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var isUniqueSymbol = createASTGuard("UniqueSymbol");
var UndefinedKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "UndefinedKeyword";
  constructor(annotations4 = {}) {
    this.annotations = annotations4;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var undefinedKeyword = new UndefinedKeyword({
  [TitleAnnotationId]: "undefined"
});
var isUndefinedKeyword = createASTGuard("UndefinedKeyword");
var VoidKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "VoidKeyword";
  constructor(annotations4 = {}) {
    this.annotations = annotations4;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var voidKeyword = new VoidKeyword({
  [TitleAnnotationId]: "void"
});
var isVoidKeyword = createASTGuard("VoidKeyword");
var NeverKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "NeverKeyword";
  constructor(annotations4 = {}) {
    this.annotations = annotations4;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var neverKeyword = new NeverKeyword({
  [TitleAnnotationId]: "never"
});
var isNeverKeyword = createASTGuard("NeverKeyword");
var UnknownKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "UnknownKeyword";
  constructor(annotations4 = {}) {
    this.annotations = annotations4;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var unknownKeyword = new UnknownKeyword({
  [TitleAnnotationId]: "unknown"
});
var isUnknownKeyword = createASTGuard("UnknownKeyword");
var AnyKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "AnyKeyword";
  constructor(annotations4 = {}) {
    this.annotations = annotations4;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var anyKeyword = new AnyKeyword({
  [TitleAnnotationId]: "any"
});
var isAnyKeyword = createASTGuard("AnyKeyword");
var StringKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "StringKeyword";
  constructor(annotations4 = {}) {
    this.annotations = annotations4;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var stringKeyword = new StringKeyword({
  [TitleAnnotationId]: "string",
  [DescriptionAnnotationId]: "a string"
});
var isStringKeyword = createASTGuard("StringKeyword");
var NumberKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "NumberKeyword";
  constructor(annotations4 = {}) {
    this.annotations = annotations4;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var numberKeyword = new NumberKeyword({
  [TitleAnnotationId]: "number",
  [DescriptionAnnotationId]: "a number"
});
var isNumberKeyword = createASTGuard("NumberKeyword");
var BooleanKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "BooleanKeyword";
  constructor(annotations4 = {}) {
    this.annotations = annotations4;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var booleanKeyword = new BooleanKeyword({
  [TitleAnnotationId]: "boolean",
  [DescriptionAnnotationId]: "a boolean"
});
var isBooleanKeyword = createASTGuard("BooleanKeyword");
var BigIntKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "BigIntKeyword";
  constructor(annotations4 = {}) {
    this.annotations = annotations4;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var bigIntKeyword = new BigIntKeyword({
  [TitleAnnotationId]: "bigint",
  [DescriptionAnnotationId]: "a bigint"
});
var isBigIntKeyword = createASTGuard("BigIntKeyword");
var SymbolKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "SymbolKeyword";
  constructor(annotations4 = {}) {
    this.annotations = annotations4;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var symbolKeyword = new SymbolKeyword({
  [TitleAnnotationId]: "symbol",
  [DescriptionAnnotationId]: "a symbol"
});
var isSymbolKeyword = createASTGuard("SymbolKeyword");
var ObjectKeyword = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "ObjectKeyword";
  constructor(annotations4 = {}) {
    this.annotations = annotations4;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var objectKeyword = new ObjectKeyword({
  [TitleAnnotationId]: "object",
  [DescriptionAnnotationId]: "an object in the TypeScript meaning, i.e. the `object` type"
});
var isObjectKeyword = createASTGuard("ObjectKeyword");
var Enums = class {
  enums;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "Enums";
  constructor(enums, annotations4 = {}) {
    this.enums = enums;
    this.annotations = annotations4;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse2(getExpected(this), () => `<enum ${this.enums.length} value(s): ${this.enums.map(([_, value10]) => JSON.stringify(value10)).join(" | ")}>`);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      enums: this.enums,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var isEnums = createASTGuard("Enums");
var isTemplateLiteralSpanType = (ast) => {
  switch (ast._tag) {
    case "Literal":
    case "NumberKeyword":
    case "StringKeyword":
    case "TemplateLiteral":
      return true;
    case "Union":
      return ast.types.every(isTemplateLiteralSpanType);
  }
  return false;
};
var templateLiteralSpanUnionTypeToString = (type3) => {
  switch (type3._tag) {
    case "Literal":
      return JSON.stringify(String(type3.literal));
    case "StringKeyword":
      return "string";
    case "NumberKeyword":
      return "number";
    case "TemplateLiteral":
      return String(type3);
    case "Union":
      return type3.types.map(templateLiteralSpanUnionTypeToString).join(" | ");
  }
};
var templateLiteralSpanTypeToString = (type3) => {
  switch (type3._tag) {
    case "Literal":
      return String(type3.literal);
    case "StringKeyword":
      return "${string}";
    case "NumberKeyword":
      return "${number}";
    case "TemplateLiteral":
      return "${" + String(type3) + "}";
    case "Union":
      return "${" + type3.types.map(templateLiteralSpanUnionTypeToString).join(" | ") + "}";
  }
};
var TemplateLiteralSpan = class {
  literal;
  /**
   * @since 3.10.0
   */
  type;
  constructor(type3, literal3) {
    this.literal = literal3;
    if (isTemplateLiteralSpanType(type3)) {
      this.type = type3;
    } else {
      throw new Error(getSchemaUnsupportedLiteralSpanErrorMessage(type3));
    }
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return templateLiteralSpanTypeToString(this.type) + this.literal;
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      type: this.type.toJSON(),
      literal: this.literal
    };
  }
};
var TemplateLiteral = class {
  head;
  spans;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "TemplateLiteral";
  constructor(head13, spans, annotations4 = {}) {
    this.head = head13;
    this.spans = spans;
    this.annotations = annotations4;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse2(getExpected(this), () => formatTemplateLiteral(this));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      head: this.head,
      spans: this.spans.map((span4) => span4.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var formatTemplateLiteral = (ast) => "`" + ast.head + ast.spans.map(String).join("") + "`";
var isTemplateLiteral = createASTGuard("TemplateLiteral");
var Type = class {
  type;
  annotations;
  constructor(type3, annotations4 = {}) {
    this.type = type3;
    this.annotations = annotations4;
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      type: this.type.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return String(this.type);
  }
};
var OptionalType = class extends Type {
  isOptional;
  constructor(type3, isOptional, annotations4 = {}) {
    super(type3, annotations4);
    this.isOptional = isOptional;
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      type: this.type.toJSON(),
      isOptional: this.isOptional,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return String(this.type) + (this.isOptional ? "?" : "");
  }
};
var getRestASTs = (rest) => rest.map((annotatedAST) => annotatedAST.type);
var TupleType = class {
  elements;
  rest;
  isReadonly;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "TupleType";
  constructor(elements, rest, isReadonly, annotations4 = {}) {
    this.elements = elements;
    this.rest = rest;
    this.isReadonly = isReadonly;
    this.annotations = annotations4;
    let hasOptionalElement = false;
    let hasIllegalRequiredElement = false;
    for (const e of elements) {
      if (e.isOptional) {
        hasOptionalElement = true;
      } else if (hasOptionalElement) {
        hasIllegalRequiredElement = true;
        break;
      }
    }
    if (hasIllegalRequiredElement || hasOptionalElement && rest.length > 1) {
      throw new Error(getASTRequiredElementFollowinAnOptionalElementErrorMessage);
    }
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse2(getExpected(this), () => formatTuple(this));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      elements: this.elements.map((e) => e.toJSON()),
      rest: this.rest.map((ast) => ast.toJSON()),
      isReadonly: this.isReadonly,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var formatTuple = (ast) => {
  const formattedElements = ast.elements.map(String).join(", ");
  return matchLeft(ast.rest, {
    onEmpty: () => `readonly [${formattedElements}]`,
    onNonEmpty: (head13, tail5) => {
      const formattedHead = String(head13);
      const wrappedHead = formattedHead.includes(" | ") ? `(${formattedHead})` : formattedHead;
      if (tail5.length > 0) {
        const formattedTail = tail5.map(String).join(", ");
        if (ast.elements.length > 0) {
          return `readonly [${formattedElements}, ...${wrappedHead}[], ${formattedTail}]`;
        } else {
          return `readonly [...${wrappedHead}[], ${formattedTail}]`;
        }
      } else {
        if (ast.elements.length > 0) {
          return `readonly [${formattedElements}, ...${wrappedHead}[]]`;
        } else {
          return `ReadonlyArray<${formattedHead}>`;
        }
      }
    }
  });
};
var isTupleType = createASTGuard("TupleType");
var PropertySignature = class extends OptionalType {
  name;
  isReadonly;
  constructor(name, type3, isOptional, isReadonly, annotations4) {
    super(type3, isOptional, annotations4);
    this.name = name;
    this.isReadonly = isReadonly;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return (this.isReadonly ? "readonly " : "") + String(this.name) + (this.isOptional ? "?" : "") + ": " + this.type;
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      name: String(this.name),
      type: this.type.toJSON(),
      isOptional: this.isOptional,
      isReadonly: this.isReadonly,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var isParameter = (ast) => {
  switch (ast._tag) {
    case "StringKeyword":
    case "SymbolKeyword":
    case "TemplateLiteral":
      return true;
    case "Refinement":
      return isParameter(ast.from);
  }
  return false;
};
var IndexSignature = class {
  type;
  isReadonly;
  /**
   * @since 3.10.0
   */
  parameter;
  constructor(parameter, type3, isReadonly) {
    this.type = type3;
    this.isReadonly = isReadonly;
    if (isParameter(parameter)) {
      this.parameter = parameter;
    } else {
      throw new Error(getASTIndexSignatureParameterErrorMessage);
    }
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return (this.isReadonly ? "readonly " : "") + `[x: ${this.parameter}]: ${this.type}`;
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      parameter: this.parameter.toJSON(),
      type: this.type.toJSON(),
      isReadonly: this.isReadonly
    };
  }
};
var TypeLiteral = class {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "TypeLiteral";
  /**
   * @since 3.10.0
   */
  propertySignatures;
  /**
   * @since 3.10.0
   */
  indexSignatures;
  constructor(propertySignatures, indexSignatures, annotations4 = {}) {
    this.annotations = annotations4;
    const keys15 = {};
    for (let i = 0; i < propertySignatures.length; i++) {
      const name = propertySignatures[i].name;
      if (Object.prototype.hasOwnProperty.call(keys15, name)) {
        throw new Error(getASTDuplicatePropertySignatureErrorMessage(name));
      }
      keys15[name] = null;
    }
    const parameters = {
      string: false,
      symbol: false
    };
    for (let i = 0; i < indexSignatures.length; i++) {
      const encodedParameter = getEncodedParameter(indexSignatures[i].parameter);
      if (isStringKeyword(encodedParameter)) {
        if (parameters.string) {
          throw new Error(getASTDuplicateIndexSignatureErrorMessage("string"));
        }
        parameters.string = true;
      } else if (isSymbolKeyword(encodedParameter)) {
        if (parameters.symbol) {
          throw new Error(getASTDuplicateIndexSignatureErrorMessage("symbol"));
        }
        parameters.symbol = true;
      }
    }
    this.propertySignatures = propertySignatures;
    this.indexSignatures = indexSignatures;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse2(getExpected(this), () => formatTypeLiteral(this));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      propertySignatures: this.propertySignatures.map((ps) => ps.toJSON()),
      indexSignatures: this.indexSignatures.map((ps) => ps.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var formatIndexSignatures = (iss) => iss.map(String).join("; ");
var formatTypeLiteral = (ast) => {
  if (ast.propertySignatures.length > 0) {
    const pss = ast.propertySignatures.map(String).join("; ");
    if (ast.indexSignatures.length > 0) {
      return `{ ${pss}; ${formatIndexSignatures(ast.indexSignatures)} }`;
    } else {
      return `{ ${pss} }`;
    }
  } else {
    if (ast.indexSignatures.length > 0) {
      return `{ ${formatIndexSignatures(ast.indexSignatures)} }`;
    } else {
      return "{}";
    }
  }
};
var isTypeLiteral = createASTGuard("TypeLiteral");
var sortCandidates = sort(mapInput3(Order, (ast) => {
  switch (ast._tag) {
    case "AnyKeyword":
      return 0;
    case "UnknownKeyword":
      return 1;
    case "ObjectKeyword":
      return 2;
    case "StringKeyword":
    case "NumberKeyword":
    case "BooleanKeyword":
    case "BigIntKeyword":
    case "SymbolKeyword":
      return 3;
  }
  return 4;
}));
var literalMap = {
  string: "StringKeyword",
  number: "NumberKeyword",
  boolean: "BooleanKeyword",
  bigint: "BigIntKeyword"
};
var flatten4 = (candidates) => flatMap4(candidates, (ast) => isUnion(ast) ? flatten4(ast.types) : [ast]);
var unify = (candidates) => {
  const cs = sortCandidates(candidates);
  const out = [];
  const uniques = {};
  const literals = [];
  for (const ast of cs) {
    switch (ast._tag) {
      case "NeverKeyword":
        break;
      case "AnyKeyword":
        return [anyKeyword];
      case "UnknownKeyword":
        return [unknownKeyword];
      // uniques
      case "ObjectKeyword":
      case "UndefinedKeyword":
      case "VoidKeyword":
      case "StringKeyword":
      case "NumberKeyword":
      case "BooleanKeyword":
      case "BigIntKeyword":
      case "SymbolKeyword": {
        if (!uniques[ast._tag]) {
          uniques[ast._tag] = ast;
          out.push(ast);
        }
        break;
      }
      case "Literal": {
        const type3 = typeof ast.literal;
        switch (type3) {
          case "string":
          case "number":
          case "bigint":
          case "boolean": {
            const _tag = literalMap[type3];
            if (!uniques[_tag] && !literals.includes(ast.literal)) {
              literals.push(ast.literal);
              out.push(ast);
            }
            break;
          }
          // null
          case "object": {
            if (!literals.includes(ast.literal)) {
              literals.push(ast.literal);
              out.push(ast);
            }
            break;
          }
        }
        break;
      }
      case "UniqueSymbol": {
        if (!uniques["SymbolKeyword"] && !literals.includes(ast.symbol)) {
          literals.push(ast.symbol);
          out.push(ast);
        }
        break;
      }
      case "TupleType": {
        if (!uniques["ObjectKeyword"]) {
          out.push(ast);
        }
        break;
      }
      case "TypeLiteral": {
        if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
          if (!uniques["{}"]) {
            uniques["{}"] = ast;
            out.push(ast);
          }
        } else if (!uniques["ObjectKeyword"]) {
          out.push(ast);
        }
        break;
      }
      default:
        out.push(ast);
    }
  }
  return out;
};
var Union = class _Union {
  types;
  annotations;
  static make = (types, annotations4) => {
    return isMembers(types) ? new _Union(types, annotations4) : types.length === 1 ? types[0] : neverKeyword;
  };
  /** @internal */
  static unify = (candidates, annotations4) => {
    return _Union.make(unify(flatten4(candidates)), annotations4);
  };
  /**
   * @since 3.10.0
   */
  _tag = "Union";
  constructor(types, annotations4 = {}) {
    this.types = types;
    this.annotations = annotations4;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse2(getExpected(this), () => this.types.map(String).join(" | "));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      types: this.types.map((ast) => ast.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var mapMembers = (members, f) => members.map(f);
var isMembers = (as18) => as18.length > 1;
var isUnion = createASTGuard("Union");
var toJSONMemoMap = globalValue(Symbol.for("effect/Schema/AST/toJSONMemoMap"), () => /* @__PURE__ */ new WeakMap());
var Suspend = class {
  f;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "Suspend";
  constructor(f, annotations4 = {}) {
    this.f = f;
    this.annotations = annotations4;
    this.f = memoizeThunk(f);
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getExpected(this).pipe(orElse2(() => flatMap2(liftThrowable(this.f)(), (ast) => getExpected(ast))), getOrElse2(() => "<suspended schema>"));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    const ast = this.f();
    let out = toJSONMemoMap.get(ast);
    if (out) {
      return out;
    }
    toJSONMemoMap.set(ast, {
      _tag: this._tag
    });
    out = {
      _tag: this._tag,
      ast: ast.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
    toJSONMemoMap.set(ast, out);
    return out;
  }
};
var isSuspend = createASTGuard("Suspend");
var Refinement = class {
  from;
  filter;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "Refinement";
  constructor(from, filter26, annotations4 = {}) {
    this.from = from;
    this.filter = filter26;
    this.annotations = annotations4;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getIdentifierAnnotation(this).pipe(getOrElse2(() => match2(getOrElseExpected(this), {
      onNone: () => `{ ${this.from} | filter }`,
      onSome: (expected) => isRefinement(this.from) ? String(this.from) + " & " + expected : expected
    })));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      from: this.from.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var isRefinement = createASTGuard("Refinement");
var defaultParseOption = {};
var Transformation = class {
  from;
  to;
  transformation;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "Transformation";
  constructor(from, to, transformation, annotations4 = {}) {
    this.from = from;
    this.to = to;
    this.transformation = transformation;
    this.annotations = annotations4;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse2(getExpected(this), () => `(${String(this.from)} <-> ${String(this.to)})`);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      from: this.from.toJSON(),
      to: this.to.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var isTransformation = createASTGuard("Transformation");
var FinalTransformation = class {
  decode;
  encode;
  /**
   * @since 3.10.0
   */
  _tag = "FinalTransformation";
  constructor(decode7, encode6) {
    this.decode = decode7;
    this.encode = encode6;
  }
};
var createTransformationGuard = (tag5) => (ast) => ast._tag === tag5;
var isFinalTransformation = createTransformationGuard("FinalTransformation");
var ComposeTransformation = class {
  /**
   * @since 3.10.0
   */
  _tag = "ComposeTransformation";
};
var composeTransformation = new ComposeTransformation();
var isComposeTransformation = createTransformationGuard("ComposeTransformation");
var PropertySignatureTransformation = class {
  from;
  to;
  decode;
  encode;
  constructor(from, to, decode7, encode6) {
    this.from = from;
    this.to = to;
    this.decode = decode7;
    this.encode = encode6;
  }
};
var isRenamingPropertySignatureTransformation = (t) => t.decode === identity && t.encode === identity;
var TypeLiteralTransformation = class {
  propertySignatureTransformations;
  /**
   * @since 3.10.0
   */
  _tag = "TypeLiteralTransformation";
  constructor(propertySignatureTransformations) {
    this.propertySignatureTransformations = propertySignatureTransformations;
    const fromKeys = {};
    const toKeys = {};
    for (const pst of propertySignatureTransformations) {
      const from = pst.from;
      if (fromKeys[from]) {
        throw new Error(getASTDuplicatePropertySignatureTransformationErrorMessage(from));
      }
      fromKeys[from] = true;
      const to = pst.to;
      if (toKeys[to]) {
        throw new Error(getASTDuplicatePropertySignatureTransformationErrorMessage(to));
      }
      toKeys[to] = true;
    }
  }
};
var isTypeLiteralTransformation = createTransformationGuard("TypeLiteralTransformation");
var annotations = (ast, overrides) => {
  const d = Object.getOwnPropertyDescriptors(ast);
  const value10 = {
    ...ast.annotations,
    ...overrides
  };
  const surrogate = getSurrogateAnnotation(ast);
  if (isSome2(surrogate)) {
    value10[SurrogateAnnotationId] = annotations(surrogate.value, overrides);
  }
  d.annotations.value = value10;
  return Object.create(Object.getPrototypeOf(ast), d);
};
var keyof = (ast) => Union.unify(_keyof(ast));
var STRING_KEYWORD_PATTERN = "[\\s\\S]*";
var NUMBER_KEYWORD_PATTERN = "[+-]?\\d*\\.?\\d+(?:[Ee][+-]?\\d+)?";
var getTemplateLiteralSpanTypePattern = (type3, capture2) => {
  switch (type3._tag) {
    case "Literal":
      return escape(String(type3.literal));
    case "StringKeyword":
      return STRING_KEYWORD_PATTERN;
    case "NumberKeyword":
      return NUMBER_KEYWORD_PATTERN;
    case "TemplateLiteral":
      return getTemplateLiteralPattern(type3, capture2, false);
    case "Union":
      return type3.types.map((type4) => getTemplateLiteralSpanTypePattern(type4, capture2)).join("|");
  }
};
var handleTemplateLiteralSpanTypeParens = (type3, s, capture2, top) => {
  if (isUnion(type3)) {
    if (capture2 && !top) {
      return `(?:${s})`;
    }
  } else if (!capture2 || !top) {
    return s;
  }
  return `(${s})`;
};
var getTemplateLiteralPattern = (ast, capture2, top) => {
  let pattern2 = ``;
  if (ast.head !== "") {
    const head13 = escape(ast.head);
    pattern2 += capture2 && top ? `(${head13})` : head13;
  }
  for (const span4 of ast.spans) {
    const spanPattern = getTemplateLiteralSpanTypePattern(span4.type, capture2);
    pattern2 += handleTemplateLiteralSpanTypeParens(span4.type, spanPattern, capture2, top);
    if (span4.literal !== "") {
      const literal3 = escape(span4.literal);
      pattern2 += capture2 && top ? `(${literal3})` : literal3;
    }
  }
  return pattern2;
};
var getTemplateLiteralRegExp = (ast) => new RegExp(`^${getTemplateLiteralPattern(ast, false, true)}$`);
var getTemplateLiteralCapturingRegExp = (ast) => new RegExp(`^${getTemplateLiteralPattern(ast, true, true)}$`);
var getPropertySignatures = (ast) => {
  const annotation = getSurrogateAnnotation(ast);
  if (isSome2(annotation)) {
    return getPropertySignatures(annotation.value);
  }
  switch (ast._tag) {
    case "TypeLiteral":
      return ast.propertySignatures.slice();
    case "Suspend":
      return getPropertySignatures(ast.f());
    case "Refinement":
      return getPropertySignatures(ast.from);
  }
  return getPropertyKeys(ast).map((name) => getPropertyKeyIndexedAccess(ast, name));
};
var getIndexSignatures = (ast) => {
  const annotation = getSurrogateAnnotation(ast);
  if (isSome2(annotation)) {
    return getIndexSignatures(annotation.value);
  }
  switch (ast._tag) {
    case "TypeLiteral":
      return ast.indexSignatures.slice();
    case "Suspend":
      return getIndexSignatures(ast.f());
    case "Refinement":
      return getIndexSignatures(ast.from);
  }
  return [];
};
var getNumberIndexedAccess = (ast) => {
  switch (ast._tag) {
    case "TupleType": {
      let hasOptional = false;
      let out = [];
      for (const e of ast.elements) {
        if (e.isOptional) {
          hasOptional = true;
        }
        out.push(e.type);
      }
      if (hasOptional) {
        out.push(undefinedKeyword);
      }
      out = out.concat(getRestASTs(ast.rest));
      return Union.make(out);
    }
    case "Refinement":
      return getNumberIndexedAccess(ast.from);
    case "Union":
      return Union.make(ast.types.map(getNumberIndexedAccess));
    case "Suspend":
      return getNumberIndexedAccess(ast.f());
  }
  throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
};
var getTypeLiteralPropertySignature = (ast, name) => {
  const ops = findFirst3(ast.propertySignatures, (ps) => ps.name === name);
  if (isSome2(ops)) {
    return ops.value;
  }
  if (isString(name)) {
    let out = void 0;
    for (const is4 of ast.indexSignatures) {
      const encodedParameter = getEncodedParameter(is4.parameter);
      switch (encodedParameter._tag) {
        case "TemplateLiteral": {
          const regex = getTemplateLiteralRegExp(encodedParameter);
          if (regex.test(name)) {
            return new PropertySignature(name, is4.type, false, true);
          }
          break;
        }
        case "StringKeyword": {
          if (out === void 0) {
            out = new PropertySignature(name, is4.type, false, true);
          }
        }
      }
    }
    if (out) {
      return out;
    }
  } else if (isSymbol(name)) {
    for (const is4 of ast.indexSignatures) {
      const encodedParameter = getEncodedParameter(is4.parameter);
      if (isSymbolKeyword(encodedParameter)) {
        return new PropertySignature(name, is4.type, false, true);
      }
    }
  }
};
var getPropertyKeyIndexedAccess = (ast, name) => {
  const annotation = getSurrogateAnnotation(ast);
  if (isSome2(annotation)) {
    return getPropertyKeyIndexedAccess(annotation.value, name);
  }
  switch (ast._tag) {
    case "TypeLiteral": {
      const ps = getTypeLiteralPropertySignature(ast, name);
      if (ps) {
        return ps;
      }
      break;
    }
    case "Union":
      return new PropertySignature(name, Union.make(ast.types.map((ast2) => getPropertyKeyIndexedAccess(ast2, name).type)), false, true);
    case "Suspend":
      return getPropertyKeyIndexedAccess(ast.f(), name);
    case "Refinement":
      return getPropertyKeyIndexedAccess(ast.from, name);
  }
  throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
};
var getPropertyKeys = (ast) => {
  const annotation = getSurrogateAnnotation(ast);
  if (isSome2(annotation)) {
    return getPropertyKeys(annotation.value);
  }
  switch (ast._tag) {
    case "TypeLiteral":
      return ast.propertySignatures.map((ps) => ps.name);
    case "Union":
      return ast.types.slice(1).reduce((out, ast2) => intersection2(out, getPropertyKeys(ast2)), getPropertyKeys(ast.types[0]));
    case "Suspend":
      return getPropertyKeys(ast.f());
    case "Refinement":
      return getPropertyKeys(ast.from);
    case "Transformation":
      return getPropertyKeys(ast.to);
  }
  return [];
};
var record2 = (key, value10) => {
  const propertySignatures = [];
  const indexSignatures = [];
  const go5 = (key2) => {
    switch (key2._tag) {
      case "NeverKeyword":
        break;
      case "StringKeyword":
      case "SymbolKeyword":
      case "TemplateLiteral":
      case "Refinement":
        indexSignatures.push(new IndexSignature(key2, value10, true));
        break;
      case "Literal":
        if (isString(key2.literal) || isNumber(key2.literal)) {
          propertySignatures.push(new PropertySignature(key2.literal, value10, false, true));
        } else {
          throw new Error(getASTUnsupportedLiteralErrorMessage(key2.literal));
        }
        break;
      case "Enums": {
        for (const [_, name] of key2.enums) {
          propertySignatures.push(new PropertySignature(name, value10, false, true));
        }
        break;
      }
      case "UniqueSymbol":
        propertySignatures.push(new PropertySignature(key2.symbol, value10, false, true));
        break;
      case "Union":
        key2.types.forEach(go5);
        break;
      default:
        throw new Error(getASTUnsupportedKeySchemaErrorMessage(key2));
    }
  };
  go5(key);
  return {
    propertySignatures,
    indexSignatures
  };
};
var pick = (ast, keys15) => {
  const annotation = getSurrogateAnnotation(ast);
  if (isSome2(annotation)) {
    return pick(annotation.value, keys15);
  }
  switch (ast._tag) {
    case "TypeLiteral": {
      const pss = [];
      const names = {};
      for (const ps of ast.propertySignatures) {
        names[ps.name] = null;
        if (keys15.includes(ps.name)) {
          pss.push(ps);
        }
      }
      for (const key of keys15) {
        if (!(key in names)) {
          const ps = getTypeLiteralPropertySignature(ast, key);
          if (ps) {
            pss.push(ps);
          }
        }
      }
      return new TypeLiteral(pss, []);
    }
    case "Union":
      return new TypeLiteral(keys15.map((name) => getPropertyKeyIndexedAccess(ast, name)), []);
    case "Suspend":
      return pick(ast.f(), keys15);
    case "Refinement":
      return pick(ast.from, keys15);
    case "Transformation": {
      switch (ast.transformation._tag) {
        case "ComposeTransformation":
          return new Transformation(pick(ast.from, keys15), pick(ast.to, keys15), composeTransformation);
        case "TypeLiteralTransformation": {
          const ts = [];
          const fromKeys = [];
          for (const k of keys15) {
            const t = ast.transformation.propertySignatureTransformations.find((t2) => t2.to === k);
            if (t) {
              ts.push(t);
              fromKeys.push(t.from);
            } else {
              fromKeys.push(k);
            }
          }
          return isNonEmptyReadonlyArray(ts) ? new Transformation(pick(ast.from, fromKeys), pick(ast.to, keys15), new TypeLiteralTransformation(ts)) : pick(ast.from, fromKeys);
        }
      }
    }
  }
  throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
};
var omit = (ast, keys15) => {
  let indexSignatures = getIndexSignatures(ast);
  if (indexSignatures.length > 0) {
    if (indexSignatures.some((is4) => isStringKeyword(getEncodedParameter(is4.parameter)))) {
      indexSignatures = indexSignatures.filter((is4) => !isTemplateLiteral(getEncodedParameter(is4.parameter)));
    }
    return new TypeLiteral([], indexSignatures);
  }
  return pick(ast, getPropertyKeys(ast).filter((name) => !keys15.includes(name)));
};
var orUndefined = (ast) => Union.make([ast, undefinedKeyword]);
var partial = (ast, options) => {
  const exact = options?.exact === true;
  switch (ast._tag) {
    case "TupleType":
      return new TupleType(ast.elements.map((e) => new OptionalType(exact ? e.type : orUndefined(e.type), true)), match3(ast.rest, {
        onEmpty: () => ast.rest,
        onNonEmpty: (rest) => [new Type(Union.make([...getRestASTs(rest), undefinedKeyword]))]
      }), ast.isReadonly);
    case "TypeLiteral":
      return new TypeLiteral(ast.propertySignatures.map((ps) => new PropertySignature(ps.name, exact ? ps.type : orUndefined(ps.type), true, ps.isReadonly, ps.annotations)), ast.indexSignatures.map((is4) => new IndexSignature(is4.parameter, orUndefined(is4.type), is4.isReadonly)));
    case "Union":
      return Union.make(ast.types.map((member) => partial(member, options)));
    case "Suspend":
      return new Suspend(() => partial(ast.f(), options));
    case "Declaration":
    case "Refinement":
      throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
    case "Transformation": {
      if (isTypeLiteralTransformation(ast.transformation) && ast.transformation.propertySignatureTransformations.every(isRenamingPropertySignatureTransformation)) {
        return new Transformation(partial(ast.from, options), partial(ast.to, options), ast.transformation);
      }
      throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
    }
  }
  return ast;
};
var required = (ast) => {
  switch (ast._tag) {
    case "TupleType":
      return new TupleType(ast.elements.map((e) => new OptionalType(e.type, false)), ast.rest, ast.isReadonly);
    case "TypeLiteral":
      return new TypeLiteral(ast.propertySignatures.map((f) => new PropertySignature(f.name, f.type, false, f.isReadonly, f.annotations)), ast.indexSignatures);
    case "Union":
      return Union.make(ast.types.map((member) => required(member)));
    case "Suspend":
      return new Suspend(() => required(ast.f()));
    case "Declaration":
    case "Refinement":
      throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
    case "Transformation": {
      if (isTypeLiteralTransformation(ast.transformation) && ast.transformation.propertySignatureTransformations.every(isRenamingPropertySignatureTransformation)) {
        return new Transformation(required(ast.from), required(ast.to), ast.transformation);
      }
      throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
    }
  }
  return ast;
};
var mutable = (ast) => {
  switch (ast._tag) {
    case "TupleType":
      return ast.isReadonly === false ? ast : new TupleType(ast.elements, ast.rest, false, ast.annotations);
    case "TypeLiteral": {
      const propertySignatures = changeMap(ast.propertySignatures, (ps) => ps.isReadonly === false ? ps : new PropertySignature(ps.name, ps.type, ps.isOptional, false, ps.annotations));
      const indexSignatures = changeMap(ast.indexSignatures, (is4) => is4.isReadonly === false ? is4 : new IndexSignature(is4.parameter, is4.type, false));
      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, ast.annotations);
    }
    case "Union": {
      const types = changeMap(ast.types, mutable);
      return types === ast.types ? ast : Union.make(types, ast.annotations);
    }
    case "Suspend":
      return new Suspend(() => mutable(ast.f()), ast.annotations);
    case "Refinement": {
      const from = mutable(ast.from);
      return from === ast.from ? ast : new Refinement(from, ast.filter, ast.annotations);
    }
    case "Transformation": {
      const from = mutable(ast.from);
      const to = mutable(ast.to);
      return from === ast.from && to === ast.to ? ast : new Transformation(from, to, ast.transformation, ast.annotations);
    }
  }
  return ast;
};
var getCompiler = (match43) => {
  const compile2 = (ast, path) => match43[ast._tag](ast, compile2, path);
  return compile2;
};
var pickAnnotations = (annotationIds) => (annotated) => {
  let out = void 0;
  for (const id3 of annotationIds) {
    if (Object.prototype.hasOwnProperty.call(annotated.annotations, id3)) {
      if (out === void 0) {
        out = {};
      }
      out[id3] = annotated.annotations[id3];
    }
  }
  return out;
};
var omitAnnotations = (annotationIds) => (annotated) => {
  const out = {
    ...annotated.annotations
  };
  for (const id3 of annotationIds) {
    delete out[id3];
  }
  return out;
};
var preserveTransformationAnnotations = pickAnnotations([ExamplesAnnotationId, DefaultAnnotationId, JSONSchemaAnnotationId, ArbitraryAnnotationId, PrettyAnnotationId, EquivalenceAnnotationId]);
var typeAST = (ast) => {
  switch (ast._tag) {
    case "Declaration": {
      const typeParameters = changeMap(ast.typeParameters, typeAST);
      return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
    }
    case "TupleType": {
      const elements = changeMap(ast.elements, (e) => {
        const type3 = typeAST(e.type);
        return type3 === e.type ? e : new OptionalType(type3, e.isOptional);
      });
      const restASTs = getRestASTs(ast.rest);
      const rest = changeMap(restASTs, typeAST);
      return elements === ast.elements && rest === restASTs ? ast : new TupleType(elements, rest.map((type3) => new Type(type3)), ast.isReadonly, ast.annotations);
    }
    case "TypeLiteral": {
      const propertySignatures = changeMap(ast.propertySignatures, (p) => {
        const type3 = typeAST(p.type);
        return type3 === p.type ? p : new PropertySignature(p.name, type3, p.isOptional, p.isReadonly);
      });
      const indexSignatures = changeMap(ast.indexSignatures, (is4) => {
        const type3 = typeAST(is4.type);
        return type3 === is4.type ? is4 : new IndexSignature(is4.parameter, type3, is4.isReadonly);
      });
      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, ast.annotations);
    }
    case "Union": {
      const types = changeMap(ast.types, typeAST);
      return types === ast.types ? ast : Union.make(types, ast.annotations);
    }
    case "Suspend":
      return new Suspend(() => typeAST(ast.f()), ast.annotations);
    case "Refinement": {
      const from = typeAST(ast.from);
      return from === ast.from ? ast : new Refinement(from, ast.filter, ast.annotations);
    }
    case "Transformation": {
      const preserve = preserveTransformationAnnotations(ast);
      return typeAST(preserve !== void 0 ? annotations(ast.to, preserve) : ast.to);
    }
  }
  return ast;
};
var createJSONIdentifierAnnotation = (annotated) => match2(getJSONIdentifier(annotated), {
  onNone: () => void 0,
  onSome: (identifier2) => ({
    [JSONIdentifierAnnotationId]: identifier2
  })
});
function changeMap(as18, f) {
  let changed = false;
  const out = allocate(as18.length);
  for (let i = 0; i < as18.length; i++) {
    const a = as18[i];
    const fa = f(a);
    if (fa !== a) {
      changed = true;
    }
    out[i] = fa;
  }
  return changed ? out : as18;
}
var getTransformationFrom = (ast) => {
  switch (ast._tag) {
    case "Transformation":
      return ast.from;
    case "Refinement":
      return getTransformationFrom(ast.from);
    case "Suspend":
      return getTransformationFrom(ast.f());
  }
};
var encodedAST_ = (ast, isBound) => {
  switch (ast._tag) {
    case "Declaration": {
      const typeParameters = changeMap(ast.typeParameters, (ast2) => encodedAST_(ast2, isBound));
      return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
    }
    case "TupleType": {
      const elements = changeMap(ast.elements, (e) => {
        const type3 = encodedAST_(e.type, isBound);
        return type3 === e.type ? e : new OptionalType(type3, e.isOptional);
      });
      const restASTs = getRestASTs(ast.rest);
      const rest = changeMap(restASTs, (ast2) => encodedAST_(ast2, isBound));
      return elements === ast.elements && rest === restASTs ? ast : new TupleType(elements, rest.map((ast2) => new Type(ast2)), ast.isReadonly, createJSONIdentifierAnnotation(ast));
    }
    case "TypeLiteral": {
      const propertySignatures = changeMap(ast.propertySignatures, (ps) => {
        const type3 = encodedAST_(ps.type, isBound);
        return type3 === ps.type ? ps : new PropertySignature(ps.name, type3, ps.isOptional, ps.isReadonly);
      });
      const indexSignatures = changeMap(ast.indexSignatures, (is4) => {
        const type3 = encodedAST_(is4.type, isBound);
        return type3 === is4.type ? is4 : new IndexSignature(is4.parameter, type3, is4.isReadonly);
      });
      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, createJSONIdentifierAnnotation(ast));
    }
    case "Union": {
      const types = changeMap(ast.types, (ast2) => encodedAST_(ast2, isBound));
      return types === ast.types ? ast : Union.make(types, createJSONIdentifierAnnotation(ast));
    }
    case "Suspend":
      return new Suspend(() => encodedAST_(ast.f(), isBound), createJSONIdentifierAnnotation(ast));
    case "Refinement": {
      const from = encodedAST_(ast.from, isBound);
      if (isBound) {
        if (from === ast.from) {
          return ast;
        }
        if (getTransformationFrom(ast.from) === void 0 && hasStableFilter(ast)) {
          return new Refinement(from, ast.filter, ast.annotations);
        }
      }
      const identifier2 = createJSONIdentifierAnnotation(ast);
      return identifier2 ? annotations(from, identifier2) : from;
    }
    case "Transformation": {
      const identifier2 = createJSONIdentifierAnnotation(ast);
      return encodedAST_(identifier2 ? annotations(ast.from, identifier2) : ast.from, isBound);
    }
  }
  return ast;
};
var encodedAST = (ast) => encodedAST_(ast, false);
var encodedBoundAST = (ast) => encodedAST_(ast, true);
var toJSONAnnotations = (annotations4) => {
  const out = {};
  for (const k of Object.getOwnPropertySymbols(annotations4)) {
    out[String(k)] = annotations4[k];
  }
  return out;
};
var getEncodedParameter = (ast) => {
  switch (ast._tag) {
    case "StringKeyword":
    case "SymbolKeyword":
    case "TemplateLiteral":
      return ast;
    case "Refinement":
      return getEncodedParameter(ast.from);
  }
};
var equals2 = (self, that) => {
  switch (self._tag) {
    case "Literal":
      return isLiteral(that) && that.literal === self.literal;
    case "UniqueSymbol":
      return isUniqueSymbol(that) && that.symbol === self.symbol;
    case "UndefinedKeyword":
    case "VoidKeyword":
    case "NeverKeyword":
    case "UnknownKeyword":
    case "AnyKeyword":
    case "StringKeyword":
    case "NumberKeyword":
    case "BooleanKeyword":
    case "BigIntKeyword":
    case "SymbolKeyword":
    case "ObjectKeyword":
      return that._tag === self._tag;
    case "TemplateLiteral":
      return isTemplateLiteral(that) && that.head === self.head && equalsTemplateLiteralSpan(that.spans, self.spans);
    case "Enums":
      return isEnums(that) && equalsEnums(that.enums, self.enums);
    case "Union":
      return isUnion(that) && equalsUnion(self.types, that.types);
    case "Refinement":
    case "TupleType":
    case "TypeLiteral":
    case "Suspend":
    case "Transformation":
    case "Declaration":
      return self === that;
  }
};
var equalsTemplateLiteralSpan = getEquivalence5((self, that) => {
  return self.literal === that.literal && equals2(self.type, that.type);
});
var equalsEnums = getEquivalence5((self, that) => that[0] === self[0] && that[1] === self[1]);
var equalsUnion = getEquivalence5(equals2);
var intersection3 = intersectionWith(equals2);
var _keyof = (ast) => {
  switch (ast._tag) {
    case "Declaration": {
      const annotation = getSurrogateAnnotation(ast);
      if (isSome2(annotation)) {
        return _keyof(annotation.value);
      }
      break;
    }
    case "TypeLiteral":
      return ast.propertySignatures.map((p) => isSymbol(p.name) ? new UniqueSymbol(p.name) : new Literal(p.name)).concat(ast.indexSignatures.map((is4) => getEncodedParameter(is4.parameter)));
    case "Suspend":
      return _keyof(ast.f());
    case "Union":
      return ast.types.slice(1).reduce((out, ast2) => intersection3(out, _keyof(ast2)), _keyof(ast.types[0]));
    case "Transformation":
      return _keyof(ast.to);
  }
  throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
};
var compose3 = (ab, cd) => new Transformation(ab, cd, composeTransformation);
var rename = (ast, mapping) => {
  switch (ast._tag) {
    case "TypeLiteral": {
      const propertySignatureTransformations = [];
      for (const key of ownKeys(mapping)) {
        const name = mapping[key];
        if (name !== void 0) {
          propertySignatureTransformations.push(new PropertySignatureTransformation(key, name, identity, identity));
        }
      }
      if (propertySignatureTransformations.length === 0) {
        return ast;
      }
      return new Transformation(ast, new TypeLiteral(ast.propertySignatures.map((ps) => {
        const name = mapping[ps.name];
        return new PropertySignature(name === void 0 ? ps.name : name, typeAST(ps.type), ps.isOptional, ps.isReadonly, ps.annotations);
      }), ast.indexSignatures), new TypeLiteralTransformation(propertySignatureTransformations));
    }
    case "Union":
      return Union.make(ast.types.map((ast2) => rename(ast2, mapping)));
    case "Suspend":
      return new Suspend(() => rename(ast.f(), mapping));
    case "Transformation":
      return compose3(ast, rename(typeAST(ast), mapping));
  }
  throw new Error(getASTUnsupportedRenameSchemaErrorMessage(ast));
};
var formatKeyword = (ast) => getOrElse2(getExpected(ast), () => ast._tag);
function getBrands(ast) {
  return match2(getBrandAnnotation(ast), {
    onNone: () => "",
    onSome: (brands) => brands.map((brand2) => ` & Brand<${formatUnknown(brand2)}>`).join("")
  });
}
var getOrElseExpected = (ast) => getTitleAnnotation(ast).pipe(orElse2(() => getDescriptionAnnotation(ast)), orElse2(() => getAutoTitleAnnotation(ast)), map2((s) => s + getBrands(ast)));
var getExpected = (ast) => orElse2(getIdentifierAnnotation(ast), () => getOrElseExpected(ast));
var pruneUndefined = (ast, self, onTransformation) => {
  switch (ast._tag) {
    case "UndefinedKeyword":
      return neverKeyword;
    case "Union": {
      const types = [];
      let hasUndefined = false;
      for (const type3 of ast.types) {
        const pruned = self(type3);
        if (pruned) {
          hasUndefined = true;
          if (!isNeverKeyword(pruned)) {
            types.push(pruned);
          }
        } else {
          types.push(type3);
        }
      }
      if (hasUndefined) {
        return Union.make(types);
      }
      break;
    }
    case "Suspend":
      return self(ast.f());
    case "Transformation":
      return onTransformation(ast);
  }
};

// ../../node_modules/effect/dist/esm/Arbitrary.js
var makeLazy2 = (schema) => {
  const description = getDescription(schema.ast, []);
  return go(description, {
    maxDepth: 2
  });
};
var make5 = (schema) => makeLazy2(schema)(FastCheck_exports);
var makeStringConstraints = (options) => {
  const out = {
    _tag: "StringConstraints",
    constraints: {}
  };
  if (isNumber(options.minLength)) {
    out.constraints.minLength = options.minLength;
  }
  if (isNumber(options.maxLength)) {
    out.constraints.maxLength = options.maxLength;
  }
  if (isString(options.pattern)) {
    out.pattern = options.pattern;
  }
  return out;
};
var makeNumberConstraints = (options) => {
  const out = {
    _tag: "NumberConstraints",
    constraints: {},
    isInteger: options.isInteger ?? false
  };
  if (isNumber(options.min)) {
    out.constraints.min = Math.fround(options.min);
  }
  if (isBoolean(options.minExcluded)) {
    out.constraints.minExcluded = options.minExcluded;
  }
  if (isNumber(options.max)) {
    out.constraints.max = Math.fround(options.max);
  }
  if (isBoolean(options.maxExcluded)) {
    out.constraints.maxExcluded = options.maxExcluded;
  }
  if (isBoolean(options.noNaN)) {
    out.constraints.noNaN = options.noNaN;
  }
  if (isBoolean(options.noDefaultInfinity)) {
    out.constraints.noDefaultInfinity = options.noDefaultInfinity;
  }
  return out;
};
var makeBigIntConstraints = (options) => {
  const out = {
    _tag: "BigIntConstraints",
    constraints: {}
  };
  if (isBigInt(options.min)) {
    out.constraints.min = options.min;
  }
  if (isBigInt(options.max)) {
    out.constraints.max = options.max;
  }
  return out;
};
var makeArrayConstraints = (options) => {
  const out = {
    _tag: "ArrayConstraints",
    constraints: {}
  };
  if (isNumber(options.minLength)) {
    out.constraints.minLength = options.minLength;
  }
  if (isNumber(options.maxLength)) {
    out.constraints.maxLength = options.maxLength;
  }
  return out;
};
var makeDateConstraints = (options) => {
  const out = {
    _tag: "DateConstraints",
    constraints: {}
  };
  if (isDate(options.min)) {
    out.constraints.min = options.min;
  }
  if (isDate(options.max)) {
    out.constraints.max = options.max;
  }
  if (isBoolean(options.noInvalidDate)) {
    out.constraints.noInvalidDate = options.noInvalidDate;
  }
  return out;
};
var getArbitraryAnnotation = getAnnotation(ArbitraryAnnotationId);
var getASTConstraints = (ast) => {
  const TypeAnnotationId = ast.annotations[SchemaIdAnnotationId];
  if (isPropertyKey(TypeAnnotationId)) {
    const out = ast.annotations[TypeAnnotationId];
    if (isReadonlyRecord(out)) {
      return out;
    }
  }
};
var idMemoMap = globalValue(Symbol.for("effect/Arbitrary/IdMemoMap"), () => /* @__PURE__ */ new Map());
var counter = 0;
function wrapGetDescription(f, g) {
  return (ast, path) => f(ast, g(ast, path));
}
function parseMeta(ast) {
  const jsonSchema = getJSONSchemaAnnotation(ast).pipe(filter(isReadonlyRecord), getOrUndefined2);
  const schemaId = getOrElse2(getSchemaIdAnnotation(ast), () => void 0);
  const schemaParams = fromNullable2(schemaId).pipe(map2((id3) => ast.annotations[id3]), filter(isReadonlyRecord), getOrUndefined2);
  return [schemaId, {
    ...schemaParams,
    ...jsonSchema
  }];
}
var getDescription = wrapGetDescription((ast, description) => {
  const annotation = getArbitraryAnnotation(ast);
  if (isSome2(annotation)) {
    return {
      ...description,
      annotations: [...description.annotations, annotation.value]
    };
  }
  return description;
}, (ast, path) => {
  const [schemaId, meta] = parseMeta(ast);
  switch (ast._tag) {
    case "Refinement": {
      const from = getDescription(ast.from, path);
      switch (from._tag) {
        case "StringKeyword":
          return {
            ...from,
            constraints: [...from.constraints, makeStringConstraints(meta)],
            refinements: [...from.refinements, ast]
          };
        case "NumberKeyword": {
          const c = schemaId === NonNaNSchemaId ? makeNumberConstraints({
            noNaN: true
          }) : makeNumberConstraints({
            isInteger: "type" in meta && meta.type === "integer",
            noNaN: "type" in meta && meta.type === "number" ? true : void 0,
            noDefaultInfinity: "type" in meta && meta.type === "number" ? true : void 0,
            min: meta.exclusiveMinimum ?? meta.minimum,
            minExcluded: "exclusiveMinimum" in meta ? true : void 0,
            max: meta.exclusiveMaximum ?? meta.maximum,
            maxExcluded: "exclusiveMaximum" in meta ? true : void 0
          });
          return {
            ...from,
            constraints: [...from.constraints, c],
            refinements: [...from.refinements, ast]
          };
        }
        case "BigIntKeyword": {
          const c = getASTConstraints(ast);
          return {
            ...from,
            constraints: c !== void 0 ? [...from.constraints, makeBigIntConstraints(c)] : from.constraints,
            refinements: [...from.refinements, ast]
          };
        }
        case "TupleType":
          return {
            ...from,
            constraints: [...from.constraints, makeArrayConstraints({
              minLength: meta.minItems,
              maxLength: meta.maxItems
            })],
            refinements: [...from.refinements, ast]
          };
        case "DateFromSelf":
          return {
            ...from,
            constraints: [...from.constraints, makeDateConstraints(meta)],
            refinements: [...from.refinements, ast]
          };
        default:
          return {
            ...from,
            refinements: [...from.refinements, ast]
          };
      }
    }
    case "Declaration": {
      if (schemaId === DateFromSelfSchemaId) {
        return {
          _tag: "DateFromSelf",
          constraints: [makeDateConstraints(meta)],
          path,
          refinements: [],
          annotations: []
        };
      }
      return {
        _tag: "Declaration",
        typeParameters: ast.typeParameters.map((ast2) => getDescription(ast2, path)),
        path,
        refinements: [],
        annotations: [],
        ast
      };
    }
    case "Literal": {
      return {
        _tag: "Literal",
        literal: ast.literal,
        path,
        refinements: [],
        annotations: []
      };
    }
    case "UniqueSymbol": {
      return {
        _tag: "UniqueSymbol",
        symbol: ast.symbol,
        path,
        refinements: [],
        annotations: []
      };
    }
    case "Enums": {
      return {
        _tag: "Enums",
        enums: ast.enums,
        path,
        refinements: [],
        annotations: [],
        ast
      };
    }
    case "TemplateLiteral": {
      return {
        _tag: "TemplateLiteral",
        head: ast.head,
        spans: ast.spans.map((span4) => ({
          description: getDescription(span4.type, path),
          literal: span4.literal
        })),
        path,
        refinements: [],
        annotations: []
      };
    }
    case "StringKeyword":
      return {
        _tag: "StringKeyword",
        constraints: [],
        path,
        refinements: [],
        annotations: []
      };
    case "NumberKeyword":
      return {
        _tag: "NumberKeyword",
        constraints: [],
        path,
        refinements: [],
        annotations: []
      };
    case "BigIntKeyword":
      return {
        _tag: "BigIntKeyword",
        constraints: [],
        path,
        refinements: [],
        annotations: []
      };
    case "TupleType":
      return {
        _tag: "TupleType",
        constraints: [],
        elements: ast.elements.map((element2, i) => ({
          isOptional: element2.isOptional,
          description: getDescription(element2.type, [...path, i])
        })),
        rest: ast.rest.map((element2, i) => getDescription(element2.type, [...path, i])),
        path,
        refinements: [],
        annotations: []
      };
    case "TypeLiteral":
      return {
        _tag: "TypeLiteral",
        propertySignatures: ast.propertySignatures.map((ps) => ({
          isOptional: ps.isOptional,
          name: ps.name,
          value: getDescription(ps.type, [...path, ps.name])
        })),
        indexSignatures: ast.indexSignatures.map((is4) => ({
          parameter: getDescription(is4.parameter, path),
          value: getDescription(is4.type, path)
        })),
        path,
        refinements: [],
        annotations: []
      };
    case "Union":
      return {
        _tag: "Union",
        members: ast.types.map((member, i) => getDescription(member, [...path, i])),
        path,
        refinements: [],
        annotations: []
      };
    case "Suspend": {
      const memoId = idMemoMap.get(ast);
      if (memoId !== void 0) {
        return {
          _tag: "Ref",
          id: memoId,
          ast,
          path,
          refinements: [],
          annotations: []
        };
      }
      counter++;
      const id3 = `__id-${counter}__`;
      idMemoMap.set(ast, id3);
      return {
        _tag: "Suspend",
        id: id3,
        ast,
        description: () => getDescription(ast.f(), path),
        path,
        refinements: [],
        annotations: []
      };
    }
    case "Transformation":
      return getDescription(ast.to, path);
    case "NeverKeyword":
      return {
        _tag: "NeverKeyword",
        path,
        refinements: [],
        annotations: [],
        ast
      };
    default: {
      return {
        _tag: "Keyword",
        value: ast._tag,
        path,
        refinements: [],
        annotations: []
      };
    }
  }
});
function getMax(n1, n2) {
  return n1 === void 0 ? n2 : n2 === void 0 ? n1 : n1 <= n2 ? n2 : n1;
}
function getMin(n1, n2) {
  return n1 === void 0 ? n2 : n2 === void 0 ? n1 : n1 <= n2 ? n1 : n2;
}
var getOr = (a, b) => {
  return a === void 0 ? b : b === void 0 ? a : a || b;
};
function mergePattern(pattern1, pattern2) {
  if (pattern1 === void 0) {
    return pattern2;
  }
  if (pattern2 === void 0) {
    return pattern1;
  }
  return `(?:${pattern1})|(?:${pattern2})`;
}
function mergeStringConstraints(c1, c2) {
  return makeStringConstraints({
    minLength: getMax(c1.constraints.minLength, c2.constraints.minLength),
    maxLength: getMin(c1.constraints.maxLength, c2.constraints.maxLength),
    pattern: mergePattern(c1.pattern, c2.pattern)
  });
}
function buildStringConstraints(description) {
  return description.constraints.length === 0 ? void 0 : description.constraints.reduce(mergeStringConstraints);
}
function mergeNumberConstraints(c1, c2) {
  return makeNumberConstraints({
    isInteger: c1.isInteger || c2.isInteger,
    min: getMax(c1.constraints.min, c2.constraints.min),
    minExcluded: getOr(c1.constraints.minExcluded, c2.constraints.minExcluded),
    max: getMin(c1.constraints.max, c2.constraints.max),
    maxExcluded: getOr(c1.constraints.maxExcluded, c2.constraints.maxExcluded),
    noNaN: getOr(c1.constraints.noNaN, c2.constraints.noNaN),
    noDefaultInfinity: getOr(c1.constraints.noDefaultInfinity, c2.constraints.noDefaultInfinity)
  });
}
function buildNumberConstraints(description) {
  return description.constraints.length === 0 ? void 0 : description.constraints.reduce(mergeNumberConstraints);
}
function mergeBigIntConstraints(c1, c2) {
  return makeBigIntConstraints({
    min: getMax(c1.constraints.min, c2.constraints.min),
    max: getMin(c1.constraints.max, c2.constraints.max)
  });
}
function buildBigIntConstraints(description) {
  return description.constraints.length === 0 ? void 0 : description.constraints.reduce(mergeBigIntConstraints);
}
function mergeDateConstraints(c1, c2) {
  return makeDateConstraints({
    min: getMax(c1.constraints.min, c2.constraints.min),
    max: getMin(c1.constraints.max, c2.constraints.max),
    noInvalidDate: getOr(c1.constraints.noInvalidDate, c2.constraints.noInvalidDate)
  });
}
function buildDateConstraints(description) {
  return description.constraints.length === 0 ? void 0 : description.constraints.reduce(mergeDateConstraints);
}
var constArrayConstraints = makeArrayConstraints({});
function mergeArrayConstraints(c1, c2) {
  return makeArrayConstraints({
    minLength: getMax(c1.constraints.minLength, c2.constraints.minLength),
    maxLength: getMin(c1.constraints.maxLength, c2.constraints.maxLength)
  });
}
function buildArrayConstraints(description) {
  return description.constraints.length === 0 ? void 0 : description.constraints.reduce(mergeArrayConstraints);
}
var arbitraryMemoMap = globalValue(Symbol.for("effect/Arbitrary/arbitraryMemoMap"), () => /* @__PURE__ */ new WeakMap());
function applyFilters(filters, arb) {
  return (fc) => filters.reduce((arb2, filter26) => arb2.filter(filter26), arb(fc));
}
function absurd2(message) {
  return () => {
    throw new Error(message);
  };
}
function getContextConstraints(description) {
  switch (description._tag) {
    case "StringKeyword":
      return buildStringConstraints(description);
    case "NumberKeyword":
      return buildNumberConstraints(description);
    case "BigIntKeyword":
      return buildBigIntConstraints(description);
    case "DateFromSelf":
      return buildDateConstraints(description);
    case "TupleType":
      return buildArrayConstraints(description);
  }
}
function wrapGo(f, g) {
  return (description, ctx) => f(description, ctx, g(description, ctx));
}
var go = wrapGo((description, ctx, lazyArb) => {
  const annotation = description.annotations[description.annotations.length - 1];
  if (annotation === void 0) {
    switch (description._tag) {
      case "Declaration":
      case "NeverKeyword":
        throw new Error(getArbitraryMissingAnnotationErrorMessage(description.path, description.ast));
      case "Enums":
        if (description.enums.length === 0) {
          throw new Error(getArbitraryEmptyEnumErrorMessage(description.path));
        }
    }
  }
  const filters = description.refinements.map((ast) => (a) => isNone2(ast.filter(a, defaultParseOption, ast)));
  if (annotation === void 0) {
    return applyFilters(filters, lazyArb);
  }
  const constraints = getContextConstraints(description);
  if (constraints !== void 0) {
    ctx = {
      ...ctx,
      constraints
    };
  }
  if (description._tag === "Declaration") {
    return applyFilters(filters, annotation(...description.typeParameters.map((p) => go(p, ctx)), ctx));
  }
  if (description.refinements.length > 0) {
    return applyFilters(filters, annotation(lazyArb, ctx));
  }
  return annotation(ctx);
}, (description, ctx) => {
  switch (description._tag) {
    case "DateFromSelf": {
      const constraints = buildDateConstraints(description);
      return (fc) => fc.date(constraints?.constraints);
    }
    case "Declaration":
    case "NeverKeyword":
      return absurd2(`BUG: cannot generate an arbitrary for ${description._tag}`);
    case "Literal":
      return (fc) => fc.constant(description.literal);
    case "UniqueSymbol":
      return (fc) => fc.constant(description.symbol);
    case "Keyword": {
      switch (description.value) {
        case "UndefinedKeyword":
          return (fc) => fc.constant(void 0);
        case "VoidKeyword":
        case "UnknownKeyword":
        case "AnyKeyword":
          return (fc) => fc.anything();
        case "BooleanKeyword":
          return (fc) => fc.boolean();
        case "SymbolKeyword":
          return (fc) => fc.string().map((s) => Symbol.for(s));
        case "ObjectKeyword":
          return (fc) => fc.oneof(fc.object(), fc.array(fc.anything()));
      }
    }
    case "Enums":
      return (fc) => fc.oneof(...description.enums.map(([_, value10]) => fc.constant(value10)));
    case "TemplateLiteral": {
      return (fc) => {
        const string8 = fc.string({
          maxLength: 5
        });
        const number7 = fc.float({
          noDefaultInfinity: true,
          noNaN: true
        });
        const getTemplateLiteralArb = (description2) => {
          const components = description2.head !== "" ? [fc.constant(description2.head)] : [];
          const getTemplateLiteralSpanTypeArb = (description3) => {
            switch (description3._tag) {
              case "StringKeyword":
                return string8;
              case "NumberKeyword":
                return number7;
              case "Literal":
                return fc.constant(String(description3.literal));
              case "Union":
                return fc.oneof(...description3.members.map(getTemplateLiteralSpanTypeArb));
              case "TemplateLiteral":
                return getTemplateLiteralArb(description3);
              default:
                return fc.constant("");
            }
          };
          description2.spans.forEach((span4) => {
            components.push(getTemplateLiteralSpanTypeArb(span4.description));
            if (span4.literal !== "") {
              components.push(fc.constant(span4.literal));
            }
          });
          return fc.tuple(...components).map((spans) => spans.join(""));
        };
        return getTemplateLiteralArb(description);
      };
    }
    case "StringKeyword": {
      const constraints = buildStringConstraints(description);
      const pattern2 = constraints?.pattern;
      return pattern2 !== void 0 ? (fc) => fc.stringMatching(new RegExp(pattern2)) : (fc) => fc.string(constraints?.constraints);
    }
    case "NumberKeyword": {
      const constraints = buildNumberConstraints(description);
      return constraints?.isInteger ? (fc) => fc.integer(constraints.constraints) : (fc) => fc.float(constraints?.constraints);
    }
    case "BigIntKeyword": {
      const constraints = buildBigIntConstraints(description);
      return (fc) => fc.bigInt(constraints?.constraints ?? {});
    }
    case "TupleType": {
      const elements = [];
      let hasOptionals = false;
      for (const element2 of description.elements) {
        elements.push(go(element2.description, ctx));
        if (element2.isOptional) {
          hasOptionals = true;
        }
      }
      const rest = description.rest.map((d) => go(d, ctx));
      return (fc) => {
        let output = fc.tuple(...elements.map((arb) => arb(fc)));
        if (hasOptionals) {
          const indexes = fc.tuple(...description.elements.map((element2) => element2.isOptional ? fc.boolean() : fc.constant(true)));
          output = output.chain((tuple7) => indexes.map((booleans) => {
            for (const [i, b] of booleans.reverse().entries()) {
              if (!b) {
                tuple7.splice(booleans.length - i, 1);
              }
            }
            return tuple7;
          }));
        }
        if (isNonEmptyReadonlyArray(rest)) {
          const constraints = buildArrayConstraints(description) ?? constArrayConstraints;
          const [head13, ...tail5] = rest;
          const item = head13(fc);
          output = output.chain((as18) => {
            const len = as18.length;
            const restArrayConstraints = subtractElementsLength(constraints.constraints, len);
            if (restArrayConstraints.maxLength === 0) {
              return fc.constant(as18);
            }
            const arr = ctx.depthIdentifier !== void 0 ? getSuspendedArray(fc, ctx.depthIdentifier, ctx.maxDepth, item, restArrayConstraints) : fc.array(item, restArrayConstraints);
            if (len === 0) {
              return arr;
            }
            return arr.map((rest2) => [...as18, ...rest2]);
          });
          for (let j = 0; j < tail5.length; j++) {
            output = output.chain((as18) => tail5[j](fc).map((a) => [...as18, a]));
          }
        }
        return output;
      };
    }
    case "TypeLiteral": {
      const propertySignatures = [];
      const requiredKeys = [];
      for (const ps of description.propertySignatures) {
        if (!ps.isOptional) {
          requiredKeys.push(ps.name);
        }
        propertySignatures.push(go(ps.value, ctx));
      }
      const indexSignatures = description.indexSignatures.map((is4) => [go(is4.parameter, ctx), go(is4.value, ctx)]);
      return (fc) => {
        const pps = {};
        for (let i = 0; i < propertySignatures.length; i++) {
          const ps = description.propertySignatures[i];
          pps[ps.name] = propertySignatures[i](fc);
        }
        let output = fc.record(pps, {
          requiredKeys
        });
        for (let i = 0; i < indexSignatures.length; i++) {
          const key = indexSignatures[i][0](fc);
          const value10 = indexSignatures[i][1](fc);
          output = output.chain((o) => {
            const item = fc.tuple(key, value10);
            const arr = ctx.depthIdentifier !== void 0 ? getSuspendedArray(fc, ctx.depthIdentifier, ctx.maxDepth, item, {
              maxLength: 2
            }) : fc.array(item);
            return arr.map((tuples) => ({
              ...Object.fromEntries(tuples),
              ...o
            }));
          });
        }
        return output;
      };
    }
    case "Union": {
      const members = description.members.map((member) => go(member, ctx));
      return (fc) => fc.oneof(...members.map((arb) => arb(fc)));
    }
    case "Suspend": {
      const memo2 = arbitraryMemoMap.get(description.ast);
      if (memo2) {
        return memo2;
      }
      if (ctx.depthIdentifier === void 0) {
        ctx = {
          ...ctx,
          depthIdentifier: description.id
        };
      }
      const get48 = memoizeThunk(() => {
        return go(description.description(), ctx);
      });
      const out = (fc) => fc.constant(null).chain(() => get48()(fc));
      arbitraryMemoMap.set(description.ast, out);
      return out;
    }
    case "Ref": {
      const memo2 = arbitraryMemoMap.get(description.ast);
      if (memo2) {
        return memo2;
      }
      throw new Error(`BUG: Ref ${JSON.stringify(description.id)} not found`);
    }
  }
});
function subtractElementsLength(constraints, len) {
  if (len === 0 || constraints.minLength === void 0 && constraints.maxLength === void 0) {
    return constraints;
  }
  const out = {
    ...constraints
  };
  if (out.minLength !== void 0) {
    out.minLength = Math.max(out.minLength - len, 0);
  }
  if (out.maxLength !== void 0) {
    out.maxLength = Math.max(out.maxLength - len, 0);
  }
  return out;
}
var getSuspendedArray = (fc, depthIdentifier, maxDepth, item, constraints) => {
  const maxLengthLimit = Math.max(2, constraints.minLength ?? 0);
  if (constraints.maxLength !== void 0 && constraints.maxLength > maxLengthLimit) {
    constraints = {
      ...constraints,
      maxLength: maxLengthLimit
    };
  }
  return fc.oneof({
    maxDepth,
    depthIdentifier
  }, fc.constant([]), fc.array(item, constraints));
};

// ../../node_modules/effect/dist/esm/BigDecimal.js
var BigDecimal_exports = {};
__export(BigDecimal_exports, {
  Equivalence: () => Equivalence2,
  Order: () => Order2,
  TypeId: () => TypeId5,
  abs: () => abs,
  between: () => between3,
  ceil: () => ceil,
  clamp: () => clamp4,
  digitAt: () => digitAt,
  divide: () => divide2,
  equals: () => equals3,
  floor: () => floor,
  format: () => format2,
  fromBigInt: () => fromBigInt,
  fromNumber: () => fromNumber,
  fromString: () => fromString,
  greaterThan: () => greaterThan3,
  greaterThanOrEqualTo: () => greaterThanOrEqualTo3,
  isBigDecimal: () => isBigDecimal,
  isInteger: () => isInteger,
  isNegative: () => isNegative,
  isPositive: () => isPositive,
  isZero: () => isZero,
  lessThan: () => lessThan3,
  lessThanOrEqualTo: () => lessThanOrEqualTo3,
  make: () => make6,
  max: () => max4,
  min: () => min4,
  multiply: () => multiply2,
  negate: () => negate2,
  normalize: () => normalize,
  remainder: () => remainder2,
  round: () => round3,
  roundTerminal: () => roundTerminal,
  safeFromNumber: () => safeFromNumber,
  scale: () => scale,
  sign: () => sign2,
  subtract: () => subtract2,
  sum: () => sum2,
  sumAll: () => sumAll2,
  toExponential: () => toExponential,
  truncate: () => truncate,
  unsafeDivide: () => unsafeDivide2,
  unsafeFromNumber: () => unsafeFromNumber,
  unsafeFromString: () => unsafeFromString,
  unsafeMakeNormalized: () => unsafeMakeNormalized,
  unsafeRemainder: () => unsafeRemainder,
  unsafeToNumber: () => unsafeToNumber
});
var DEFAULT_PRECISION = 100;
var FINITE_INT_REGEX = /^[+-]?\d+$/;
var TypeId5 = Symbol.for("effect/BigDecimal");
var BigDecimalProto = {
  [TypeId5]: TypeId5,
  [symbol2]() {
    const normalized = normalize(this);
    return pipe(hash(normalized.value), combine2(number2(normalized.scale)), cached(this));
  },
  [symbol3](that) {
    return isBigDecimal(that) && equals3(this, that);
  },
  toString() {
    return `BigDecimal(${format2(this)})`;
  },
  toJSON() {
    return {
      _id: "BigDecimal",
      value: String(this.value),
      scale: this.scale
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isBigDecimal = (u) => hasProperty(u, TypeId5);
var make6 = (value10, scale2) => {
  const o = Object.create(BigDecimalProto);
  o.value = value10;
  o.scale = scale2;
  return o;
};
var unsafeMakeNormalized = (value10, scale2) => {
  if (value10 !== bigint0 && value10 % bigint10 === bigint0) {
    throw new RangeError("Value must be normalized");
  }
  const o = make6(value10, scale2);
  o.normalized = o;
  return o;
};
var bigint0 = BigInt(0);
var bigint1 = BigInt(1);
var bigint10 = BigInt(10);
var zero = unsafeMakeNormalized(bigint0, 0);
var normalize = (self) => {
  if (self.normalized === void 0) {
    if (self.value === bigint0) {
      self.normalized = zero;
    } else {
      const digits = `${self.value}`;
      let trail = 0;
      for (let i = digits.length - 1; i >= 0; i--) {
        if (digits[i] === "0") {
          trail++;
        } else {
          break;
        }
      }
      if (trail === 0) {
        self.normalized = self;
      }
      const value10 = BigInt(digits.substring(0, digits.length - trail));
      const scale2 = self.scale - trail;
      self.normalized = unsafeMakeNormalized(value10, scale2);
    }
  }
  return self.normalized;
};
var scale = dual(2, (self, scale2) => {
  if (scale2 > self.scale) {
    return make6(self.value * bigint10 ** BigInt(scale2 - self.scale), scale2);
  }
  if (scale2 < self.scale) {
    return make6(self.value / bigint10 ** BigInt(self.scale - scale2), scale2);
  }
  return self;
});
var sum2 = dual(2, (self, that) => {
  if (that.value === bigint0) {
    return self;
  }
  if (self.value === bigint0) {
    return that;
  }
  if (self.scale > that.scale) {
    return make6(scale(that, self.scale).value + self.value, self.scale);
  }
  if (self.scale < that.scale) {
    return make6(scale(self, that.scale).value + that.value, that.scale);
  }
  return make6(self.value + that.value, self.scale);
});
var multiply2 = dual(2, (self, that) => {
  if (that.value === bigint0 || self.value === bigint0) {
    return zero;
  }
  return make6(self.value * that.value, self.scale + that.scale);
});
var subtract2 = dual(2, (self, that) => {
  if (that.value === bigint0) {
    return self;
  }
  if (self.value === bigint0) {
    return make6(-that.value, that.scale);
  }
  if (self.scale > that.scale) {
    return make6(self.value - scale(that, self.scale).value, self.scale);
  }
  if (self.scale < that.scale) {
    return make6(scale(self, that.scale).value - that.value, that.scale);
  }
  return make6(self.value - that.value, self.scale);
});
var divideWithPrecision = (num, den, scale2, precision) => {
  const numNegative = num < bigint0;
  const denNegative = den < bigint0;
  const negateResult = numNegative !== denNegative;
  num = numNegative ? -num : num;
  den = denNegative ? -den : den;
  while (num < den) {
    num *= bigint10;
    scale2++;
  }
  let quotient = num / den;
  let remainder3 = num % den;
  if (remainder3 === bigint0) {
    return make6(negateResult ? -quotient : quotient, scale2);
  }
  let count9 = `${quotient}`.length;
  remainder3 *= bigint10;
  while (remainder3 !== bigint0 && count9 < precision) {
    const q = remainder3 / den;
    const r = remainder3 % den;
    quotient = quotient * bigint10 + q;
    remainder3 = r * bigint10;
    count9++;
    scale2++;
  }
  if (remainder3 !== bigint0) {
    quotient += roundTerminal(remainder3 / den);
  }
  return make6(negateResult ? -quotient : quotient, scale2);
};
var roundTerminal = (n) => {
  const pos = n >= bigint0 ? 0 : 1;
  return Number(`${n}`[pos]) < 5 ? bigint0 : bigint1;
};
var divide2 = dual(2, (self, that) => {
  if (that.value === bigint0) {
    return none2();
  }
  if (self.value === bigint0) {
    return some3(zero);
  }
  const scale2 = self.scale - that.scale;
  if (self.value === that.value) {
    return some3(make6(bigint1, scale2));
  }
  return some3(divideWithPrecision(self.value, that.value, scale2, DEFAULT_PRECISION));
});
var unsafeDivide2 = dual(2, (self, that) => {
  if (that.value === bigint0) {
    throw new RangeError("Division by zero");
  }
  if (self.value === bigint0) {
    return zero;
  }
  const scale2 = self.scale - that.scale;
  if (self.value === that.value) {
    return make6(bigint1, scale2);
  }
  return divideWithPrecision(self.value, that.value, scale2, DEFAULT_PRECISION);
});
var Order2 = make2((self, that) => {
  const scmp = number3(sign2(self), sign2(that));
  if (scmp !== 0) {
    return scmp;
  }
  if (self.scale > that.scale) {
    return bigint2(self.value, scale(that, self.scale).value);
  }
  if (self.scale < that.scale) {
    return bigint2(scale(self, that.scale).value, that.value);
  }
  return bigint2(self.value, that.value);
});
var lessThan3 = lessThan(Order2);
var lessThanOrEqualTo3 = lessThanOrEqualTo(Order2);
var greaterThan3 = greaterThan(Order2);
var greaterThanOrEqualTo3 = greaterThanOrEqualTo(Order2);
var between3 = between(Order2);
var clamp4 = clamp(Order2);
var min4 = min(Order2);
var max4 = max(Order2);
var sign2 = (n) => n.value === bigint0 ? 0 : n.value < bigint0 ? -1 : 1;
var abs = (n) => n.value < bigint0 ? make6(-n.value, n.scale) : n;
var negate2 = (n) => make6(-n.value, n.scale);
var remainder2 = dual(2, (self, divisor) => {
  if (divisor.value === bigint0) {
    return none2();
  }
  const max13 = Math.max(self.scale, divisor.scale);
  return some3(make6(scale(self, max13).value % scale(divisor, max13).value, max13));
});
var unsafeRemainder = dual(2, (self, divisor) => {
  if (divisor.value === bigint0) {
    throw new RangeError("Division by zero");
  }
  const max13 = Math.max(self.scale, divisor.scale);
  return make6(scale(self, max13).value % scale(divisor, max13).value, max13);
});
var Equivalence2 = make((self, that) => {
  if (self.scale > that.scale) {
    return scale(that, self.scale).value === self.value;
  }
  if (self.scale < that.scale) {
    return scale(self, that.scale).value === that.value;
  }
  return self.value === that.value;
});
var equals3 = dual(2, (self, that) => Equivalence2(self, that));
var fromBigInt = (n) => make6(n, 0);
var unsafeFromNumber = (n) => getOrThrowWith2(safeFromNumber(n), () => new RangeError(`Number must be finite, got ${n}`));
var fromNumber = unsafeFromNumber;
var safeFromNumber = (n) => {
  if (!Number.isFinite(n)) {
    return none2();
  }
  const string8 = `${n}`;
  if (string8.includes("e")) {
    return fromString(string8);
  }
  const [lead, trail = ""] = string8.split(".");
  return some3(make6(BigInt(`${lead}${trail}`), trail.length));
};
var fromString = (s) => {
  if (s === "") {
    return some3(zero);
  }
  let base;
  let exp;
  const seperator = s.search(/[eE]/);
  if (seperator !== -1) {
    const trail = s.slice(seperator + 1);
    base = s.slice(0, seperator);
    exp = Number(trail);
    if (base === "" || !Number.isSafeInteger(exp) || !FINITE_INT_REGEX.test(trail)) {
      return none2();
    }
  } else {
    base = s;
    exp = 0;
  }
  let digits;
  let offset;
  const dot = base.search(/\./);
  if (dot !== -1) {
    const lead = base.slice(0, dot);
    const trail = base.slice(dot + 1);
    digits = `${lead}${trail}`;
    offset = trail.length;
  } else {
    digits = base;
    offset = 0;
  }
  if (!FINITE_INT_REGEX.test(digits)) {
    return none2();
  }
  const scale2 = offset - exp;
  if (!Number.isSafeInteger(scale2)) {
    return none2();
  }
  return some3(make6(BigInt(digits), scale2));
};
var unsafeFromString = (s) => getOrThrowWith2(fromString(s), () => new Error("Invalid numerical string"));
var format2 = (n) => {
  const normalized = normalize(n);
  if (Math.abs(normalized.scale) >= 16) {
    return toExponential(normalized);
  }
  const negative2 = normalized.value < bigint0;
  const absolute = negative2 ? `${normalized.value}`.substring(1) : `${normalized.value}`;
  let before3;
  let after3;
  if (normalized.scale >= absolute.length) {
    before3 = "0";
    after3 = "0".repeat(normalized.scale - absolute.length) + absolute;
  } else {
    const location = absolute.length - normalized.scale;
    if (location > absolute.length) {
      const zeros = location - absolute.length;
      before3 = `${absolute}${"0".repeat(zeros)}`;
      after3 = "";
    } else {
      after3 = absolute.slice(location);
      before3 = absolute.slice(0, location);
    }
  }
  const complete6 = after3 === "" ? before3 : `${before3}.${after3}`;
  return negative2 ? `-${complete6}` : complete6;
};
var toExponential = (n) => {
  if (isZero(n)) {
    return "0e+0";
  }
  const normalized = normalize(n);
  const digits = `${abs(normalized).value}`;
  const head13 = digits.slice(0, 1);
  const tail5 = digits.slice(1);
  let output = `${isNegative(normalized) ? "-" : ""}${head13}`;
  if (tail5 !== "") {
    output += `.${tail5}`;
  }
  const exp = tail5.length - normalized.scale;
  return `${output}e${exp >= 0 ? "+" : ""}${exp}`;
};
var unsafeToNumber = (n) => Number(format2(n));
var isInteger = (n) => normalize(n).scale <= 0;
var isZero = (n) => n.value === bigint0;
var isNegative = (n) => n.value < bigint0;
var isPositive = (n) => n.value > bigint0;
var isBigDecimalArgs = (args2) => isBigDecimal(args2[0]);
var ceil = dual(isBigDecimalArgs, (self, scale2 = 0) => {
  const truncated = truncate(self, scale2);
  if (isPositive(self) && lessThan3(truncated, self)) {
    return sum2(truncated, make6(1n, scale2));
  }
  return truncated;
});
var floor = dual(isBigDecimalArgs, (self, scale2 = 0) => {
  const truncated = truncate(self, scale2);
  if (isNegative(self) && greaterThan3(truncated, self)) {
    return sum2(truncated, make6(-1n, scale2));
  }
  return truncated;
});
var truncate = dual(isBigDecimalArgs, (self, scale2 = 0) => {
  if (self.scale <= scale2) {
    return self;
  }
  return make6(self.value / 10n ** BigInt(self.scale - scale2), scale2);
});
var digitAt = dual(2, (self, scale2) => {
  if (self.scale < scale2) {
    return 0n;
  }
  const scaled = self.value / 10n ** BigInt(self.scale - scale2);
  return scaled % 10n;
});
var round3 = dual(isBigDecimalArgs, (self, options) => {
  const mode = options?.mode ?? "half-from-zero";
  const scale2 = options?.scale ?? 0;
  switch (mode) {
    case "ceil":
      return ceil(self, scale2);
    case "floor":
      return floor(self, scale2);
    case "to-zero":
      return truncate(self, scale2);
    case "from-zero":
      return isPositive(self) ? ceil(self, scale2) : floor(self, scale2);
    case "half-ceil":
      return floor(sum2(self, make6(5n, scale2 + 1)), scale2);
    case "half-floor":
      return ceil(sum2(self, make6(-5n, scale2 + 1)), scale2);
    case "half-to-zero":
      return isNegative(self) ? floor(sum2(self, make6(5n, scale2 + 1)), scale2) : ceil(sum2(self, make6(-5n, scale2 + 1)), scale2);
    case "half-from-zero":
      return isNegative(self) ? ceil(sum2(self, make6(-5n, scale2 + 1)), scale2) : floor(sum2(self, make6(5n, scale2 + 1)), scale2);
  }
  const halfCeil = floor(sum2(self, make6(5n, scale2 + 1)), scale2);
  const halfFloor = ceil(sum2(self, make6(-5n, scale2 + 1)), scale2);
  const digit = digitAt(halfCeil, scale2);
  switch (mode) {
    case "half-even":
      return equals3(halfCeil, halfFloor) ? halfCeil : digit % 2n === 0n ? halfCeil : halfFloor;
    case "half-odd":
      return equals3(halfCeil, halfFloor) ? halfCeil : digit % 2n === 0n ? halfFloor : halfCeil;
  }
});
var sumAll2 = (collection) => {
  let out = zero;
  for (const n of collection) {
    out = sum2(out, n);
  }
  return out;
};

// ../../node_modules/effect/dist/esm/BigInt.js
var BigInt_exports = {};
__export(BigInt_exports, {
  Equivalence: () => Equivalence3,
  Order: () => Order3,
  abs: () => abs2,
  between: () => between4,
  clamp: () => clamp5,
  decrement: () => decrement2,
  divide: () => divide3,
  fromNumber: () => fromNumber2,
  fromString: () => fromString2,
  gcd: () => gcd,
  greaterThan: () => greaterThan4,
  greaterThanOrEqualTo: () => greaterThanOrEqualTo4,
  increment: () => increment2,
  isBigInt: () => isBigInt2,
  lcm: () => lcm,
  lessThan: () => lessThan4,
  lessThanOrEqualTo: () => lessThanOrEqualTo4,
  max: () => max5,
  min: () => min5,
  multiply: () => multiply3,
  multiplyAll: () => multiplyAll2,
  sign: () => sign3,
  sqrt: () => sqrt,
  subtract: () => subtract3,
  sum: () => sum3,
  sumAll: () => sumAll3,
  toNumber: () => toNumber,
  unsafeDivide: () => unsafeDivide3,
  unsafeSqrt: () => unsafeSqrt
});
var bigint02 = BigInt(0);
var bigint12 = BigInt(1);
var bigint22 = BigInt(2);
var isBigInt2 = isBigInt;
var sum3 = dual(2, (self, that) => self + that);
var multiply3 = dual(2, (self, that) => self * that);
var subtract3 = dual(2, (self, that) => self - that);
var divide3 = dual(2, (self, that) => that === bigint02 ? none2() : some3(self / that));
var unsafeDivide3 = dual(2, (self, that) => self / that);
var increment2 = (n) => n + bigint12;
var decrement2 = (n) => n - bigint12;
var Equivalence3 = bigint;
var Order3 = bigint2;
var lessThan4 = lessThan(Order3);
var lessThanOrEqualTo4 = lessThanOrEqualTo(Order3);
var greaterThan4 = greaterThan(Order3);
var greaterThanOrEqualTo4 = greaterThanOrEqualTo(Order3);
var between4 = between(Order3);
var clamp5 = clamp(Order3);
var min5 = min(Order3);
var max5 = max(Order3);
var sign3 = (n) => Order3(n, bigint02);
var abs2 = (n) => n < bigint02 ? -n : n;
var gcd = dual(2, (self, that) => {
  while (that !== bigint02) {
    const t = that;
    that = self % that;
    self = t;
  }
  return self;
});
var lcm = dual(2, (self, that) => self * that / gcd(self, that));
var unsafeSqrt = (n) => {
  if (n < bigint02) {
    throw new RangeError("Cannot take the square root of a negative number");
  }
  if (n < bigint22) {
    return n;
  }
  let x = n / bigint22;
  while (x * x > n) {
    x = (n / x + x) / bigint22;
  }
  return x;
};
var sqrt = (n) => greaterThanOrEqualTo4(n, bigint02) ? some3(unsafeSqrt(n)) : none2();
var sumAll3 = (collection) => {
  let out = bigint02;
  for (const n of collection) {
    out += n;
  }
  return out;
};
var multiplyAll2 = (collection) => {
  let out = bigint12;
  for (const n of collection) {
    if (n === bigint02) {
      return bigint02;
    }
    out *= n;
  }
  return out;
};
var toNumber = (b) => {
  if (b > BigInt(Number.MAX_SAFE_INTEGER) || b < BigInt(Number.MIN_SAFE_INTEGER)) {
    return none2();
  }
  return some3(Number(b));
};
var fromString2 = (s) => {
  try {
    return s.trim() === "" ? none2() : some3(BigInt(s));
  } catch {
    return none2();
  }
};
var fromNumber2 = (n) => {
  if (n > Number.MAX_SAFE_INTEGER || n < Number.MIN_SAFE_INTEGER) {
    return none2();
  }
  try {
    return some3(BigInt(n));
  } catch {
    return none2();
  }
};

// ../../node_modules/effect/dist/esm/Boolean.js
var Boolean_exports = {};
__export(Boolean_exports, {
  Equivalence: () => Equivalence4,
  Order: () => Order4,
  and: () => and2,
  eqv: () => eqv2,
  every: () => every4,
  implies: () => implies2,
  isBoolean: () => isBoolean2,
  match: () => match4,
  nand: () => nand2,
  nor: () => nor2,
  not: () => not2,
  or: () => or2,
  some: () => some7,
  xor: () => xor2
});
var isBoolean2 = isBoolean;
var match4 = dual(2, (value10, options) => value10 ? options.onTrue() : options.onFalse());
var Equivalence4 = boolean;
var Order4 = boolean2;
var not2 = (self) => !self;
var and2 = dual(2, (self, that) => self && that);
var nand2 = dual(2, (self, that) => !(self && that));
var or2 = dual(2, (self, that) => self || that);
var nor2 = dual(2, (self, that) => !(self || that));
var xor2 = dual(2, (self, that) => !self && that || self && !that);
var eqv2 = dual(2, (self, that) => !xor2(self, that));
var implies2 = dual(2, (self, that) => self ? that : true);
var every4 = (collection) => {
  for (const b of collection) {
    if (!b) {
      return false;
    }
  }
  return true;
};
var some7 = (collection) => {
  for (const b of collection) {
    if (b) {
      return true;
    }
  }
  return false;
};

// ../../node_modules/effect/dist/esm/Brand.js
var Brand_exports = {};
__export(Brand_exports, {
  BrandTypeId: () => BrandTypeId,
  RefinedConstructorsTypeId: () => RefinedConstructorsTypeId,
  all: () => all6,
  error: () => error,
  errors: () => errors,
  nominal: () => nominal,
  refined: () => refined,
  unbranded: () => unbranded
});
var BrandTypeId = Symbol.for("effect/Brand");
var RefinedConstructorsTypeId = Symbol.for("effect/Brand/Refined");
var error = (message, meta) => [{
  message,
  meta
}];
var errors = (...errors2) => flatten3(errors2);
function refined(...args2) {
  const either14 = args2.length === 2 ? (unbranded2) => args2[0](unbranded2) ? right2(unbranded2) : left2(args2[1](unbranded2)) : (unbranded2) => {
    return match2(args2[0](unbranded2), {
      onNone: () => right2(unbranded2),
      onSome: left2
    });
  };
  return Object.assign((unbranded2) => getOrThrowWith(either14(unbranded2), identity), {
    [RefinedConstructorsTypeId]: RefinedConstructorsTypeId,
    option: (args3) => getRight3(either14(args3)),
    either: either14,
    is: (args3) => isRight2(either14(args3))
  });
}
var nominal = () => {
  return Object.assign((args2) => args2, {
    [RefinedConstructorsTypeId]: RefinedConstructorsTypeId,
    option: (args2) => some3(args2),
    either: (args2) => right2(args2),
    is: (_args) => true
  });
};
var all6 = (...brands) => {
  const either14 = (args2) => {
    let result = right2(args2);
    for (const brand2 of brands) {
      const nextResult = brand2.either(args2);
      if (isLeft2(result) && isLeft2(nextResult)) {
        result = left2([...result.left, ...nextResult.left]);
      } else {
        result = isLeft2(result) ? result : nextResult;
      }
    }
    return result;
  };
  return Object.assign((args2) => match(either14(args2), {
    onLeft: (e) => {
      throw e;
    },
    onRight: identity
  }), {
    [RefinedConstructorsTypeId]: RefinedConstructorsTypeId,
    option: (args2) => getRight3(either14(args2)),
    either: either14,
    is: (args2) => isRight2(either14(args2))
  });
};
var unbranded = unsafeCoerce;

// ../../node_modules/effect/dist/esm/Cache.js
var Cache_exports = {};
__export(Cache_exports, {
  CacheTypeId: () => CacheTypeId2,
  ConsumerCacheTypeId: () => ConsumerCacheTypeId2,
  make: () => make50,
  makeCacheStats: () => makeCacheStats2,
  makeEntryStats: () => makeEntryStats2,
  makeWith: () => makeWith2
});

// ../../node_modules/effect/dist/esm/Context.js
var Context_exports = {};
__export(Context_exports, {
  GenericTag: () => GenericTag,
  Reference: () => Reference2,
  Tag: () => Tag2,
  add: () => add2,
  empty: () => empty6,
  get: () => get4,
  getOption: () => getOption2,
  getOrElse: () => getOrElse4,
  isContext: () => isContext2,
  isReference: () => isReference2,
  isTag: () => isTag2,
  make: () => make8,
  merge: () => merge3,
  mergeAll: () => mergeAll2,
  omit: () => omit3,
  pick: () => pick3,
  unsafeGet: () => unsafeGet3,
  unsafeMake: () => unsafeMake
});

// ../../node_modules/effect/dist/esm/internal/context.js
var TagTypeId = Symbol.for("effect/Context/Tag");
var ReferenceTypeId = Symbol.for("effect/Context/Reference");
var STMSymbolKey = "effect/STM";
var STMTypeId = Symbol.for(STMSymbolKey);
var TagProto = {
  ...EffectPrototype,
  _op: "Tag",
  [STMTypeId]: effectVariance,
  [TagTypeId]: {
    _Service: (_) => _,
    _Identifier: (_) => _
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Tag",
      key: this.key,
      stack: this.stack
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  of(self) {
    return self;
  },
  context(self) {
    return make7(this, self);
  }
};
var ReferenceProto = {
  ...TagProto,
  [ReferenceTypeId]: ReferenceTypeId
};
var makeGenericTag = (key) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit;
  const tag5 = Object.create(TagProto);
  Object.defineProperty(tag5, "stack", {
    get() {
      return creationError.stack;
    }
  });
  tag5.key = key;
  return tag5;
};
var Tag = (id3) => () => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit;
  function TagClass() {
  }
  Object.setPrototypeOf(TagClass, TagProto);
  TagClass.key = id3;
  Object.defineProperty(TagClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return TagClass;
};
var Reference = () => (id3, options) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit;
  function ReferenceClass() {
  }
  Object.setPrototypeOf(ReferenceClass, ReferenceProto);
  ReferenceClass.key = id3;
  ReferenceClass.defaultValue = options.defaultValue;
  Object.defineProperty(ReferenceClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return ReferenceClass;
};
var TypeId6 = Symbol.for("effect/Context");
var ContextProto = {
  [TypeId6]: {
    _Services: (_) => _
  },
  [symbol3](that) {
    if (isContext(that)) {
      if (this.unsafeMap.size === that.unsafeMap.size) {
        for (const k of this.unsafeMap.keys()) {
          if (!that.unsafeMap.has(k) || !equals(this.unsafeMap.get(k), that.unsafeMap.get(k))) {
            return false;
          }
        }
        return true;
      }
    }
    return false;
  },
  [symbol2]() {
    return cached(this, number2(this.unsafeMap.size));
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Context",
      services: Array.from(this.unsafeMap).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var makeContext = (unsafeMap) => {
  const context15 = Object.create(ContextProto);
  context15.unsafeMap = unsafeMap;
  return context15;
};
var serviceNotFoundError = (tag5) => {
  const error4 = new Error(`Service not found${tag5.key ? `: ${String(tag5.key)}` : ""}`);
  if (tag5.stack) {
    const lines = tag5.stack.split("\n");
    if (lines.length > 2) {
      const afterAt = lines[2].match(/at (.*)/);
      if (afterAt) {
        error4.message = error4.message + ` (defined at ${afterAt[1]})`;
      }
    }
  }
  if (error4.stack) {
    const lines = error4.stack.split("\n");
    lines.splice(1, 3);
    error4.stack = lines.join("\n");
  }
  return error4;
};
var isContext = (u) => hasProperty(u, TypeId6);
var isTag = (u) => hasProperty(u, TagTypeId);
var isReference = (u) => hasProperty(u, ReferenceTypeId);
var _empty = makeContext(/* @__PURE__ */ new Map());
var empty5 = () => _empty;
var make7 = (tag5, service4) => makeContext(/* @__PURE__ */ new Map([[tag5.key, service4]]));
var add = dual(3, (self, tag5, service4) => {
  const map49 = new Map(self.unsafeMap);
  map49.set(tag5.key, service4);
  return makeContext(map49);
});
var defaultValueCache = globalValue("effect/Context/defaultValueCache", () => /* @__PURE__ */ new Map());
var getDefaultValue = (tag5) => {
  if (defaultValueCache.has(tag5.key)) {
    return defaultValueCache.get(tag5.key);
  }
  const value10 = tag5.defaultValue();
  defaultValueCache.set(tag5.key, value10);
  return value10;
};
var unsafeGetReference = (self, tag5) => {
  return self.unsafeMap.has(tag5.key) ? self.unsafeMap.get(tag5.key) : getDefaultValue(tag5);
};
var unsafeGet2 = dual(2, (self, tag5) => {
  if (!self.unsafeMap.has(tag5.key)) {
    if (ReferenceTypeId in tag5) return getDefaultValue(tag5);
    throw serviceNotFoundError(tag5);
  }
  return self.unsafeMap.get(tag5.key);
});
var get3 = unsafeGet2;
var getOrElse3 = dual(3, (self, tag5, orElse24) => {
  if (!self.unsafeMap.has(tag5.key)) {
    return isReference(tag5) ? getDefaultValue(tag5) : orElse24();
  }
  return self.unsafeMap.get(tag5.key);
});
var getOption = dual(2, (self, tag5) => {
  if (!self.unsafeMap.has(tag5.key)) {
    return isReference(tag5) ? some2(getDefaultValue(tag5)) : none;
  }
  return some2(self.unsafeMap.get(tag5.key));
});
var merge2 = dual(2, (self, that) => {
  const map49 = new Map(self.unsafeMap);
  for (const [tag5, s] of that.unsafeMap) {
    map49.set(tag5, s);
  }
  return makeContext(map49);
});
var mergeAll = (...ctxs) => {
  const map49 = /* @__PURE__ */ new Map();
  for (const ctx of ctxs) {
    for (const [tag5, s] of ctx.unsafeMap) {
      map49.set(tag5, s);
    }
  }
  return makeContext(map49);
};
var pick2 = (...tags3) => (self) => {
  const tagSet = new Set(tags3.map((_) => _.key));
  const newEnv = /* @__PURE__ */ new Map();
  for (const [tag5, s] of self.unsafeMap.entries()) {
    if (tagSet.has(tag5)) {
      newEnv.set(tag5, s);
    }
  }
  return makeContext(newEnv);
};
var omit2 = (...tags3) => (self) => {
  const newEnv = new Map(self.unsafeMap);
  for (const tag5 of tags3) {
    newEnv.delete(tag5.key);
  }
  return makeContext(newEnv);
};

// ../../node_modules/effect/dist/esm/Context.js
var GenericTag = makeGenericTag;
var unsafeMake = makeContext;
var isContext2 = isContext;
var isTag2 = isTag;
var isReference2 = isReference;
var empty6 = empty5;
var make8 = make7;
var add2 = add;
var get4 = get3;
var getOrElse4 = getOrElse3;
var unsafeGet3 = unsafeGet2;
var getOption2 = getOption;
var merge3 = merge2;
var mergeAll2 = mergeAll;
var pick3 = pick2;
var omit3 = omit2;
var Tag2 = Tag;
var Reference2 = Reference;

// ../../node_modules/effect/dist/esm/Deferred.js
var Deferred_exports = {};
__export(Deferred_exports, {
  DeferredTypeId: () => DeferredTypeId2,
  await: () => _await,
  complete: () => complete,
  completeWith: () => completeWith,
  die: () => die3,
  dieSync: () => dieSync2,
  done: () => done2,
  fail: () => fail3,
  failCause: () => failCause2,
  failCauseSync: () => failCauseSync2,
  failSync: () => failSync2,
  interrupt: () => interrupt3,
  interruptWith: () => interruptWith2,
  isDone: () => isDone,
  make: () => make24,
  makeAs: () => makeAs,
  poll: () => poll,
  succeed: () => succeed2,
  sync: () => sync2,
  unsafeDone: () => unsafeDone,
  unsafeMake: () => unsafeMake4
});

// ../../node_modules/effect/dist/esm/Chunk.js
var Chunk_exports = {};
__export(Chunk_exports, {
  append: () => append3,
  appendAll: () => appendAll3,
  chunksOf: () => chunksOf3,
  compact: () => compact,
  contains: () => contains4,
  containsWith: () => containsWith4,
  dedupe: () => dedupe2,
  dedupeAdjacent: () => dedupeAdjacent3,
  difference: () => difference3,
  differenceWith: () => differenceWith2,
  drop: () => drop3,
  dropRight: () => dropRight2,
  dropWhile: () => dropWhile2,
  empty: () => empty7,
  every: () => every5,
  filter: () => filter5,
  filterMap: () => filterMap5,
  filterMapWhile: () => filterMapWhile3,
  findFirst: () => findFirst4,
  findFirstIndex: () => findFirstIndex2,
  findLast: () => findLast3,
  findLastIndex: () => findLastIndex2,
  flatMap: () => flatMap5,
  flatten: () => flatten5,
  forEach: () => forEach3,
  fromIterable: () => fromIterable3,
  get: () => get5,
  getEquivalence: () => getEquivalence6,
  head: () => head3,
  headNonEmpty: () => headNonEmpty2,
  intersection: () => intersection4,
  isChunk: () => isChunk,
  isEmpty: () => isEmpty2,
  isNonEmpty: () => isNonEmpty2,
  join: () => join2,
  last: () => last2,
  lastNonEmpty: () => lastNonEmpty2,
  make: () => make9,
  makeBy: () => makeBy3,
  map: () => map7,
  mapAccum: () => mapAccum2,
  modify: () => modify3,
  modifyOption: () => modifyOption3,
  of: () => of3,
  partition: () => partition3,
  partitionMap: () => partitionMap4,
  prepend: () => prepend3,
  prependAll: () => prependAll3,
  range: () => range3,
  reduce: () => reduce4,
  reduceRight: () => reduceRight2,
  remove: () => remove3,
  removeOption: () => removeOption2,
  replace: () => replace3,
  replaceOption: () => replaceOption3,
  reverse: () => reverse3,
  separate: () => separate3,
  size: () => size3,
  some: () => some8,
  sort: () => sort2,
  sortWith: () => sortWith2,
  split: () => split2,
  splitAt: () => splitAt2,
  splitNonEmptyAt: () => splitNonEmptyAt2,
  splitWhere: () => splitWhere2,
  tail: () => tail2,
  tailNonEmpty: () => tailNonEmpty2,
  take: () => take3,
  takeRight: () => takeRight2,
  takeWhile: () => takeWhile3,
  toArray: () => toArray2,
  toReadonlyArray: () => toReadonlyArray,
  union: () => union3,
  unsafeFromArray: () => unsafeFromArray,
  unsafeFromNonEmptyArray: () => unsafeFromNonEmptyArray,
  unsafeGet: () => unsafeGet4,
  unsafeHead: () => unsafeHead2,
  unsafeLast: () => unsafeLast,
  unzip: () => unzip2,
  zip: () => zip3,
  zipWith: () => zipWith5
});
var TypeId7 = Symbol.for("effect/Chunk");
function copy2(src, srcPos, dest, destPos, len) {
  for (let i = srcPos; i < Math.min(src.length, srcPos + len); i++) {
    dest[destPos + i - srcPos] = src[i];
  }
  return dest;
}
var emptyArray = [];
var getEquivalence6 = (isEquivalent) => make((self, that) => self.length === that.length && toReadonlyArray(self).every((value10, i) => isEquivalent(value10, unsafeGet4(that, i))));
var _equivalence4 = getEquivalence6(equals);
var ChunkProto = {
  [TypeId7]: {
    _A: (_) => _
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Chunk",
      values: toReadonlyArray(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol3](that) {
    return isChunk(that) && _equivalence4(this, that);
  },
  [symbol2]() {
    return cached(this, array2(toReadonlyArray(this)));
  },
  [Symbol.iterator]() {
    switch (this.backing._tag) {
      case "IArray": {
        return this.backing.array[Symbol.iterator]();
      }
      case "IEmpty": {
        return emptyArray[Symbol.iterator]();
      }
      default: {
        return toReadonlyArray(this)[Symbol.iterator]();
      }
    }
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeChunk = (backing) => {
  const chunk7 = Object.create(ChunkProto);
  chunk7.backing = backing;
  switch (backing._tag) {
    case "IEmpty": {
      chunk7.length = 0;
      chunk7.depth = 0;
      chunk7.left = chunk7;
      chunk7.right = chunk7;
      break;
    }
    case "IConcat": {
      chunk7.length = backing.left.length + backing.right.length;
      chunk7.depth = 1 + Math.max(backing.left.depth, backing.right.depth);
      chunk7.left = backing.left;
      chunk7.right = backing.right;
      break;
    }
    case "IArray": {
      chunk7.length = backing.array.length;
      chunk7.depth = 0;
      chunk7.left = _empty2;
      chunk7.right = _empty2;
      break;
    }
    case "ISingleton": {
      chunk7.length = 1;
      chunk7.depth = 0;
      chunk7.left = _empty2;
      chunk7.right = _empty2;
      break;
    }
    case "ISlice": {
      chunk7.length = backing.length;
      chunk7.depth = backing.chunk.depth + 1;
      chunk7.left = _empty2;
      chunk7.right = _empty2;
      break;
    }
  }
  return chunk7;
};
var isChunk = (u) => hasProperty(u, TypeId7);
var _empty2 = makeChunk({
  _tag: "IEmpty"
});
var empty7 = () => _empty2;
var make9 = (...as18) => unsafeFromNonEmptyArray(as18);
var of3 = (a) => makeChunk({
  _tag: "ISingleton",
  a
});
var fromIterable3 = (self) => isChunk(self) ? self : unsafeFromArray(fromIterable2(self));
var copyToArray = (self, array8, initial) => {
  switch (self.backing._tag) {
    case "IArray": {
      copy2(self.backing.array, 0, array8, initial, self.length);
      break;
    }
    case "IConcat": {
      copyToArray(self.left, array8, initial);
      copyToArray(self.right, array8, initial + self.left.length);
      break;
    }
    case "ISingleton": {
      array8[initial] = self.backing.a;
      break;
    }
    case "ISlice": {
      let i = 0;
      let j = initial;
      while (i < self.length) {
        array8[j] = unsafeGet4(self, i);
        i += 1;
        j += 1;
      }
      break;
    }
  }
};
var toArray_ = (self) => toReadonlyArray(self).slice();
var toArray2 = toArray_;
var toReadonlyArray_ = (self) => {
  switch (self.backing._tag) {
    case "IEmpty": {
      return emptyArray;
    }
    case "IArray": {
      return self.backing.array;
    }
    default: {
      const arr = new Array(self.length);
      copyToArray(self, arr, 0);
      self.backing = {
        _tag: "IArray",
        array: arr
      };
      self.left = _empty2;
      self.right = _empty2;
      self.depth = 0;
      return arr;
    }
  }
};
var toReadonlyArray = toReadonlyArray_;
var reverseChunk = (self) => {
  switch (self.backing._tag) {
    case "IEmpty":
    case "ISingleton":
      return self;
    case "IArray": {
      return makeChunk({
        _tag: "IArray",
        array: reverse2(self.backing.array)
      });
    }
    case "IConcat": {
      return makeChunk({
        _tag: "IConcat",
        left: reverse3(self.backing.right),
        right: reverse3(self.backing.left)
      });
    }
    case "ISlice":
      return unsafeFromArray(reverse2(toReadonlyArray(self)));
  }
};
var reverse3 = reverseChunk;
var get5 = dual(2, (self, index) => index < 0 || index >= self.length ? none2() : some3(unsafeGet4(self, index)));
var unsafeFromArray = (self) => self.length === 0 ? empty7() : self.length === 1 ? of3(self[0]) : makeChunk({
  _tag: "IArray",
  array: self
});
var unsafeFromNonEmptyArray = (self) => unsafeFromArray(self);
var unsafeGet4 = dual(2, (self, index) => {
  switch (self.backing._tag) {
    case "IEmpty": {
      throw new Error(`Index out of bounds`);
    }
    case "ISingleton": {
      if (index !== 0) {
        throw new Error(`Index out of bounds`);
      }
      return self.backing.a;
    }
    case "IArray": {
      if (index >= self.length || index < 0) {
        throw new Error(`Index out of bounds`);
      }
      return self.backing.array[index];
    }
    case "IConcat": {
      return index < self.left.length ? unsafeGet4(self.left, index) : unsafeGet4(self.right, index - self.left.length);
    }
    case "ISlice": {
      return unsafeGet4(self.backing.chunk, index + self.backing.offset);
    }
  }
});
var append3 = dual(2, (self, a) => appendAll3(self, of3(a)));
var prepend3 = dual(2, (self, elem) => appendAll3(of3(elem), self));
var take3 = dual(2, (self, n) => {
  if (n <= 0) {
    return _empty2;
  } else if (n >= self.length) {
    return self;
  } else {
    switch (self.backing._tag) {
      case "ISlice": {
        return makeChunk({
          _tag: "ISlice",
          chunk: self.backing.chunk,
          length: n,
          offset: self.backing.offset
        });
      }
      case "IConcat": {
        if (n > self.left.length) {
          return makeChunk({
            _tag: "IConcat",
            left: self.left,
            right: take3(self.right, n - self.left.length)
          });
        }
        return take3(self.left, n);
      }
      default: {
        return makeChunk({
          _tag: "ISlice",
          chunk: self,
          offset: 0,
          length: n
        });
      }
    }
  }
});
var drop3 = dual(2, (self, n) => {
  if (n <= 0) {
    return self;
  } else if (n >= self.length) {
    return _empty2;
  } else {
    switch (self.backing._tag) {
      case "ISlice": {
        return makeChunk({
          _tag: "ISlice",
          chunk: self.backing.chunk,
          offset: self.backing.offset + n,
          length: self.backing.length - n
        });
      }
      case "IConcat": {
        if (n > self.left.length) {
          return drop3(self.right, n - self.left.length);
        }
        return makeChunk({
          _tag: "IConcat",
          left: drop3(self.left, n),
          right: self.right
        });
      }
      default: {
        return makeChunk({
          _tag: "ISlice",
          chunk: self,
          offset: n,
          length: self.length - n
        });
      }
    }
  }
});
var dropRight2 = dual(2, (self, n) => take3(self, Math.max(0, self.length - n)));
var dropWhile2 = dual(2, (self, predicate) => {
  const arr = toReadonlyArray(self);
  const len = arr.length;
  let i = 0;
  while (i < len && predicate(arr[i])) {
    i++;
  }
  return drop3(self, i);
});
var prependAll3 = dual(2, (self, that) => appendAll3(that, self));
var appendAll3 = dual(2, (self, that) => {
  if (self.backing._tag === "IEmpty") {
    return that;
  }
  if (that.backing._tag === "IEmpty") {
    return self;
  }
  const diff13 = that.depth - self.depth;
  if (Math.abs(diff13) <= 1) {
    return makeChunk({
      _tag: "IConcat",
      left: self,
      right: that
    });
  } else if (diff13 < -1) {
    if (self.left.depth >= self.right.depth) {
      const nr = appendAll3(self.right, that);
      return makeChunk({
        _tag: "IConcat",
        left: self.left,
        right: nr
      });
    } else {
      const nrr = appendAll3(self.right.right, that);
      if (nrr.depth === self.depth - 3) {
        const nr = makeChunk({
          _tag: "IConcat",
          left: self.right.left,
          right: nrr
        });
        return makeChunk({
          _tag: "IConcat",
          left: self.left,
          right: nr
        });
      } else {
        const nl = makeChunk({
          _tag: "IConcat",
          left: self.left,
          right: self.right.left
        });
        return makeChunk({
          _tag: "IConcat",
          left: nl,
          right: nrr
        });
      }
    }
  } else {
    if (that.right.depth >= that.left.depth) {
      const nl = appendAll3(self, that.left);
      return makeChunk({
        _tag: "IConcat",
        left: nl,
        right: that.right
      });
    } else {
      const nll = appendAll3(self, that.left.left);
      if (nll.depth === that.depth - 3) {
        const nl = makeChunk({
          _tag: "IConcat",
          left: nll,
          right: that.left.right
        });
        return makeChunk({
          _tag: "IConcat",
          left: nl,
          right: that.right
        });
      } else {
        const nr = makeChunk({
          _tag: "IConcat",
          left: that.left.right,
          right: that.right
        });
        return makeChunk({
          _tag: "IConcat",
          left: nll,
          right: nr
        });
      }
    }
  }
});
var filterMap5 = dual(2, (self, f) => unsafeFromArray(filterMap4(self, f)));
var filter5 = dual(2, (self, predicate) => unsafeFromArray(filter4(self, predicate)));
var filterMapWhile3 = dual(2, (self, f) => unsafeFromArray(filterMapWhile2(self, f)));
var compact = (self) => filterMap5(self, identity);
var flatMap5 = dual(2, (self, f) => {
  if (self.backing._tag === "ISingleton") {
    return f(self.backing.a, 0);
  }
  let out = _empty2;
  let i = 0;
  for (const k of self) {
    out = appendAll3(out, f(k, i++));
  }
  return out;
});
var forEach3 = dual(2, (self, f) => toReadonlyArray(self).forEach(f));
var flatten5 = flatMap5(identity);
var chunksOf3 = dual(2, (self, n) => {
  const gr = [];
  let current2 = [];
  toReadonlyArray(self).forEach((a) => {
    current2.push(a);
    if (current2.length >= n) {
      gr.push(unsafeFromArray(current2));
      current2 = [];
    }
  });
  if (current2.length > 0) {
    gr.push(unsafeFromArray(current2));
  }
  return unsafeFromArray(gr);
});
var intersection4 = dual(2, (self, that) => unsafeFromArray(intersection2(toReadonlyArray(self), toReadonlyArray(that))));
var isEmpty2 = (self) => self.length === 0;
var isNonEmpty2 = (self) => self.length > 0;
var head3 = get5(0);
var unsafeHead2 = (self) => unsafeGet4(self, 0);
var headNonEmpty2 = unsafeHead2;
var last2 = (self) => get5(self, self.length - 1);
var unsafeLast = (self) => unsafeGet4(self, self.length - 1);
var lastNonEmpty2 = unsafeLast;
var map7 = dual(2, (self, f) => self.backing._tag === "ISingleton" ? of3(f(self.backing.a, 0)) : unsafeFromArray(pipe(toReadonlyArray(self), map6((a, i) => f(a, i)))));
var mapAccum2 = dual(3, (self, s, f) => {
  const [s1, as18] = mapAccum(self, s, f);
  return [s1, unsafeFromArray(as18)];
});
var partition3 = dual(2, (self, predicate) => pipe(partition2(toReadonlyArray(self), predicate), ([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)]));
var partitionMap4 = dual(2, (self, f) => pipe(partitionMap3(toReadonlyArray(self), f), ([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)]));
var separate3 = (self) => pipe(separate2(toReadonlyArray(self)), ([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)]);
var size3 = (self) => self.length;
var sort2 = dual(2, (self, O) => unsafeFromArray(sort(toReadonlyArray(self), O)));
var sortWith2 = dual(3, (self, f, order) => sort2(self, mapInput3(order, f)));
var splitAt2 = dual(2, (self, n) => [take3(self, n), drop3(self, n)]);
var splitNonEmptyAt2 = dual(2, (self, n) => {
  const _n = Math.max(1, Math.floor(n));
  return _n >= self.length ? [self, empty7()] : [take3(self, _n), drop3(self, _n)];
});
var split2 = dual(2, (self, n) => chunksOf3(self, Math.ceil(self.length / Math.floor(n))));
var splitWhere2 = dual(2, (self, predicate) => {
  let i = 0;
  for (const a of toReadonlyArray(self)) {
    if (predicate(a)) {
      break;
    } else {
      i++;
    }
  }
  return splitAt2(self, i);
});
var tail2 = (self) => self.length > 0 ? some3(drop3(self, 1)) : none2();
var tailNonEmpty2 = (self) => drop3(self, 1);
var takeRight2 = dual(2, (self, n) => drop3(self, self.length - n));
var takeWhile3 = dual(2, (self, predicate) => {
  const out = [];
  for (const a of toReadonlyArray(self)) {
    if (predicate(a)) {
      out.push(a);
    } else {
      break;
    }
  }
  return unsafeFromArray(out);
});
var union3 = dual(2, (self, that) => unsafeFromArray(union2(toReadonlyArray(self), toReadonlyArray(that))));
var dedupe2 = (self) => unsafeFromArray(dedupe(toReadonlyArray(self)));
var dedupeAdjacent3 = (self) => unsafeFromArray(dedupeAdjacent2(self));
var unzip2 = (self) => {
  const [left3, right3] = unzip(self);
  return [unsafeFromArray(left3), unsafeFromArray(right3)];
};
var zipWith5 = dual(3, (self, that, f) => unsafeFromArray(zipWith4(self, that, f)));
var zip3 = dual(2, (self, that) => zipWith5(self, that, (a, b) => [a, b]));
var remove3 = dual(2, (self, i) => {
  if (i < 0 || i >= self.length) return self;
  return unsafeFromArray(remove2(toReadonlyArray(self), i));
});
var removeOption2 = dual(2, (self, i) => {
  if (i < 0 || i >= self.length) return none2();
  return some3(unsafeFromArray(remove2(toReadonlyArray(self), i)));
});
var modifyOption3 = dual(3, (self, i, f) => {
  if (i < 0 || i >= self.length) return none2();
  return some3(unsafeFromArray(modify2(toReadonlyArray(self), i, f)));
});
var modify3 = dual(3, (self, i, f) => getOrElse2(modifyOption3(self, i, f), () => self));
var replace3 = dual(3, (self, i, b) => modify3(self, i, () => b));
var replaceOption3 = dual(3, (self, i, b) => modifyOption3(self, i, () => b));
var makeBy3 = dual(2, (n, f) => fromIterable3(makeBy2(n, f)));
var range3 = (start5, end7) => start5 <= end7 ? makeBy3(end7 - start5 + 1, (i) => start5 + i) : of3(start5);
var contains4 = contains3;
var containsWith4 = containsWith3;
var findFirst4 = findFirst3;
var findFirstIndex2 = findFirstIndex;
var findLast3 = findLast2;
var findLastIndex2 = findLastIndex;
var every5 = dual(2, (self, refinement) => fromIterable2(self).every(refinement));
var some8 = dual(2, (self, predicate) => fromIterable2(self).some(predicate));
var join2 = join;
var reduce4 = reduce3;
var reduceRight2 = reduceRight;
var differenceWith2 = (isEquivalent) => {
  return dual(2, (self, that) => unsafeFromArray(differenceWith(isEquivalent)(that, self)));
};
var difference3 = dual(2, (self, that) => unsafeFromArray(difference2(that, self)));

// ../../node_modules/effect/dist/esm/Duration.js
var Duration_exports = {};
__export(Duration_exports, {
  Equivalence: () => Equivalence5,
  Order: () => Order5,
  between: () => between5,
  clamp: () => clamp6,
  days: () => days,
  decode: () => decode,
  decodeUnknown: () => decodeUnknown,
  divide: () => divide4,
  equals: () => equals4,
  format: () => format3,
  formatIso: () => formatIso,
  fromIso: () => fromIso,
  greaterThan: () => greaterThan5,
  greaterThanOrEqualTo: () => greaterThanOrEqualTo5,
  hours: () => hours,
  infinity: () => infinity,
  isDuration: () => isDuration,
  isFinite: () => isFinite,
  isZero: () => isZero2,
  lessThan: () => lessThan5,
  lessThanOrEqualTo: () => lessThanOrEqualTo5,
  match: () => match5,
  matchWith: () => matchWith,
  max: () => max6,
  micros: () => micros,
  millis: () => millis,
  min: () => min6,
  minutes: () => minutes,
  nanos: () => nanos,
  parts: () => parts,
  seconds: () => seconds,
  subtract: () => subtract4,
  sum: () => sum4,
  times: () => times,
  toDays: () => toDays,
  toHours: () => toHours,
  toHrTime: () => toHrTime,
  toMillis: () => toMillis,
  toMinutes: () => toMinutes,
  toNanos: () => toNanos,
  toSeconds: () => toSeconds,
  toWeeks: () => toWeeks,
  unsafeDivide: () => unsafeDivide4,
  unsafeFormatIso: () => unsafeFormatIso,
  unsafeToNanos: () => unsafeToNanos,
  weeks: () => weeks,
  zero: () => zero2
});
var TypeId8 = Symbol.for("effect/Duration");
var bigint03 = BigInt(0);
var bigint24 = BigInt(24);
var bigint60 = BigInt(60);
var bigint1e3 = BigInt(1e3);
var bigint1e6 = BigInt(1e6);
var bigint1e9 = BigInt(1e9);
var DURATION_REGEX = /^(-?\d+(?:\.\d+)?)\s+(nanos?|micros?|millis?|seconds?|minutes?|hours?|days?|weeks?)$/;
var decode = (input) => {
  if (isDuration(input)) {
    return input;
  } else if (isNumber(input)) {
    return millis(input);
  } else if (isBigInt(input)) {
    return nanos(input);
  } else if (Array.isArray(input) && input.length === 2 && input.every(isNumber)) {
    if (input[0] === -Infinity || input[1] === -Infinity || Number.isNaN(input[0]) || Number.isNaN(input[1])) {
      return zero2;
    }
    if (input[0] === Infinity || input[1] === Infinity) {
      return infinity;
    }
    return nanos(BigInt(Math.round(input[0] * 1e9)) + BigInt(Math.round(input[1])));
  } else if (isString(input)) {
    const match43 = DURATION_REGEX.exec(input);
    if (match43) {
      const [_, valueStr, unit] = match43;
      const value10 = Number(valueStr);
      switch (unit) {
        case "nano":
        case "nanos":
          return nanos(BigInt(valueStr));
        case "micro":
        case "micros":
          return micros(BigInt(valueStr));
        case "milli":
        case "millis":
          return millis(value10);
        case "second":
        case "seconds":
          return seconds(value10);
        case "minute":
        case "minutes":
          return minutes(value10);
        case "hour":
        case "hours":
          return hours(value10);
        case "day":
        case "days":
          return days(value10);
        case "week":
        case "weeks":
          return weeks(value10);
      }
    }
  }
  throw new Error("Invalid DurationInput");
};
var decodeUnknown = liftThrowable(decode);
var zeroValue = {
  _tag: "Millis",
  millis: 0
};
var infinityValue = {
  _tag: "Infinity"
};
var DurationProto = {
  [TypeId8]: TypeId8,
  [symbol2]() {
    return cached(this, structure(this.value));
  },
  [symbol3](that) {
    return isDuration(that) && equals4(this, that);
  },
  toString() {
    return `Duration(${format3(this)})`;
  },
  toJSON() {
    switch (this.value._tag) {
      case "Millis":
        return {
          _id: "Duration",
          _tag: "Millis",
          millis: this.value.millis
        };
      case "Nanos":
        return {
          _id: "Duration",
          _tag: "Nanos",
          hrtime: toHrTime(this)
        };
      case "Infinity":
        return {
          _id: "Duration",
          _tag: "Infinity"
        };
    }
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make10 = (input) => {
  const duration5 = Object.create(DurationProto);
  if (isNumber(input)) {
    if (isNaN(input) || input <= 0) {
      duration5.value = zeroValue;
    } else if (!Number.isFinite(input)) {
      duration5.value = infinityValue;
    } else if (!Number.isInteger(input)) {
      duration5.value = {
        _tag: "Nanos",
        nanos: BigInt(Math.round(input * 1e6))
      };
    } else {
      duration5.value = {
        _tag: "Millis",
        millis: input
      };
    }
  } else if (input <= bigint03) {
    duration5.value = zeroValue;
  } else {
    duration5.value = {
      _tag: "Nanos",
      nanos: input
    };
  }
  return duration5;
};
var isDuration = (u) => hasProperty(u, TypeId8);
var isFinite = (self) => self.value._tag !== "Infinity";
var isZero2 = (self) => {
  switch (self.value._tag) {
    case "Millis": {
      return self.value.millis === 0;
    }
    case "Nanos": {
      return self.value.nanos === bigint03;
    }
    case "Infinity": {
      return false;
    }
  }
};
var zero2 = make10(0);
var infinity = make10(Infinity);
var nanos = (nanos2) => make10(nanos2);
var micros = (micros2) => make10(micros2 * bigint1e3);
var millis = (millis2) => make10(millis2);
var seconds = (seconds2) => make10(seconds2 * 1e3);
var minutes = (minutes2) => make10(minutes2 * 6e4);
var hours = (hours2) => make10(hours2 * 36e5);
var days = (days2) => make10(days2 * 864e5);
var weeks = (weeks2) => make10(weeks2 * 6048e5);
var toMillis = (self) => match5(self, {
  onMillis: (millis2) => millis2,
  onNanos: (nanos2) => Number(nanos2) / 1e6
});
var toSeconds = (self) => match5(self, {
  onMillis: (millis2) => millis2 / 1e3,
  onNanos: (nanos2) => Number(nanos2) / 1e9
});
var toMinutes = (self) => match5(self, {
  onMillis: (millis2) => millis2 / 6e4,
  onNanos: (nanos2) => Number(nanos2) / 6e10
});
var toHours = (self) => match5(self, {
  onMillis: (millis2) => millis2 / 36e5,
  onNanos: (nanos2) => Number(nanos2) / 36e11
});
var toDays = (self) => match5(self, {
  onMillis: (millis2) => millis2 / 864e5,
  onNanos: (nanos2) => Number(nanos2) / 864e11
});
var toWeeks = (self) => match5(self, {
  onMillis: (millis2) => millis2 / 6048e5,
  onNanos: (nanos2) => Number(nanos2) / 6048e11
});
var toNanos = (self) => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Infinity":
      return none2();
    case "Nanos":
      return some3(_self.value.nanos);
    case "Millis":
      return some3(BigInt(Math.round(_self.value.millis * 1e6)));
  }
};
var unsafeToNanos = (self) => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Infinity":
      throw new Error("Cannot convert infinite duration to nanos");
    case "Nanos":
      return _self.value.nanos;
    case "Millis":
      return BigInt(Math.round(_self.value.millis * 1e6));
  }
};
var toHrTime = (self) => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Infinity":
      return [Infinity, 0];
    case "Nanos":
      return [Number(_self.value.nanos / bigint1e9), Number(_self.value.nanos % bigint1e9)];
    case "Millis":
      return [Math.floor(_self.value.millis / 1e3), Math.round(_self.value.millis % 1e3 * 1e6)];
  }
};
var match5 = dual(2, (self, options) => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Nanos":
      return options.onNanos(_self.value.nanos);
    case "Infinity":
      return options.onMillis(Infinity);
    case "Millis":
      return options.onMillis(_self.value.millis);
  }
});
var matchWith = dual(3, (self, that, options) => {
  const _self = decode(self);
  const _that = decode(that);
  if (_self.value._tag === "Infinity" || _that.value._tag === "Infinity") {
    return options.onMillis(toMillis(_self), toMillis(_that));
  } else if (_self.value._tag === "Nanos" || _that.value._tag === "Nanos") {
    const selfNanos = _self.value._tag === "Nanos" ? _self.value.nanos : BigInt(Math.round(_self.value.millis * 1e6));
    const thatNanos = _that.value._tag === "Nanos" ? _that.value.nanos : BigInt(Math.round(_that.value.millis * 1e6));
    return options.onNanos(selfNanos, thatNanos);
  }
  return options.onMillis(_self.value.millis, _that.value.millis);
});
var Order5 = make2((self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => self2 < that2 ? -1 : self2 > that2 ? 1 : 0,
  onNanos: (self2, that2) => self2 < that2 ? -1 : self2 > that2 ? 1 : 0
}));
var between5 = between(mapInput3(Order5, decode));
var Equivalence5 = (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => self2 === that2,
  onNanos: (self2, that2) => self2 === that2
});
var _min = min(Order5);
var min6 = dual(2, (self, that) => _min(decode(self), decode(that)));
var _max = max(Order5);
var max6 = dual(2, (self, that) => _max(decode(self), decode(that)));
var _clamp = clamp(Order5);
var clamp6 = dual(2, (self, options) => _clamp(decode(self), {
  minimum: decode(options.minimum),
  maximum: decode(options.maximum)
}));
var divide4 = dual(2, (self, by) => match5(self, {
  onMillis: (millis2) => {
    if (by === 0 || isNaN(by) || !Number.isFinite(by)) {
      return none2();
    }
    return some3(make10(millis2 / by));
  },
  onNanos: (nanos2) => {
    if (isNaN(by) || by <= 0 || !Number.isFinite(by)) {
      return none2();
    }
    try {
      return some3(make10(nanos2 / BigInt(by)));
    } catch {
      return none2();
    }
  }
}));
var unsafeDivide4 = dual(2, (self, by) => match5(self, {
  onMillis: (millis2) => make10(millis2 / by),
  onNanos: (nanos2) => {
    if (isNaN(by) || by < 0 || Object.is(by, -0)) {
      return zero2;
    } else if (Object.is(by, 0) || !Number.isFinite(by)) {
      return infinity;
    }
    return make10(nanos2 / BigInt(by));
  }
}));
var times = dual(2, (self, times2) => match5(self, {
  onMillis: (millis2) => make10(millis2 * times2),
  onNanos: (nanos2) => make10(nanos2 * BigInt(times2))
}));
var subtract4 = dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => make10(self2 - that2),
  onNanos: (self2, that2) => make10(self2 - that2)
}));
var sum4 = dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => make10(self2 + that2),
  onNanos: (self2, that2) => make10(self2 + that2)
}));
var lessThan5 = dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => self2 < that2,
  onNanos: (self2, that2) => self2 < that2
}));
var lessThanOrEqualTo5 = dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => self2 <= that2,
  onNanos: (self2, that2) => self2 <= that2
}));
var greaterThan5 = dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => self2 > that2,
  onNanos: (self2, that2) => self2 > that2
}));
var greaterThanOrEqualTo5 = dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => self2 >= that2,
  onNanos: (self2, that2) => self2 >= that2
}));
var equals4 = dual(2, (self, that) => Equivalence5(decode(self), decode(that)));
var parts = (self) => {
  const duration5 = decode(self);
  if (duration5.value._tag === "Infinity") {
    return {
      days: Infinity,
      hours: Infinity,
      minutes: Infinity,
      seconds: Infinity,
      millis: Infinity,
      nanos: Infinity
    };
  }
  const nanos2 = unsafeToNanos(duration5);
  const ms = nanos2 / bigint1e6;
  const sec = ms / bigint1e3;
  const min11 = sec / bigint60;
  const hr = min11 / bigint60;
  const days2 = hr / bigint24;
  return {
    days: Number(days2),
    hours: Number(hr % bigint24),
    minutes: Number(min11 % bigint60),
    seconds: Number(sec % bigint60),
    millis: Number(ms % bigint1e3),
    nanos: Number(nanos2 % bigint1e6)
  };
};
var format3 = (self) => {
  const duration5 = decode(self);
  if (duration5.value._tag === "Infinity") {
    return "Infinity";
  }
  if (isZero2(duration5)) {
    return "0";
  }
  const fragments = parts(duration5);
  const pieces = [];
  if (fragments.days !== 0) {
    pieces.push(`${fragments.days}d`);
  }
  if (fragments.hours !== 0) {
    pieces.push(`${fragments.hours}h`);
  }
  if (fragments.minutes !== 0) {
    pieces.push(`${fragments.minutes}m`);
  }
  if (fragments.seconds !== 0) {
    pieces.push(`${fragments.seconds}s`);
  }
  if (fragments.millis !== 0) {
    pieces.push(`${fragments.millis}ms`);
  }
  if (fragments.nanos !== 0) {
    pieces.push(`${fragments.nanos}ns`);
  }
  return pieces.join(" ");
};
var unsafeFormatIso = (self) => {
  const duration5 = decode(self);
  if (!isFinite(duration5)) {
    throw new RangeError("Cannot format infinite duration");
  }
  const fragments = [];
  const {
    days: days2,
    hours: hours2,
    millis: millis2,
    minutes: minutes2,
    nanos: nanos2,
    seconds: seconds2
  } = parts(duration5);
  let rest = days2;
  if (rest >= 365) {
    const years = Math.floor(rest / 365);
    rest %= 365;
    fragments.push(`${years}Y`);
  }
  if (rest >= 30) {
    const months = Math.floor(rest / 30);
    rest %= 30;
    fragments.push(`${months}M`);
  }
  if (rest >= 7) {
    const weeks2 = Math.floor(rest / 7);
    rest %= 7;
    fragments.push(`${weeks2}W`);
  }
  if (rest > 0) {
    fragments.push(`${rest}D`);
  }
  if (hours2 !== 0 || minutes2 !== 0 || seconds2 !== 0 || millis2 !== 0 || nanos2 !== 0) {
    fragments.push("T");
    if (hours2 !== 0) {
      fragments.push(`${hours2}H`);
    }
    if (minutes2 !== 0) {
      fragments.push(`${minutes2}M`);
    }
    if (seconds2 !== 0 || millis2 !== 0 || nanos2 !== 0) {
      const total = BigInt(seconds2) * bigint1e9 + BigInt(millis2) * bigint1e6 + BigInt(nanos2);
      const str = (Number(total) / 1e9).toFixed(9).replace(/\.?0+$/, "");
      fragments.push(`${str}S`);
    }
  }
  return `P${fragments.join("") || "T0S"}`;
};
var formatIso = (self) => {
  const duration5 = decode(self);
  return isFinite(duration5) ? some3(unsafeFormatIso(duration5)) : none2();
};
var fromIso = (iso) => {
  const result = DURATION_ISO_REGEX.exec(iso);
  if (result == null) {
    return none2();
  }
  const [years, months, weeks2, days2, hours2, mins, secs] = result.slice(1, 8).map((_) => _ ? Number(_) : 0);
  const value10 = years * 365 * 24 * 60 * 60 + months * 30 * 24 * 60 * 60 + weeks2 * 7 * 24 * 60 * 60 + days2 * 24 * 60 * 60 + hours2 * 60 * 60 + mins * 60 + secs;
  return some3(seconds(value10));
};
var DURATION_ISO_REGEX = /^P(?!$)(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)W)?(?:(\d+)D)?(?:T(?!$)(?:(\d+)H)?(?:(\d+)M)?(?:(\d+(?:\.\d+)?)S)?)?$/;

// ../../node_modules/effect/dist/esm/FiberId.js
var FiberId_exports = {};
__export(FiberId_exports, {
  FiberIdTypeId: () => FiberIdTypeId2,
  combine: () => combine5,
  combineAll: () => combineAll4,
  composite: () => composite2,
  getOrElse: () => getOrElse6,
  ids: () => ids2,
  isComposite: () => isComposite2,
  isFiberId: () => isFiberId2,
  isNone: () => isNone4,
  isRuntime: () => isRuntime2,
  make: () => make17,
  none: () => none4,
  runtime: () => runtime2,
  threadName: () => threadName2,
  toOption: () => toOption2,
  toSet: () => toSet2,
  unsafeMake: () => unsafeMake3
});

// ../../node_modules/effect/dist/esm/HashSet.js
var HashSet_exports = {};
__export(HashSet_exports, {
  add: () => add4,
  beginMutation: () => beginMutation3,
  difference: () => difference5,
  empty: () => empty10,
  endMutation: () => endMutation3,
  every: () => every8,
  filter: () => filter8,
  flatMap: () => flatMap8,
  forEach: () => forEach6,
  fromIterable: () => fromIterable6,
  has: () => has4,
  intersection: () => intersection6,
  isHashSet: () => isHashSet2,
  isSubset: () => isSubset2,
  make: () => make14,
  map: () => map10,
  mutate: () => mutate3,
  partition: () => partition5,
  reduce: () => reduce7,
  remove: () => remove6,
  size: () => size6,
  some: () => some11,
  toValues: () => toValues,
  toggle: () => toggle2,
  union: () => union6,
  values: () => values4
});

// ../../node_modules/effect/dist/esm/internal/hashMap/config.js
var SIZE = 5;
var BUCKET_SIZE = Math.pow(2, SIZE);
var MASK2 = BUCKET_SIZE - 1;
var MAX_INDEX_NODE = BUCKET_SIZE / 2;
var MIN_ARRAY_NODE = BUCKET_SIZE / 4;

// ../../node_modules/effect/dist/esm/internal/hashMap/bitwise.js
function popcount(x) {
  x -= x >> 1 & 1431655765;
  x = (x & 858993459) + (x >> 2 & 858993459);
  x = x + (x >> 4) & 252645135;
  x += x >> 8;
  x += x >> 16;
  return x & 127;
}
function hashFragment(shift2, h2) {
  return h2 >>> shift2 & MASK2;
}
function toBitmap(x) {
  return 1 << x;
}
function fromBitmap(bitmap, bit) {
  return popcount(bitmap & bit - 1);
}

// ../../node_modules/effect/dist/esm/internal/stack.js
var make11 = (value10, previous2) => ({
  value: value10,
  previous: previous2
});

// ../../node_modules/effect/dist/esm/internal/hashMap/array.js
function arrayUpdate(mutate7, at5, v, arr) {
  let out = arr;
  if (!mutate7) {
    const len = arr.length;
    out = new Array(len);
    for (let i = 0; i < len; ++i) out[i] = arr[i];
  }
  out[at5] = v;
  return out;
}
function arraySpliceOut(mutate7, at5, arr) {
  const newLen = arr.length - 1;
  let i = 0;
  let g = 0;
  let out = arr;
  if (mutate7) {
    i = g = at5;
  } else {
    out = new Array(newLen);
    while (i < at5) out[g++] = arr[i++];
  }
  ++i;
  while (i <= newLen) out[g++] = arr[i++];
  if (mutate7) {
    out.length = newLen;
  }
  return out;
}
function arraySpliceIn(mutate7, at5, v, arr) {
  const len = arr.length;
  if (mutate7) {
    let i2 = len;
    while (i2 >= at5) arr[i2--] = arr[i2];
    arr[at5] = v;
    return arr;
  }
  let i = 0, g = 0;
  const out = new Array(len + 1);
  while (i < at5) out[g++] = arr[i++];
  out[at5] = v;
  while (i < len) out[++g] = arr[i++];
  return out;
}

// ../../node_modules/effect/dist/esm/internal/hashMap/node.js
var EmptyNode = class _EmptyNode {
  _tag = "EmptyNode";
  modify(edit, _shift, f, hash4, key, size40) {
    const v = f(none2());
    if (isNone2(v)) return new _EmptyNode();
    ++size40.value;
    return new LeafNode(edit, hash4, key, v);
  }
};
function isEmptyNode(a) {
  return isTagged(a, "EmptyNode");
}
function isLeafNode(node) {
  return isEmptyNode(node) || node._tag === "LeafNode" || node._tag === "CollisionNode";
}
function canEditNode(node, edit) {
  return isEmptyNode(node) ? false : edit === node.edit;
}
var LeafNode = class _LeafNode {
  edit;
  hash;
  key;
  value;
  _tag = "LeafNode";
  constructor(edit, hash4, key, value10) {
    this.edit = edit;
    this.hash = hash4;
    this.key = key;
    this.value = value10;
  }
  modify(edit, shift2, f, hash4, key, size40) {
    if (equals(key, this.key)) {
      const v2 = f(this.value);
      if (v2 === this.value) return this;
      else if (isNone2(v2)) {
        --size40.value;
        return new EmptyNode();
      }
      if (canEditNode(this, edit)) {
        this.value = v2;
        return this;
      }
      return new _LeafNode(edit, hash4, key, v2);
    }
    const v = f(none2());
    if (isNone2(v)) return this;
    ++size40.value;
    return mergeLeaves(edit, shift2, this.hash, this, hash4, new _LeafNode(edit, hash4, key, v));
  }
};
var CollisionNode = class _CollisionNode {
  edit;
  hash;
  children;
  _tag = "CollisionNode";
  constructor(edit, hash4, children3) {
    this.edit = edit;
    this.hash = hash4;
    this.children = children3;
  }
  modify(edit, shift2, f, hash4, key, size40) {
    if (hash4 === this.hash) {
      const canEdit = canEditNode(this, edit);
      const list = this.updateCollisionList(canEdit, edit, this.hash, this.children, f, key, size40);
      if (list === this.children) return this;
      return list.length > 1 ? new _CollisionNode(edit, this.hash, list) : list[0];
    }
    const v = f(none2());
    if (isNone2(v)) return this;
    ++size40.value;
    return mergeLeaves(edit, shift2, this.hash, this, hash4, new LeafNode(edit, hash4, key, v));
  }
  updateCollisionList(mutate7, edit, hash4, list, f, key, size40) {
    const len = list.length;
    for (let i = 0; i < len; ++i) {
      const child = list[i];
      if ("key" in child && equals(key, child.key)) {
        const value10 = child.value;
        const newValue2 = f(value10);
        if (newValue2 === value10) return list;
        if (isNone2(newValue2)) {
          --size40.value;
          return arraySpliceOut(mutate7, i, list);
        }
        return arrayUpdate(mutate7, i, new LeafNode(edit, hash4, key, newValue2), list);
      }
    }
    const newValue = f(none2());
    if (isNone2(newValue)) return list;
    ++size40.value;
    return arrayUpdate(mutate7, len, new LeafNode(edit, hash4, key, newValue), list);
  }
};
var IndexedNode = class _IndexedNode {
  edit;
  mask;
  children;
  _tag = "IndexedNode";
  constructor(edit, mask, children3) {
    this.edit = edit;
    this.mask = mask;
    this.children = children3;
  }
  modify(edit, shift2, f, hash4, key, size40) {
    const mask = this.mask;
    const children3 = this.children;
    const frag = hashFragment(shift2, hash4);
    const bit = toBitmap(frag);
    const indx = fromBitmap(mask, bit);
    const exists7 = mask & bit;
    const canEdit = canEditNode(this, edit);
    if (!exists7) {
      const _newChild = new EmptyNode().modify(edit, shift2 + SIZE, f, hash4, key, size40);
      if (!_newChild) return this;
      return children3.length >= MAX_INDEX_NODE ? expand(edit, frag, _newChild, mask, children3) : new _IndexedNode(edit, mask | bit, arraySpliceIn(canEdit, indx, _newChild, children3));
    }
    const current2 = children3[indx];
    const child = current2.modify(edit, shift2 + SIZE, f, hash4, key, size40);
    if (current2 === child) return this;
    let bitmap = mask;
    let newChildren;
    if (isEmptyNode(child)) {
      bitmap &= ~bit;
      if (!bitmap) return new EmptyNode();
      if (children3.length <= 2 && isLeafNode(children3[indx ^ 1])) {
        return children3[indx ^ 1];
      }
      newChildren = arraySpliceOut(canEdit, indx, children3);
    } else {
      newChildren = arrayUpdate(canEdit, indx, child, children3);
    }
    if (canEdit) {
      this.mask = bitmap;
      this.children = newChildren;
      return this;
    }
    return new _IndexedNode(edit, bitmap, newChildren);
  }
};
var ArrayNode = class _ArrayNode {
  edit;
  size;
  children;
  _tag = "ArrayNode";
  constructor(edit, size40, children3) {
    this.edit = edit;
    this.size = size40;
    this.children = children3;
  }
  modify(edit, shift2, f, hash4, key, size40) {
    let count9 = this.size;
    const children3 = this.children;
    const frag = hashFragment(shift2, hash4);
    const child = children3[frag];
    const newChild = (child || new EmptyNode()).modify(edit, shift2 + SIZE, f, hash4, key, size40);
    if (child === newChild) return this;
    const canEdit = canEditNode(this, edit);
    let newChildren;
    if (isEmptyNode(child) && !isEmptyNode(newChild)) {
      ++count9;
      newChildren = arrayUpdate(canEdit, frag, newChild, children3);
    } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {
      --count9;
      if (count9 <= MIN_ARRAY_NODE) {
        return pack(edit, count9, frag, children3);
      }
      newChildren = arrayUpdate(canEdit, frag, new EmptyNode(), children3);
    } else {
      newChildren = arrayUpdate(canEdit, frag, newChild, children3);
    }
    if (canEdit) {
      this.size = count9;
      this.children = newChildren;
      return this;
    }
    return new _ArrayNode(edit, count9, newChildren);
  }
};
function pack(edit, count9, removed, elements) {
  const children3 = new Array(count9 - 1);
  let g = 0;
  let bitmap = 0;
  for (let i = 0, len = elements.length; i < len; ++i) {
    if (i !== removed) {
      const elem = elements[i];
      if (elem && !isEmptyNode(elem)) {
        children3[g++] = elem;
        bitmap |= 1 << i;
      }
    }
  }
  return new IndexedNode(edit, bitmap, children3);
}
function expand(edit, frag, child, bitmap, subNodes) {
  const arr = [];
  let bit = bitmap;
  let count9 = 0;
  for (let i = 0; bit; ++i) {
    if (bit & 1) arr[i] = subNodes[count9++];
    bit >>>= 1;
  }
  arr[frag] = child;
  return new ArrayNode(edit, count9 + 1, arr);
}
function mergeLeavesInner(edit, shift2, h1, n1, h2, n2) {
  if (h1 === h2) return new CollisionNode(edit, h1, [n2, n1]);
  const subH1 = hashFragment(shift2, h1);
  const subH2 = hashFragment(shift2, h2);
  if (subH1 === subH2) {
    return (child) => new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), [child]);
  } else {
    const children3 = subH1 < subH2 ? [n1, n2] : [n2, n1];
    return new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), children3);
  }
}
function mergeLeaves(edit, shift2, h1, n1, h2, n2) {
  let stack = void 0;
  let currentShift = shift2;
  while (true) {
    const res = mergeLeavesInner(edit, currentShift, h1, n1, h2, n2);
    if (typeof res === "function") {
      stack = make11(res, stack);
      currentShift = currentShift + SIZE;
    } else {
      let final = res;
      while (stack != null) {
        final = stack.value(final);
        stack = stack.previous;
      }
      return final;
    }
  }
}

// ../../node_modules/effect/dist/esm/internal/hashMap.js
var HashMapSymbolKey = "effect/HashMap";
var HashMapTypeId = Symbol.for(HashMapSymbolKey);
var HashMapProto = {
  [HashMapTypeId]: HashMapTypeId,
  [Symbol.iterator]() {
    return new HashMapIterator(this, (k, v) => [k, v]);
  },
  [symbol2]() {
    let hash4 = hash(HashMapSymbolKey);
    for (const item of this) {
      hash4 ^= pipe(hash(item[0]), combine2(hash(item[1])));
    }
    return cached(this, hash4);
  },
  [symbol3](that) {
    if (isHashMap(that)) {
      if (that._size !== this._size) {
        return false;
      }
      for (const item of this) {
        const elem = pipe(that, getHash(item[0], hash(item[0])));
        if (isNone2(elem)) {
          return false;
        } else {
          if (!equals(item[1], elem.value)) {
            return false;
          }
        }
      }
      return true;
    }
    return false;
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "HashMap",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl = (editable, edit, root, size40) => {
  const map49 = Object.create(HashMapProto);
  map49._editable = editable;
  map49._edit = edit;
  map49._root = root;
  map49._size = size40;
  return map49;
};
var HashMapIterator = class _HashMapIterator {
  map;
  f;
  v;
  constructor(map49, f) {
    this.map = map49;
    this.f = f;
    this.v = visitLazy(this.map._root, this.f, void 0);
  }
  next() {
    if (isNone2(this.v)) {
      return {
        done: true,
        value: void 0
      };
    }
    const v0 = this.v.value;
    this.v = applyCont(v0.cont);
    return {
      done: false,
      value: v0.value
    };
  }
  [Symbol.iterator]() {
    return new _HashMapIterator(this.map, this.f);
  }
};
var applyCont = (cont) => cont ? visitLazyChildren(cont[0], cont[1], cont[2], cont[3], cont[4]) : none2();
var visitLazy = (node, f, cont = void 0) => {
  switch (node._tag) {
    case "LeafNode": {
      if (isSome2(node.value)) {
        return some3({
          value: f(node.key, node.value.value),
          cont
        });
      }
      return applyCont(cont);
    }
    case "CollisionNode":
    case "ArrayNode":
    case "IndexedNode": {
      const children3 = node.children;
      return visitLazyChildren(children3.length, children3, 0, f, cont);
    }
    default: {
      return applyCont(cont);
    }
  }
};
var visitLazyChildren = (len, children3, i, f, cont) => {
  while (i < len) {
    const child = children3[i++];
    if (child && !isEmptyNode(child)) {
      return visitLazy(child, f, [len, children3, i, f, cont]);
    }
  }
  return applyCont(cont);
};
var _empty3 = makeImpl(false, 0, new EmptyNode(), 0);
var empty8 = () => _empty3;
var make12 = (...entries7) => fromIterable4(entries7);
var fromIterable4 = (entries7) => {
  const map49 = beginMutation(empty8());
  for (const entry of entries7) {
    set2(map49, entry[0], entry[1]);
  }
  return endMutation(map49);
};
var isHashMap = (u) => hasProperty(u, HashMapTypeId);
var isEmpty3 = (self) => self && isEmptyNode(self._root);
var get6 = dual(2, (self, key) => getHash(self, key, hash(key)));
var getHash = dual(3, (self, key, hash4) => {
  let node = self._root;
  let shift2 = 0;
  while (true) {
    switch (node._tag) {
      case "LeafNode": {
        return equals(key, node.key) ? node.value : none2();
      }
      case "CollisionNode": {
        if (hash4 === node.hash) {
          const children3 = node.children;
          for (let i = 0, len = children3.length; i < len; ++i) {
            const child = children3[i];
            if ("key" in child && equals(key, child.key)) {
              return child.value;
            }
          }
        }
        return none2();
      }
      case "IndexedNode": {
        const frag = hashFragment(shift2, hash4);
        const bit = toBitmap(frag);
        if (node.mask & bit) {
          node = node.children[fromBitmap(node.mask, bit)];
          shift2 += SIZE;
          break;
        }
        return none2();
      }
      case "ArrayNode": {
        node = node.children[hashFragment(shift2, hash4)];
        if (node) {
          shift2 += SIZE;
          break;
        }
        return none2();
      }
      default:
        return none2();
    }
  }
});
var unsafeGet5 = dual(2, (self, key) => {
  const element2 = getHash(self, key, hash(key));
  if (isNone2(element2)) {
    throw new Error("Expected map to contain key");
  }
  return element2.value;
});
var has2 = dual(2, (self, key) => isSome2(getHash(self, key, hash(key))));
var hasHash = dual(3, (self, key, hash4) => isSome2(getHash(self, key, hash4)));
var hasBy = dual(2, (self, predicate) => isSome2(findFirst5(self, predicate)));
var set2 = dual(3, (self, key, value10) => modifyAt(self, key, () => some3(value10)));
var setTree = dual(3, (self, newRoot, newSize) => {
  if (self._editable) {
    ;
    self._root = newRoot;
    self._size = newSize;
    return self;
  }
  return newRoot === self._root ? self : makeImpl(self._editable, self._edit, newRoot, newSize);
});
var keys2 = (self) => new HashMapIterator(self, (key) => key);
var values2 = (self) => new HashMapIterator(self, (_, value10) => value10);
var entries = (self) => new HashMapIterator(self, (key, value10) => [key, value10]);
var size4 = (self) => self._size;
var countBy3 = dual(2, (self, f) => {
  let count9 = 0;
  for (const [k, a] of self) {
    if (f(a, k)) {
      count9++;
    }
  }
  return count9;
});
var beginMutation = (self) => makeImpl(true, self._edit + 1, self._root, self._size);
var endMutation = (self) => {
  ;
  self._editable = false;
  return self;
};
var mutate = dual(2, (self, f) => {
  const transient = beginMutation(self);
  f(transient);
  return endMutation(transient);
});
var modifyAt = dual(3, (self, key, f) => modifyHash(self, key, hash(key), f));
var modifyHash = dual(4, (self, key, hash4, f) => {
  const size40 = {
    value: self._size
  };
  const newRoot = self._root.modify(self._editable ? self._edit : NaN, 0, f, hash4, key, size40);
  return pipe(self, setTree(newRoot, size40.value));
});
var modify4 = dual(3, (self, key, f) => modifyAt(self, key, map2(f)));
var union4 = dual(2, (self, that) => {
  const result = beginMutation(self);
  forEach4(that, (v, k) => set2(result, k, v));
  return endMutation(result);
});
var remove4 = dual(2, (self, key) => modifyAt(self, key, none2));
var removeMany = dual(2, (self, keys15) => mutate(self, (map49) => {
  for (const key of keys15) {
    remove4(key)(map49);
  }
}));
var map8 = dual(2, (self, f) => reduce5(self, empty8(), (map49, value10, key) => set2(map49, key, f(value10, key))));
var flatMap6 = dual(2, (self, f) => reduce5(self, empty8(), (zero3, value10, key) => mutate(zero3, (map49) => forEach4(f(value10, key), (value11, key2) => set2(map49, key2, value11)))));
var forEach4 = dual(2, (self, f) => reduce5(self, void 0, (_, value10, key) => f(value10, key)));
var reduce5 = dual(3, (self, zero3, f) => {
  const root = self._root;
  if (root._tag === "LeafNode") {
    return isSome2(root.value) ? f(zero3, root.value.value, root.key) : zero3;
  }
  if (root._tag === "EmptyNode") {
    return zero3;
  }
  const toVisit = [root.children];
  let children3;
  while (children3 = toVisit.pop()) {
    for (let i = 0, len = children3.length; i < len; ) {
      const child = children3[i++];
      if (child && !isEmptyNode(child)) {
        if (child._tag === "LeafNode") {
          if (isSome2(child.value)) {
            zero3 = f(zero3, child.value.value, child.key);
          }
        } else {
          toVisit.push(child.children);
        }
      }
    }
  }
  return zero3;
});
var filter6 = dual(2, (self, f) => mutate(empty8(), (map49) => {
  for (const [k, a] of self) {
    if (f(a, k)) {
      set2(map49, k, a);
    }
  }
}));
var compact2 = (self) => filterMap6(self, identity);
var filterMap6 = dual(2, (self, f) => mutate(empty8(), (map49) => {
  for (const [k, a] of self) {
    const option11 = f(a, k);
    if (isSome2(option11)) {
      set2(map49, k, option11.value);
    }
  }
}));
var findFirst5 = dual(2, (self, predicate) => {
  for (const ka of self) {
    if (predicate(ka[1], ka[0])) {
      return some3(ka);
    }
  }
  return none2();
});
var some9 = dual(2, (self, predicate) => {
  for (const ka of self) {
    if (predicate(ka[1], ka[0])) {
      return true;
    }
  }
  return false;
});
var every6 = dual(2, (self, predicate) => !some9(self, (a, k) => !predicate(a, k)));

// ../../node_modules/effect/dist/esm/internal/hashSet.js
var HashSetSymbolKey = "effect/HashSet";
var HashSetTypeId = Symbol.for(HashSetSymbolKey);
var HashSetProto = {
  [HashSetTypeId]: HashSetTypeId,
  [Symbol.iterator]() {
    return keys2(this._keyMap);
  },
  [symbol2]() {
    return cached(this, combine2(hash(this._keyMap))(hash(HashSetSymbolKey)));
  },
  [symbol3](that) {
    if (isHashSet(that)) {
      return size4(this._keyMap) === size4(that._keyMap) && equals(this._keyMap, that._keyMap);
    }
    return false;
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "HashSet",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl2 = (keyMap) => {
  const set26 = Object.create(HashSetProto);
  set26._keyMap = keyMap;
  return set26;
};
var isHashSet = (u) => hasProperty(u, HashSetTypeId);
var _empty4 = makeImpl2(empty8());
var empty9 = () => _empty4;
var fromIterable5 = (elements) => {
  const set26 = beginMutation2(empty9());
  for (const value10 of elements) {
    add3(set26, value10);
  }
  return endMutation2(set26);
};
var make13 = (...elements) => {
  const set26 = beginMutation2(empty9());
  for (const value10 of elements) {
    add3(set26, value10);
  }
  return endMutation2(set26);
};
var has3 = dual(2, (self, value10) => has2(self._keyMap, value10));
var some10 = dual(2, (self, f) => {
  let found = false;
  for (const value10 of self) {
    found = f(value10);
    if (found) {
      break;
    }
  }
  return found;
});
var every7 = dual(2, (self, refinement) => !some10(self, (a) => !refinement(a)));
var isSubset = dual(2, (self, that) => every7(self, (value10) => has3(that, value10)));
var values3 = (self) => keys2(self._keyMap);
var size5 = (self) => size4(self._keyMap);
var beginMutation2 = (self) => makeImpl2(beginMutation(self._keyMap));
var endMutation2 = (self) => {
  ;
  self._keyMap._editable = false;
  return self;
};
var mutate2 = dual(2, (self, f) => {
  const transient = beginMutation2(self);
  f(transient);
  return endMutation2(transient);
});
var add3 = dual(2, (self, value10) => self._keyMap._editable ? (set2(value10, true)(self._keyMap), self) : makeImpl2(set2(value10, true)(self._keyMap)));
var remove5 = dual(2, (self, value10) => self._keyMap._editable ? (remove4(value10)(self._keyMap), self) : makeImpl2(remove4(value10)(self._keyMap)));
var difference4 = dual(2, (self, that) => mutate2(self, (set26) => {
  for (const value10 of that) {
    remove5(set26, value10);
  }
}));
var intersection5 = dual(2, (self, that) => mutate2(empty9(), (set26) => {
  for (const value10 of that) {
    if (has3(value10)(self)) {
      add3(value10)(set26);
    }
  }
}));
var union5 = dual(2, (self, that) => mutate2(empty9(), (set26) => {
  forEach5(self, (value10) => add3(set26, value10));
  for (const value10 of that) {
    add3(set26, value10);
  }
}));
var toggle = dual(2, (self, value10) => has3(self, value10) ? remove5(self, value10) : add3(self, value10));
var map9 = dual(2, (self, f) => mutate2(empty9(), (set26) => {
  forEach5(self, (a) => {
    const b = f(a);
    if (!has3(set26, b)) {
      add3(set26, b);
    }
  });
}));
var flatMap7 = dual(2, (self, f) => mutate2(empty9(), (set26) => {
  forEach5(self, (a) => {
    for (const b of f(a)) {
      if (!has3(set26, b)) {
        add3(set26, b);
      }
    }
  });
}));
var forEach5 = dual(2, (self, f) => forEach4(self._keyMap, (_, k) => f(k)));
var reduce6 = dual(3, (self, zero3, f) => reduce5(self._keyMap, zero3, (z, _, a) => f(z, a)));
var filter7 = dual(2, (self, f) => {
  return mutate2(empty9(), (set26) => {
    const iterator = values3(self);
    let next6;
    while (!(next6 = iterator.next()).done) {
      const value10 = next6.value;
      if (f(value10)) {
        add3(set26, value10);
      }
    }
  });
});
var partition4 = dual(2, (self, predicate) => {
  const iterator = values3(self);
  let next6;
  const right3 = beginMutation2(empty9());
  const left3 = beginMutation2(empty9());
  while (!(next6 = iterator.next()).done) {
    const value10 = next6.value;
    if (predicate(value10)) {
      add3(right3, value10);
    } else {
      add3(left3, value10);
    }
  }
  return [endMutation2(left3), endMutation2(right3)];
});

// ../../node_modules/effect/dist/esm/HashSet.js
var isHashSet2 = isHashSet;
var empty10 = empty9;
var fromIterable6 = fromIterable5;
var make14 = make13;
var has4 = has3;
var some11 = some10;
var every8 = every7;
var isSubset2 = isSubset;
var values4 = values3;
var toValues = (self) => Array.from(values4(self));
var size6 = size5;
var beginMutation3 = beginMutation2;
var endMutation3 = endMutation2;
var mutate3 = mutate2;
var add4 = add3;
var remove6 = remove5;
var difference5 = difference4;
var intersection6 = intersection5;
var union6 = union5;
var toggle2 = toggle;
var map10 = map9;
var flatMap8 = flatMap7;
var forEach6 = forEach5;
var reduce7 = reduce6;
var filter8 = filter7;
var partition5 = partition4;

// ../../node_modules/effect/dist/esm/MutableRef.js
var MutableRef_exports = {};
__export(MutableRef_exports, {
  compareAndSet: () => compareAndSet,
  decrement: () => decrement3,
  decrementAndGet: () => decrementAndGet,
  get: () => get7,
  getAndDecrement: () => getAndDecrement,
  getAndIncrement: () => getAndIncrement,
  getAndSet: () => getAndSet,
  getAndUpdate: () => getAndUpdate,
  increment: () => increment3,
  incrementAndGet: () => incrementAndGet,
  make: () => make15,
  set: () => set3,
  setAndGet: () => setAndGet,
  toggle: () => toggle3,
  update: () => update,
  updateAndGet: () => updateAndGet
});
var TypeId9 = Symbol.for("effect/MutableRef");
var MutableRefProto = {
  [TypeId9]: TypeId9,
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableRef",
      current: toJSON(this.current)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make15 = (value10) => {
  const ref = Object.create(MutableRefProto);
  ref.current = value10;
  return ref;
};
var compareAndSet = dual(3, (self, oldValue, newValue) => {
  if (equals(oldValue, self.current)) {
    self.current = newValue;
    return true;
  }
  return false;
});
var decrement3 = (self) => update(self, (n) => n - 1);
var decrementAndGet = (self) => updateAndGet(self, (n) => n - 1);
var get7 = (self) => self.current;
var getAndDecrement = (self) => getAndUpdate(self, (n) => n - 1);
var getAndIncrement = (self) => getAndUpdate(self, (n) => n + 1);
var getAndSet = dual(2, (self, value10) => {
  const ret = self.current;
  self.current = value10;
  return ret;
});
var getAndUpdate = dual(2, (self, f) => getAndSet(self, f(get7(self))));
var increment3 = (self) => update(self, (n) => n + 1);
var incrementAndGet = (self) => updateAndGet(self, (n) => n + 1);
var set3 = dual(2, (self, value10) => {
  self.current = value10;
  return self;
});
var setAndGet = dual(2, (self, value10) => {
  self.current = value10;
  return self.current;
});
var update = dual(2, (self, f) => set3(self, f(get7(self))));
var updateAndGet = dual(2, (self, f) => setAndGet(self, f(get7(self))));
var toggle3 = (self) => update(self, (_) => !_);

// ../../node_modules/effect/dist/esm/internal/fiberId.js
var FiberIdSymbolKey = "effect/FiberId";
var FiberIdTypeId = Symbol.for(FiberIdSymbolKey);
var OP_NONE = "None";
var OP_RUNTIME = "Runtime";
var OP_COMPOSITE = "Composite";
var emptyHash = string2(`${FiberIdSymbolKey}-${OP_NONE}`);
var None = class {
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_NONE;
  id = -1;
  startTimeMillis = -1;
  [symbol2]() {
    return emptyHash;
  }
  [symbol3](that) {
    return isFiberId(that) && that._tag === OP_NONE;
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var Runtime = class {
  id;
  startTimeMillis;
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_RUNTIME;
  constructor(id3, startTimeMillis) {
    this.id = id3;
    this.startTimeMillis = startTimeMillis;
  }
  [symbol2]() {
    return cached(this, string2(`${FiberIdSymbolKey}-${this._tag}-${this.id}-${this.startTimeMillis}`));
  }
  [symbol3](that) {
    return isFiberId(that) && that._tag === OP_RUNTIME && this.id === that.id && this.startTimeMillis === that.startTimeMillis;
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag,
      id: this.id,
      startTimeMillis: this.startTimeMillis
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var Composite = class {
  left;
  right;
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_COMPOSITE;
  constructor(left3, right3) {
    this.left = left3;
    this.right = right3;
  }
  _hash;
  [symbol2]() {
    return pipe(string2(`${FiberIdSymbolKey}-${this._tag}`), combine2(hash(this.left)), combine2(hash(this.right)), cached(this));
  }
  [symbol3](that) {
    return isFiberId(that) && that._tag === OP_COMPOSITE && equals(this.left, that.left) && equals(this.right, that.right);
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag,
      left: toJSON(this.left),
      right: toJSON(this.right)
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var none3 = new None();
var runtime = (id3, startTimeMillis) => {
  return new Runtime(id3, startTimeMillis);
};
var composite = (left3, right3) => {
  return new Composite(left3, right3);
};
var isFiberId = (self) => hasProperty(self, FiberIdTypeId);
var isNone3 = (self) => {
  return self._tag === OP_NONE || pipe(toSet(self), every8((id3) => isNone3(id3)));
};
var isRuntime = (self) => {
  return self._tag === OP_RUNTIME;
};
var isComposite = (self) => {
  return self._tag === OP_COMPOSITE;
};
var combine4 = dual(2, (self, that) => {
  if (self._tag === OP_NONE) {
    return that;
  }
  if (that._tag === OP_NONE) {
    return self;
  }
  return new Composite(self, that);
});
var combineAll3 = (fiberIds) => {
  return pipe(fiberIds, reduce7(none3, (a, b) => combine4(b)(a)));
};
var getOrElse5 = dual(2, (self, that) => isNone3(self) ? that : self);
var ids = (self) => {
  switch (self._tag) {
    case OP_NONE: {
      return empty10();
    }
    case OP_RUNTIME: {
      return make14(self.id);
    }
    case OP_COMPOSITE: {
      return pipe(ids(self.left), union6(ids(self.right)));
    }
  }
};
var _fiberCounter = globalValue(Symbol.for("effect/Fiber/Id/_fiberCounter"), () => make15(0));
var make16 = (id3, startTimeSeconds) => {
  return new Runtime(id3, startTimeSeconds);
};
var threadName = (self) => {
  const identifiers = Array.from(ids(self)).map((n) => `#${n}`).join(",");
  return identifiers;
};
var toOption = (self) => {
  const fiberIds = toSet(self);
  if (size6(fiberIds) === 0) {
    return none2();
  }
  let first5 = true;
  let acc;
  for (const fiberId5 of fiberIds) {
    if (first5) {
      acc = fiberId5;
      first5 = false;
    } else {
      acc = pipe(acc, combine4(fiberId5));
    }
  }
  return some3(acc);
};
var toSet = (self) => {
  switch (self._tag) {
    case OP_NONE: {
      return empty10();
    }
    case OP_RUNTIME: {
      return make14(self);
    }
    case OP_COMPOSITE: {
      return pipe(toSet(self.left), union6(toSet(self.right)));
    }
  }
};
var unsafeMake2 = () => {
  const id3 = get7(_fiberCounter);
  pipe(_fiberCounter, set3(id3 + 1));
  return new Runtime(id3, Date.now());
};

// ../../node_modules/effect/dist/esm/FiberId.js
var FiberIdTypeId2 = FiberIdTypeId;
var none4 = none3;
var runtime2 = runtime;
var composite2 = composite;
var isFiberId2 = isFiberId;
var isNone4 = isNone3;
var isRuntime2 = isRuntime;
var isComposite2 = isComposite;
var combine5 = combine4;
var combineAll4 = combineAll3;
var getOrElse6 = getOrElse5;
var ids2 = ids;
var make17 = make16;
var threadName2 = threadName;
var toOption2 = toOption;
var toSet2 = toSet;
var unsafeMake3 = unsafeMake2;

// ../../node_modules/effect/dist/esm/HashMap.js
var HashMap_exports = {};
__export(HashMap_exports, {
  beginMutation: () => beginMutation4,
  compact: () => compact3,
  countBy: () => countBy4,
  empty: () => empty11,
  endMutation: () => endMutation4,
  entries: () => entries2,
  every: () => every9,
  filter: () => filter9,
  filterMap: () => filterMap7,
  findFirst: () => findFirst6,
  flatMap: () => flatMap9,
  forEach: () => forEach7,
  fromIterable: () => fromIterable7,
  get: () => get8,
  getHash: () => getHash2,
  has: () => has5,
  hasBy: () => hasBy2,
  hasHash: () => hasHash2,
  isEmpty: () => isEmpty4,
  isHashMap: () => isHashMap2,
  keySet: () => keySet2,
  keys: () => keys3,
  make: () => make18,
  map: () => map11,
  modify: () => modify5,
  modifyAt: () => modifyAt2,
  modifyHash: () => modifyHash2,
  mutate: () => mutate4,
  reduce: () => reduce8,
  remove: () => remove7,
  removeMany: () => removeMany2,
  set: () => set4,
  size: () => size7,
  some: () => some12,
  toEntries: () => toEntries2,
  toValues: () => toValues2,
  union: () => union7,
  unsafeGet: () => unsafeGet6,
  values: () => values5
});

// ../../node_modules/effect/dist/esm/internal/hashMap/keySet.js
function keySet(self) {
  return makeImpl2(self);
}

// ../../node_modules/effect/dist/esm/HashMap.js
var isHashMap2 = isHashMap;
var empty11 = empty8;
var make18 = make12;
var fromIterable7 = fromIterable4;
var isEmpty4 = isEmpty3;
var get8 = get6;
var getHash2 = getHash;
var unsafeGet6 = unsafeGet5;
var has5 = has2;
var hasHash2 = hasHash;
var hasBy2 = hasBy;
var set4 = set2;
var keys3 = keys2;
var keySet2 = keySet;
var values5 = values2;
var toValues2 = (self) => Array.from(values5(self));
var entries2 = entries;
var toEntries2 = (self) => Array.from(entries2(self));
var size7 = size4;
var countBy4 = countBy3;
var beginMutation4 = beginMutation;
var endMutation4 = endMutation;
var mutate4 = mutate;
var modifyAt2 = modifyAt;
var modifyHash2 = modifyHash;
var modify5 = modify4;
var union7 = union4;
var remove7 = remove4;
var removeMany2 = removeMany;
var map11 = map8;
var flatMap9 = flatMap6;
var forEach7 = forEach4;
var reduce8 = reduce5;
var filter9 = filter6;
var compact3 = compact2;
var filterMap7 = filterMap6;
var findFirst6 = findFirst5;
var some12 = some9;
var every9 = every6;

// ../../node_modules/effect/dist/esm/List.js
var List_exports = {};
__export(List_exports, {
  TypeId: () => TypeId10,
  append: () => append4,
  appendAll: () => appendAll4,
  compact: () => compact4,
  cons: () => cons,
  drop: () => drop4,
  empty: () => empty12,
  every: () => every10,
  filter: () => filter10,
  filterMap: () => filterMap8,
  findFirst: () => findFirst7,
  flatMap: () => flatMap10,
  forEach: () => forEach8,
  fromIterable: () => fromIterable8,
  getEquivalence: () => getEquivalence7,
  head: () => head4,
  isCons: () => isCons,
  isList: () => isList,
  isNil: () => isNil,
  last: () => last3,
  make: () => make19,
  map: () => map12,
  nil: () => nil,
  of: () => of4,
  partition: () => partition6,
  partitionMap: () => partitionMap5,
  prepend: () => prepend4,
  prependAll: () => prependAll4,
  prependAllReversed: () => prependAllReversed,
  reduce: () => reduce9,
  reduceRight: () => reduceRight3,
  reverse: () => reverse4,
  size: () => size8,
  some: () => some13,
  splitAt: () => splitAt3,
  tail: () => tail3,
  take: () => take4,
  toArray: () => toArray3,
  toChunk: () => toChunk,
  unsafeHead: () => unsafeHead3,
  unsafeLast: () => unsafeLast2,
  unsafeTail: () => unsafeTail
});
var TypeId10 = Symbol.for("effect/List");
var toArray3 = (self) => fromIterable2(self);
var getEquivalence7 = (isEquivalent) => mapInput(getEquivalence5(isEquivalent), toArray3);
var _equivalence5 = getEquivalence7(equals);
var ConsProto = {
  [TypeId10]: TypeId10,
  _tag: "Cons",
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "List",
      _tag: "Cons",
      values: toArray3(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol3](that) {
    return isList(that) && this._tag === that._tag && _equivalence5(this, that);
  },
  [symbol2]() {
    return cached(this, array2(toArray3(this)));
  },
  [Symbol.iterator]() {
    let done17 = false;
    let self = this;
    return {
      next() {
        if (done17) {
          return this.return();
        }
        if (self._tag === "Nil") {
          done17 = true;
          return this.return();
        }
        const value10 = self.head;
        self = self.tail;
        return {
          done: done17,
          value: value10
        };
      },
      return(value10) {
        if (!done17) {
          done17 = true;
        }
        return {
          done: true,
          value: value10
        };
      }
    };
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeCons = (head13, tail5) => {
  const cons2 = Object.create(ConsProto);
  cons2.head = head13;
  cons2.tail = tail5;
  return cons2;
};
var NilHash = string2("Nil");
var NilProto = {
  [TypeId10]: TypeId10,
  _tag: "Nil",
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "List",
      _tag: "Nil"
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol2]() {
    return NilHash;
  },
  [symbol3](that) {
    return isList(that) && this._tag === that._tag;
  },
  [Symbol.iterator]() {
    return {
      next() {
        return {
          done: true,
          value: void 0
        };
      }
    };
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var _Nil = Object.create(NilProto);
var isList = (u) => hasProperty(u, TypeId10);
var isNil = (self) => self._tag === "Nil";
var isCons = (self) => self._tag === "Cons";
var size8 = (self) => {
  let these = self;
  let len = 0;
  while (!isNil(these)) {
    len += 1;
    these = these.tail;
  }
  return len;
};
var nil = () => _Nil;
var cons = (head13, tail5) => makeCons(head13, tail5);
var empty12 = nil;
var of4 = (value10) => makeCons(value10, _Nil);
var fromIterable8 = (prefix) => {
  const iterator = prefix[Symbol.iterator]();
  let next6;
  if ((next6 = iterator.next()) && !next6.done) {
    const result = makeCons(next6.value, _Nil);
    let curr = result;
    while ((next6 = iterator.next()) && !next6.done) {
      const temp = makeCons(next6.value, _Nil);
      curr.tail = temp;
      curr = temp;
    }
    return result;
  } else {
    return _Nil;
  }
};
var make19 = (...elements) => fromIterable8(elements);
var append4 = dual(2, (self, element2) => appendAll4(self, of4(element2)));
var appendAll4 = dual(2, (self, that) => prependAll4(that, self));
var prepend4 = dual(2, (self, element2) => cons(element2, self));
var prependAll4 = dual(2, (self, prefix) => {
  if (isNil(self)) {
    return prefix;
  } else if (isNil(prefix)) {
    return self;
  } else {
    const result = makeCons(prefix.head, self);
    let curr = result;
    let that = prefix.tail;
    while (!isNil(that)) {
      const temp = makeCons(that.head, self);
      curr.tail = temp;
      curr = temp;
      that = that.tail;
    }
    return result;
  }
});
var prependAllReversed = dual(2, (self, prefix) => {
  let out = self;
  let pres = prefix;
  while (isCons(pres)) {
    out = makeCons(pres.head, out);
    pres = pres.tail;
  }
  return out;
});
var drop4 = dual(2, (self, n) => {
  if (n <= 0) {
    return self;
  }
  if (n >= size8(self)) {
    return _Nil;
  }
  let these = self;
  let i = 0;
  while (!isNil(these) && i < n) {
    these = these.tail;
    i += 1;
  }
  return these;
});
var every10 = dual(2, (self, refinement) => {
  for (const a of self) {
    if (!refinement(a)) {
      return false;
    }
  }
  return true;
});
var some13 = dual(2, (self, predicate) => {
  let these = self;
  while (!isNil(these)) {
    if (predicate(these.head)) {
      return true;
    }
    these = these.tail;
  }
  return false;
});
var filter10 = dual(2, (self, predicate) => noneIn(self, predicate, false));
var noneIn = (self, predicate, isFlipped) => {
  while (true) {
    if (isNil(self)) {
      return _Nil;
    } else {
      if (predicate(self.head) !== isFlipped) {
        return allIn(self, self.tail, predicate, isFlipped);
      } else {
        self = self.tail;
      }
    }
  }
};
var allIn = (start5, remaining, predicate, isFlipped) => {
  while (true) {
    if (isNil(remaining)) {
      return start5;
    } else {
      if (predicate(remaining.head) !== isFlipped) {
        remaining = remaining.tail;
      } else {
        return partialFill(start5, remaining, predicate, isFlipped);
      }
    }
  }
};
var partialFill = (origStart, firstMiss, predicate, isFlipped) => {
  const newHead = makeCons(unsafeHead3(origStart), _Nil);
  let toProcess = unsafeTail(origStart);
  let currentLast = newHead;
  while (!(toProcess === firstMiss)) {
    const newElem = makeCons(unsafeHead3(toProcess), _Nil);
    currentLast.tail = newElem;
    currentLast = unsafeCoerce(newElem);
    toProcess = unsafeCoerce(toProcess.tail);
  }
  let next6 = firstMiss.tail;
  let nextToCopy = unsafeCoerce(next6);
  while (!isNil(next6)) {
    const head13 = unsafeHead3(next6);
    if (predicate(head13) !== isFlipped) {
      next6 = next6.tail;
    } else {
      while (!(nextToCopy === next6)) {
        const newElem = makeCons(unsafeHead3(nextToCopy), _Nil);
        currentLast.tail = newElem;
        currentLast = newElem;
        nextToCopy = unsafeCoerce(nextToCopy.tail);
      }
      nextToCopy = unsafeCoerce(next6.tail);
      next6 = next6.tail;
    }
  }
  if (!isNil(nextToCopy)) {
    currentLast.tail = nextToCopy;
  }
  return newHead;
};
var filterMap8 = dual(2, (self, f) => {
  const bs = [];
  for (const a of self) {
    const oa = f(a);
    if (isSome2(oa)) {
      bs.push(oa.value);
    }
  }
  return fromIterable8(bs);
});
var compact4 = (self) => filterMap8(self, identity);
var findFirst7 = dual(2, (self, predicate) => {
  let these = self;
  while (!isNil(these)) {
    if (predicate(these.head)) {
      return some3(these.head);
    }
    these = these.tail;
  }
  return none2();
});
var flatMap10 = dual(2, (self, f) => {
  let rest = self;
  let head13 = void 0;
  let tail5 = void 0;
  while (!isNil(rest)) {
    let bs = f(rest.head);
    while (!isNil(bs)) {
      const next6 = makeCons(bs.head, _Nil);
      if (tail5 === void 0) {
        head13 = next6;
      } else {
        tail5.tail = next6;
      }
      tail5 = next6;
      bs = bs.tail;
    }
    rest = rest.tail;
  }
  if (head13 === void 0) {
    return _Nil;
  }
  return head13;
});
var forEach8 = dual(2, (self, f) => {
  let these = self;
  while (!isNil(these)) {
    f(these.head);
    these = these.tail;
  }
});
var head4 = (self) => isNil(self) ? none2() : some3(self.head);
var last3 = (self) => isNil(self) ? none2() : some3(unsafeLast2(self));
var map12 = dual(2, (self, f) => {
  if (isNil(self)) {
    return self;
  } else {
    let i = 0;
    const head13 = makeCons(f(self.head, i++), _Nil);
    let nextHead = head13;
    let rest = self.tail;
    while (!isNil(rest)) {
      const next6 = makeCons(f(rest.head, i++), _Nil);
      nextHead.tail = next6;
      nextHead = next6;
      rest = rest.tail;
    }
    return head13;
  }
});
var partition6 = dual(2, (self, predicate) => {
  const left3 = [];
  const right3 = [];
  for (const a of self) {
    if (predicate(a)) {
      right3.push(a);
    } else {
      left3.push(a);
    }
  }
  return [fromIterable8(left3), fromIterable8(right3)];
});
var partitionMap5 = dual(2, (self, f) => {
  const left3 = [];
  const right3 = [];
  for (const a of self) {
    const e = f(a);
    if (isLeft2(e)) {
      left3.push(e.left);
    } else {
      right3.push(e.right);
    }
  }
  return [fromIterable8(left3), fromIterable8(right3)];
});
var reduce9 = dual(3, (self, zero3, f) => {
  let acc = zero3;
  let these = self;
  while (!isNil(these)) {
    acc = f(acc, these.head);
    these = these.tail;
  }
  return acc;
});
var reduceRight3 = dual(3, (self, zero3, f) => {
  let acc = zero3;
  let these = reverse4(self);
  while (!isNil(these)) {
    acc = f(acc, these.head);
    these = these.tail;
  }
  return acc;
});
var reverse4 = (self) => {
  let result = empty12();
  let these = self;
  while (!isNil(these)) {
    result = prepend4(result, these.head);
    these = these.tail;
  }
  return result;
};
var splitAt3 = dual(2, (self, n) => [take4(self, n), drop4(self, n)]);
var tail3 = (self) => isNil(self) ? none2() : some3(self.tail);
var take4 = dual(2, (self, n) => {
  if (n <= 0) {
    return _Nil;
  }
  if (n >= size8(self)) {
    return self;
  }
  let these = make19(unsafeHead3(self));
  let current2 = unsafeTail(self);
  for (let i = 1; i < n; i++) {
    these = makeCons(unsafeHead3(current2), these);
    current2 = unsafeTail(current2);
  }
  return reverse4(these);
});
var toChunk = (self) => fromIterable3(self);
var getExpectedListToBeNonEmptyErrorMessage = "Expected List to be non-empty";
var unsafeHead3 = (self) => {
  if (isNil(self)) {
    throw new Error(getExpectedListToBeNonEmptyErrorMessage);
  }
  return self.head;
};
var unsafeLast2 = (self) => {
  if (isNil(self)) {
    throw new Error(getExpectedListToBeNonEmptyErrorMessage);
  }
  let these = self;
  let scout = self.tail;
  while (!isNil(scout)) {
    these = scout;
    scout = scout.tail;
  }
  return these.head;
};
var unsafeTail = (self) => {
  if (isNil(self)) {
    throw new Error(getExpectedListToBeNonEmptyErrorMessage);
  }
  return self.tail;
};

// ../../node_modules/effect/dist/esm/RuntimeFlagsPatch.js
var RuntimeFlagsPatch_exports = {};
__export(RuntimeFlagsPatch_exports, {
  andThen: () => andThen4,
  both: () => both2,
  disable: () => disable3,
  disabledSet: () => disabledSet2,
  either: () => either2,
  empty: () => empty20,
  enable: () => enable3,
  enabledSet: () => enabledSet2,
  exclude: () => exclude2,
  includes: () => includes,
  inverse: () => inverse2,
  isActive: () => isActive2,
  isDisabled: () => isDisabled3,
  isEmpty: () => isEmpty6,
  isEnabled: () => isEnabled3,
  make: () => make23,
  render: () => render2
});

// ../../node_modules/effect/dist/esm/internal/data.js
var ArrayProto = Object.assign(Object.create(Array.prototype), {
  [symbol2]() {
    return cached(this, array2(this));
  },
  [symbol3](that) {
    if (Array.isArray(that) && this.length === that.length) {
      return this.every((v, i) => equals(v, that[i]));
    } else {
      return false;
    }
  }
});
var Structural = function() {
  function Structural3(args2) {
    if (args2) {
      Object.assign(this, args2);
    }
  }
  Structural3.prototype = StructuralPrototype;
  return Structural3;
}();
var struct4 = (as18) => Object.assign(Object.create(StructuralPrototype), as18);

// ../../node_modules/effect/dist/esm/internal/differ/chunkPatch.js
var ChunkPatchTypeId = Symbol.for("effect/DifferChunkPatch");
function variance(a) {
  return a;
}
var PatchProto = {
  ...Structural.prototype,
  [ChunkPatchTypeId]: {
    _Value: variance,
    _Patch: variance
  }
};
var EmptyProto = Object.assign(Object.create(PatchProto), {
  _tag: "Empty"
});
var _empty5 = Object.create(EmptyProto);
var empty13 = () => _empty5;
var AndThenProto = Object.assign(Object.create(PatchProto), {
  _tag: "AndThen"
});
var makeAndThen = (first5, second) => {
  const o = Object.create(AndThenProto);
  o.first = first5;
  o.second = second;
  return o;
};
var AppendProto = Object.assign(Object.create(PatchProto), {
  _tag: "Append"
});
var makeAppend = (values15) => {
  const o = Object.create(AppendProto);
  o.values = values15;
  return o;
};
var SliceProto = Object.assign(Object.create(PatchProto), {
  _tag: "Slice"
});
var makeSlice = (from, until) => {
  const o = Object.create(SliceProto);
  o.from = from;
  o.until = until;
  return o;
};
var UpdateProto = Object.assign(Object.create(PatchProto), {
  _tag: "Update"
});
var makeUpdate = (index, patch14) => {
  const o = Object.create(UpdateProto);
  o.index = index;
  o.patch = patch14;
  return o;
};
var diff = (options) => {
  let i = 0;
  let patch14 = empty13();
  while (i < options.oldValue.length && i < options.newValue.length) {
    const oldElement = unsafeGet4(i)(options.oldValue);
    const newElement = unsafeGet4(i)(options.newValue);
    const valuePatch = options.differ.diff(oldElement, newElement);
    if (!equals(valuePatch, options.differ.empty)) {
      patch14 = pipe(patch14, combine6(makeUpdate(i, valuePatch)));
    }
    i = i + 1;
  }
  if (i < options.oldValue.length) {
    patch14 = pipe(patch14, combine6(makeSlice(0, i)));
  }
  if (i < options.newValue.length) {
    patch14 = pipe(patch14, combine6(makeAppend(drop3(i)(options.newValue))));
  }
  return patch14;
};
var combine6 = dual(2, (self, that) => makeAndThen(self, that));
var patch = dual(3, (self, oldValue, differ4) => {
  if (self._tag === "Empty") {
    return oldValue;
  }
  let chunk7 = oldValue;
  let patches = of3(self);
  while (isNonEmpty2(patches)) {
    const head13 = headNonEmpty2(patches);
    const tail5 = tailNonEmpty2(patches);
    switch (head13._tag) {
      case "Empty": {
        patches = tail5;
        break;
      }
      case "AndThen": {
        patches = prepend3(head13.first)(prepend3(head13.second)(tail5));
        break;
      }
      case "Append": {
        chunk7 = appendAll3(head13.values)(chunk7);
        patches = tail5;
        break;
      }
      case "Slice": {
        const array8 = toReadonlyArray(chunk7);
        chunk7 = unsafeFromArray(array8.slice(head13.from, head13.until));
        patches = tail5;
        break;
      }
      case "Update": {
        const array8 = toReadonlyArray(chunk7);
        array8[head13.index] = differ4.patch(head13.patch, array8[head13.index]);
        chunk7 = unsafeFromArray(array8);
        patches = tail5;
        break;
      }
    }
  }
  return chunk7;
});

// ../../node_modules/effect/dist/esm/internal/differ/contextPatch.js
var ContextPatchTypeId = Symbol.for("effect/DifferContextPatch");
function variance2(a) {
  return a;
}
var PatchProto2 = {
  ...Structural.prototype,
  [ContextPatchTypeId]: {
    _Value: variance2,
    _Patch: variance2
  }
};
var EmptyProto2 = Object.assign(Object.create(PatchProto2), {
  _tag: "Empty"
});
var _empty6 = Object.create(EmptyProto2);
var empty14 = () => _empty6;
var AndThenProto2 = Object.assign(Object.create(PatchProto2), {
  _tag: "AndThen"
});
var makeAndThen2 = (first5, second) => {
  const o = Object.create(AndThenProto2);
  o.first = first5;
  o.second = second;
  return o;
};
var AddServiceProto = Object.assign(Object.create(PatchProto2), {
  _tag: "AddService"
});
var makeAddService = (key, service4) => {
  const o = Object.create(AddServiceProto);
  o.key = key;
  o.service = service4;
  return o;
};
var RemoveServiceProto = Object.assign(Object.create(PatchProto2), {
  _tag: "RemoveService"
});
var makeRemoveService = (key) => {
  const o = Object.create(RemoveServiceProto);
  o.key = key;
  return o;
};
var UpdateServiceProto = Object.assign(Object.create(PatchProto2), {
  _tag: "UpdateService"
});
var makeUpdateService = (key, update18) => {
  const o = Object.create(UpdateServiceProto);
  o.key = key;
  o.update = update18;
  return o;
};
var diff2 = (oldValue, newValue) => {
  const missingServices = new Map(oldValue.unsafeMap);
  let patch14 = empty14();
  for (const [tag5, newService] of newValue.unsafeMap.entries()) {
    if (missingServices.has(tag5)) {
      const old = missingServices.get(tag5);
      missingServices.delete(tag5);
      if (!equals(old, newService)) {
        patch14 = combine7(makeUpdateService(tag5, () => newService))(patch14);
      }
    } else {
      missingServices.delete(tag5);
      patch14 = combine7(makeAddService(tag5, newService))(patch14);
    }
  }
  for (const [tag5] of missingServices.entries()) {
    patch14 = combine7(makeRemoveService(tag5))(patch14);
  }
  return patch14;
};
var combine7 = dual(2, (self, that) => makeAndThen2(self, that));
var patch2 = dual(2, (self, context15) => {
  if (self._tag === "Empty") {
    return context15;
  }
  let wasServiceUpdated = false;
  let patches = of3(self);
  const updatedContext = new Map(context15.unsafeMap);
  while (isNonEmpty2(patches)) {
    const head13 = headNonEmpty2(patches);
    const tail5 = tailNonEmpty2(patches);
    switch (head13._tag) {
      case "Empty": {
        patches = tail5;
        break;
      }
      case "AddService": {
        updatedContext.set(head13.key, head13.service);
        patches = tail5;
        break;
      }
      case "AndThen": {
        patches = prepend3(prepend3(tail5, head13.second), head13.first);
        break;
      }
      case "RemoveService": {
        updatedContext.delete(head13.key);
        patches = tail5;
        break;
      }
      case "UpdateService": {
        updatedContext.set(head13.key, head13.update(updatedContext.get(head13.key)));
        wasServiceUpdated = true;
        patches = tail5;
        break;
      }
    }
  }
  if (!wasServiceUpdated) {
    return makeContext(updatedContext);
  }
  const map49 = /* @__PURE__ */ new Map();
  for (const [tag5] of context15.unsafeMap) {
    if (updatedContext.has(tag5)) {
      map49.set(tag5, updatedContext.get(tag5));
      updatedContext.delete(tag5);
    }
  }
  for (const [tag5, s] of updatedContext) {
    map49.set(tag5, s);
  }
  return makeContext(map49);
});

// ../../node_modules/effect/dist/esm/internal/differ/hashMapPatch.js
var HashMapPatchTypeId = Symbol.for("effect/DifferHashMapPatch");
function variance3(a) {
  return a;
}
var PatchProto3 = {
  ...Structural.prototype,
  [HashMapPatchTypeId]: {
    _Value: variance3,
    _Key: variance3,
    _Patch: variance3
  }
};
var EmptyProto3 = Object.assign(Object.create(PatchProto3), {
  _tag: "Empty"
});
var _empty7 = Object.create(EmptyProto3);
var empty15 = () => _empty7;
var AndThenProto3 = Object.assign(Object.create(PatchProto3), {
  _tag: "AndThen"
});
var makeAndThen3 = (first5, second) => {
  const o = Object.create(AndThenProto3);
  o.first = first5;
  o.second = second;
  return o;
};
var AddProto = Object.assign(Object.create(PatchProto3), {
  _tag: "Add"
});
var makeAdd = (key, value10) => {
  const o = Object.create(AddProto);
  o.key = key;
  o.value = value10;
  return o;
};
var RemoveProto = Object.assign(Object.create(PatchProto3), {
  _tag: "Remove"
});
var makeRemove = (key) => {
  const o = Object.create(RemoveProto);
  o.key = key;
  return o;
};
var UpdateProto2 = Object.assign(Object.create(PatchProto3), {
  _tag: "Update"
});
var makeUpdate2 = (key, patch14) => {
  const o = Object.create(UpdateProto2);
  o.key = key;
  o.patch = patch14;
  return o;
};
var diff3 = (options) => {
  const [removed, patch14] = reduce8([options.oldValue, empty15()], ([map49, patch15], newValue, key) => {
    const option11 = get8(key)(map49);
    switch (option11._tag) {
      case "Some": {
        const valuePatch = options.differ.diff(option11.value, newValue);
        if (equals(valuePatch, options.differ.empty)) {
          return [remove7(key)(map49), patch15];
        }
        return [remove7(key)(map49), combine8(makeUpdate2(key, valuePatch))(patch15)];
      }
      case "None": {
        return [map49, combine8(makeAdd(key, newValue))(patch15)];
      }
    }
  })(options.newValue);
  return reduce8(patch14, (patch15, _, key) => combine8(makeRemove(key))(patch15))(removed);
};
var combine8 = dual(2, (self, that) => makeAndThen3(self, that));
var patch3 = dual(3, (self, oldValue, differ4) => {
  if (self._tag === "Empty") {
    return oldValue;
  }
  let map49 = oldValue;
  let patches = of3(self);
  while (isNonEmpty2(patches)) {
    const head13 = headNonEmpty2(patches);
    const tail5 = tailNonEmpty2(patches);
    switch (head13._tag) {
      case "Empty": {
        patches = tail5;
        break;
      }
      case "AndThen": {
        patches = prepend3(head13.first)(prepend3(head13.second)(tail5));
        break;
      }
      case "Add": {
        map49 = set4(head13.key, head13.value)(map49);
        patches = tail5;
        break;
      }
      case "Remove": {
        map49 = remove7(head13.key)(map49);
        patches = tail5;
        break;
      }
      case "Update": {
        const option11 = get8(head13.key)(map49);
        if (option11._tag === "Some") {
          map49 = set4(head13.key, differ4.patch(head13.patch, option11.value))(map49);
        }
        patches = tail5;
        break;
      }
    }
  }
  return map49;
});

// ../../node_modules/effect/dist/esm/internal/differ/hashSetPatch.js
var HashSetPatchTypeId = Symbol.for("effect/DifferHashSetPatch");
function variance4(a) {
  return a;
}
var PatchProto4 = {
  ...Structural.prototype,
  [HashSetPatchTypeId]: {
    _Value: variance4,
    _Key: variance4,
    _Patch: variance4
  }
};
var EmptyProto4 = Object.assign(Object.create(PatchProto4), {
  _tag: "Empty"
});
var _empty8 = Object.create(EmptyProto4);
var empty16 = () => _empty8;
var AndThenProto4 = Object.assign(Object.create(PatchProto4), {
  _tag: "AndThen"
});
var makeAndThen4 = (first5, second) => {
  const o = Object.create(AndThenProto4);
  o.first = first5;
  o.second = second;
  return o;
};
var AddProto2 = Object.assign(Object.create(PatchProto4), {
  _tag: "Add"
});
var makeAdd2 = (value10) => {
  const o = Object.create(AddProto2);
  o.value = value10;
  return o;
};
var RemoveProto2 = Object.assign(Object.create(PatchProto4), {
  _tag: "Remove"
});
var makeRemove2 = (value10) => {
  const o = Object.create(RemoveProto2);
  o.value = value10;
  return o;
};
var diff4 = (oldValue, newValue) => {
  const [removed, patch14] = reduce7([oldValue, empty16()], ([set26, patch15], value10) => {
    if (has4(value10)(set26)) {
      return [remove6(value10)(set26), patch15];
    }
    return [set26, combine9(makeAdd2(value10))(patch15)];
  })(newValue);
  return reduce7(patch14, (patch15, value10) => combine9(makeRemove2(value10))(patch15))(removed);
};
var combine9 = dual(2, (self, that) => makeAndThen4(self, that));
var patch4 = dual(2, (self, oldValue) => {
  if (self._tag === "Empty") {
    return oldValue;
  }
  let set26 = oldValue;
  let patches = of3(self);
  while (isNonEmpty2(patches)) {
    const head13 = headNonEmpty2(patches);
    const tail5 = tailNonEmpty2(patches);
    switch (head13._tag) {
      case "Empty": {
        patches = tail5;
        break;
      }
      case "AndThen": {
        patches = prepend3(head13.first)(prepend3(head13.second)(tail5));
        break;
      }
      case "Add": {
        set26 = add4(head13.value)(set26);
        patches = tail5;
        break;
      }
      case "Remove": {
        set26 = remove6(head13.value)(set26);
        patches = tail5;
      }
    }
  }
  return set26;
});

// ../../node_modules/effect/dist/esm/internal/differ/orPatch.js
var OrPatchTypeId = Symbol.for("effect/DifferOrPatch");
function variance5(a) {
  return a;
}
var PatchProto5 = {
  ...Structural.prototype,
  [OrPatchTypeId]: {
    _Value: variance5,
    _Key: variance5,
    _Patch: variance5
  }
};
var EmptyProto5 = Object.assign(Object.create(PatchProto5), {
  _tag: "Empty"
});
var _empty9 = Object.create(EmptyProto5);
var empty17 = () => _empty9;
var AndThenProto5 = Object.assign(Object.create(PatchProto5), {
  _tag: "AndThen"
});
var makeAndThen5 = (first5, second) => {
  const o = Object.create(AndThenProto5);
  o.first = first5;
  o.second = second;
  return o;
};
var SetLeftProto = Object.assign(Object.create(PatchProto5), {
  _tag: "SetLeft"
});
var makeSetLeft = (value10) => {
  const o = Object.create(SetLeftProto);
  o.value = value10;
  return o;
};
var SetRightProto = Object.assign(Object.create(PatchProto5), {
  _tag: "SetRight"
});
var makeSetRight = (value10) => {
  const o = Object.create(SetRightProto);
  o.value = value10;
  return o;
};
var UpdateLeftProto = Object.assign(Object.create(PatchProto5), {
  _tag: "UpdateLeft"
});
var makeUpdateLeft = (patch14) => {
  const o = Object.create(UpdateLeftProto);
  o.patch = patch14;
  return o;
};
var UpdateRightProto = Object.assign(Object.create(PatchProto5), {
  _tag: "UpdateRight"
});
var makeUpdateRight = (patch14) => {
  const o = Object.create(UpdateRightProto);
  o.patch = patch14;
  return o;
};
var diff5 = (options) => {
  switch (options.oldValue._tag) {
    case "Left": {
      switch (options.newValue._tag) {
        case "Left": {
          const valuePatch = options.left.diff(options.oldValue.left, options.newValue.left);
          if (equals(valuePatch, options.left.empty)) {
            return empty17();
          }
          return makeUpdateLeft(valuePatch);
        }
        case "Right": {
          return makeSetRight(options.newValue.right);
        }
      }
    }
    case "Right": {
      switch (options.newValue._tag) {
        case "Left": {
          return makeSetLeft(options.newValue.left);
        }
        case "Right": {
          const valuePatch = options.right.diff(options.oldValue.right, options.newValue.right);
          if (equals(valuePatch, options.right.empty)) {
            return empty17();
          }
          return makeUpdateRight(valuePatch);
        }
      }
    }
  }
};
var combine10 = dual(2, (self, that) => makeAndThen5(self, that));
var patch5 = dual(2, (self, {
  left: left3,
  oldValue,
  right: right3
}) => {
  if (self._tag === "Empty") {
    return oldValue;
  }
  let patches = of3(self);
  let result = oldValue;
  while (isNonEmpty2(patches)) {
    const head13 = headNonEmpty2(patches);
    const tail5 = tailNonEmpty2(patches);
    switch (head13._tag) {
      case "Empty": {
        patches = tail5;
        break;
      }
      case "AndThen": {
        patches = prepend3(head13.first)(prepend3(head13.second)(tail5));
        break;
      }
      case "UpdateLeft": {
        if (result._tag === "Left") {
          result = left2(left3.patch(head13.patch, result.left));
        }
        patches = tail5;
        break;
      }
      case "UpdateRight": {
        if (result._tag === "Right") {
          result = right2(right3.patch(head13.patch, result.right));
        }
        patches = tail5;
        break;
      }
      case "SetLeft": {
        result = left2(head13.value);
        patches = tail5;
        break;
      }
      case "SetRight": {
        result = right2(head13.value);
        patches = tail5;
        break;
      }
    }
  }
  return result;
});

// ../../node_modules/effect/dist/esm/internal/differ/readonlyArrayPatch.js
var ReadonlyArrayPatchTypeId = Symbol.for("effect/DifferReadonlyArrayPatch");
function variance6(a) {
  return a;
}
var PatchProto6 = {
  ...Structural.prototype,
  [ReadonlyArrayPatchTypeId]: {
    _Value: variance6,
    _Patch: variance6
  }
};
var EmptyProto6 = Object.assign(Object.create(PatchProto6), {
  _tag: "Empty"
});
var _empty10 = Object.create(EmptyProto6);
var empty18 = () => _empty10;
var AndThenProto6 = Object.assign(Object.create(PatchProto6), {
  _tag: "AndThen"
});
var makeAndThen6 = (first5, second) => {
  const o = Object.create(AndThenProto6);
  o.first = first5;
  o.second = second;
  return o;
};
var AppendProto2 = Object.assign(Object.create(PatchProto6), {
  _tag: "Append"
});
var makeAppend2 = (values15) => {
  const o = Object.create(AppendProto2);
  o.values = values15;
  return o;
};
var SliceProto2 = Object.assign(Object.create(PatchProto6), {
  _tag: "Slice"
});
var makeSlice2 = (from, until) => {
  const o = Object.create(SliceProto2);
  o.from = from;
  o.until = until;
  return o;
};
var UpdateProto3 = Object.assign(Object.create(PatchProto6), {
  _tag: "Update"
});
var makeUpdate3 = (index, patch14) => {
  const o = Object.create(UpdateProto3);
  o.index = index;
  o.patch = patch14;
  return o;
};
var diff6 = (options) => {
  let i = 0;
  let patch14 = empty18();
  while (i < options.oldValue.length && i < options.newValue.length) {
    const oldElement = options.oldValue[i];
    const newElement = options.newValue[i];
    const valuePatch = options.differ.diff(oldElement, newElement);
    if (!equals(valuePatch, options.differ.empty)) {
      patch14 = combine11(patch14, makeUpdate3(i, valuePatch));
    }
    i = i + 1;
  }
  if (i < options.oldValue.length) {
    patch14 = combine11(patch14, makeSlice2(0, i));
  }
  if (i < options.newValue.length) {
    patch14 = combine11(patch14, makeAppend2(drop2(i)(options.newValue)));
  }
  return patch14;
};
var combine11 = dual(2, (self, that) => makeAndThen6(self, that));
var patch6 = dual(3, (self, oldValue, differ4) => {
  if (self._tag === "Empty") {
    return oldValue;
  }
  let readonlyArray3 = oldValue.slice();
  let patches = of2(self);
  while (isNonEmptyArray2(patches)) {
    const head13 = headNonEmpty(patches);
    const tail5 = tailNonEmpty(patches);
    switch (head13._tag) {
      case "Empty": {
        patches = tail5;
        break;
      }
      case "AndThen": {
        tail5.unshift(head13.first, head13.second);
        patches = tail5;
        break;
      }
      case "Append": {
        for (const value10 of head13.values) {
          readonlyArray3.push(value10);
        }
        patches = tail5;
        break;
      }
      case "Slice": {
        readonlyArray3 = readonlyArray3.slice(head13.from, head13.until);
        patches = tail5;
        break;
      }
      case "Update": {
        readonlyArray3[head13.index] = differ4.patch(head13.patch, readonlyArray3[head13.index]);
        patches = tail5;
        break;
      }
    }
  }
  return readonlyArray3;
});

// ../../node_modules/effect/dist/esm/internal/differ.js
var DifferTypeId = Symbol.for("effect/Differ");
var DifferProto = {
  [DifferTypeId]: {
    _P: identity,
    _V: identity
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make20 = (params) => {
  const differ4 = Object.create(DifferProto);
  differ4.empty = params.empty;
  differ4.diff = params.diff;
  differ4.combine = params.combine;
  differ4.patch = params.patch;
  return differ4;
};
var environment = () => make20({
  empty: empty14(),
  combine: (first5, second) => combine7(second)(first5),
  diff: (oldValue, newValue) => diff2(oldValue, newValue),
  patch: (patch14, oldValue) => patch2(oldValue)(patch14)
});
var chunk = (differ4) => make20({
  empty: empty13(),
  combine: (first5, second) => combine6(second)(first5),
  diff: (oldValue, newValue) => diff({
    oldValue,
    newValue,
    differ: differ4
  }),
  patch: (patch14, oldValue) => patch(oldValue, differ4)(patch14)
});
var hashMap = (differ4) => make20({
  empty: empty15(),
  combine: (first5, second) => combine8(second)(first5),
  diff: (oldValue, newValue) => diff3({
    oldValue,
    newValue,
    differ: differ4
  }),
  patch: (patch14, oldValue) => patch3(oldValue, differ4)(patch14)
});
var hashSet = () => make20({
  empty: empty16(),
  combine: (first5, second) => combine9(second)(first5),
  diff: (oldValue, newValue) => diff4(oldValue, newValue),
  patch: (patch14, oldValue) => patch4(oldValue)(patch14)
});
var orElseEither2 = dual(2, (self, that) => make20({
  empty: empty17(),
  combine: (first5, second) => combine10(first5, second),
  diff: (oldValue, newValue) => diff5({
    oldValue,
    newValue,
    left: self,
    right: that
  }),
  patch: (patch14, oldValue) => patch5(patch14, {
    oldValue,
    left: self,
    right: that
  })
}));
var readonlyArray = (differ4) => make20({
  empty: empty18(),
  combine: (first5, second) => combine11(first5, second),
  diff: (oldValue, newValue) => diff6({
    oldValue,
    newValue,
    differ: differ4
  }),
  patch: (patch14, oldValue) => patch6(patch14, oldValue, differ4)
});
var transform = dual(2, (self, {
  toNew,
  toOld
}) => make20({
  empty: self.empty,
  combine: (first5, second) => self.combine(first5, second),
  diff: (oldValue, newValue) => self.diff(toOld(oldValue), toOld(newValue)),
  patch: (patch14, oldValue) => toNew(self.patch(patch14, toOld(oldValue)))
}));
var update2 = () => updateWith((_, a) => a);
var updateWith = (f) => make20({
  empty: identity,
  combine: (first5, second) => {
    if (first5 === identity) {
      return second;
    }
    if (second === identity) {
      return first5;
    }
    return (a) => second(first5(a));
  },
  diff: (oldValue, newValue) => {
    if (equals(oldValue, newValue)) {
      return identity;
    }
    return constant(newValue);
  },
  patch: (patch14, oldValue) => f(oldValue, patch14(oldValue))
});
var zip4 = dual(2, (self, that) => make20({
  empty: [self.empty, that.empty],
  combine: (first5, second) => [self.combine(first5[0], second[0]), that.combine(first5[1], second[1])],
  diff: (oldValue, newValue) => [self.diff(oldValue[0], newValue[0]), that.diff(oldValue[1], newValue[1])],
  patch: (patch14, oldValue) => [self.patch(patch14[0], oldValue[0]), that.patch(patch14[1], oldValue[1])]
}));

// ../../node_modules/effect/dist/esm/internal/runtimeFlagsPatch.js
var BIT_MASK = 255;
var BIT_SHIFT = 8;
var active = (patch14) => patch14 & BIT_MASK;
var enabled = (patch14) => patch14 >> BIT_SHIFT & BIT_MASK;
var make21 = (active2, enabled2) => (active2 & BIT_MASK) + ((enabled2 & active2 & BIT_MASK) << BIT_SHIFT);
var empty19 = make21(0, 0);
var enable = (flag) => make21(flag, flag);
var disable = (flag) => make21(flag, 0);
var isEmpty5 = (patch14) => patch14 === 0;
var isActive = dual(2, (self, flag) => (active(self) & flag) !== 0);
var isEnabled = dual(2, (self, flag) => (enabled(self) & flag) !== 0);
var isDisabled = dual(2, (self, flag) => (active(self) & flag) !== 0 && (enabled(self) & flag) === 0);
var exclude = dual(2, (self, flag) => make21(active(self) & ~flag, enabled(self)));
var both = dual(2, (self, that) => make21(active(self) | active(that), enabled(self) & enabled(that)));
var either = dual(2, (self, that) => make21(active(self) | active(that), enabled(self) | enabled(that)));
var andThen3 = dual(2, (self, that) => self | that);
var inverse = (patch14) => make21(enabled(patch14), invert(active(patch14)));
var invert = (n) => ~n >>> 0 & BIT_MASK;

// ../../node_modules/effect/dist/esm/internal/runtimeFlags.js
var None2 = 0;
var Interruption = 1 << 0;
var OpSupervision = 1 << 1;
var RuntimeMetrics = 1 << 2;
var WindDown = 1 << 4;
var CooperativeYielding = 1 << 5;
var allFlags = [None2, Interruption, OpSupervision, RuntimeMetrics, WindDown, CooperativeYielding];
var print = (flag) => {
  switch (flag) {
    case CooperativeYielding: {
      return "CooperativeYielding";
    }
    case WindDown: {
      return "WindDown";
    }
    case RuntimeMetrics: {
      return "RuntimeMetrics";
    }
    case OpSupervision: {
      return "OpSupervision";
    }
    case Interruption: {
      return "Interruption";
    }
    case None2: {
      return "None";
    }
  }
};
var cooperativeYielding = (self) => isEnabled2(self, CooperativeYielding);
var disable2 = dual(2, (self, flag) => self & ~flag);
var disableAll = dual(2, (self, flags) => self & ~flags);
var enable2 = dual(2, (self, flag) => self | flag);
var enableAll = dual(2, (self, flags) => self | flags);
var interruptible = (self) => interruption(self) && !windDown(self);
var interruption = (self) => isEnabled2(self, Interruption);
var isDisabled2 = dual(2, (self, flag) => !isEnabled2(self, flag));
var isEnabled2 = dual(2, (self, flag) => (self & flag) !== 0);
var make22 = (...flags) => flags.reduce((a, b) => a | b, 0);
var none5 = make22(None2);
var opSupervision = (self) => isEnabled2(self, OpSupervision);
var render = (self) => {
  const active2 = [];
  allFlags.forEach((flag) => {
    if (isEnabled2(self, flag)) {
      active2.push(`${print(flag)}`);
    }
  });
  return `RuntimeFlags(${active2.join(", ")})`;
};
var runtimeMetrics = (self) => isEnabled2(self, RuntimeMetrics);
var toSet3 = (self) => new Set(allFlags.filter((flag) => isEnabled2(self, flag)));
var windDown = (self) => isEnabled2(self, WindDown);
var enabledSet = (self) => toSet3(active(self) & enabled(self));
var disabledSet = (self) => toSet3(active(self) & ~enabled(self));
var diff7 = dual(2, (self, that) => make21(self ^ that, that));
var patch7 = dual(2, (self, patch14) => self & (invert(active(patch14)) | enabled(patch14)) | active(patch14) & enabled(patch14));
var renderPatch = (self) => {
  const enabled2 = Array.from(enabledSet(self)).map((flag) => print(flag)).join(", ");
  const disabled = Array.from(disabledSet(self)).map((flag) => print(flag)).join(", ");
  return `RuntimeFlagsPatch(enabled = (${enabled2}), disabled = (${disabled}))`;
};
var differ = make20({
  empty: empty19,
  diff: (oldValue, newValue) => diff7(oldValue, newValue),
  combine: (first5, second) => andThen3(second)(first5),
  patch: (_patch, oldValue) => patch7(oldValue, _patch)
});

// ../../node_modules/effect/dist/esm/RuntimeFlagsPatch.js
var empty20 = empty19;
var make23 = make21;
var enable3 = enable;
var disable3 = disable;
var isEmpty6 = isEmpty5;
var isActive2 = isActive;
var isEnabled3 = isEnabled;
var isDisabled3 = isDisabled;
var includes = isActive;
var andThen4 = andThen3;
var both2 = both;
var either2 = either;
var exclude2 = exclude;
var inverse2 = inverse;
var enabledSet2 = enabledSet;
var disabledSet2 = disabledSet;
var render2 = renderPatch;

// ../../node_modules/effect/dist/esm/internal/blockedRequests.js
var empty21 = {
  _tag: "Empty"
};
var par = (self, that) => ({
  _tag: "Par",
  left: self,
  right: that
});
var seq = (self, that) => ({
  _tag: "Seq",
  left: self,
  right: that
});
var single = (dataSource, blockedRequest) => ({
  _tag: "Single",
  dataSource,
  blockedRequest
});
var MapRequestResolversReducer = (f) => ({
  emptyCase: () => empty21,
  parCase: (left3, right3) => par(left3, right3),
  seqCase: (left3, right3) => seq(left3, right3),
  singleCase: (dataSource, blockedRequest) => single(f(dataSource), blockedRequest)
});
var mapRequestResolvers = (self, f) => reduce10(self, MapRequestResolversReducer(f));
var reduce10 = (self, reducer) => {
  let input = of4(self);
  let output = empty12();
  while (isCons(input)) {
    const current2 = input.head;
    switch (current2._tag) {
      case "Empty": {
        output = cons(right2(reducer.emptyCase()), output);
        input = input.tail;
        break;
      }
      case "Par": {
        output = cons(left2({
          _tag: "ParCase"
        }), output);
        input = cons(current2.left, cons(current2.right, input.tail));
        break;
      }
      case "Seq": {
        output = cons(left2({
          _tag: "SeqCase"
        }), output);
        input = cons(current2.left, cons(current2.right, input.tail));
        break;
      }
      case "Single": {
        const result2 = reducer.singleCase(current2.dataSource, current2.blockedRequest);
        output = cons(right2(result2), output);
        input = input.tail;
        break;
      }
    }
  }
  const result = reduce9(output, empty12(), (acc, current2) => {
    switch (current2._tag) {
      case "Left": {
        const left3 = unsafeHead3(acc);
        const right3 = unsafeHead3(unsafeTail(acc));
        const tail5 = unsafeTail(unsafeTail(acc));
        switch (current2.left._tag) {
          case "ParCase": {
            return cons(reducer.parCase(left3, right3), tail5);
          }
          case "SeqCase": {
            return cons(reducer.seqCase(left3, right3), tail5);
          }
        }
      }
      case "Right": {
        return cons(current2.right, acc);
      }
    }
  });
  if (isNil(result)) {
    throw new Error("BUG: BlockedRequests.reduce - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  return result.head;
};
var flatten6 = (self) => {
  let current2 = of4(self);
  let updated = empty12();
  while (1) {
    const [parallel6, sequential6] = reduce9(current2, [parallelCollectionEmpty(), empty12()], ([parallel7, sequential7], blockedRequest) => {
      const [par2, seq2] = step(blockedRequest);
      return [parallelCollectionCombine(parallel7, par2), appendAll4(sequential7, seq2)];
    });
    updated = merge4(updated, parallel6);
    if (isNil(sequential6)) {
      return reverse4(updated);
    }
    current2 = sequential6;
  }
  throw new Error("BUG: BlockedRequests.flatten - please report an issue at https://github.com/Effect-TS/effect/issues");
};
var step = (requests) => {
  let current2 = requests;
  let parallel6 = parallelCollectionEmpty();
  let stack = empty12();
  let sequential6 = empty12();
  while (1) {
    switch (current2._tag) {
      case "Empty": {
        if (isNil(stack)) {
          return [parallel6, sequential6];
        }
        current2 = stack.head;
        stack = stack.tail;
        break;
      }
      case "Par": {
        stack = cons(current2.right, stack);
        current2 = current2.left;
        break;
      }
      case "Seq": {
        const left3 = current2.left;
        const right3 = current2.right;
        switch (left3._tag) {
          case "Empty": {
            current2 = right3;
            break;
          }
          case "Par": {
            const l = left3.left;
            const r = left3.right;
            current2 = par(seq(l, right3), seq(r, right3));
            break;
          }
          case "Seq": {
            const l = left3.left;
            const r = left3.right;
            current2 = seq(l, seq(r, right3));
            break;
          }
          case "Single": {
            current2 = left3;
            sequential6 = cons(right3, sequential6);
            break;
          }
        }
        break;
      }
      case "Single": {
        parallel6 = parallelCollectionAdd(parallel6, current2);
        if (isNil(stack)) {
          return [parallel6, sequential6];
        }
        current2 = stack.head;
        stack = stack.tail;
        break;
      }
    }
  }
  throw new Error("BUG: BlockedRequests.step - please report an issue at https://github.com/Effect-TS/effect/issues");
};
var merge4 = (sequential6, parallel6) => {
  if (isNil(sequential6)) {
    return of4(parallelCollectionToSequentialCollection(parallel6));
  }
  if (parallelCollectionIsEmpty(parallel6)) {
    return sequential6;
  }
  const seqHeadKeys = sequentialCollectionKeys(sequential6.head);
  const parKeys = parallelCollectionKeys(parallel6);
  if (seqHeadKeys.length === 1 && parKeys.length === 1 && equals(seqHeadKeys[0], parKeys[0])) {
    return cons(sequentialCollectionCombine(sequential6.head, parallelCollectionToSequentialCollection(parallel6)), sequential6.tail);
  }
  return cons(parallelCollectionToSequentialCollection(parallel6), sequential6);
};
var EntryTypeId = Symbol.for("effect/RequestBlock/Entry");
var EntryImpl = class {
  request;
  result;
  listeners;
  ownerId;
  state;
  [EntryTypeId] = blockedRequestVariance;
  constructor(request2, result, listeners, ownerId, state) {
    this.request = request2;
    this.result = result;
    this.listeners = listeners;
    this.ownerId = ownerId;
    this.state = state;
  }
};
var blockedRequestVariance = {
  /* c8 ignore next */
  _R: (_) => _
};
var isEntry = (u) => hasProperty(u, EntryTypeId);
var makeEntry = (options) => new EntryImpl(options.request, options.result, options.listeners, options.ownerId, options.state);
var RequestBlockParallelTypeId = Symbol.for("effect/RequestBlock/RequestBlockParallel");
var parallelVariance = {
  /* c8 ignore next */
  _R: (_) => _
};
var ParallelImpl = class {
  map;
  [RequestBlockParallelTypeId] = parallelVariance;
  constructor(map49) {
    this.map = map49;
  }
};
var parallelCollectionEmpty = () => new ParallelImpl(empty11());
var parallelCollectionAdd = (self, blockedRequest) => new ParallelImpl(modifyAt2(self.map, blockedRequest.dataSource, (_) => orElseSome(map2(_, append3(blockedRequest.blockedRequest)), () => of3(blockedRequest.blockedRequest))));
var parallelCollectionCombine = (self, that) => new ParallelImpl(reduce8(self.map, that.map, (map49, value10, key) => set4(map49, key, match2(get8(map49, key), {
  onNone: () => value10,
  onSome: (other) => appendAll3(value10, other)
}))));
var parallelCollectionIsEmpty = (self) => isEmpty4(self.map);
var parallelCollectionKeys = (self) => Array.from(keys3(self.map));
var parallelCollectionToSequentialCollection = (self) => sequentialCollectionMake(map11(self.map, (x) => of3(x)));
var SequentialCollectionTypeId = Symbol.for("effect/RequestBlock/RequestBlockSequential");
var sequentialVariance = {
  /* c8 ignore next */
  _R: (_) => _
};
var SequentialImpl = class {
  map;
  [SequentialCollectionTypeId] = sequentialVariance;
  constructor(map49) {
    this.map = map49;
  }
};
var sequentialCollectionMake = (map49) => new SequentialImpl(map49);
var sequentialCollectionCombine = (self, that) => new SequentialImpl(reduce8(that.map, self.map, (map49, value10, key) => set4(map49, key, match2(get8(map49, key), {
  onNone: () => empty7(),
  onSome: (a) => appendAll3(a, value10)
}))));
var sequentialCollectionKeys = (self) => Array.from(keys3(self.map));
var sequentialCollectionToChunk = (self) => Array.from(self.map);

// ../../node_modules/effect/dist/esm/internal/opCodes/cause.js
var OP_DIE = "Die";
var OP_EMPTY = "Empty";
var OP_FAIL = "Fail";
var OP_INTERRUPT = "Interrupt";
var OP_PARALLEL = "Parallel";
var OP_SEQUENTIAL = "Sequential";

// ../../node_modules/effect/dist/esm/internal/cause.js
var CauseSymbolKey = "effect/Cause";
var CauseTypeId = Symbol.for(CauseSymbolKey);
var variance7 = {
  /* c8 ignore next */
  _E: (_) => _
};
var proto = {
  [CauseTypeId]: variance7,
  [symbol2]() {
    return pipe(hash(CauseSymbolKey), combine2(hash(flattenCause(this))), cached(this));
  },
  [symbol3](that) {
    return isCause(that) && causeEquals(this, that);
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toJSON() {
    switch (this._tag) {
      case "Empty":
        return {
          _id: "Cause",
          _tag: this._tag
        };
      case "Die":
        return {
          _id: "Cause",
          _tag: this._tag,
          defect: toJSON(this.defect)
        };
      case "Interrupt":
        return {
          _id: "Cause",
          _tag: this._tag,
          fiberId: this.fiberId.toJSON()
        };
      case "Fail":
        return {
          _id: "Cause",
          _tag: this._tag,
          failure: toJSON(this.error)
        };
      case "Sequential":
      case "Parallel":
        return {
          _id: "Cause",
          _tag: this._tag,
          left: toJSON(this.left),
          right: toJSON(this.right)
        };
    }
  },
  toString() {
    return pretty(this);
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var empty22 = (() => {
  const o = Object.create(proto);
  o._tag = OP_EMPTY;
  return o;
})();
var fail = (error4) => {
  const o = Object.create(proto);
  o._tag = OP_FAIL;
  o.error = error4;
  return o;
};
var die = (defect) => {
  const o = Object.create(proto);
  o._tag = OP_DIE;
  o.defect = defect;
  return o;
};
var interrupt = (fiberId5) => {
  const o = Object.create(proto);
  o._tag = OP_INTERRUPT;
  o.fiberId = fiberId5;
  return o;
};
var parallel = (left3, right3) => {
  const o = Object.create(proto);
  o._tag = OP_PARALLEL;
  o.left = left3;
  o.right = right3;
  return o;
};
var sequential = (left3, right3) => {
  const o = Object.create(proto);
  o._tag = OP_SEQUENTIAL;
  o.left = left3;
  o.right = right3;
  return o;
};
var isCause = (u) => hasProperty(u, CauseTypeId);
var isEmptyType = (self) => self._tag === OP_EMPTY;
var isFailType = (self) => self._tag === OP_FAIL;
var isDieType = (self) => self._tag === OP_DIE;
var isInterruptType = (self) => self._tag === OP_INTERRUPT;
var isSequentialType = (self) => self._tag === OP_SEQUENTIAL;
var isParallelType = (self) => self._tag === OP_PARALLEL;
var size9 = (self) => reduceWithContext(self, void 0, SizeCauseReducer);
var isEmpty7 = (self) => {
  if (self._tag === OP_EMPTY) {
    return true;
  }
  return reduce11(self, true, (acc, cause3) => {
    switch (cause3._tag) {
      case OP_EMPTY: {
        return some3(acc);
      }
      case OP_DIE:
      case OP_FAIL:
      case OP_INTERRUPT: {
        return some3(false);
      }
      default: {
        return none2();
      }
    }
  });
};
var isFailure = (self) => isSome2(failureOption(self));
var isDie = (self) => isSome2(dieOption(self));
var isInterrupted = (self) => isSome2(interruptOption(self));
var isInterruptedOnly = (self) => reduceWithContext(void 0, IsInterruptedOnlyCauseReducer)(self);
var failures = (self) => reverse3(reduce11(self, empty7(), (list, cause3) => cause3._tag === OP_FAIL ? some3(pipe(list, prepend3(cause3.error))) : none2()));
var defects = (self) => reverse3(reduce11(self, empty7(), (list, cause3) => cause3._tag === OP_DIE ? some3(pipe(list, prepend3(cause3.defect))) : none2()));
var interruptors = (self) => reduce11(self, empty10(), (set26, cause3) => cause3._tag === OP_INTERRUPT ? some3(pipe(set26, add4(cause3.fiberId))) : none2());
var failureOption = (self) => find(self, (cause3) => cause3._tag === OP_FAIL ? some3(cause3.error) : none2());
var failureOrCause = (self) => {
  const option11 = failureOption(self);
  switch (option11._tag) {
    case "None": {
      return right2(self);
    }
    case "Some": {
      return left2(option11.value);
    }
  }
};
var dieOption = (self) => find(self, (cause3) => cause3._tag === OP_DIE ? some3(cause3.defect) : none2());
var flipCauseOption = (self) => match6(self, {
  onEmpty: some3(empty22),
  onFail: map2(fail),
  onDie: (defect) => some3(die(defect)),
  onInterrupt: (fiberId5) => some3(interrupt(fiberId5)),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
});
var interruptOption = (self) => find(self, (cause3) => cause3._tag === OP_INTERRUPT ? some3(cause3.fiberId) : none2());
var keepDefects = (self) => match6(self, {
  onEmpty: none2(),
  onFail: () => none2(),
  onDie: (defect) => some3(die(defect)),
  onInterrupt: () => none2(),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
});
var keepDefectsAndElectFailures = (self) => match6(self, {
  onEmpty: none2(),
  onFail: (failure) => some3(die(failure)),
  onDie: (defect) => some3(die(defect)),
  onInterrupt: () => none2(),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
});
var linearize = (self) => match6(self, {
  onEmpty: empty10(),
  onFail: (error4) => make14(fail(error4)),
  onDie: (defect) => make14(die(defect)),
  onInterrupt: (fiberId5) => make14(interrupt(fiberId5)),
  onSequential: (leftSet, rightSet) => flatMap8(leftSet, (leftCause) => map10(rightSet, (rightCause) => sequential(leftCause, rightCause))),
  onParallel: (leftSet, rightSet) => flatMap8(leftSet, (leftCause) => map10(rightSet, (rightCause) => parallel(leftCause, rightCause)))
});
var stripFailures = (self) => match6(self, {
  onEmpty: empty22,
  onFail: () => empty22,
  onDie: die,
  onInterrupt: interrupt,
  onSequential: sequential,
  onParallel: parallel
});
var electFailures = (self) => match6(self, {
  onEmpty: empty22,
  onFail: die,
  onDie: die,
  onInterrupt: interrupt,
  onSequential: sequential,
  onParallel: parallel
});
var stripSomeDefects = dual(2, (self, pf) => match6(self, {
  onEmpty: some3(empty22),
  onFail: (error4) => some3(fail(error4)),
  onDie: (defect) => {
    const option11 = pf(defect);
    return isSome2(option11) ? none2() : some3(die(defect));
  },
  onInterrupt: (fiberId5) => some3(interrupt(fiberId5)),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
}));
var as2 = dual(2, (self, error4) => map13(self, () => error4));
var map13 = dual(2, (self, f) => flatMap11(self, (e) => fail(f(e))));
var flatMap11 = dual(2, (self, f) => match6(self, {
  onEmpty: empty22,
  onFail: (error4) => f(error4),
  onDie: (defect) => die(defect),
  onInterrupt: (fiberId5) => interrupt(fiberId5),
  onSequential: (left3, right3) => sequential(left3, right3),
  onParallel: (left3, right3) => parallel(left3, right3)
}));
var flatten7 = (self) => flatMap11(self, identity);
var andThen5 = dual(2, (self, f) => isFunction2(f) ? flatMap11(self, f) : flatMap11(self, () => f));
var contains5 = dual(2, (self, that) => {
  if (that._tag === OP_EMPTY || self === that) {
    return true;
  }
  return reduce11(self, false, (accumulator, cause3) => {
    return some3(accumulator || causeEquals(cause3, that));
  });
});
var causeEquals = (left3, right3) => {
  let leftStack = of3(left3);
  let rightStack = of3(right3);
  while (isNonEmpty2(leftStack) && isNonEmpty2(rightStack)) {
    const [leftParallel, leftSequential] = pipe(headNonEmpty2(leftStack), reduce11([empty10(), empty7()], ([parallel6, sequential6], cause3) => {
      const [par2, seq2] = evaluateCause(cause3);
      return some3([pipe(parallel6, union6(par2)), pipe(sequential6, appendAll3(seq2))]);
    }));
    const [rightParallel, rightSequential] = pipe(headNonEmpty2(rightStack), reduce11([empty10(), empty7()], ([parallel6, sequential6], cause3) => {
      const [par2, seq2] = evaluateCause(cause3);
      return some3([pipe(parallel6, union6(par2)), pipe(sequential6, appendAll3(seq2))]);
    }));
    if (!equals(leftParallel, rightParallel)) {
      return false;
    }
    leftStack = leftSequential;
    rightStack = rightSequential;
  }
  return true;
};
var flattenCause = (cause3) => {
  return flattenCauseLoop(of3(cause3), empty7());
};
var flattenCauseLoop = (causes, flattened) => {
  while (1) {
    const [parallel6, sequential6] = pipe(causes, reduce3([empty10(), empty7()], ([parallel7, sequential7], cause3) => {
      const [par2, seq2] = evaluateCause(cause3);
      return [pipe(parallel7, union6(par2)), pipe(sequential7, appendAll3(seq2))];
    }));
    const updated = size6(parallel6) > 0 ? pipe(flattened, prepend3(parallel6)) : flattened;
    if (isEmpty2(sequential6)) {
      return reverse3(updated);
    }
    causes = sequential6;
    flattened = updated;
  }
  throw new Error(getBugErrorMessage("Cause.flattenCauseLoop"));
};
var find = dual(2, (self, pf) => {
  const stack = [self];
  while (stack.length > 0) {
    const item = stack.pop();
    const option11 = pf(item);
    switch (option11._tag) {
      case "None": {
        switch (item._tag) {
          case OP_SEQUENTIAL:
          case OP_PARALLEL: {
            stack.push(item.right);
            stack.push(item.left);
            break;
          }
        }
        break;
      }
      case "Some": {
        return option11;
      }
    }
  }
  return none2();
});
var filter11 = dual(2, (self, predicate) => reduceWithContext(self, void 0, FilterCauseReducer(predicate)));
var evaluateCause = (self) => {
  let cause3 = self;
  const stack = [];
  let _parallel = empty10();
  let _sequential = empty7();
  while (cause3 !== void 0) {
    switch (cause3._tag) {
      case OP_EMPTY: {
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause3 = stack.pop();
        break;
      }
      case OP_FAIL: {
        _parallel = add4(_parallel, make9(cause3._tag, cause3.error));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause3 = stack.pop();
        break;
      }
      case OP_DIE: {
        _parallel = add4(_parallel, make9(cause3._tag, cause3.defect));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause3 = stack.pop();
        break;
      }
      case OP_INTERRUPT: {
        _parallel = add4(_parallel, make9(cause3._tag, cause3.fiberId));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause3 = stack.pop();
        break;
      }
      case OP_SEQUENTIAL: {
        switch (cause3.left._tag) {
          case OP_EMPTY: {
            cause3 = cause3.right;
            break;
          }
          case OP_SEQUENTIAL: {
            cause3 = sequential(cause3.left.left, sequential(cause3.left.right, cause3.right));
            break;
          }
          case OP_PARALLEL: {
            cause3 = parallel(sequential(cause3.left.left, cause3.right), sequential(cause3.left.right, cause3.right));
            break;
          }
          default: {
            _sequential = prepend3(_sequential, cause3.right);
            cause3 = cause3.left;
            break;
          }
        }
        break;
      }
      case OP_PARALLEL: {
        stack.push(cause3.right);
        cause3 = cause3.left;
        break;
      }
    }
  }
  throw new Error(getBugErrorMessage("Cause.evaluateCauseLoop"));
};
var SizeCauseReducer = {
  emptyCase: () => 0,
  failCase: () => 1,
  dieCase: () => 1,
  interruptCase: () => 1,
  sequentialCase: (_, left3, right3) => left3 + right3,
  parallelCase: (_, left3, right3) => left3 + right3
};
var IsInterruptedOnlyCauseReducer = {
  emptyCase: constTrue,
  failCase: constFalse,
  dieCase: constFalse,
  interruptCase: constTrue,
  sequentialCase: (_, left3, right3) => left3 && right3,
  parallelCase: (_, left3, right3) => left3 && right3
};
var FilterCauseReducer = (predicate) => ({
  emptyCase: () => empty22,
  failCase: (_, error4) => fail(error4),
  dieCase: (_, defect) => die(defect),
  interruptCase: (_, fiberId5) => interrupt(fiberId5),
  sequentialCase: (_, left3, right3) => {
    if (predicate(left3)) {
      if (predicate(right3)) {
        return sequential(left3, right3);
      }
      return left3;
    }
    if (predicate(right3)) {
      return right3;
    }
    return empty22;
  },
  parallelCase: (_, left3, right3) => {
    if (predicate(left3)) {
      if (predicate(right3)) {
        return parallel(left3, right3);
      }
      return left3;
    }
    if (predicate(right3)) {
      return right3;
    }
    return empty22;
  }
});
var OP_SEQUENTIAL_CASE = "SequentialCase";
var OP_PARALLEL_CASE = "ParallelCase";
var match6 = dual(2, (self, {
  onDie,
  onEmpty,
  onFail,
  onInterrupt: onInterrupt4,
  onParallel,
  onSequential
}) => {
  return reduceWithContext(self, void 0, {
    emptyCase: () => onEmpty,
    failCase: (_, error4) => onFail(error4),
    dieCase: (_, defect) => onDie(defect),
    interruptCase: (_, fiberId5) => onInterrupt4(fiberId5),
    sequentialCase: (_, left3, right3) => onSequential(left3, right3),
    parallelCase: (_, left3, right3) => onParallel(left3, right3)
  });
});
var reduce11 = dual(3, (self, zero3, pf) => {
  let accumulator = zero3;
  let cause3 = self;
  const causes = [];
  while (cause3 !== void 0) {
    const option11 = pf(accumulator, cause3);
    accumulator = isSome2(option11) ? option11.value : accumulator;
    switch (cause3._tag) {
      case OP_SEQUENTIAL: {
        causes.push(cause3.right);
        cause3 = cause3.left;
        break;
      }
      case OP_PARALLEL: {
        causes.push(cause3.right);
        cause3 = cause3.left;
        break;
      }
      default: {
        cause3 = void 0;
        break;
      }
    }
    if (cause3 === void 0 && causes.length > 0) {
      cause3 = causes.pop();
    }
  }
  return accumulator;
});
var reduceWithContext = dual(3, (self, context15, reducer) => {
  const input = [self];
  const output = [];
  while (input.length > 0) {
    const cause3 = input.pop();
    switch (cause3._tag) {
      case OP_EMPTY: {
        output.push(right2(reducer.emptyCase(context15)));
        break;
      }
      case OP_FAIL: {
        output.push(right2(reducer.failCase(context15, cause3.error)));
        break;
      }
      case OP_DIE: {
        output.push(right2(reducer.dieCase(context15, cause3.defect)));
        break;
      }
      case OP_INTERRUPT: {
        output.push(right2(reducer.interruptCase(context15, cause3.fiberId)));
        break;
      }
      case OP_SEQUENTIAL: {
        input.push(cause3.right);
        input.push(cause3.left);
        output.push(left2({
          _tag: OP_SEQUENTIAL_CASE
        }));
        break;
      }
      case OP_PARALLEL: {
        input.push(cause3.right);
        input.push(cause3.left);
        output.push(left2({
          _tag: OP_PARALLEL_CASE
        }));
        break;
      }
    }
  }
  const accumulator = [];
  while (output.length > 0) {
    const either14 = output.pop();
    switch (either14._tag) {
      case "Left": {
        switch (either14.left._tag) {
          case OP_SEQUENTIAL_CASE: {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value10 = reducer.sequentialCase(context15, left3, right3);
            accumulator.push(value10);
            break;
          }
          case OP_PARALLEL_CASE: {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value10 = reducer.parallelCase(context15, left3, right3);
            accumulator.push(value10);
            break;
          }
        }
        break;
      }
      case "Right": {
        accumulator.push(either14.right);
        break;
      }
    }
  }
  if (accumulator.length === 0) {
    throw new Error("BUG: Cause.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  return accumulator.pop();
});
var pretty = (cause3, options) => {
  if (isInterruptedOnly(cause3)) {
    return "All fibers interrupted without errors.";
  }
  return prettyErrors(cause3).map(function(e) {
    if (options?.renderErrorCause !== true || e.cause === void 0) {
      return e.stack;
    }
    return `${e.stack} {
${renderErrorCause(e.cause, "  ")}
}`;
  }).join("\n");
};
var renderErrorCause = (cause3, prefix) => {
  const lines = cause3.stack.split("\n");
  let stack = `${prefix}[cause]: ${lines[0]}`;
  for (let i = 1, len = lines.length; i < len; i++) {
    stack += `
${prefix}${lines[i]}`;
  }
  if (cause3.cause) {
    stack += ` {
${renderErrorCause(cause3.cause, `${prefix}  `)}
${prefix}}`;
  }
  return stack;
};
var PrettyError = class _PrettyError extends globalThis.Error {
  span = void 0;
  constructor(originalError2) {
    const originalErrorIsObject = typeof originalError2 === "object" && originalError2 !== null;
    const prevLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = 1;
    super(prettyErrorMessage(originalError2), originalErrorIsObject && "cause" in originalError2 && typeof originalError2.cause !== "undefined" ? {
      cause: new _PrettyError(originalError2.cause)
    } : void 0);
    if (this.message === "") {
      this.message = "An error has occurred";
    }
    Error.stackTraceLimit = prevLimit;
    this.name = originalError2 instanceof Error ? originalError2.name : "Error";
    if (originalErrorIsObject) {
      if (spanSymbol in originalError2) {
        this.span = originalError2[spanSymbol];
      }
      Object.keys(originalError2).forEach((key) => {
        if (!(key in this)) {
          this[key] = originalError2[key];
        }
      });
    }
    this.stack = prettyErrorStack(`${this.name}: ${this.message}`, originalError2 instanceof Error && originalError2.stack ? originalError2.stack : "", this.span);
  }
};
var prettyErrorMessage = (u) => {
  if (typeof u === "string") {
    return u;
  }
  if (typeof u === "object" && u !== null && u instanceof Error) {
    return u.message;
  }
  try {
    if (hasProperty(u, "toString") && isFunction2(u["toString"]) && u["toString"] !== Object.prototype.toString && u["toString"] !== globalThis.Array.prototype.toString) {
      return u["toString"]();
    }
  } catch {
  }
  return stringifyCircular(u);
};
var locationRegex = /\((.*)\)/g;
var spanToTrace = globalValue("effect/Tracer/spanToTrace", () => /* @__PURE__ */ new WeakMap());
var prettyErrorStack = (message, stack, span4) => {
  const out = [message];
  const lines = stack.startsWith(message) ? stack.slice(message.length).split("\n") : stack.split("\n");
  for (let i = 1; i < lines.length; i++) {
    if (lines[i].includes(" at new BaseEffectError") || lines[i].includes(" at new YieldableError")) {
      i++;
      continue;
    }
    if (lines[i].includes("Generator.next")) {
      break;
    }
    if (lines[i].includes("effect_internal_function")) {
      break;
    }
    out.push(lines[i].replace(/at .*effect_instruction_i.*\((.*)\)/, "at $1").replace(/EffectPrimitive\.\w+/, "<anonymous>"));
  }
  if (span4) {
    let current2 = span4;
    let i = 0;
    while (current2 && current2._tag === "Span" && i < 10) {
      const stackFn = spanToTrace.get(current2);
      if (typeof stackFn === "function") {
        const stack2 = stackFn();
        if (typeof stack2 === "string") {
          const locationMatchAll = stack2.matchAll(locationRegex);
          let match43 = false;
          for (const [, location] of locationMatchAll) {
            match43 = true;
            out.push(`    at ${current2.name} (${location})`);
          }
          if (!match43) {
            out.push(`    at ${current2.name} (${stack2.replace(/^at /, "")})`);
          }
        } else {
          out.push(`    at ${current2.name}`);
        }
      } else {
        out.push(`    at ${current2.name}`);
      }
      current2 = getOrUndefined2(current2.parent);
      i++;
    }
  }
  return out.join("\n");
};
var spanSymbol = Symbol.for("effect/SpanAnnotation");
var prettyErrors = (cause3) => reduceWithContext(cause3, void 0, {
  emptyCase: () => [],
  dieCase: (_, unknownError) => {
    return [new PrettyError(unknownError)];
  },
  failCase: (_, error4) => {
    return [new PrettyError(error4)];
  },
  interruptCase: () => [],
  parallelCase: (_, l, r) => [...l, ...r],
  sequentialCase: (_, l, r) => [...l, ...r]
});

// ../../node_modules/effect/dist/esm/internal/opCodes/deferred.js
var OP_STATE_PENDING = "Pending";
var OP_STATE_DONE = "Done";

// ../../node_modules/effect/dist/esm/internal/deferred.js
var DeferredSymbolKey = "effect/Deferred";
var DeferredTypeId = Symbol.for(DeferredSymbolKey);
var deferredVariance = {
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var pending = (joiners) => {
  return {
    _tag: OP_STATE_PENDING,
    joiners
  };
};
var done = (effect4) => {
  return {
    _tag: OP_STATE_DONE,
    effect: effect4
  };
};

// ../../node_modules/effect/dist/esm/internal/singleShotGen.js
var SingleShotGen2 = class _SingleShotGen {
  self;
  called = false;
  constructor(self) {
    this.self = self;
  }
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  return(a) {
    return {
      value: a,
      done: true
    };
  }
  throw(e) {
    throw e;
  }
  [Symbol.iterator]() {
    return new _SingleShotGen(this.self);
  }
};

// ../../node_modules/effect/dist/esm/internal/core.js
var blocked = (blockedRequests, _continue3) => {
  const effect4 = new EffectPrimitive("Blocked");
  effect4.effect_instruction_i0 = blockedRequests;
  effect4.effect_instruction_i1 = _continue3;
  return effect4;
};
var runRequestBlock = (blockedRequests) => {
  const effect4 = new EffectPrimitive("RunBlocked");
  effect4.effect_instruction_i0 = blockedRequests;
  return effect4;
};
var EffectTypeId2 = Symbol.for("effect/Effect");
var RevertFlags = class {
  patch;
  op;
  _op = OP_REVERT_FLAGS;
  constructor(patch14, op) {
    this.patch = patch14;
    this.op = op;
  }
};
var EffectPrimitive = class {
  _op;
  effect_instruction_i0 = void 0;
  effect_instruction_i1 = void 0;
  effect_instruction_i2 = void 0;
  trace = void 0;
  [EffectTypeId2] = effectVariance;
  constructor(_op) {
    this._op = _op;
  }
  [symbol3](that) {
    return this === that;
  }
  [symbol2]() {
    return cached(this, random(this));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Effect",
      _op: this._op,
      effect_instruction_i0: toJSON(this.effect_instruction_i0),
      effect_instruction_i1: toJSON(this.effect_instruction_i1),
      effect_instruction_i2: toJSON(this.effect_instruction_i2)
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
};
var EffectPrimitiveFailure = class {
  _op;
  effect_instruction_i0 = void 0;
  effect_instruction_i1 = void 0;
  effect_instruction_i2 = void 0;
  trace = void 0;
  [EffectTypeId2] = effectVariance;
  constructor(_op) {
    this._op = _op;
    this._tag = _op;
  }
  [symbol3](that) {
    return exitIsExit(that) && that._op === "Failure" && // @ts-expect-error
    equals(this.effect_instruction_i0, that.effect_instruction_i0);
  }
  [symbol2]() {
    return pipe(
      // @ts-expect-error
      string2(this._tag),
      // @ts-expect-error
      combine2(hash(this.effect_instruction_i0)),
      cached(this)
    );
  }
  get cause() {
    return this.effect_instruction_i0;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Exit",
      _tag: this._op,
      cause: this.cause.toJSON()
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
};
var EffectPrimitiveSuccess = class {
  _op;
  effect_instruction_i0 = void 0;
  effect_instruction_i1 = void 0;
  effect_instruction_i2 = void 0;
  trace = void 0;
  [EffectTypeId2] = effectVariance;
  constructor(_op) {
    this._op = _op;
    this._tag = _op;
  }
  [symbol3](that) {
    return exitIsExit(that) && that._op === "Success" && // @ts-expect-error
    equals(this.effect_instruction_i0, that.effect_instruction_i0);
  }
  [symbol2]() {
    return pipe(
      // @ts-expect-error
      string2(this._tag),
      // @ts-expect-error
      combine2(hash(this.effect_instruction_i0)),
      cached(this)
    );
  }
  get value() {
    return this.effect_instruction_i0;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Exit",
      _tag: this._op,
      value: toJSON(this.value)
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
};
var isEffect = (u) => hasProperty(u, EffectTypeId2);
var withFiberRuntime = (withRuntime) => {
  const effect4 = new EffectPrimitive(OP_WITH_RUNTIME);
  effect4.effect_instruction_i0 = withRuntime;
  return effect4;
};
var acquireUseRelease = dual(3, (acquire4, use2, release4) => uninterruptibleMask((restore) => flatMap12(acquire4, (a) => flatMap12(exit(suspend(() => restore(use2(a)))), (exit4) => {
  return suspend(() => release4(a, exit4)).pipe(matchCauseEffect({
    onFailure: (cause3) => {
      switch (exit4._tag) {
        case OP_FAILURE:
          return failCause(sequential(exit4.effect_instruction_i0, cause3));
        case OP_SUCCESS:
          return failCause(cause3);
      }
    },
    onSuccess: () => exit4
  }));
}))));
var as3 = dual(2, (self, value10) => flatMap12(self, () => succeed(value10)));
var asVoid2 = (self) => as3(self, void 0);
var custom = function() {
  const wrapper = new EffectPrimitive(OP_COMMIT);
  switch (arguments.length) {
    case 2: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.commit = arguments[1];
      break;
    }
    case 3: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.effect_instruction_i1 = arguments[1];
      wrapper.commit = arguments[2];
      break;
    }
    case 4: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.effect_instruction_i1 = arguments[1];
      wrapper.effect_instruction_i2 = arguments[2];
      wrapper.commit = arguments[3];
      break;
    }
    default: {
      throw new Error(getBugErrorMessage("you're not supposed to end up here"));
    }
  }
  return wrapper;
};
var unsafeAsync = (register, blockingOn = none4) => {
  const effect4 = new EffectPrimitive(OP_ASYNC);
  let cancelerRef = void 0;
  effect4.effect_instruction_i0 = (resume2) => {
    cancelerRef = register(resume2);
  };
  effect4.effect_instruction_i1 = blockingOn;
  return onInterrupt(effect4, (_) => isEffect(cancelerRef) ? cancelerRef : void_3);
};
var asyncInterrupt = (register, blockingOn = none4) => suspend(() => unsafeAsync(register, blockingOn));
var async_ = (resume2, blockingOn = none4) => {
  return custom(resume2, function() {
    let backingResume = void 0;
    let pendingEffect = void 0;
    function proxyResume(effect5) {
      if (backingResume) {
        backingResume(effect5);
      } else if (pendingEffect === void 0) {
        pendingEffect = effect5;
      }
    }
    const effect4 = new EffectPrimitive(OP_ASYNC);
    effect4.effect_instruction_i0 = (resume3) => {
      backingResume = resume3;
      if (pendingEffect) {
        resume3(pendingEffect);
      }
    };
    effect4.effect_instruction_i1 = blockingOn;
    let cancelerRef = void 0;
    let controllerRef = void 0;
    if (this.effect_instruction_i0.length !== 1) {
      controllerRef = new AbortController();
      cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume, controllerRef.signal));
    } else {
      cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume));
    }
    return cancelerRef || controllerRef ? onInterrupt(effect4, (_) => {
      if (controllerRef) {
        controllerRef.abort();
      }
      return cancelerRef ?? void_3;
    }) : effect4;
  });
};
var catchAllCause = dual(2, (self, f) => {
  const effect4 = new EffectPrimitive(OP_ON_FAILURE);
  effect4.effect_instruction_i0 = self;
  effect4.effect_instruction_i1 = f;
  return effect4;
});
var catchAll = dual(2, (self, f) => matchEffect(self, {
  onFailure: f,
  onSuccess: succeed
}));
var catchIf = dual(3, (self, predicate, f) => catchAllCause(self, (cause3) => {
  const either14 = failureOrCause(cause3);
  switch (either14._tag) {
    case "Left":
      return predicate(either14.left) ? f(either14.left) : failCause(cause3);
    case "Right":
      return failCause(either14.right);
  }
}));
var catchSome = dual(2, (self, pf) => catchAllCause(self, (cause3) => {
  const either14 = failureOrCause(cause3);
  switch (either14._tag) {
    case "Left":
      return pipe(pf(either14.left), getOrElse2(() => failCause(cause3)));
    case "Right":
      return failCause(either14.right);
  }
}));
var checkInterruptible = (f) => withFiberRuntime((_, status3) => f(interruption(status3.runtimeFlags)));
var originalSymbol = Symbol.for("effect/OriginalAnnotation");
var originalInstance = (obj) => {
  if (hasProperty(obj, originalSymbol)) {
    return obj[originalSymbol];
  }
  return obj;
};
var capture = (obj, span4) => {
  if (isSome2(span4)) {
    return new Proxy(obj, {
      has(target, p) {
        return p === spanSymbol || p === originalSymbol || p in target;
      },
      get(target, p) {
        if (p === spanSymbol) {
          return span4.value;
        }
        if (p === originalSymbol) {
          return obj;
        }
        return target[p];
      }
    });
  }
  return obj;
};
var die2 = (defect) => isObject(defect) && !(spanSymbol in defect) ? withFiberRuntime((fiber) => failCause(die(capture(defect, currentSpanFromFiber(fiber))))) : failCause(die(defect));
var dieMessage = (message) => failCauseSync(() => die(new RuntimeException(message)));
var dieSync = (evaluate4) => flatMap12(sync(evaluate4), die2);
var either3 = (self) => matchEffect(self, {
  onFailure: (e) => succeed(left2(e)),
  onSuccess: (a) => succeed(right2(a))
});
var exit = (self) => matchCause(self, {
  onFailure: exitFailCause,
  onSuccess: exitSucceed
});
var fail2 = (error4) => isObject(error4) && !(spanSymbol in error4) ? withFiberRuntime((fiber) => failCause(fail(capture(error4, currentSpanFromFiber(fiber))))) : failCause(fail(error4));
var failSync = (evaluate4) => flatMap12(sync(evaluate4), fail2);
var failCause = (cause3) => {
  const effect4 = new EffectPrimitiveFailure(OP_FAILURE);
  effect4.effect_instruction_i0 = cause3;
  return effect4;
};
var failCauseSync = (evaluate4) => flatMap12(sync(evaluate4), failCause);
var fiberId = withFiberRuntime((state) => succeed(state.id()));
var fiberIdWith = (f) => withFiberRuntime((state) => f(state.id()));
var flatMap12 = dual(2, (self, f) => {
  const effect4 = new EffectPrimitive(OP_ON_SUCCESS);
  effect4.effect_instruction_i0 = self;
  effect4.effect_instruction_i1 = f;
  return effect4;
});
var andThen6 = dual(2, (self, f) => flatMap12(self, (a) => {
  const b = typeof f === "function" ? f(a) : f;
  if (isEffect(b)) {
    return b;
  } else if (isPromiseLike(b)) {
    return unsafeAsync((resume2) => {
      b.then((a2) => resume2(succeed(a2)), (e) => resume2(fail2(new UnknownException(e, "An unknown error occurred in Effect.andThen"))));
    });
  }
  return succeed(b);
}));
var step2 = (self) => {
  const effect4 = new EffectPrimitive("OnStep");
  effect4.effect_instruction_i0 = self;
  return effect4;
};
var flatten8 = (self) => flatMap12(self, identity);
var flip3 = (self) => matchEffect(self, {
  onFailure: succeed,
  onSuccess: fail2
});
var matchCause = dual(2, (self, options) => matchCauseEffect(self, {
  onFailure: (cause3) => succeed(options.onFailure(cause3)),
  onSuccess: (a) => succeed(options.onSuccess(a))
}));
var matchCauseEffect = dual(2, (self, options) => {
  const effect4 = new EffectPrimitive(OP_ON_SUCCESS_AND_FAILURE);
  effect4.effect_instruction_i0 = self;
  effect4.effect_instruction_i1 = options.onFailure;
  effect4.effect_instruction_i2 = options.onSuccess;
  return effect4;
});
var matchEffect = dual(2, (self, options) => matchCauseEffect(self, {
  onFailure: (cause3) => {
    const defects3 = defects(cause3);
    if (defects3.length > 0) {
      return failCause(electFailures(cause3));
    }
    const failures3 = failures(cause3);
    if (failures3.length > 0) {
      return options.onFailure(unsafeHead2(failures3));
    }
    return failCause(cause3);
  },
  onSuccess: options.onSuccess
}));
var forEachSequential = dual(2, (self, f) => suspend(() => {
  const arr = fromIterable2(self);
  const ret = allocate(arr.length);
  let i = 0;
  return as3(whileLoop({
    while: () => i < arr.length,
    body: () => f(arr[i], i),
    step: (b) => {
      ret[i++] = b;
    }
  }), ret);
}));
var forEachSequentialDiscard = dual(2, (self, f) => suspend(() => {
  const arr = fromIterable2(self);
  let i = 0;
  return whileLoop({
    while: () => i < arr.length,
    body: () => f(arr[i], i),
    step: () => {
      i++;
    }
  });
}));
var if_ = dual((args2) => typeof args2[0] === "boolean" || isEffect(args2[0]), (self, options) => isEffect(self) ? flatMap12(self, (b) => b ? options.onTrue() : options.onFalse()) : self ? options.onTrue() : options.onFalse());
var interrupt2 = flatMap12(fiberId, (fiberId5) => interruptWith(fiberId5));
var interruptWith = (fiberId5) => failCause(interrupt(fiberId5));
var interruptible2 = (self) => {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = enable3(Interruption);
  effect4.effect_instruction_i1 = () => self;
  return effect4;
};
var interruptibleMask = (f) => custom(f, function() {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = enable3(Interruption);
  effect4.effect_instruction_i1 = (oldFlags) => interruption(oldFlags) ? internalCall(() => this.effect_instruction_i0(interruptible2)) : internalCall(() => this.effect_instruction_i0(uninterruptible));
  return effect4;
});
var intoDeferred = dual(2, (self, deferred) => uninterruptibleMask((restore) => flatMap12(exit(restore(self)), (exit4) => deferredDone(deferred, exit4))));
var map14 = dual(2, (self, f) => flatMap12(self, (a) => sync(() => f(a))));
var mapBoth3 = dual(2, (self, options) => matchEffect(self, {
  onFailure: (e) => failSync(() => options.onFailure(e)),
  onSuccess: (a) => sync(() => options.onSuccess(a))
}));
var mapError = dual(2, (self, f) => matchCauseEffect(self, {
  onFailure: (cause3) => {
    const either14 = failureOrCause(cause3);
    switch (either14._tag) {
      case "Left": {
        return failSync(() => f(either14.left));
      }
      case "Right": {
        return failCause(either14.right);
      }
    }
  },
  onSuccess: succeed
}));
var onError = dual(2, (self, cleanup) => onExit(self, (exit4) => exitIsSuccess(exit4) ? void_3 : cleanup(exit4.effect_instruction_i0)));
var onExit = dual(2, (self, cleanup) => uninterruptibleMask((restore) => matchCauseEffect(restore(self), {
  onFailure: (cause1) => {
    const result = exitFailCause(cause1);
    return matchCauseEffect(cleanup(result), {
      onFailure: (cause22) => exitFailCause(sequential(cause1, cause22)),
      onSuccess: () => result
    });
  },
  onSuccess: (success) => {
    const result = exitSucceed(success);
    return zipRight2(cleanup(result), result);
  }
})));
var onInterrupt = dual(2, (self, cleanup) => onExit(self, exitMatch({
  onFailure: (cause3) => isInterruptedOnly(cause3) ? asVoid2(cleanup(interruptors(cause3))) : void_3,
  onSuccess: () => void_3
})));
var orElse3 = dual(2, (self, that) => attemptOrElse(self, that, succeed));
var orDie = (self) => orDieWith(self, identity);
var orDieWith = dual(2, (self, f) => matchEffect(self, {
  onFailure: (e) => die2(f(e)),
  onSuccess: succeed
}));
var partitionMap6 = partitionMap3;
var runtimeFlags = withFiberRuntime((_, status3) => succeed(status3.runtimeFlags));
var succeed = (value10) => {
  const effect4 = new EffectPrimitiveSuccess(OP_SUCCESS);
  effect4.effect_instruction_i0 = value10;
  return effect4;
};
var suspend = (evaluate4) => {
  const effect4 = new EffectPrimitive(OP_COMMIT);
  effect4.commit = evaluate4;
  return effect4;
};
var sync = (thunk) => {
  const effect4 = new EffectPrimitive(OP_SYNC);
  effect4.effect_instruction_i0 = thunk;
  return effect4;
};
var tap2 = dual((args2) => args2.length === 3 || args2.length === 2 && !(isObject(args2[1]) && "onlyEffect" in args2[1]), (self, f) => flatMap12(self, (a) => {
  const b = typeof f === "function" ? f(a) : f;
  if (isEffect(b)) {
    return as3(b, a);
  } else if (isPromiseLike(b)) {
    return unsafeAsync((resume2) => {
      b.then((_) => resume2(succeed(a)), (e) => resume2(fail2(new UnknownException(e, "An unknown error occurred in Effect.tap"))));
    });
  }
  return succeed(a);
}));
var transplant = (f) => withFiberRuntime((state) => {
  const scopeOverride = state.getFiberRef(currentForkScopeOverride);
  const scope6 = pipe(scopeOverride, getOrElse2(() => state.scope()));
  return f(fiberRefLocally(currentForkScopeOverride, some3(scope6)));
});
var attemptOrElse = dual(3, (self, that, onSuccess) => matchCauseEffect(self, {
  onFailure: (cause3) => {
    const defects3 = defects(cause3);
    if (defects3.length > 0) {
      return failCause(getOrThrow2(keepDefectsAndElectFailures(cause3)));
    }
    return that();
  },
  onSuccess
}));
var uninterruptible = (self) => {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = disable3(Interruption);
  effect4.effect_instruction_i1 = () => self;
  return effect4;
};
var uninterruptibleMask = (f) => custom(f, function() {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = disable3(Interruption);
  effect4.effect_instruction_i1 = (oldFlags) => interruption(oldFlags) ? internalCall(() => this.effect_instruction_i0(interruptible2)) : internalCall(() => this.effect_instruction_i0(uninterruptible));
  return effect4;
});
var void_3 = succeed(void 0);
var updateRuntimeFlags = (patch14) => {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = patch14;
  effect4.effect_instruction_i1 = void 0;
  return effect4;
};
var whenEffect = dual(2, (self, condition) => flatMap12(condition, (b) => {
  if (b) {
    return pipe(self, map14(some3));
  }
  return succeed(none2());
}));
var whileLoop = (options) => {
  const effect4 = new EffectPrimitive(OP_WHILE);
  effect4.effect_instruction_i0 = options.while;
  effect4.effect_instruction_i1 = options.body;
  effect4.effect_instruction_i2 = options.step;
  return effect4;
};
var fromIterator = (iterator) => suspend(() => {
  const effect4 = new EffectPrimitive(OP_ITERATOR);
  effect4.effect_instruction_i0 = iterator();
  return effect4;
});
var gen4 = function() {
  const f = arguments.length === 1 ? arguments[0] : arguments[1].bind(arguments[0]);
  return fromIterator(() => f(pipe));
};
var fnUntraced = (body, ...pipeables) => Object.defineProperty(pipeables.length === 0 ? function(...args2) {
  return fromIterator(() => body.apply(this, args2));
} : function(...args2) {
  let effect4 = fromIterator(() => body.apply(this, args2));
  for (const x of pipeables) {
    effect4 = x(effect4, ...args2);
  }
  return effect4;
}, "length", {
  value: body.length,
  configurable: true
});
var withConcurrency = dual(2, (self, concurrency) => fiberRefLocally(self, currentConcurrency, concurrency));
var withRequestBatching = dual(2, (self, requestBatching) => fiberRefLocally(self, currentRequestBatching, requestBatching));
var withRuntimeFlags = dual(2, (self, update18) => {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = update18;
  effect4.effect_instruction_i1 = () => self;
  return effect4;
});
var withTracerEnabled = dual(2, (effect4, enabled2) => fiberRefLocally(effect4, currentTracerEnabled, enabled2));
var withTracerTiming = dual(2, (effect4, enabled2) => fiberRefLocally(effect4, currentTracerTimingEnabled, enabled2));
var yieldNow = (options) => {
  const effect4 = new EffectPrimitive(OP_YIELD);
  return typeof options?.priority !== "undefined" ? withSchedulingPriority(effect4, options.priority) : effect4;
};
var zip5 = dual(2, (self, that) => flatMap12(self, (a) => map14(that, (b) => [a, b])));
var zipFlatten = dual(2, (self, that) => flatMap12(self, (a) => map14(that, (b) => [...a, b])));
var zipLeft2 = dual(2, (self, that) => flatMap12(self, (a) => as3(that, a)));
var zipRight2 = dual(2, (self, that) => flatMap12(self, () => that));
var zipWith6 = dual(3, (self, that, f) => flatMap12(self, (a) => map14(that, (b) => f(a, b))));
var never = asyncInterrupt(() => {
  const interval = setInterval(() => {
  }, 2 ** 31 - 1);
  return sync(() => clearInterval(interval));
});
var interruptFiber = (self) => flatMap12(fiberId, (fiberId5) => pipe(self, interruptAsFiber(fiberId5)));
var interruptAsFiber = dual(2, (self, fiberId5) => flatMap12(self.interruptAsFork(fiberId5), () => self.await));
var logLevelAll = {
  _tag: "All",
  syslog: 0,
  label: "ALL",
  ordinal: Number.MIN_SAFE_INTEGER,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelFatal = {
  _tag: "Fatal",
  syslog: 2,
  label: "FATAL",
  ordinal: 5e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelError = {
  _tag: "Error",
  syslog: 3,
  label: "ERROR",
  ordinal: 4e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelWarning = {
  _tag: "Warning",
  syslog: 4,
  label: "WARN",
  ordinal: 3e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelInfo = {
  _tag: "Info",
  syslog: 6,
  label: "INFO",
  ordinal: 2e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelDebug = {
  _tag: "Debug",
  syslog: 7,
  label: "DEBUG",
  ordinal: 1e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelTrace = {
  _tag: "Trace",
  syslog: 7,
  label: "TRACE",
  ordinal: 0,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelNone = {
  _tag: "None",
  syslog: 7,
  label: "OFF",
  ordinal: Number.MAX_SAFE_INTEGER,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var allLogLevels = [logLevelAll, logLevelTrace, logLevelDebug, logLevelInfo, logLevelWarning, logLevelError, logLevelFatal, logLevelNone];
var FiberRefSymbolKey = "effect/FiberRef";
var FiberRefTypeId = Symbol.for(FiberRefSymbolKey);
var fiberRefVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var fiberRefGet = (self) => withFiberRuntime((fiber) => exitSucceed(fiber.getFiberRef(self)));
var fiberRefGetAndSet = dual(2, (self, value10) => fiberRefModify(self, (v) => [v, value10]));
var fiberRefGetAndUpdate = dual(2, (self, f) => fiberRefModify(self, (v) => [v, f(v)]));
var fiberRefGetAndUpdateSome = dual(2, (self, pf) => fiberRefModify(self, (v) => [v, getOrElse2(pf(v), () => v)]));
var fiberRefGetWith = dual(2, (self, f) => flatMap12(fiberRefGet(self), f));
var fiberRefSet = dual(2, (self, value10) => fiberRefModify(self, () => [void 0, value10]));
var fiberRefDelete = (self) => withFiberRuntime((state) => {
  state.unsafeDeleteFiberRef(self);
  return void_3;
});
var fiberRefReset = (self) => fiberRefSet(self, self.initial);
var fiberRefModify = dual(2, (self, f) => withFiberRuntime((state) => {
  const [b, a] = f(state.getFiberRef(self));
  state.setFiberRef(self, a);
  return succeed(b);
}));
var fiberRefModifySome = (self, def, f) => fiberRefModify(self, (v) => getOrElse2(f(v), () => [def, v]));
var fiberRefUpdate = dual(2, (self, f) => fiberRefModify(self, (v) => [void 0, f(v)]));
var fiberRefUpdateSome = dual(2, (self, pf) => fiberRefModify(self, (v) => [void 0, getOrElse2(pf(v), () => v)]));
var fiberRefUpdateAndGet = dual(2, (self, f) => fiberRefModify(self, (v) => {
  const result = f(v);
  return [result, result];
}));
var fiberRefUpdateSomeAndGet = dual(2, (self, pf) => fiberRefModify(self, (v) => {
  const result = getOrElse2(pf(v), () => v);
  return [result, result];
}));
var RequestResolverSymbolKey = "effect/RequestResolver";
var RequestResolverTypeId = Symbol.for(RequestResolverSymbolKey);
var requestResolverVariance = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var RequestResolverImpl = class _RequestResolverImpl {
  runAll;
  target;
  [RequestResolverTypeId] = requestResolverVariance;
  constructor(runAll, target) {
    this.runAll = runAll;
    this.target = target;
  }
  [symbol2]() {
    return cached(this, this.target ? hash(this.target) : random(this));
  }
  [symbol3](that) {
    return this.target ? isRequestResolver(that) && equals(this.target, that.target) : this === that;
  }
  identified(...ids3) {
    return new _RequestResolverImpl(this.runAll, fromIterable3(ids3));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isRequestResolver = (u) => hasProperty(u, RequestResolverTypeId);
var resolverLocally = dual(3, (use2, self, value10) => new RequestResolverImpl((requests) => fiberRefLocally(use2.runAll(requests), self, value10), make9("Locally", use2, self, value10)));
var fiberRefLocally = dual(3, (use2, self, value10) => acquireUseRelease(zipLeft2(fiberRefGet(self), fiberRefSet(self, value10)), () => use2, (oldValue) => fiberRefSet(self, oldValue)));
var fiberRefLocallyWith = dual(3, (use2, self, f) => fiberRefGetWith(self, (a) => fiberRefLocally(use2, self, f(a))));
var fiberRefUnsafeMake = (initial, options) => fiberRefUnsafeMakePatch(initial, {
  differ: update2(),
  fork: options?.fork ?? identity,
  join: options?.join
});
var fiberRefUnsafeMakeHashSet = (initial) => {
  const differ4 = hashSet();
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ4,
    fork: differ4.empty
  });
};
var fiberRefUnsafeMakeReadonlyArray = (initial) => {
  const differ4 = readonlyArray(update2());
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ4,
    fork: differ4.empty
  });
};
var fiberRefUnsafeMakeContext = (initial) => {
  const differ4 = environment();
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ4,
    fork: differ4.empty
  });
};
var fiberRefUnsafeMakePatch = (initial, options) => {
  const _fiberRef = {
    ...CommitPrototype,
    [FiberRefTypeId]: fiberRefVariance,
    initial,
    commit() {
      return fiberRefGet(this);
    },
    diff: (oldValue, newValue) => options.differ.diff(oldValue, newValue),
    combine: (first5, second) => options.differ.combine(first5, second),
    patch: (patch14) => (oldValue) => options.differ.patch(patch14, oldValue),
    fork: options.fork,
    join: options.join ?? ((_, n) => n)
  };
  return _fiberRef;
};
var fiberRefUnsafeMakeRuntimeFlags = (initial) => fiberRefUnsafeMakePatch(initial, {
  differ,
  fork: differ.empty
});
var currentContext = globalValue(Symbol.for("effect/FiberRef/currentContext"), () => fiberRefUnsafeMakeContext(empty6()));
var currentSchedulingPriority = globalValue(Symbol.for("effect/FiberRef/currentSchedulingPriority"), () => fiberRefUnsafeMake(0));
var currentMaxOpsBeforeYield = globalValue(Symbol.for("effect/FiberRef/currentMaxOpsBeforeYield"), () => fiberRefUnsafeMake(2048));
var currentLogAnnotations = globalValue(Symbol.for("effect/FiberRef/currentLogAnnotation"), () => fiberRefUnsafeMake(empty11()));
var currentLogLevel = globalValue(Symbol.for("effect/FiberRef/currentLogLevel"), () => fiberRefUnsafeMake(logLevelInfo));
var currentLogSpan = globalValue(Symbol.for("effect/FiberRef/currentLogSpan"), () => fiberRefUnsafeMake(empty12()));
var withSchedulingPriority = dual(2, (self, scheduler2) => fiberRefLocally(self, currentSchedulingPriority, scheduler2));
var withMaxOpsBeforeYield = dual(2, (self, scheduler2) => fiberRefLocally(self, currentMaxOpsBeforeYield, scheduler2));
var currentConcurrency = globalValue(Symbol.for("effect/FiberRef/currentConcurrency"), () => fiberRefUnsafeMake("unbounded"));
var currentRequestBatching = globalValue(Symbol.for("effect/FiberRef/currentRequestBatching"), () => fiberRefUnsafeMake(true));
var currentUnhandledErrorLogLevel = globalValue(Symbol.for("effect/FiberRef/currentUnhandledErrorLogLevel"), () => fiberRefUnsafeMake(some3(logLevelDebug)));
var currentVersionMismatchErrorLogLevel = globalValue(Symbol.for("effect/FiberRef/versionMismatchErrorLogLevel"), () => fiberRefUnsafeMake(some3(logLevelWarning)));
var withUnhandledErrorLogLevel = dual(2, (self, level) => fiberRefLocally(self, currentUnhandledErrorLogLevel, level));
var currentMetricLabels = globalValue(Symbol.for("effect/FiberRef/currentMetricLabels"), () => fiberRefUnsafeMakeReadonlyArray(empty4()));
var metricLabels = fiberRefGet(currentMetricLabels);
var currentForkScopeOverride = globalValue(Symbol.for("effect/FiberRef/currentForkScopeOverride"), () => fiberRefUnsafeMake(none2(), {
  fork: () => none2(),
  join: (parent, _) => parent
}));
var currentInterruptedCause = globalValue(Symbol.for("effect/FiberRef/currentInterruptedCause"), () => fiberRefUnsafeMake(empty22, {
  fork: () => empty22,
  join: (parent, _) => parent
}));
var currentTracerEnabled = globalValue(Symbol.for("effect/FiberRef/currentTracerEnabled"), () => fiberRefUnsafeMake(true));
var currentTracerTimingEnabled = globalValue(Symbol.for("effect/FiberRef/currentTracerTiming"), () => fiberRefUnsafeMake(true));
var currentTracerSpanAnnotations = globalValue(Symbol.for("effect/FiberRef/currentTracerSpanAnnotations"), () => fiberRefUnsafeMake(empty11()));
var currentTracerSpanLinks = globalValue(Symbol.for("effect/FiberRef/currentTracerSpanLinks"), () => fiberRefUnsafeMake(empty7()));
var ScopeTypeId = Symbol.for("effect/Scope");
var CloseableScopeTypeId = Symbol.for("effect/CloseableScope");
var scopeAddFinalizer = (self, finalizer3) => self.addFinalizer(() => asVoid2(finalizer3));
var scopeAddFinalizerExit = (self, finalizer3) => self.addFinalizer(finalizer3);
var scopeClose = (self, exit4) => self.close(exit4);
var scopeFork = (self, strategy) => self.fork(strategy);
var causeSquash = (self) => {
  return causeSquashWith(identity)(self);
};
var causeSquashWith = dual(2, (self, f) => {
  const option11 = pipe(self, failureOption, map2(f));
  switch (option11._tag) {
    case "None": {
      return pipe(defects(self), head3, match2({
        onNone: () => {
          const interrupts = fromIterable2(interruptors(self)).flatMap((fiberId5) => fromIterable2(ids2(fiberId5)).map((id3) => `#${id3}`));
          return new InterruptedException(interrupts ? `Interrupted by fibers: ${interrupts.join(", ")}` : void 0);
        },
        onSome: identity
      }));
    }
    case "Some": {
      return option11.value;
    }
  }
});
var YieldableError = function() {
  class YieldableError4 extends globalThis.Error {
    commit() {
      return fail2(this);
    }
    toJSON() {
      const obj = {
        ...this
      };
      if (this.message) obj.message = this.message;
      if (this.cause) obj.cause = this.cause;
      return obj;
    }
    [NodeInspectSymbol]() {
      if (this.toString !== globalThis.Error.prototype.toString) {
        return this.stack ? `${this.toString()}
${this.stack.split("\n").slice(1).join("\n")}` : this.toString();
      } else if ("Bun" in globalThis) {
        return pretty(fail(this), {
          renderErrorCause: true
        });
      }
      return this;
    }
  }
  Object.assign(YieldableError4.prototype, StructuralCommitPrototype);
  return YieldableError4;
}();
var makeException = (proto16, tag5) => {
  class Base4 extends YieldableError {
    _tag = tag5;
  }
  Object.assign(Base4.prototype, proto16);
  Base4.prototype.name = tag5;
  return Base4;
};
var RuntimeExceptionTypeId = Symbol.for("effect/Cause/errors/RuntimeException");
var RuntimeException = makeException({
  [RuntimeExceptionTypeId]: RuntimeExceptionTypeId
}, "RuntimeException");
var isRuntimeException = (u) => hasProperty(u, RuntimeExceptionTypeId);
var InterruptedExceptionTypeId = Symbol.for("effect/Cause/errors/InterruptedException");
var InterruptedException = makeException({
  [InterruptedExceptionTypeId]: InterruptedExceptionTypeId
}, "InterruptedException");
var isInterruptedException = (u) => hasProperty(u, InterruptedExceptionTypeId);
var IllegalArgumentExceptionTypeId = Symbol.for("effect/Cause/errors/IllegalArgument");
var IllegalArgumentException = makeException({
  [IllegalArgumentExceptionTypeId]: IllegalArgumentExceptionTypeId
}, "IllegalArgumentException");
var isIllegalArgumentException = (u) => hasProperty(u, IllegalArgumentExceptionTypeId);
var NoSuchElementExceptionTypeId = Symbol.for("effect/Cause/errors/NoSuchElement");
var NoSuchElementException = makeException({
  [NoSuchElementExceptionTypeId]: NoSuchElementExceptionTypeId
}, "NoSuchElementException");
var isNoSuchElementException = (u) => hasProperty(u, NoSuchElementExceptionTypeId);
var InvalidPubSubCapacityExceptionTypeId = Symbol.for("effect/Cause/errors/InvalidPubSubCapacityException");
var InvalidPubSubCapacityException = makeException({
  [InvalidPubSubCapacityExceptionTypeId]: InvalidPubSubCapacityExceptionTypeId
}, "InvalidPubSubCapacityException");
var ExceededCapacityExceptionTypeId = Symbol.for("effect/Cause/errors/ExceededCapacityException");
var ExceededCapacityException = makeException({
  [ExceededCapacityExceptionTypeId]: ExceededCapacityExceptionTypeId
}, "ExceededCapacityException");
var isExceededCapacityException = (u) => hasProperty(u, ExceededCapacityExceptionTypeId);
var TimeoutExceptionTypeId = Symbol.for("effect/Cause/errors/Timeout");
var TimeoutException = makeException({
  [TimeoutExceptionTypeId]: TimeoutExceptionTypeId
}, "TimeoutException");
var timeoutExceptionFromDuration = (duration5) => new TimeoutException(`Operation timed out after '${format3(duration5)}'`);
var isTimeoutException = (u) => hasProperty(u, TimeoutExceptionTypeId);
var UnknownExceptionTypeId = Symbol.for("effect/Cause/errors/UnknownException");
var UnknownException = function() {
  class UnknownException3 extends YieldableError {
    _tag = "UnknownException";
    error;
    constructor(cause3, message) {
      super(message ?? "An unknown error occurred", {
        cause: cause3
      });
      this.error = cause3;
    }
  }
  Object.assign(UnknownException3.prototype, {
    [UnknownExceptionTypeId]: UnknownExceptionTypeId,
    name: "UnknownException"
  });
  return UnknownException3;
}();
var isUnknownException = (u) => hasProperty(u, UnknownExceptionTypeId);
var exitIsExit = (u) => isEffect(u) && "_tag" in u && (u._tag === "Success" || u._tag === "Failure");
var exitIsFailure = (self) => self._tag === "Failure";
var exitIsSuccess = (self) => self._tag === "Success";
var exitIsInterrupted = (self) => {
  switch (self._tag) {
    case OP_FAILURE:
      return isInterrupted(self.effect_instruction_i0);
    case OP_SUCCESS:
      return false;
  }
};
var exitAs = dual(2, (self, value10) => {
  switch (self._tag) {
    case OP_FAILURE: {
      return exitFailCause(self.effect_instruction_i0);
    }
    case OP_SUCCESS: {
      return exitSucceed(value10);
    }
  }
});
var exitAsVoid = (self) => exitAs(self, void 0);
var exitCauseOption = (self) => {
  switch (self._tag) {
    case OP_FAILURE:
      return some3(self.effect_instruction_i0);
    case OP_SUCCESS:
      return none2();
  }
};
var exitCollectAll = (exits, options) => exitCollectAllInternal(exits, options?.parallel ? parallel : sequential);
var exitDie = (defect) => exitFailCause(die(defect));
var exitExists = dual(2, (self, refinement) => {
  switch (self._tag) {
    case OP_FAILURE:
      return false;
    case OP_SUCCESS:
      return refinement(self.effect_instruction_i0);
  }
});
var exitFail = (error4) => exitFailCause(fail(error4));
var exitFailCause = (cause3) => {
  const effect4 = new EffectPrimitiveFailure(OP_FAILURE);
  effect4.effect_instruction_i0 = cause3;
  return effect4;
};
var exitFlatMap = dual(2, (self, f) => {
  switch (self._tag) {
    case OP_FAILURE: {
      return exitFailCause(self.effect_instruction_i0);
    }
    case OP_SUCCESS: {
      return f(self.effect_instruction_i0);
    }
  }
});
var exitFlatMapEffect = dual(2, (self, f) => {
  switch (self._tag) {
    case OP_FAILURE: {
      return succeed(exitFailCause(self.effect_instruction_i0));
    }
    case OP_SUCCESS: {
      return f(self.effect_instruction_i0);
    }
  }
});
var exitFlatten = (self) => pipe(self, exitFlatMap(identity));
var exitForEachEffect = dual(2, (self, f) => {
  switch (self._tag) {
    case OP_FAILURE: {
      return succeed(exitFailCause(self.effect_instruction_i0));
    }
    case OP_SUCCESS: {
      return exit(f(self.effect_instruction_i0));
    }
  }
});
var exitFromEither = (either14) => {
  switch (either14._tag) {
    case "Left":
      return exitFail(either14.left);
    case "Right":
      return exitSucceed(either14.right);
  }
};
var exitFromOption = (option11) => {
  switch (option11._tag) {
    case "None":
      return exitFail(void 0);
    case "Some":
      return exitSucceed(option11.value);
  }
};
var exitGetOrElse = dual(2, (self, orElse24) => {
  switch (self._tag) {
    case OP_FAILURE:
      return orElse24(self.effect_instruction_i0);
    case OP_SUCCESS:
      return self.effect_instruction_i0;
  }
});
var exitInterrupt = (fiberId5) => exitFailCause(interrupt(fiberId5));
var exitMap = dual(2, (self, f) => {
  switch (self._tag) {
    case OP_FAILURE:
      return exitFailCause(self.effect_instruction_i0);
    case OP_SUCCESS:
      return exitSucceed(f(self.effect_instruction_i0));
  }
});
var exitMapBoth = dual(2, (self, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OP_FAILURE:
      return exitFailCause(pipe(self.effect_instruction_i0, map13(onFailure)));
    case OP_SUCCESS:
      return exitSucceed(onSuccess(self.effect_instruction_i0));
  }
});
var exitMapError = dual(2, (self, f) => {
  switch (self._tag) {
    case OP_FAILURE:
      return exitFailCause(pipe(self.effect_instruction_i0, map13(f)));
    case OP_SUCCESS:
      return exitSucceed(self.effect_instruction_i0);
  }
});
var exitMapErrorCause = dual(2, (self, f) => {
  switch (self._tag) {
    case OP_FAILURE:
      return exitFailCause(f(self.effect_instruction_i0));
    case OP_SUCCESS:
      return exitSucceed(self.effect_instruction_i0);
  }
});
var exitMatch = dual(2, (self, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OP_FAILURE:
      return onFailure(self.effect_instruction_i0);
    case OP_SUCCESS:
      return onSuccess(self.effect_instruction_i0);
  }
});
var exitMatchEffect = dual(2, (self, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OP_FAILURE:
      return onFailure(self.effect_instruction_i0);
    case OP_SUCCESS:
      return onSuccess(self.effect_instruction_i0);
  }
});
var exitSucceed = (value10) => {
  const effect4 = new EffectPrimitiveSuccess(OP_SUCCESS);
  effect4.effect_instruction_i0 = value10;
  return effect4;
};
var exitVoid = exitSucceed(void 0);
var exitZip = dual(2, (self, that) => exitZipWith(self, that, {
  onSuccess: (a, a2) => [a, a2],
  onFailure: sequential
}));
var exitZipLeft = dual(2, (self, that) => exitZipWith(self, that, {
  onSuccess: (a, _) => a,
  onFailure: sequential
}));
var exitZipRight = dual(2, (self, that) => exitZipWith(self, that, {
  onSuccess: (_, a2) => a2,
  onFailure: sequential
}));
var exitZipPar = dual(2, (self, that) => exitZipWith(self, that, {
  onSuccess: (a, a2) => [a, a2],
  onFailure: parallel
}));
var exitZipParLeft = dual(2, (self, that) => exitZipWith(self, that, {
  onSuccess: (a, _) => a,
  onFailure: parallel
}));
var exitZipParRight = dual(2, (self, that) => exitZipWith(self, that, {
  onSuccess: (_, a2) => a2,
  onFailure: parallel
}));
var exitZipWith = dual(3, (self, that, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OP_FAILURE: {
      switch (that._tag) {
        case OP_SUCCESS:
          return exitFailCause(self.effect_instruction_i0);
        case OP_FAILURE: {
          return exitFailCause(onFailure(self.effect_instruction_i0, that.effect_instruction_i0));
        }
      }
    }
    case OP_SUCCESS: {
      switch (that._tag) {
        case OP_SUCCESS:
          return exitSucceed(onSuccess(self.effect_instruction_i0, that.effect_instruction_i0));
        case OP_FAILURE:
          return exitFailCause(that.effect_instruction_i0);
      }
    }
  }
});
var exitCollectAllInternal = (exits, combineCauses) => {
  const list = fromIterable3(exits);
  if (!isNonEmpty2(list)) {
    return none2();
  }
  return pipe(tailNonEmpty2(list), reduce3(pipe(headNonEmpty2(list), exitMap(of3)), (accumulator, current2) => pipe(accumulator, exitZipWith(current2, {
    onSuccess: (list2, value10) => pipe(list2, prepend3(value10)),
    onFailure: combineCauses
  }))), exitMap(reverse3), exitMap((chunk7) => toReadonlyArray(chunk7)), some3);
};
var deferredUnsafeMake = (fiberId5) => {
  const _deferred = {
    ...CommitPrototype,
    [DeferredTypeId]: deferredVariance,
    state: make15(pending([])),
    commit() {
      return deferredAwait(this);
    },
    blockingOn: fiberId5
  };
  return _deferred;
};
var deferredMake = () => flatMap12(fiberId, (id3) => deferredMakeAs(id3));
var deferredMakeAs = (fiberId5) => sync(() => deferredUnsafeMake(fiberId5));
var deferredAwait = (self) => asyncInterrupt((resume2) => {
  const state = get7(self.state);
  switch (state._tag) {
    case OP_STATE_DONE: {
      return resume2(state.effect);
    }
    case OP_STATE_PENDING: {
      state.joiners.push(resume2);
      return deferredInterruptJoiner(self, resume2);
    }
  }
}, self.blockingOn);
var deferredComplete = dual(2, (self, effect4) => intoDeferred(effect4, self));
var deferredCompleteWith = dual(2, (self, effect4) => sync(() => {
  const state = get7(self.state);
  switch (state._tag) {
    case OP_STATE_DONE: {
      return false;
    }
    case OP_STATE_PENDING: {
      set3(self.state, done(effect4));
      for (let i = 0, len = state.joiners.length; i < len; i++) {
        state.joiners[i](effect4);
      }
      return true;
    }
  }
}));
var deferredDone = dual(2, (self, exit4) => deferredCompleteWith(self, exit4));
var deferredFail = dual(2, (self, error4) => deferredCompleteWith(self, fail2(error4)));
var deferredFailSync = dual(2, (self, evaluate4) => deferredCompleteWith(self, failSync(evaluate4)));
var deferredFailCause = dual(2, (self, cause3) => deferredCompleteWith(self, failCause(cause3)));
var deferredFailCauseSync = dual(2, (self, evaluate4) => deferredCompleteWith(self, failCauseSync(evaluate4)));
var deferredDie = dual(2, (self, defect) => deferredCompleteWith(self, die2(defect)));
var deferredDieSync = dual(2, (self, evaluate4) => deferredCompleteWith(self, dieSync(evaluate4)));
var deferredInterrupt = (self) => flatMap12(fiberId, (fiberId5) => deferredCompleteWith(self, interruptWith(fiberId5)));
var deferredInterruptWith = dual(2, (self, fiberId5) => deferredCompleteWith(self, interruptWith(fiberId5)));
var deferredIsDone = (self) => sync(() => get7(self.state)._tag === OP_STATE_DONE);
var deferredPoll = (self) => sync(() => {
  const state = get7(self.state);
  switch (state._tag) {
    case OP_STATE_DONE: {
      return some3(state.effect);
    }
    case OP_STATE_PENDING: {
      return none2();
    }
  }
});
var deferredSucceed = dual(2, (self, value10) => deferredCompleteWith(self, succeed(value10)));
var deferredSync = dual(2, (self, evaluate4) => deferredCompleteWith(self, sync(evaluate4)));
var deferredUnsafeDone = (self, effect4) => {
  const state = get7(self.state);
  if (state._tag === OP_STATE_PENDING) {
    set3(self.state, done(effect4));
    for (let i = 0, len = state.joiners.length; i < len; i++) {
      state.joiners[i](effect4);
    }
  }
};
var deferredInterruptJoiner = (self, joiner) => sync(() => {
  const state = get7(self.state);
  if (state._tag === OP_STATE_PENDING) {
    const index = state.joiners.indexOf(joiner);
    if (index >= 0) {
      state.joiners.splice(index, 1);
    }
  }
});
var constContext = withFiberRuntime((fiber) => exitSucceed(fiber.currentContext));
var context2 = () => constContext;
var contextWithEffect = (f) => flatMap12(context2(), f);
var provideContext = dual(2, (self, context15) => fiberRefLocally(currentContext, context15)(self));
var provideSomeContext = dual(2, (self, context15) => fiberRefLocallyWith(currentContext, (parent) => merge3(parent, context15))(self));
var mapInputContext = dual(2, (self, f) => contextWithEffect((context15) => provideContext(self, f(context15))));
var filterEffectOrElse = dual(2, (self, options) => flatMap12(self, (a) => flatMap12(options.predicate(a), (pass) => pass ? succeed(a) : options.orElse(a))));
var filterEffectOrFail = dual(2, (self, options) => filterEffectOrElse(self, {
  predicate: options.predicate,
  orElse: (a) => fail2(options.orFailWith(a))
}));
var currentSpanFromFiber = (fiber) => {
  const span4 = fiber.currentSpan;
  return span4 !== void 0 && span4._tag === "Span" ? some3(span4) : none2();
};
var NoopSpanProto = {
  _tag: "Span",
  spanId: "noop",
  traceId: "noop",
  sampled: false,
  status: {
    _tag: "Ended",
    startTime: BigInt(0),
    endTime: BigInt(0),
    exit: exitVoid
  },
  attributes: /* @__PURE__ */ new Map(),
  links: [],
  kind: "internal",
  attribute() {
  },
  event() {
  },
  end() {
  },
  addLinks() {
  }
};
var noopSpan = (options) => Object.assign(Object.create(NoopSpanProto), options);

// ../../node_modules/effect/dist/esm/Deferred.js
var DeferredTypeId2 = DeferredTypeId;
var make24 = deferredMake;
var makeAs = deferredMakeAs;
var _await = deferredAwait;
var complete = deferredComplete;
var completeWith = deferredCompleteWith;
var done2 = deferredDone;
var fail3 = deferredFail;
var failSync2 = deferredFailSync;
var failCause2 = deferredFailCause;
var failCauseSync2 = deferredFailCauseSync;
var die3 = deferredDie;
var dieSync2 = deferredDieSync;
var interrupt3 = deferredInterrupt;
var interruptWith2 = deferredInterruptWith;
var isDone = deferredIsDone;
var poll = deferredPoll;
var succeed2 = deferredSucceed;
var sync2 = deferredSync;
var unsafeMake4 = deferredUnsafeMake;
var unsafeDone = deferredUnsafeDone;

// ../../node_modules/effect/dist/esm/Exit.js
var Exit_exports = {};
__export(Exit_exports, {
  all: () => all7,
  as: () => as4,
  asVoid: () => asVoid3,
  causeOption: () => causeOption,
  die: () => die4,
  exists: () => exists2,
  fail: () => fail4,
  failCause: () => failCause3,
  flatMap: () => flatMap13,
  flatMapEffect: () => flatMapEffect,
  flatten: () => flatten9,
  forEachEffect: () => forEachEffect,
  fromEither: () => fromEither,
  fromOption: () => fromOption4,
  getOrElse: () => getOrElse7,
  interrupt: () => interrupt4,
  isExit: () => isExit,
  isFailure: () => isFailure2,
  isInterrupted: () => isInterrupted2,
  isSuccess: () => isSuccess,
  map: () => map15,
  mapBoth: () => mapBoth4,
  mapError: () => mapError2,
  mapErrorCause: () => mapErrorCause,
  match: () => match7,
  matchEffect: () => matchEffect2,
  succeed: () => succeed3,
  void: () => void_4,
  zip: () => zip6,
  zipLeft: () => zipLeft3,
  zipPar: () => zipPar,
  zipParLeft: () => zipParLeft,
  zipParRight: () => zipParRight,
  zipRight: () => zipRight3,
  zipWith: () => zipWith7
});
var isExit = exitIsExit;
var isFailure2 = exitIsFailure;
var isSuccess = exitIsSuccess;
var isInterrupted2 = exitIsInterrupted;
var as4 = exitAs;
var asVoid3 = exitAsVoid;
var causeOption = exitCauseOption;
var all7 = exitCollectAll;
var die4 = exitDie;
var exists2 = exitExists;
var fail4 = exitFail;
var failCause3 = exitFailCause;
var flatMap13 = exitFlatMap;
var flatMapEffect = exitFlatMapEffect;
var flatten9 = exitFlatten;
var forEachEffect = exitForEachEffect;
var fromEither = exitFromEither;
var fromOption4 = exitFromOption;
var getOrElse7 = exitGetOrElse;
var interrupt4 = exitInterrupt;
var map15 = exitMap;
var mapBoth4 = exitMapBoth;
var mapError2 = exitMapError;
var mapErrorCause = exitMapErrorCause;
var match7 = exitMatch;
var matchEffect2 = exitMatchEffect;
var succeed3 = exitSucceed;
var void_4 = exitVoid;
var zip6 = exitZip;
var zipLeft3 = exitZipLeft;
var zipRight3 = exitZipRight;
var zipPar = exitZipPar;
var zipParLeft = exitZipParLeft;
var zipParRight = exitZipParRight;
var zipWith7 = exitZipWith;

// ../../node_modules/effect/dist/esm/MutableHashMap.js
var MutableHashMap_exports = {};
__export(MutableHashMap_exports, {
  clear: () => clear,
  empty: () => empty23,
  forEach: () => forEach9,
  fromIterable: () => fromIterable9,
  get: () => get9,
  has: () => has6,
  isEmpty: () => isEmpty8,
  keys: () => keys4,
  make: () => make25,
  modify: () => modify6,
  modifyAt: () => modifyAt3,
  remove: () => remove8,
  set: () => set5,
  size: () => size10,
  values: () => values6
});
var TypeId11 = Symbol.for("effect/MutableHashMap");
var MutableHashMapProto = {
  [TypeId11]: TypeId11,
  [Symbol.iterator]() {
    return new MutableHashMapIterator(this);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableHashMap",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var MutableHashMapIterator = class _MutableHashMapIterator {
  self;
  referentialIterator;
  bucketIterator;
  constructor(self) {
    this.self = self;
    this.referentialIterator = self.referential[Symbol.iterator]();
  }
  next() {
    if (this.bucketIterator !== void 0) {
      return this.bucketIterator.next();
    }
    const result = this.referentialIterator.next();
    if (result.done) {
      this.bucketIterator = new BucketIterator(this.self.buckets.values());
      return this.next();
    }
    return result;
  }
  [Symbol.iterator]() {
    return new _MutableHashMapIterator(this.self);
  }
};
var BucketIterator = class {
  backing;
  constructor(backing) {
    this.backing = backing;
  }
  currentBucket;
  next() {
    if (this.currentBucket === void 0) {
      const result2 = this.backing.next();
      if (result2.done) {
        return result2;
      }
      this.currentBucket = result2.value[Symbol.iterator]();
    }
    const result = this.currentBucket.next();
    if (result.done) {
      this.currentBucket = void 0;
      return this.next();
    }
    return result;
  }
};
var empty23 = () => {
  const self = Object.create(MutableHashMapProto);
  self.referential = /* @__PURE__ */ new Map();
  self.buckets = /* @__PURE__ */ new Map();
  self.bucketsSize = 0;
  return self;
};
var make25 = (...entries7) => fromIterable9(entries7);
var fromIterable9 = (entries7) => {
  const self = empty23();
  for (const [key, value10] of entries7) {
    set5(self, key, value10);
  }
  return self;
};
var get9 = dual(2, (self, key) => {
  if (isEqual(key) === false) {
    return self.referential.has(key) ? some3(self.referential.get(key)) : none2();
  }
  const hash4 = key[symbol2]();
  const bucket = self.buckets.get(hash4);
  if (bucket === void 0) {
    return none2();
  }
  return getFromBucket(self, bucket, key);
});
var keys4 = (self) => {
  const keys15 = Array.from(self.referential.keys());
  for (const bucket of self.buckets.values()) {
    for (let i = 0, len = bucket.length; i < len; i++) {
      keys15.push(bucket[i][0]);
    }
  }
  return keys15;
};
var values6 = (self) => {
  const values15 = Array.from(self.referential.values());
  for (const bucket of self.buckets.values()) {
    for (let i = 0, len = bucket.length; i < len; i++) {
      values15.push(bucket[i][1]);
    }
  }
  return values15;
};
var getFromBucket = (self, bucket, key, remove21 = false) => {
  for (let i = 0, len = bucket.length; i < len; i++) {
    if (key[symbol3](bucket[i][0])) {
      const value10 = bucket[i][1];
      if (remove21) {
        bucket.splice(i, 1);
        self.bucketsSize--;
      }
      return some3(value10);
    }
  }
  return none2();
};
var has6 = dual(2, (self, key) => isSome2(get9(self, key)));
var set5 = dual(3, (self, key, value10) => {
  if (isEqual(key) === false) {
    self.referential.set(key, value10);
    return self;
  }
  const hash4 = key[symbol2]();
  const bucket = self.buckets.get(hash4);
  if (bucket === void 0) {
    self.buckets.set(hash4, [[key, value10]]);
    self.bucketsSize++;
    return self;
  }
  removeFromBucket(self, bucket, key);
  bucket.push([key, value10]);
  self.bucketsSize++;
  return self;
});
var removeFromBucket = (self, bucket, key) => {
  for (let i = 0, len = bucket.length; i < len; i++) {
    if (key[symbol3](bucket[i][0])) {
      bucket.splice(i, 1);
      self.bucketsSize--;
      return;
    }
  }
};
var modify6 = dual(3, (self, key, f) => {
  if (isEqual(key) === false) {
    if (self.referential.has(key)) {
      self.referential.set(key, f(self.referential.get(key)));
    }
    return self;
  }
  const hash4 = key[symbol2]();
  const bucket = self.buckets.get(hash4);
  if (bucket === void 0) {
    return self;
  }
  const value10 = getFromBucket(self, bucket, key, true);
  if (isNone2(value10)) {
    return self;
  }
  bucket.push([key, f(value10.value)]);
  self.bucketsSize++;
  return self;
});
var modifyAt3 = dual(3, (self, key, f) => {
  if (isEqual(key) === false) {
    const result2 = f(get9(self, key));
    if (isSome2(result2)) {
      set5(self, key, result2.value);
    } else {
      remove8(self, key);
    }
    return self;
  }
  const hash4 = key[symbol2]();
  const bucket = self.buckets.get(hash4);
  if (bucket === void 0) {
    const result2 = f(none2());
    return isSome2(result2) ? set5(self, key, result2.value) : self;
  }
  const result = f(getFromBucket(self, bucket, key, true));
  if (isNone2(result)) {
    if (bucket.length === 0) {
      self.buckets.delete(hash4);
    }
    return self;
  }
  bucket.push([key, result.value]);
  self.bucketsSize++;
  return self;
});
var remove8 = dual(2, (self, key) => {
  if (isEqual(key) === false) {
    self.referential.delete(key);
    return self;
  }
  const hash4 = key[symbol2]();
  const bucket = self.buckets.get(hash4);
  if (bucket === void 0) {
    return self;
  }
  removeFromBucket(self, bucket, key);
  if (bucket.length === 0) {
    self.buckets.delete(hash4);
  }
  return self;
});
var clear = (self) => {
  self.referential.clear();
  self.buckets.clear();
  self.bucketsSize = 0;
  return self;
};
var size10 = (self) => {
  return self.referential.size + self.bucketsSize;
};
var isEmpty8 = (self) => size10(self) === 0;
var forEach9 = dual(2, (self, f) => {
  self.referential.forEach(f);
  for (const bucket of self.buckets.values()) {
    for (const [key, value10] of bucket) {
      f(value10, key);
    }
  }
});

// ../../node_modules/effect/dist/esm/MutableQueue.js
var MutableQueue_exports = {};
__export(MutableQueue_exports, {
  EmptyMutableQueue: () => EmptyMutableQueue,
  bounded: () => bounded,
  capacity: () => capacity,
  isEmpty: () => isEmpty10,
  isFull: () => isFull,
  length: () => length3,
  offer: () => offer,
  offerAll: () => offerAll,
  poll: () => poll2,
  pollUpTo: () => pollUpTo,
  unbounded: () => unbounded
});

// ../../node_modules/effect/dist/esm/MutableList.js
var MutableList_exports = {};
__export(MutableList_exports, {
  append: () => append5,
  empty: () => empty24,
  forEach: () => forEach10,
  fromIterable: () => fromIterable10,
  head: () => head5,
  isEmpty: () => isEmpty9,
  length: () => length2,
  make: () => make26,
  pop: () => pop2,
  prepend: () => prepend5,
  reset: () => reset,
  shift: () => shift,
  tail: () => tail4
});
var TypeId12 = Symbol.for("effect/MutableList");
var MutableListProto = {
  [TypeId12]: TypeId12,
  [Symbol.iterator]() {
    let done17 = false;
    let head13 = this.head;
    return {
      next() {
        if (done17) {
          return this.return();
        }
        if (head13 == null) {
          done17 = true;
          return this.return();
        }
        const value10 = head13.value;
        head13 = head13.next;
        return {
          done: done17,
          value: value10
        };
      },
      return(value10) {
        if (!done17) {
          done17 = true;
        }
        return {
          done: true,
          value: value10
        };
      }
    };
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableList",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeNode = (value10) => ({
  value: value10,
  removed: false,
  prev: void 0,
  next: void 0
});
var empty24 = () => {
  const list = Object.create(MutableListProto);
  list.head = void 0;
  list.tail = void 0;
  list._length = 0;
  return list;
};
var fromIterable10 = (iterable) => {
  const list = empty24();
  for (const element2 of iterable) {
    append5(list, element2);
  }
  return list;
};
var make26 = (...elements) => fromIterable10(elements);
var isEmpty9 = (self) => length2(self) === 0;
var length2 = (self) => self._length;
var tail4 = (self) => self.tail === void 0 ? void 0 : self.tail.value;
var head5 = (self) => self.head === void 0 ? void 0 : self.head.value;
var forEach10 = dual(2, (self, f) => {
  let current2 = self.head;
  while (current2 !== void 0) {
    f(current2.value);
    current2 = current2.next;
  }
});
var reset = (self) => {
  ;
  self._length = 0;
  self.head = void 0;
  self.tail = void 0;
  return self;
};
var append5 = dual(2, (self, value10) => {
  const node = makeNode(value10);
  if (self.head === void 0) {
    self.head = node;
  }
  if (self.tail === void 0) {
    self.tail = node;
  } else {
    self.tail.next = node;
    node.prev = self.tail;
    self.tail = node;
  }
  ;
  self._length += 1;
  return self;
});
var shift = (self) => {
  const head13 = self.head;
  if (head13 !== void 0) {
    remove9(self, head13);
    return head13.value;
  }
  return void 0;
};
var pop2 = (self) => {
  const tail5 = self.tail;
  if (tail5 !== void 0) {
    remove9(self, tail5);
    return tail5.value;
  }
  return void 0;
};
var prepend5 = dual(2, (self, value10) => {
  const node = makeNode(value10);
  node.next = self.head;
  if (self.head !== void 0) {
    self.head.prev = node;
  }
  self.head = node;
  if (self.tail === void 0) {
    self.tail = node;
  }
  ;
  self._length += 1;
  return self;
});
var remove9 = (self, node) => {
  if (node.removed) {
    return;
  }
  node.removed = true;
  if (node.prev !== void 0 && node.next !== void 0) {
    node.prev.next = node.next;
    node.next.prev = node.prev;
  } else if (node.prev !== void 0) {
    self.tail = node.prev;
    node.prev.next = void 0;
  } else if (node.next !== void 0) {
    self.head = node.next;
    node.next.prev = void 0;
  } else {
    self.tail = void 0;
    self.head = void 0;
  }
  if (self._length > 0) {
    ;
    self._length -= 1;
  }
};

// ../../node_modules/effect/dist/esm/MutableQueue.js
var TypeId13 = Symbol.for("effect/MutableQueue");
var EmptyMutableQueue = Symbol.for("effect/mutable/MutableQueue/Empty");
var MutableQueueProto = {
  [TypeId13]: TypeId13,
  [Symbol.iterator]() {
    return Array.from(this.queue)[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableQueue",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make27 = (capacity10) => {
  const queue = Object.create(MutableQueueProto);
  queue.queue = empty24();
  queue.capacity = capacity10;
  return queue;
};
var bounded = (capacity10) => make27(capacity10);
var unbounded = () => make27(void 0);
var length3 = (self) => length2(self.queue);
var isEmpty10 = (self) => isEmpty9(self.queue);
var isFull = (self) => self.capacity === void 0 ? false : length2(self.queue) === self.capacity;
var capacity = (self) => self.capacity === void 0 ? Infinity : self.capacity;
var offer = dual(2, (self, value10) => {
  const queueLength = length2(self.queue);
  if (self.capacity !== void 0 && queueLength === self.capacity) {
    return false;
  }
  append5(value10)(self.queue);
  return true;
});
var offerAll = dual(2, (self, values15) => {
  const iterator = values15[Symbol.iterator]();
  let next6;
  let remainder3 = empty7();
  let offering = true;
  while (offering && (next6 = iterator.next()) && !next6.done) {
    offering = offer(next6.value)(self);
  }
  while (next6 != null && !next6.done) {
    remainder3 = prepend3(next6.value)(remainder3);
    next6 = iterator.next();
  }
  return reverse3(remainder3);
});
var poll2 = dual(2, (self, def) => {
  if (isEmpty9(self.queue)) {
    return def;
  }
  return shift(self.queue);
});
var pollUpTo = dual(2, (self, n) => {
  let result = empty7();
  let count9 = 0;
  while (count9 < n) {
    const element2 = poll2(EmptyMutableQueue)(self);
    if (element2 === EmptyMutableQueue) {
      break;
    }
    result = prepend3(element2)(result);
    count9 += 1;
  }
  return reverse3(result);
});

// ../../node_modules/effect/dist/esm/Clock.js
var Clock_exports = {};
__export(Clock_exports, {
  Clock: () => Clock,
  ClockTypeId: () => ClockTypeId2,
  clockWith: () => clockWith2,
  currentTimeMillis: () => currentTimeMillis2,
  currentTimeNanos: () => currentTimeNanos2,
  make: () => make32,
  sleep: () => sleep2
});

// ../../node_modules/effect/dist/esm/internal/clock.js
var ClockSymbolKey = "effect/Clock";
var ClockTypeId = Symbol.for(ClockSymbolKey);
var clockTag = GenericTag("effect/Clock");
var MAX_TIMER_MILLIS = 2 ** 31 - 1;
var globalClockScheduler = {
  unsafeSchedule(task, duration5) {
    const millis2 = toMillis(duration5);
    if (millis2 > MAX_TIMER_MILLIS) {
      return constFalse;
    }
    let completed = false;
    const handle = setTimeout(() => {
      completed = true;
      task();
    }, millis2);
    return () => {
      clearTimeout(handle);
      return !completed;
    };
  }
};
var performanceNowNanos = function() {
  const bigint1e62 = BigInt(1e6);
  if (typeof performance === "undefined") {
    return () => BigInt(Date.now()) * bigint1e62;
  }
  let origin;
  return () => {
    if (origin === void 0) {
      origin = BigInt(Date.now()) * bigint1e62 - BigInt(Math.round(performance.now() * 1e6));
    }
    return origin + BigInt(Math.round(performance.now() * 1e6));
  };
}();
var processOrPerformanceNow = function() {
  const processHrtime = typeof process === "object" && "hrtime" in process && typeof process.hrtime.bigint === "function" ? process.hrtime : void 0;
  if (!processHrtime) {
    return performanceNowNanos;
  }
  const origin = performanceNowNanos() - processHrtime.bigint();
  return () => origin + processHrtime.bigint();
}();
var ClockImpl = class {
  [ClockTypeId] = ClockTypeId;
  unsafeCurrentTimeMillis() {
    return Date.now();
  }
  unsafeCurrentTimeNanos() {
    return processOrPerformanceNow();
  }
  currentTimeMillis = sync(() => this.unsafeCurrentTimeMillis());
  currentTimeNanos = sync(() => this.unsafeCurrentTimeNanos());
  scheduler() {
    return succeed(globalClockScheduler);
  }
  sleep(duration5) {
    return async_((resume2) => {
      const canceler = globalClockScheduler.unsafeSchedule(() => resume2(void_3), duration5);
      return asVoid2(sync(canceler));
    });
  }
};
var make28 = () => new ClockImpl();

// ../../node_modules/effect/dist/esm/internal/opCodes/configError.js
var OP_AND = "And";
var OP_OR = "Or";
var OP_INVALID_DATA = "InvalidData";
var OP_MISSING_DATA = "MissingData";
var OP_SOURCE_UNAVAILABLE = "SourceUnavailable";
var OP_UNSUPPORTED = "Unsupported";

// ../../node_modules/effect/dist/esm/internal/configError.js
var ConfigErrorSymbolKey = "effect/ConfigError";
var ConfigErrorTypeId = Symbol.for(ConfigErrorSymbolKey);
var proto2 = {
  _tag: "ConfigError",
  [ConfigErrorTypeId]: ConfigErrorTypeId
};
var And = (self, that) => {
  const error4 = Object.create(proto2);
  error4._op = OP_AND;
  error4.left = self;
  error4.right = that;
  Object.defineProperty(error4, "toString", {
    enumerable: false,
    value() {
      return `${this.left} and ${this.right}`;
    }
  });
  Object.defineProperty(error4, "message", {
    enumerable: false,
    get() {
      return this.toString();
    }
  });
  return error4;
};
var Or = (self, that) => {
  const error4 = Object.create(proto2);
  error4._op = OP_OR;
  error4.left = self;
  error4.right = that;
  Object.defineProperty(error4, "toString", {
    enumerable: false,
    value() {
      return `${this.left} or ${this.right}`;
    }
  });
  Object.defineProperty(error4, "message", {
    enumerable: false,
    get() {
      return this.toString();
    }
  });
  return error4;
};
var InvalidData = (path, message, options = {
  pathDelim: "."
}) => {
  const error4 = Object.create(proto2);
  error4._op = OP_INVALID_DATA;
  error4.path = path;
  error4.message = message;
  Object.defineProperty(error4, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options.pathDelim));
      return `(Invalid data at ${path2}: "${this.message}")`;
    }
  });
  return error4;
};
var MissingData = (path, message, options = {
  pathDelim: "."
}) => {
  const error4 = Object.create(proto2);
  error4._op = OP_MISSING_DATA;
  error4.path = path;
  error4.message = message;
  Object.defineProperty(error4, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options.pathDelim));
      return `(Missing data at ${path2}: "${this.message}")`;
    }
  });
  return error4;
};
var SourceUnavailable = (path, message, cause3, options = {
  pathDelim: "."
}) => {
  const error4 = Object.create(proto2);
  error4._op = OP_SOURCE_UNAVAILABLE;
  error4.path = path;
  error4.message = message;
  error4.cause = cause3;
  Object.defineProperty(error4, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options.pathDelim));
      return `(Source unavailable at ${path2}: "${this.message}")`;
    }
  });
  return error4;
};
var Unsupported = (path, message, options = {
  pathDelim: "."
}) => {
  const error4 = Object.create(proto2);
  error4._op = OP_UNSUPPORTED;
  error4.path = path;
  error4.message = message;
  Object.defineProperty(error4, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options.pathDelim));
      return `(Unsupported operation at ${path2}: "${this.message}")`;
    }
  });
  return error4;
};
var isConfigError = (u) => hasProperty(u, ConfigErrorTypeId);
var isAnd = (self) => self._op === OP_AND;
var isOr = (self) => self._op === OP_OR;
var isInvalidData = (self) => self._op === OP_INVALID_DATA;
var isMissingData = (self) => self._op === OP_MISSING_DATA;
var isSourceUnavailable = (self) => self._op === OP_SOURCE_UNAVAILABLE;
var isUnsupported = (self) => self._op === OP_UNSUPPORTED;
var prefixed = dual(2, (self, prefix) => {
  switch (self._op) {
    case OP_AND: {
      return And(prefixed(self.left, prefix), prefixed(self.right, prefix));
    }
    case OP_OR: {
      return Or(prefixed(self.left, prefix), prefixed(self.right, prefix));
    }
    case OP_INVALID_DATA: {
      return InvalidData([...prefix, ...self.path], self.message);
    }
    case OP_MISSING_DATA: {
      return MissingData([...prefix, ...self.path], self.message);
    }
    case OP_SOURCE_UNAVAILABLE: {
      return SourceUnavailable([...prefix, ...self.path], self.message, self.cause);
    }
    case OP_UNSUPPORTED: {
      return Unsupported([...prefix, ...self.path], self.message);
    }
  }
});
var IsMissingDataOnlyReducer = {
  andCase: (_, left3, right3) => left3 && right3,
  orCase: (_, left3, right3) => left3 && right3,
  invalidDataCase: constFalse,
  missingDataCase: constTrue,
  sourceUnavailableCase: constFalse,
  unsupportedCase: constFalse
};
var reduceWithContext2 = dual(3, (self, context15, reducer) => {
  const input = [self];
  const output = [];
  while (input.length > 0) {
    const error4 = input.pop();
    switch (error4._op) {
      case OP_AND: {
        input.push(error4.right);
        input.push(error4.left);
        output.push(left2({
          _op: "AndCase"
        }));
        break;
      }
      case OP_OR: {
        input.push(error4.right);
        input.push(error4.left);
        output.push(left2({
          _op: "OrCase"
        }));
        break;
      }
      case OP_INVALID_DATA: {
        output.push(right2(reducer.invalidDataCase(context15, error4.path, error4.message)));
        break;
      }
      case OP_MISSING_DATA: {
        output.push(right2(reducer.missingDataCase(context15, error4.path, error4.message)));
        break;
      }
      case OP_SOURCE_UNAVAILABLE: {
        output.push(right2(reducer.sourceUnavailableCase(context15, error4.path, error4.message, error4.cause)));
        break;
      }
      case OP_UNSUPPORTED: {
        output.push(right2(reducer.unsupportedCase(context15, error4.path, error4.message)));
        break;
      }
    }
  }
  const accumulator = [];
  while (output.length > 0) {
    const either14 = output.pop();
    switch (either14._op) {
      case "Left": {
        switch (either14.left._op) {
          case "AndCase": {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value10 = reducer.andCase(context15, left3, right3);
            accumulator.push(value10);
            break;
          }
          case "OrCase": {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value10 = reducer.orCase(context15, left3, right3);
            accumulator.push(value10);
            break;
          }
        }
        break;
      }
      case "Right": {
        accumulator.push(either14.right);
        break;
      }
    }
  }
  if (accumulator.length === 0) {
    throw new Error("BUG: ConfigError.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  return accumulator.pop();
});
var isMissingDataOnly = (self) => reduceWithContext2(self, void 0, IsMissingDataOnlyReducer);

// ../../node_modules/effect/dist/esm/internal/configProvider/pathPatch.js
var empty25 = {
  _tag: "Empty"
};
var andThen7 = dual(2, (self, that) => ({
  _tag: "AndThen",
  first: self,
  second: that
}));
var mapName = dual(2, (self, f) => andThen7(self, {
  _tag: "MapName",
  f
}));
var nested = dual(2, (self, name) => andThen7(self, {
  _tag: "Nested",
  name
}));
var unnested = dual(2, (self, name) => andThen7(self, {
  _tag: "Unnested",
  name
}));
var patch8 = dual(2, (path, patch14) => {
  let input = of4(patch14);
  let output = path;
  while (isCons(input)) {
    const patch15 = input.head;
    switch (patch15._tag) {
      case "Empty": {
        input = input.tail;
        break;
      }
      case "AndThen": {
        input = cons(patch15.first, cons(patch15.second, input.tail));
        break;
      }
      case "MapName": {
        output = map6(output, patch15.f);
        input = input.tail;
        break;
      }
      case "Nested": {
        output = prepend2(output, patch15.name);
        input = input.tail;
        break;
      }
      case "Unnested": {
        const containsName = pipe(head2(output), contains(patch15.name));
        if (containsName) {
          output = tailNonEmpty(output);
          input = input.tail;
        } else {
          return left2(MissingData(output, `Expected ${patch15.name} to be in path in ConfigProvider#unnested`));
        }
        break;
      }
    }
  }
  return right2(output);
});

// ../../node_modules/effect/dist/esm/internal/opCodes/config.js
var OP_CONSTANT = "Constant";
var OP_FAIL2 = "Fail";
var OP_FALLBACK = "Fallback";
var OP_DESCRIBED = "Described";
var OP_LAZY = "Lazy";
var OP_MAP_OR_FAIL = "MapOrFail";
var OP_NESTED = "Nested";
var OP_PRIMITIVE = "Primitive";
var OP_SEQUENCE = "Sequence";
var OP_HASHMAP = "HashMap";
var OP_ZIP_WITH = "ZipWith";

// ../../node_modules/effect/dist/esm/internal/string-utils.js
var lowerCase = (str) => str.toLowerCase();
var upperCase = (str) => str.toUpperCase();
var replace4 = (input, re, value10) => re instanceof RegExp ? input.replace(re, value10) : re.reduce((input2, re2) => input2.replace(re2, value10), input);
var DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];
var DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;
var noCase = (input, options = {}) => {
  const {
    delimiter = " ",
    splitRegexp = DEFAULT_SPLIT_REGEXP,
    stripRegexp = DEFAULT_STRIP_REGEXP,
    transform: transform10 = lowerCase
  } = options;
  const result = replace4(replace4(input, splitRegexp, "$1\0$2"), stripRegexp, "\0");
  let start5 = 0;
  let end7 = result.length;
  while (result.charAt(start5) === "\0") {
    start5++;
  }
  while (result.charAt(end7 - 1) === "\0") {
    end7--;
  }
  return result.slice(start5, end7).split("\0").map(transform10).join(delimiter);
};
var constantCase = (input, options) => noCase(input, {
  delimiter: "_",
  transform: upperCase,
  ...options
});
var kebabCase = (input, options) => noCase(input, {
  delimiter: "-",
  ...options
});
var snakeCase = (input, options) => noCase(input, {
  delimiter: "_",
  ...options
});

// ../../node_modules/effect/dist/esm/internal/configProvider.js
var concat = (l, r) => [...l, ...r];
var ConfigProviderSymbolKey = "effect/ConfigProvider";
var ConfigProviderTypeId = Symbol.for(ConfigProviderSymbolKey);
var configProviderTag = GenericTag("effect/ConfigProvider");
var FlatConfigProviderSymbolKey = "effect/ConfigProviderFlat";
var FlatConfigProviderTypeId = Symbol.for(FlatConfigProviderSymbolKey);
var make29 = (options) => ({
  [ConfigProviderTypeId]: ConfigProviderTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  ...options
});
var makeFlat = (options) => ({
  [FlatConfigProviderTypeId]: FlatConfigProviderTypeId,
  patch: options.patch,
  load: (path, config2, split7 = true) => options.load(path, config2, split7),
  enumerateChildren: options.enumerateChildren
});
var fromFlat = (flat) => make29({
  load: (config2) => flatMap12(fromFlatLoop(flat, empty4(), config2, false), (chunk7) => match2(head2(chunk7), {
    onNone: () => fail2(MissingData(empty4(), `Expected a single value having structure: ${config2}`)),
    onSome: succeed
  })),
  flattened: flat
});
var fromEnv = (options) => {
  const {
    pathDelim,
    seqDelim
  } = Object.assign({}, {
    pathDelim: "_",
    seqDelim: ","
  }, options);
  const makePathString = (path) => pipe(path, join(pathDelim));
  const unmakePathString = (pathString) => pathString.split(pathDelim);
  const getEnv = () => typeof process !== "undefined" && "env" in process && typeof process.env === "object" ? process.env : {};
  const load = (path, primitive3, split7 = true) => {
    const pathString = makePathString(path);
    const current2 = getEnv();
    const valueOpt = pathString in current2 ? some3(current2[pathString]) : none2();
    return pipe(valueOpt, mapError(() => MissingData(path, `Expected ${pathString} to exist in the process context`)), flatMap12((value10) => parsePrimitive(value10, path, primitive3, seqDelim, split7)));
  };
  const enumerateChildren = (path) => sync(() => {
    const current2 = getEnv();
    const keys15 = Object.keys(current2);
    const keyPaths = keys15.map((value10) => unmakePathString(value10.toUpperCase()));
    const filteredKeyPaths = keyPaths.filter((keyPath) => {
      for (let i = 0; i < path.length; i++) {
        const pathComponent = pipe(path, unsafeGet(i));
        const currentElement = keyPath[i];
        if (currentElement === void 0 || pathComponent !== currentElement) {
          return false;
        }
      }
      return true;
    }).flatMap((keyPath) => keyPath.slice(path.length, path.length + 1));
    return fromIterable6(filteredKeyPaths);
  });
  return fromFlat(makeFlat({
    load,
    enumerateChildren,
    patch: empty25
  }));
};
var fromMap = (map49, config2) => {
  const {
    pathDelim,
    seqDelim
  } = Object.assign({
    seqDelim: ",",
    pathDelim: "."
  }, config2);
  const makePathString = (path) => pipe(path, join(pathDelim));
  const unmakePathString = (pathString) => pathString.split(pathDelim);
  const mapWithIndexSplit = splitIndexInKeys(map49, (str) => unmakePathString(str), makePathString);
  const load = (path, primitive3, split7 = true) => {
    const pathString = makePathString(path);
    const valueOpt = mapWithIndexSplit.has(pathString) ? some3(mapWithIndexSplit.get(pathString)) : none2();
    return pipe(valueOpt, mapError(() => MissingData(path, `Expected ${pathString} to exist in the provided map`)), flatMap12((value10) => parsePrimitive(value10, path, primitive3, seqDelim, split7)));
  };
  const enumerateChildren = (path) => sync(() => {
    const keyPaths = fromIterable2(mapWithIndexSplit.keys()).map(unmakePathString);
    const filteredKeyPaths = keyPaths.filter((keyPath) => {
      for (let i = 0; i < path.length; i++) {
        const pathComponent = pipe(path, unsafeGet(i));
        const currentElement = keyPath[i];
        if (currentElement === void 0 || pathComponent !== currentElement) {
          return false;
        }
      }
      return true;
    }).flatMap((keyPath) => keyPath.slice(path.length, path.length + 1));
    return fromIterable6(filteredKeyPaths);
  });
  return fromFlat(makeFlat({
    load,
    enumerateChildren,
    patch: empty25
  }));
};
var extend2 = (leftDef, rightDef, left3, right3) => {
  const leftPad = unfold2(left3.length, (index) => index >= right3.length ? none2() : some3([leftDef(index), index + 1]));
  const rightPad = unfold2(right3.length, (index) => index >= left3.length ? none2() : some3([rightDef(index), index + 1]));
  const leftExtension = concat(left3, leftPad);
  const rightExtension = concat(right3, rightPad);
  return [leftExtension, rightExtension];
};
var appendConfigPath = (path, config2) => {
  let op = config2;
  if (op._tag === "Nested") {
    const out = path.slice();
    while (op._tag === "Nested") {
      out.push(op.name);
      op = op.config;
    }
    return out;
  }
  return path;
};
var fromFlatLoop = (flat, prefix, config2, split7) => {
  const op = config2;
  switch (op._tag) {
    case OP_CONSTANT: {
      return succeed(of2(op.value));
    }
    case OP_DESCRIBED: {
      return suspend(() => fromFlatLoop(flat, prefix, op.config, split7));
    }
    case OP_FAIL2: {
      return fail2(MissingData(prefix, op.message));
    }
    case OP_FALLBACK: {
      return pipe(suspend(() => fromFlatLoop(flat, prefix, op.first, split7)), catchAll((error1) => {
        if (op.condition(error1)) {
          return pipe(fromFlatLoop(flat, prefix, op.second, split7), catchAll((error22) => fail2(Or(error1, error22))));
        }
        return fail2(error1);
      }));
    }
    case OP_LAZY: {
      return suspend(() => fromFlatLoop(flat, prefix, op.config(), split7));
    }
    case OP_MAP_OR_FAIL: {
      return suspend(() => pipe(fromFlatLoop(flat, prefix, op.original, split7), flatMap12(forEachSequential((a) => pipe(op.mapOrFail(a), mapError(prefixed(appendConfigPath(prefix, op.original))))))));
    }
    case OP_NESTED: {
      return suspend(() => fromFlatLoop(flat, concat(prefix, of2(op.name)), op.config, split7));
    }
    case OP_PRIMITIVE: {
      return pipe(patch8(prefix, flat.patch), flatMap12((prefix2) => pipe(flat.load(prefix2, op, split7), flatMap12((values15) => {
        if (values15.length === 0) {
          const name = pipe(last(prefix2), getOrElse2(() => "<n/a>"));
          return fail2(MissingData([], `Expected ${op.description} with name ${name}`));
        }
        return succeed(values15);
      }))));
    }
    case OP_SEQUENCE: {
      return pipe(patch8(prefix, flat.patch), flatMap12((patchedPrefix) => pipe(flat.enumerateChildren(patchedPrefix), flatMap12(indicesFrom), flatMap12((indices) => {
        if (indices.length === 0) {
          return suspend(() => map14(fromFlatLoop(flat, prefix, op.config, true), of2));
        }
        return pipe(forEachSequential(indices, (index) => fromFlatLoop(flat, append2(prefix, `[${index}]`), op.config, true)), map14((chunkChunk) => {
          const flattened = flatten3(chunkChunk);
          if (flattened.length === 0) {
            return of2(empty4());
          }
          return of2(flattened);
        }));
      }))));
    }
    case OP_HASHMAP: {
      return suspend(() => pipe(patch8(prefix, flat.patch), flatMap12((prefix2) => pipe(flat.enumerateChildren(prefix2), flatMap12((keys15) => {
        return pipe(keys15, forEachSequential((key) => fromFlatLoop(flat, concat(prefix2, of2(key)), op.valueConfig, split7)), map14((matrix) => {
          if (matrix.length === 0) {
            return of2(empty11());
          }
          return pipe(transpose(matrix), map6((values15) => fromIterable7(zip2(fromIterable2(keys15), values15))));
        }));
      })))));
    }
    case OP_ZIP_WITH: {
      return suspend(() => pipe(fromFlatLoop(flat, prefix, op.left, split7), either3, flatMap12((left3) => pipe(fromFlatLoop(flat, prefix, op.right, split7), either3, flatMap12((right3) => {
        if (isLeft2(left3) && isLeft2(right3)) {
          return fail2(And(left3.left, right3.left));
        }
        if (isLeft2(left3) && isRight2(right3)) {
          return fail2(left3.left);
        }
        if (isRight2(left3) && isLeft2(right3)) {
          return fail2(right3.left);
        }
        if (isRight2(left3) && isRight2(right3)) {
          const path = pipe(prefix, join("."));
          const fail30 = fromFlatLoopFail(prefix, path);
          const [lefts, rights] = extend2(fail30, fail30, pipe(left3.right, map6(right2)), pipe(right3.right, map6(right2)));
          return pipe(lefts, zip2(rights), forEachSequential(([left4, right4]) => pipe(zip5(left4, right4), map14(([left5, right5]) => op.zip(left5, right5)))));
        }
        throw new Error("BUG: ConfigProvider.fromFlatLoop - please report an issue at https://github.com/Effect-TS/effect/issues");
      })))));
    }
  }
};
var fromFlatLoopFail = (prefix, path) => (index) => left2(MissingData(prefix, `The element at index ${index} in a sequence at path "${path}" was missing`));
var mapInputPath = dual(2, (self, f) => fromFlat(mapInputPathFlat(self.flattened, f)));
var mapInputPathFlat = (self, f) => makeFlat({
  load: (path, config2, split7 = true) => self.load(path, config2, split7),
  enumerateChildren: (path) => self.enumerateChildren(path),
  patch: mapName(self.patch, f)
});
var nested2 = dual(2, (self, name) => fromFlat(makeFlat({
  load: (path, config2) => self.flattened.load(path, config2, true),
  enumerateChildren: (path) => self.flattened.enumerateChildren(path),
  patch: nested(self.flattened.patch, name)
})));
var unnested2 = dual(2, (self, name) => fromFlat(makeFlat({
  load: (path, config2) => self.flattened.load(path, config2, true),
  enumerateChildren: (path) => self.flattened.enumerateChildren(path),
  patch: unnested(self.flattened.patch, name)
})));
var orElse4 = dual(2, (self, that) => fromFlat(orElseFlat(self.flattened, () => that().flattened)));
var orElseFlat = (self, that) => makeFlat({
  load: (path, config2, split7) => pipe(patch8(path, self.patch), flatMap12((patch14) => self.load(patch14, config2, split7)), catchAll((error1) => pipe(sync(that), flatMap12((that2) => pipe(patch8(path, that2.patch), flatMap12((patch14) => that2.load(patch14, config2, split7)), catchAll((error22) => fail2(Or(error1, error22)))))))),
  enumerateChildren: (path) => pipe(patch8(path, self.patch), flatMap12((patch14) => self.enumerateChildren(patch14)), either3, flatMap12((left3) => pipe(sync(that), flatMap12((that2) => pipe(patch8(path, that2.patch), flatMap12((patch14) => that2.enumerateChildren(patch14)), either3, flatMap12((right3) => {
    if (isLeft2(left3) && isLeft2(right3)) {
      return fail2(And(left3.left, right3.left));
    }
    if (isLeft2(left3) && isRight2(right3)) {
      return succeed(right3.right);
    }
    if (isRight2(left3) && isLeft2(right3)) {
      return succeed(left3.right);
    }
    if (isRight2(left3) && isRight2(right3)) {
      return succeed(pipe(left3.right, union6(right3.right)));
    }
    throw new Error("BUG: ConfigProvider.orElseFlat - please report an issue at https://github.com/Effect-TS/effect/issues");
  })))))),
  patch: empty25
});
var constantCase2 = (self) => mapInputPath(self, constantCase);
var kebabCase2 = (self) => mapInputPath(self, kebabCase);
var lowerCase2 = (self) => mapInputPath(self, lowerCase);
var snakeCase2 = (self) => mapInputPath(self, snakeCase);
var upperCase2 = (self) => mapInputPath(self, upperCase);
var within = dual(3, (self, path, f) => {
  const unnest = reduce3(path, self, (provider, name) => unnested2(provider, name));
  const nest = reduceRight(path, f(unnest), (provider, name) => nested2(provider, name));
  return orElse4(nest, () => self);
});
var splitPathString = (text, delim) => {
  const split7 = text.split(new RegExp(`\\s*${escape(delim)}\\s*`));
  return split7;
};
var parsePrimitive = (text, path, primitive3, delimiter, split7) => {
  if (!split7) {
    return pipe(primitive3.parse(text), mapBoth3({
      onFailure: prefixed(path),
      onSuccess: of2
    }));
  }
  return pipe(splitPathString(text, delimiter), forEachSequential((char2) => primitive3.parse(char2.trim())), mapError(prefixed(path)));
};
var transpose = (array8) => {
  return Object.keys(array8[0]).map((column) => array8.map((row) => row[column]));
};
var indicesFrom = (quotedIndices) => pipe(forEachSequential(quotedIndices, parseQuotedIndex), mapBoth3({
  onFailure: () => empty4(),
  onSuccess: sort(Order)
}), either3, map14(merge));
var STR_INDEX_REGEX = /(^.+)(\[(\d+)\])$/;
var QUOTED_INDEX_REGEX = /^(\[(\d+)\])$/;
var parseQuotedIndex = (str) => {
  const match43 = str.match(QUOTED_INDEX_REGEX);
  if (match43 !== null) {
    const matchedIndex = match43[2];
    return pipe(matchedIndex !== void 0 && matchedIndex.length > 0 ? some3(matchedIndex) : none2(), flatMap2(parseInteger));
  }
  return none2();
};
var splitIndexInKeys = (map49, unmakePathString, makePathString) => {
  const newMap = /* @__PURE__ */ new Map();
  for (const [pathString, value10] of map49) {
    const keyWithIndex = pipe(unmakePathString(pathString), flatMap4((key) => match2(splitIndexFrom(key), {
      onNone: () => of2(key),
      onSome: ([key2, index]) => make4(key2, `[${index}]`)
    })));
    newMap.set(makePathString(keyWithIndex), value10);
  }
  return newMap;
};
var splitIndexFrom = (key) => {
  const match43 = key.match(STR_INDEX_REGEX);
  if (match43 !== null) {
    const matchedString = match43[1];
    const matchedIndex = match43[3];
    const optionalString = matchedString !== void 0 && matchedString.length > 0 ? some3(matchedString) : none2();
    const optionalIndex = pipe(matchedIndex !== void 0 && matchedIndex.length > 0 ? some3(matchedIndex) : none2(), flatMap2(parseInteger));
    return all5([optionalString, optionalIndex]);
  }
  return none2();
};
var parseInteger = (str) => {
  const parsedIndex = Number.parseInt(str);
  return Number.isNaN(parsedIndex) ? none2() : some3(parsedIndex);
};
var keyName = (name) => ({
  _tag: "KeyName",
  name
});
var keyIndex = (index) => ({
  _tag: "KeyIndex",
  index
});
var fromJson = (json3) => {
  const hiddenDelimiter = "\uFEFF";
  const indexedEntries = map6(getIndexedEntries(json3), ([key, value10]) => [configPathToString(key).join(hiddenDelimiter), value10]);
  return fromMap(new Map(indexedEntries), {
    pathDelim: hiddenDelimiter,
    seqDelim: hiddenDelimiter
  });
};
var configPathToString = (path) => {
  const output = [];
  let i = 0;
  while (i < path.length) {
    const component = path[i];
    if (component._tag === "KeyName") {
      if (i + 1 < path.length) {
        const nextComponent = path[i + 1];
        if (nextComponent._tag === "KeyIndex") {
          output.push(`${component.name}[${nextComponent.index}]`);
          i += 2;
        } else {
          output.push(component.name);
          i += 1;
        }
      } else {
        output.push(component.name);
        i += 1;
      }
    }
  }
  return output;
};
var getIndexedEntries = (config2) => {
  const loopAny = (path, value10) => {
    if (typeof value10 === "string") {
      return make4([path, value10]);
    }
    if (typeof value10 === "number" || typeof value10 === "boolean") {
      return make4([path, String(value10)]);
    }
    if (isArray(value10)) {
      return loopArray(path, value10);
    }
    if (typeof value10 === "object" && value10 !== null) {
      return loopObject(path, value10);
    }
    return empty4();
  };
  const loopArray = (path, values15) => match3(values15, {
    onEmpty: () => make4([path, "<nil>"]),
    onNonEmpty: flatMap4((value10, index) => loopAny(append2(path, keyIndex(index)), value10))
  });
  const loopObject = (path, value10) => Object.entries(value10).filter(([, value11]) => isNotNullable(value11)).flatMap(([key, value11]) => {
    const newPath = append2(path, keyName(key));
    const result = loopAny(newPath, value11);
    if (isEmptyReadonlyArray(result)) {
      return make4([newPath, ""]);
    }
    return result;
  });
  return loopObject(empty4(), config2);
};

// ../../node_modules/effect/dist/esm/internal/defaultServices/console.js
var TypeId14 = Symbol.for("effect/Console");
var consoleTag = GenericTag("effect/Console");
var defaultConsole = {
  [TypeId14]: TypeId14,
  assert(condition, ...args2) {
    return sync(() => {
      console.assert(condition, ...args2);
    });
  },
  clear: sync(() => {
    console.clear();
  }),
  count(label) {
    return sync(() => {
      console.count(label);
    });
  },
  countReset(label) {
    return sync(() => {
      console.countReset(label);
    });
  },
  debug(...args2) {
    return sync(() => {
      console.debug(...args2);
    });
  },
  dir(item, options) {
    return sync(() => {
      console.dir(item, options);
    });
  },
  dirxml(...args2) {
    return sync(() => {
      console.dirxml(...args2);
    });
  },
  error(...args2) {
    return sync(() => {
      console.error(...args2);
    });
  },
  group(options) {
    return options?.collapsed ? sync(() => console.groupCollapsed(options?.label)) : sync(() => console.group(options?.label));
  },
  groupEnd: sync(() => {
    console.groupEnd();
  }),
  info(...args2) {
    return sync(() => {
      console.info(...args2);
    });
  },
  log(...args2) {
    return sync(() => {
      console.log(...args2);
    });
  },
  table(tabularData, properties) {
    return sync(() => {
      console.table(tabularData, properties);
    });
  },
  time(label) {
    return sync(() => console.time(label));
  },
  timeEnd(label) {
    return sync(() => console.timeEnd(label));
  },
  timeLog(label, ...args2) {
    return sync(() => {
      console.timeLog(label, ...args2);
    });
  },
  trace(...args2) {
    return sync(() => {
      console.trace(...args2);
    });
  },
  warn(...args2) {
    return sync(() => {
      console.warn(...args2);
    });
  },
  unsafe: console
};

// ../../node_modules/effect/dist/esm/internal/random.js
var RandomSymbolKey = "effect/Random";
var RandomTypeId = Symbol.for(RandomSymbolKey);
var randomTag = GenericTag("effect/Random");
var RandomImpl = class {
  seed;
  [RandomTypeId] = RandomTypeId;
  PRNG;
  constructor(seed) {
    this.seed = seed;
    this.PRNG = new PCGRandom(seed);
  }
  get next() {
    return sync(() => this.PRNG.number());
  }
  get nextBoolean() {
    return map14(this.next, (n) => n > 0.5);
  }
  get nextInt() {
    return sync(() => this.PRNG.integer(Number.MAX_SAFE_INTEGER));
  }
  nextRange(min11, max13) {
    return map14(this.next, (n) => (max13 - min11) * n + min11);
  }
  nextIntBetween(min11, max13) {
    return sync(() => this.PRNG.integer(max13 - min11) + min11);
  }
  shuffle(elements) {
    return shuffleWith(elements, (n) => this.nextIntBetween(0, n));
  }
};
var shuffleWith = (elements, nextIntBounded) => {
  return suspend(() => pipe(sync(() => Array.from(elements)), flatMap12((buffer5) => {
    const numbers = [];
    for (let i = buffer5.length; i >= 2; i = i - 1) {
      numbers.push(i);
    }
    return pipe(numbers, forEachSequentialDiscard((n) => pipe(nextIntBounded(n), map14((k) => swap2(buffer5, n - 1, k)))), as3(fromIterable3(buffer5)));
  })));
};
var swap2 = (buffer5, index1, index2) => {
  const tmp = buffer5[index1];
  buffer5[index1] = buffer5[index2];
  buffer5[index2] = tmp;
  return buffer5;
};
var make30 = (seed) => new RandomImpl(hash(seed));
var FixedRandomImpl = class {
  values;
  [RandomTypeId] = RandomTypeId;
  index = 0;
  constructor(values15) {
    this.values = values15;
    if (values15.length === 0) {
      throw new Error("Requires at least one value");
    }
  }
  getNextValue() {
    const value10 = this.values[this.index];
    this.index = (this.index + 1) % this.values.length;
    return value10;
  }
  get next() {
    return sync(() => {
      const value10 = this.getNextValue();
      if (typeof value10 === "number") {
        return Math.max(0, Math.min(1, value10));
      }
      return hash(value10) / 2147483647;
    });
  }
  get nextBoolean() {
    return sync(() => {
      const value10 = this.getNextValue();
      if (typeof value10 === "boolean") {
        return value10;
      }
      return hash(value10) % 2 === 0;
    });
  }
  get nextInt() {
    return sync(() => {
      const value10 = this.getNextValue();
      if (typeof value10 === "number" && Number.isFinite(value10)) {
        return Math.round(value10);
      }
      return Math.abs(hash(value10));
    });
  }
  nextRange(min11, max13) {
    return map14(this.next, (n) => (max13 - min11) * n + min11);
  }
  nextIntBetween(min11, max13) {
    return sync(() => {
      const value10 = this.getNextValue();
      if (typeof value10 === "number" && Number.isFinite(value10)) {
        return Math.max(min11, Math.min(max13 - 1, Math.round(value10)));
      }
      const hash4 = Math.abs(hash(value10));
      return min11 + hash4 % (max13 - min11);
    });
  }
  shuffle(elements) {
    return shuffleWith(elements, (n) => this.nextIntBetween(0, n));
  }
};
var fixed = (values15) => new FixedRandomImpl(values15);

// ../../node_modules/effect/dist/esm/internal/tracer.js
var TracerTypeId = Symbol.for("effect/Tracer");
var make31 = (options) => ({
  [TracerTypeId]: TracerTypeId,
  ...options
});
var tracerTag = GenericTag("effect/Tracer");
var spanTag = GenericTag("effect/ParentSpan");
var randomHexString = function() {
  const characters = "abcdef0123456789";
  const charactersLength = characters.length;
  return function(length6) {
    let result = "";
    for (let i = 0; i < length6; i++) {
      result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
  };
}();
var NativeSpan = class {
  name;
  parent;
  context;
  startTime;
  kind;
  _tag = "Span";
  spanId;
  traceId = "native";
  sampled = true;
  status;
  attributes;
  events = [];
  links;
  constructor(name, parent, context15, links, startTime, kind) {
    this.name = name;
    this.parent = parent;
    this.context = context15;
    this.startTime = startTime;
    this.kind = kind;
    this.status = {
      _tag: "Started",
      startTime
    };
    this.attributes = /* @__PURE__ */ new Map();
    this.traceId = parent._tag === "Some" ? parent.value.traceId : randomHexString(32);
    this.spanId = randomHexString(16);
    this.links = Array.from(links);
  }
  end(endTime, exit4) {
    this.status = {
      _tag: "Ended",
      endTime,
      exit: exit4,
      startTime: this.status.startTime
    };
  }
  attribute(key, value10) {
    this.attributes.set(key, value10);
  }
  event(name, startTime, attributes) {
    this.events.push([name, startTime, attributes ?? {}]);
  }
  addLinks(links) {
    this.links.push(...links);
  }
};
var nativeTracer = make31({
  span: (name, parent, context15, links, startTime, kind) => new NativeSpan(name, parent, context15, links, startTime, kind),
  context: (f) => f()
});
var externalSpan = (options) => ({
  _tag: "ExternalSpan",
  spanId: options.spanId,
  traceId: options.traceId,
  sampled: options.sampled ?? true,
  context: options.context ?? empty6()
});
var addSpanStackTrace = (options) => {
  if (options?.captureStackTrace === false) {
    return options;
  } else if (options?.captureStackTrace !== void 0 && typeof options.captureStackTrace !== "boolean") {
    return options;
  }
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 3;
  const traceError = new Error();
  Error.stackTraceLimit = limit;
  let cache = false;
  return {
    ...options,
    captureStackTrace: () => {
      if (cache !== false) {
        return cache;
      }
      if (traceError.stack !== void 0) {
        const stack = traceError.stack.split("\n");
        if (stack[3] !== void 0) {
          cache = stack[3].trim();
          return cache;
        }
      }
    }
  };
};
var DisablePropagation = Reference2()("effect/Tracer/DisablePropagation", {
  defaultValue: constFalse
});

// ../../node_modules/effect/dist/esm/internal/defaultServices.js
var liveServices = pipe(empty6(), add2(clockTag, make28()), add2(consoleTag, defaultConsole), add2(randomTag, make30(Math.random())), add2(configProviderTag, fromEnv()), add2(tracerTag, nativeTracer));
var currentServices = globalValue(Symbol.for("effect/DefaultServices/currentServices"), () => fiberRefUnsafeMakeContext(liveServices));
var sleep = (duration5) => {
  const decodedDuration = decode(duration5);
  return clockWith((clock3) => clock3.sleep(decodedDuration));
};
var defaultServicesWith = (f) => withFiberRuntime((fiber) => f(fiber.currentDefaultServices));
var clockWith = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(clockTag.key)));
var currentTimeMillis = clockWith((clock3) => clock3.currentTimeMillis);
var currentTimeNanos = clockWith((clock3) => clock3.currentTimeNanos);
var withClock = dual(2, (effect4, c) => fiberRefLocallyWith(currentServices, add2(clockTag, c))(effect4));
var withConfigProvider = dual(2, (self, provider) => fiberRefLocallyWith(currentServices, add2(configProviderTag, provider))(self));
var configProviderWith = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(configProviderTag.key)));
var config = (config2) => configProviderWith((_) => _.load(config2));
var randomWith = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(randomTag.key)));
var withRandom = dual(2, (effect4, value10) => fiberRefLocallyWith(currentServices, add2(randomTag, value10))(effect4));
var next = randomWith((random4) => random4.next);
var nextInt = randomWith((random4) => random4.nextInt);
var nextBoolean = randomWith((random4) => random4.nextBoolean);
var nextRange = (min11, max13) => randomWith((random4) => random4.nextRange(min11, max13));
var nextIntBetween = (min11, max13) => randomWith((random4) => random4.nextIntBetween(min11, max13));
var shuffle = (elements) => randomWith((random4) => random4.shuffle(elements));
var choice = (elements) => {
  const array8 = fromIterable2(elements);
  return map14(array8.length === 0 ? fail2(new NoSuchElementException("Cannot select a random element from an empty array")) : randomWith((random4) => random4.nextIntBetween(0, array8.length)), (i) => array8[i]);
};
var tracerWith = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(tracerTag.key)));
var withTracer = dual(2, (effect4, value10) => fiberRefLocallyWith(currentServices, add2(tracerTag, value10))(effect4));

// ../../node_modules/effect/dist/esm/Clock.js
var ClockTypeId2 = ClockTypeId;
var make32 = make28;
var sleep2 = sleep;
var currentTimeMillis2 = currentTimeMillis;
var currentTimeNanos2 = currentTimeNanos;
var clockWith2 = clockWith;
var Clock = clockTag;

// ../../node_modules/effect/dist/esm/FiberRefs.js
var FiberRefs_exports = {};
__export(FiberRefs_exports, {
  FiberRefsSym: () => FiberRefsSym2,
  delete: () => delete_2,
  empty: () => empty27,
  fiberRefs: () => fiberRefs2,
  forkAs: () => forkAs2,
  get: () => get11,
  getOrDefault: () => getOrDefault2,
  joinAs: () => joinAs2,
  setAll: () => setAll2,
  unsafeMake: () => unsafeMake6,
  updateAs: () => updateAs2,
  updateManyAs: () => updateManyAs2
});

// ../../node_modules/effect/dist/esm/internal/fiberRefs.js
function unsafeMake5(fiberRefLocals) {
  return new FiberRefsImpl(fiberRefLocals);
}
function empty26() {
  return unsafeMake5(/* @__PURE__ */ new Map());
}
var FiberRefsSym = Symbol.for("effect/FiberRefs");
var FiberRefsImpl = class {
  locals;
  [FiberRefsSym] = FiberRefsSym;
  constructor(locals) {
    this.locals = locals;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var findAncestor = (_ref, _parentStack, _childStack, _childModified = false) => {
  const ref = _ref;
  let parentStack = _parentStack;
  let childStack = _childStack;
  let childModified = _childModified;
  let ret = void 0;
  while (ret === void 0) {
    if (isNonEmptyReadonlyArray(parentStack) && isNonEmptyReadonlyArray(childStack)) {
      const parentFiberId = headNonEmpty(parentStack)[0];
      const parentAncestors = tailNonEmpty(parentStack);
      const childFiberId = headNonEmpty(childStack)[0];
      const childRefValue = headNonEmpty(childStack)[1];
      const childAncestors = tailNonEmpty(childStack);
      if (parentFiberId.startTimeMillis < childFiberId.startTimeMillis) {
        childStack = childAncestors;
        childModified = true;
      } else if (parentFiberId.startTimeMillis > childFiberId.startTimeMillis) {
        parentStack = parentAncestors;
      } else {
        if (parentFiberId.id < childFiberId.id) {
          childStack = childAncestors;
          childModified = true;
        } else if (parentFiberId.id > childFiberId.id) {
          parentStack = parentAncestors;
        } else {
          ret = [childRefValue, childModified];
        }
      }
    } else {
      ret = [ref.initial, true];
    }
  }
  return ret;
};
var joinAs = dual(3, (self, fiberId5, that) => {
  const parentFiberRefs = new Map(self.locals);
  that.locals.forEach((childStack, fiberRef) => {
    const childValue = childStack[0][1];
    if (!childStack[0][0][symbol3](fiberId5)) {
      if (!parentFiberRefs.has(fiberRef)) {
        if (equals(childValue, fiberRef.initial)) {
          return;
        }
        parentFiberRefs.set(fiberRef, [[fiberId5, fiberRef.join(fiberRef.initial, childValue)]]);
        return;
      }
      const parentStack = parentFiberRefs.get(fiberRef);
      const [ancestor, wasModified] = findAncestor(fiberRef, parentStack, childStack);
      if (wasModified) {
        const patch14 = fiberRef.diff(ancestor, childValue);
        const oldValue = parentStack[0][1];
        const newValue = fiberRef.join(oldValue, fiberRef.patch(patch14)(oldValue));
        if (!equals(oldValue, newValue)) {
          let newStack;
          const parentFiberId = parentStack[0][0];
          if (parentFiberId[symbol3](fiberId5)) {
            newStack = [[parentFiberId, newValue], ...parentStack.slice(1)];
          } else {
            newStack = [[fiberId5, newValue], ...parentStack];
          }
          parentFiberRefs.set(fiberRef, newStack);
        }
      }
    }
  });
  return new FiberRefsImpl(parentFiberRefs);
});
var forkAs = dual(2, (self, childId) => {
  const map49 = /* @__PURE__ */ new Map();
  unsafeForkAs(self, map49, childId);
  return new FiberRefsImpl(map49);
});
var unsafeForkAs = (self, map49, fiberId5) => {
  self.locals.forEach((stack, fiberRef) => {
    const oldValue = stack[0][1];
    const newValue = fiberRef.patch(fiberRef.fork)(oldValue);
    if (equals(oldValue, newValue)) {
      map49.set(fiberRef, stack);
    } else {
      map49.set(fiberRef, [[fiberId5, newValue], ...stack]);
    }
  });
};
var fiberRefs = (self) => fromIterable6(self.locals.keys());
var setAll = (self) => forEachSequentialDiscard(fiberRefs(self), (fiberRef) => fiberRefSet(fiberRef, getOrDefault(self, fiberRef)));
var delete_ = dual(2, (self, fiberRef) => {
  const locals = new Map(self.locals);
  locals.delete(fiberRef);
  return new FiberRefsImpl(locals);
});
var get10 = dual(2, (self, fiberRef) => {
  if (!self.locals.has(fiberRef)) {
    return none2();
  }
  return some3(headNonEmpty(self.locals.get(fiberRef))[1]);
});
var getOrDefault = dual(2, (self, fiberRef) => pipe(get10(self, fiberRef), getOrElse2(() => fiberRef.initial)));
var updateAs = dual(2, (self, {
  fiberId: fiberId5,
  fiberRef,
  value: value10
}) => {
  if (self.locals.size === 0) {
    return new FiberRefsImpl(/* @__PURE__ */ new Map([[fiberRef, [[fiberId5, value10]]]]));
  }
  const locals = new Map(self.locals);
  unsafeUpdateAs(locals, fiberId5, fiberRef, value10);
  return new FiberRefsImpl(locals);
});
var unsafeUpdateAs = (locals, fiberId5, fiberRef, value10) => {
  const oldStack = locals.get(fiberRef) ?? [];
  let newStack;
  if (isNonEmptyReadonlyArray(oldStack)) {
    const [currentId, currentValue] = headNonEmpty(oldStack);
    if (currentId[symbol3](fiberId5)) {
      if (equals(currentValue, value10)) {
        return;
      } else {
        newStack = [[fiberId5, value10], ...oldStack.slice(1)];
      }
    } else {
      newStack = [[fiberId5, value10], ...oldStack];
    }
  } else {
    newStack = [[fiberId5, value10]];
  }
  locals.set(fiberRef, newStack);
};
var updateManyAs = dual(2, (self, {
  entries: entries7,
  forkAs: forkAs3
}) => {
  if (self.locals.size === 0) {
    return new FiberRefsImpl(new Map(entries7));
  }
  const locals = new Map(self.locals);
  if (forkAs3 !== void 0) {
    unsafeForkAs(self, locals, forkAs3);
  }
  entries7.forEach(([fiberRef, values15]) => {
    if (values15.length === 1) {
      unsafeUpdateAs(locals, values15[0][0], fiberRef, values15[0][1]);
    } else {
      values15.forEach(([fiberId5, value10]) => {
        unsafeUpdateAs(locals, fiberId5, fiberRef, value10);
      });
    }
  });
  return new FiberRefsImpl(locals);
});

// ../../node_modules/effect/dist/esm/FiberRefs.js
var FiberRefsSym2 = FiberRefsSym;
var delete_2 = delete_;
var fiberRefs2 = fiberRefs;
var forkAs2 = forkAs;
var get11 = get10;
var getOrDefault2 = getOrDefault;
var joinAs2 = joinAs;
var setAll2 = setAll;
var updateAs2 = updateAs;
var updateManyAs2 = updateManyAs;
var unsafeMake6 = unsafeMake5;
var empty27 = empty26;

// ../../node_modules/effect/dist/esm/LogLevel.js
var LogLevel_exports = {};
__export(LogLevel_exports, {
  All: () => All,
  Debug: () => Debug,
  Error: () => Error2,
  Fatal: () => Fatal,
  Info: () => Info,
  None: () => None3,
  Order: () => Order6,
  Trace: () => Trace,
  Warning: () => Warning,
  allLevels: () => allLevels,
  fromLiteral: () => fromLiteral,
  greaterThan: () => greaterThan6,
  greaterThanEqual: () => greaterThanEqual,
  lessThan: () => lessThan6,
  lessThanEqual: () => lessThanEqual,
  locally: () => locally
});
var All = logLevelAll;
var Fatal = logLevelFatal;
var Error2 = logLevelError;
var Warning = logLevelWarning;
var Info = logLevelInfo;
var Debug = logLevelDebug;
var Trace = logLevelTrace;
var None3 = logLevelNone;
var allLevels = allLogLevels;
var locally = dual(2, (use2, self) => fiberRefLocally(use2, currentLogLevel, self));
var Order6 = pipe(Order, mapInput3((level) => level.ordinal));
var lessThan6 = lessThan(Order6);
var lessThanEqual = lessThanOrEqualTo(Order6);
var greaterThan6 = greaterThan(Order6);
var greaterThanEqual = greaterThanOrEqualTo(Order6);
var fromLiteral = (literal3) => {
  switch (literal3) {
    case "All":
      return All;
    case "Debug":
      return Debug;
    case "Error":
      return Error2;
    case "Fatal":
      return Fatal;
    case "Info":
      return Info;
    case "Trace":
      return Trace;
    case "None":
      return None3;
    case "Warning":
      return Warning;
  }
};

// ../../node_modules/effect/dist/esm/LogSpan.js
var LogSpan_exports = {};
__export(LogSpan_exports, {
  make: () => make34,
  render: () => render4
});

// ../../node_modules/effect/dist/esm/internal/logSpan.js
var make33 = (label, startTime) => ({
  label,
  startTime
});
var formatLabel = (key) => key.replace(/[\s="]/g, "_");
var render3 = (now3) => (self) => {
  const label = formatLabel(self.label);
  return `${label}=${now3 - self.startTime}ms`;
};

// ../../node_modules/effect/dist/esm/LogSpan.js
var make34 = make33;
var render4 = render3;

// ../../node_modules/effect/dist/esm/Ref.js
var Ref_exports = {};
__export(Ref_exports, {
  RefTypeId: () => RefTypeId2,
  get: () => get13,
  getAndSet: () => getAndSet3,
  getAndUpdate: () => getAndUpdate3,
  getAndUpdateSome: () => getAndUpdateSome2,
  make: () => make37,
  modify: () => modify8,
  modifySome: () => modifySome2,
  set: () => set7,
  setAndGet: () => setAndGet3,
  unsafeMake: () => unsafeMake8,
  update: () => update4,
  updateAndGet: () => updateAndGet3,
  updateSome: () => updateSome2,
  updateSomeAndGet: () => updateSomeAndGet2
});

// ../../node_modules/effect/dist/esm/Effectable.js
var Effectable_exports = {};
__export(Effectable_exports, {
  ChannelTypeId: () => ChannelTypeId2,
  Class: () => Class3,
  CommitPrototype: () => CommitPrototype2,
  EffectPrototype: () => EffectPrototype2,
  EffectTypeId: () => EffectTypeId3,
  SinkTypeId: () => SinkTypeId2,
  StreamTypeId: () => StreamTypeId2,
  StructuralClass: () => StructuralClass,
  StructuralCommitPrototype: () => StructuralCommitPrototype2
});
var EffectTypeId3 = EffectTypeId;
var StreamTypeId2 = StreamTypeId;
var SinkTypeId2 = SinkTypeId;
var ChannelTypeId2 = ChannelTypeId;
var EffectPrototype2 = EffectPrototype;
var CommitPrototype2 = CommitPrototype;
var StructuralCommitPrototype2 = StructuralCommitPrototype;
var Base3 = Base2;
var StructuralBase2 = StructuralBase;
var Class3 = class extends Base3 {
};
var StructuralClass = class extends StructuralBase2 {
};

// ../../node_modules/effect/dist/esm/Readable.js
var Readable_exports = {};
__export(Readable_exports, {
  TypeId: () => TypeId15,
  isReadable: () => isReadable,
  make: () => make35,
  map: () => map16,
  mapEffect: () => mapEffect,
  unwrap: () => unwrap
});
var TypeId15 = Symbol.for("effect/Readable");
var isReadable = (u) => hasProperty(u, TypeId15);
var Proto = {
  [TypeId15]: TypeId15,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make35 = (get48) => {
  const self = Object.create(Proto);
  self.get = get48;
  return self;
};
var map16 = dual(2, (self, f) => make35(map14(self.get, f)));
var mapEffect = dual(2, (self, f) => make35(flatMap12(self.get, f)));
var unwrap = (effect4) => make35(flatMap12(effect4, (s) => s.get));

// ../../node_modules/effect/dist/esm/internal/ref.js
var RefTypeId = Symbol.for("effect/Ref");
var refVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var RefImpl = class extends Class3 {
  ref;
  commit() {
    return this.get;
  }
  [RefTypeId] = refVariance;
  [TypeId15] = TypeId15;
  constructor(ref) {
    super();
    this.ref = ref;
    this.get = sync(() => get7(this.ref));
  }
  get;
  modify(f) {
    return sync(() => {
      const current2 = get7(this.ref);
      const [b, a] = f(current2);
      if (current2 !== a) {
        set3(a)(this.ref);
      }
      return b;
    });
  }
};
var unsafeMake7 = (value10) => new RefImpl(make15(value10));
var make36 = (value10) => sync(() => unsafeMake7(value10));
var get12 = (self) => self.get;
var set6 = dual(2, (self, value10) => self.modify(() => [void 0, value10]));
var getAndSet2 = dual(2, (self, value10) => self.modify((a) => [a, value10]));
var getAndUpdate2 = dual(2, (self, f) => self.modify((a) => [a, f(a)]));
var getAndUpdateSome = dual(2, (self, pf) => self.modify((value10) => {
  const option11 = pf(value10);
  switch (option11._tag) {
    case "None": {
      return [value10, value10];
    }
    case "Some": {
      return [value10, option11.value];
    }
  }
}));
var setAndGet2 = dual(2, (self, value10) => self.modify(() => [value10, value10]));
var modify7 = dual(2, (self, f) => self.modify(f));
var modifySome = dual(3, (self, fallback, pf) => self.modify((value10) => {
  const option11 = pf(value10);
  switch (option11._tag) {
    case "None": {
      return [fallback, value10];
    }
    case "Some": {
      return option11.value;
    }
  }
}));
var update3 = dual(2, (self, f) => self.modify((a) => [void 0, f(a)]));
var updateAndGet2 = dual(2, (self, f) => self.modify((a) => {
  const result = f(a);
  return [result, result];
}));
var updateSome = dual(2, (self, f) => self.modify((a) => [void 0, match2(f(a), {
  onNone: () => a,
  onSome: (b) => b
})]));
var updateSomeAndGet = dual(2, (self, pf) => self.modify((value10) => {
  const option11 = pf(value10);
  switch (option11._tag) {
    case "None": {
      return [value10, value10];
    }
    case "Some": {
      return [option11.value, option11.value];
    }
  }
}));
var unsafeGet7 = (self) => get7(self.ref);

// ../../node_modules/effect/dist/esm/Ref.js
var RefTypeId2 = RefTypeId;
var make37 = make36;
var get13 = get12;
var getAndSet3 = getAndSet2;
var getAndUpdate3 = getAndUpdate2;
var getAndUpdateSome2 = getAndUpdateSome;
var modify8 = modify7;
var modifySome2 = modifySome;
var set7 = set6;
var setAndGet3 = setAndGet2;
var update4 = update3;
var updateAndGet3 = updateAndGet2;
var updateSome2 = updateSome;
var updateSomeAndGet2 = updateSomeAndGet;
var unsafeMake8 = unsafeMake7;

// ../../node_modules/effect/dist/esm/Tracer.js
var Tracer_exports = {};
__export(Tracer_exports, {
  DisablePropagation: () => DisablePropagation2,
  ParentSpan: () => ParentSpan,
  Tracer: () => Tracer,
  TracerTypeId: () => TracerTypeId2,
  externalSpan: () => externalSpan2,
  make: () => make38,
  tracerWith: () => tracerWith2
});
var TracerTypeId2 = TracerTypeId;
var ParentSpan = spanTag;
var Tracer = tracerTag;
var make38 = make31;
var externalSpan2 = externalSpan;
var tracerWith2 = tracerWith;
var DisablePropagation2 = DisablePropagation;

// ../../node_modules/effect/dist/esm/internal/fiberRefs/patch.js
var OP_EMPTY2 = "Empty";
var OP_ADD = "Add";
var OP_REMOVE = "Remove";
var OP_UPDATE = "Update";
var OP_AND_THEN = "AndThen";
var empty28 = {
  _tag: OP_EMPTY2
};
var diff8 = (oldValue, newValue) => {
  const missingLocals = new Map(oldValue.locals);
  let patch14 = empty28;
  for (const [fiberRef, pairs] of newValue.locals.entries()) {
    const newValue2 = headNonEmpty(pairs)[1];
    const old = missingLocals.get(fiberRef);
    if (old !== void 0) {
      const oldValue2 = headNonEmpty(old)[1];
      if (!equals(oldValue2, newValue2)) {
        patch14 = combine12({
          _tag: OP_UPDATE,
          fiberRef,
          patch: fiberRef.diff(oldValue2, newValue2)
        })(patch14);
      }
    } else {
      patch14 = combine12({
        _tag: OP_ADD,
        fiberRef,
        value: newValue2
      })(patch14);
    }
    missingLocals.delete(fiberRef);
  }
  for (const [fiberRef] of missingLocals.entries()) {
    patch14 = combine12({
      _tag: OP_REMOVE,
      fiberRef
    })(patch14);
  }
  return patch14;
};
var combine12 = dual(2, (self, that) => ({
  _tag: OP_AND_THEN,
  first: self,
  second: that
}));
var patch9 = dual(3, (self, fiberId5, oldValue) => {
  let fiberRefs4 = oldValue;
  let patches = of2(self);
  while (isNonEmptyReadonlyArray(patches)) {
    const head13 = headNonEmpty(patches);
    const tail5 = tailNonEmpty(patches);
    switch (head13._tag) {
      case OP_EMPTY2: {
        patches = tail5;
        break;
      }
      case OP_ADD: {
        fiberRefs4 = updateAs(fiberRefs4, {
          fiberId: fiberId5,
          fiberRef: head13.fiberRef,
          value: head13.value
        });
        patches = tail5;
        break;
      }
      case OP_REMOVE: {
        fiberRefs4 = delete_(fiberRefs4, head13.fiberRef);
        patches = tail5;
        break;
      }
      case OP_UPDATE: {
        const value10 = getOrDefault(fiberRefs4, head13.fiberRef);
        fiberRefs4 = updateAs(fiberRefs4, {
          fiberId: fiberId5,
          fiberRef: head13.fiberRef,
          value: head13.fiberRef.patch(head13.patch)(value10)
        });
        patches = tail5;
        break;
      }
      case OP_AND_THEN: {
        patches = prepend2(head13.first)(prepend2(head13.second)(tail5));
        break;
      }
    }
  }
  return fiberRefs4;
});

// ../../node_modules/effect/dist/esm/internal/metric/label.js
var MetricLabelSymbolKey = "effect/MetricLabel";
var MetricLabelTypeId = Symbol.for(MetricLabelSymbolKey);
var MetricLabelImpl = class {
  key;
  value;
  [MetricLabelTypeId] = MetricLabelTypeId;
  _hash;
  constructor(key, value10) {
    this.key = key;
    this.value = value10;
    this._hash = string2(MetricLabelSymbolKey + this.key + this.value);
  }
  [symbol2]() {
    return this._hash;
  }
  [symbol3](that) {
    return isMetricLabel(that) && this.key === that.key && this.value === that.value;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make39 = (key, value10) => {
  return new MetricLabelImpl(key, value10);
};
var isMetricLabel = (u) => hasProperty(u, MetricLabelTypeId);

// ../../node_modules/effect/dist/esm/internal/core-effect.js
var annotateLogs = dual((args2) => isEffect(args2[0]), function() {
  const args2 = arguments;
  return fiberRefLocallyWith(args2[0], currentLogAnnotations, typeof args2[1] === "string" ? set4(args2[1], args2[2]) : (annotations4) => Object.entries(args2[1]).reduce((acc, [key, value10]) => set4(acc, key, value10), annotations4));
});
var asSome = (self) => map14(self, some3);
var asSomeError = (self) => mapError(self, some3);
var try_2 = (arg) => {
  let evaluate4;
  let onFailure = void 0;
  if (typeof arg === "function") {
    evaluate4 = arg;
  } else {
    evaluate4 = arg.try;
    onFailure = arg.catch;
  }
  return suspend(() => {
    try {
      return succeed(internalCall(evaluate4));
    } catch (error4) {
      return fail2(onFailure ? internalCall(() => onFailure(error4)) : new UnknownException(error4, "An unknown error occurred in Effect.try"));
    }
  });
};
var _catch = dual(3, (self, tag5, options) => catchAll(self, (e) => {
  if (hasProperty(e, tag5) && e[tag5] === options.failure) {
    return options.onFailure(e);
  }
  return fail2(e);
}));
var catchAllDefect = dual(2, (self, f) => catchAllCause(self, (cause3) => {
  const option11 = find(cause3, (_) => isDieType(_) ? some3(_) : none2());
  switch (option11._tag) {
    case "None": {
      return failCause(cause3);
    }
    case "Some": {
      return f(option11.value.defect);
    }
  }
}));
var catchSomeCause = dual(2, (self, f) => matchCauseEffect(self, {
  onFailure: (cause3) => {
    const option11 = f(cause3);
    switch (option11._tag) {
      case "None": {
        return failCause(cause3);
      }
      case "Some": {
        return option11.value;
      }
    }
  },
  onSuccess: succeed
}));
var catchSomeDefect = dual(2, (self, pf) => catchAllCause(self, (cause3) => {
  const option11 = find(cause3, (_) => isDieType(_) ? some3(_) : none2());
  switch (option11._tag) {
    case "None": {
      return failCause(cause3);
    }
    case "Some": {
      const optionEffect = pf(option11.value.defect);
      return optionEffect._tag === "Some" ? optionEffect.value : failCause(cause3);
    }
  }
}));
var catchTag = dual((args2) => isEffect(args2[0]), (self, ...args2) => {
  const f = args2[args2.length - 1];
  let predicate;
  if (args2.length === 2) {
    predicate = isTagged(args2[0]);
  } else {
    predicate = (e) => {
      const tag5 = hasProperty(e, "_tag") ? e["_tag"] : void 0;
      if (!tag5) return false;
      for (let i = 0; i < args2.length - 1; i++) {
        if (args2[i] === tag5) return true;
      }
      return false;
    };
  }
  return catchIf(self, predicate, f);
});
var catchTags = dual(2, (self, cases) => {
  let keys15;
  return catchIf(self, (e) => {
    keys15 ??= Object.keys(cases);
    return hasProperty(e, "_tag") && isString(e["_tag"]) && keys15.includes(e["_tag"]);
  }, (e) => cases[e["_tag"]](e));
});
var cause = (self) => matchCause(self, {
  onFailure: identity,
  onSuccess: () => empty22
});
var clockWith3 = clockWith2;
var clock = clockWith3(succeed);
var delay = dual(2, (self, duration5) => zipRight2(sleep2(duration5), self));
var descriptorWith = (f) => withFiberRuntime((state, status3) => f({
  id: state.id(),
  status: status3,
  interruptors: interruptors(state.getFiberRef(currentInterruptedCause))
}));
var allowInterrupt = descriptorWith((descriptor3) => size6(descriptor3.interruptors) > 0 ? interrupt2 : void_3);
var descriptor = descriptorWith(succeed);
var diffFiberRefs = (self) => summarized(self, fiberRefs3, diff8);
var diffFiberRefsAndRuntimeFlags = (self) => summarized(self, zip5(fiberRefs3, runtimeFlags), ([refs, flags], [refsNew, flagsNew]) => [diff8(refs, refsNew), diff7(flags, flagsNew)]);
var Do4 = succeed({});
var bind5 = bind(map14, flatMap12);
var bindTo5 = bindTo(map14);
var let_5 = let_(map14);
var dropUntil = dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next6;
  let dropping9 = succeed(false);
  let i = 0;
  while ((next6 = iterator.next()) && !next6.done) {
    const a = next6.value;
    const index = i++;
    dropping9 = flatMap12(dropping9, (bool) => {
      if (bool) {
        builder.push(a);
        return succeed(true);
      }
      return predicate(a, index);
    });
  }
  return map14(dropping9, () => builder);
}));
var dropWhile3 = dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next6;
  let dropping9 = succeed(true);
  let i = 0;
  while ((next6 = iterator.next()) && !next6.done) {
    const a = next6.value;
    const index = i++;
    dropping9 = flatMap12(dropping9, (d) => map14(d ? predicate(a, index) : succeed(false), (b) => {
      if (!b) {
        builder.push(a);
      }
      return b;
    }));
  }
  return map14(dropping9, () => builder);
}));
var contextWith = (f) => map14(context2(), f);
var eventually = (self) => orElse3(self, () => flatMap12(yieldNow(), () => eventually(self)));
var filterMap9 = dual(2, (elements, pf) => map14(forEachSequential(elements, identity), filterMap4(pf)));
var filterOrDie = dual(3, (self, predicate, orDieWith9) => filterOrElse(self, predicate, (a) => dieSync(() => orDieWith9(a))));
var filterOrDieMessage = dual(3, (self, predicate, message) => filterOrElse(self, predicate, () => dieMessage(message)));
var filterOrElse = dual(3, (self, predicate, orElse24) => flatMap12(self, (a) => predicate(a) ? succeed(a) : orElse24(a)));
var liftPredicate4 = dual(3, (self, predicate, orFailWith) => suspend(() => predicate(self) ? succeed(self) : fail2(orFailWith(self))));
var filterOrFail = dual((args2) => isEffect(args2[0]), (self, predicate, orFailWith) => filterOrElse(self, predicate, (a) => orFailWith === void 0 ? fail2(new NoSuchElementException()) : failSync(() => orFailWith(a))));
var findFirst8 = dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const next6 = iterator.next();
  if (!next6.done) {
    return findLoop(iterator, 0, predicate, next6.value);
  }
  return succeed(none2());
}));
var findLoop = (iterator, index, f, value10) => flatMap12(f(value10, index), (result) => {
  if (result) {
    return succeed(some3(value10));
  }
  const next6 = iterator.next();
  if (!next6.done) {
    return findLoop(iterator, index + 1, f, next6.value);
  }
  return succeed(none2());
});
var firstSuccessOf = (effects) => suspend(() => {
  const list = fromIterable3(effects);
  if (!isNonEmpty2(list)) {
    return dieSync(() => new IllegalArgumentException(`Received an empty collection of effects`));
  }
  return pipe(tailNonEmpty2(list), reduce3(headNonEmpty2(list), (left3, right3) => orElse3(left3, () => right3)));
});
var flipWith = dual(2, (self, f) => flip3(f(flip3(self))));
var match8 = dual(2, (self, options) => matchEffect(self, {
  onFailure: (e) => succeed(options.onFailure(e)),
  onSuccess: (a) => succeed(options.onSuccess(a))
}));
var every11 = dual(2, (elements, predicate) => suspend(() => forAllLoop(elements[Symbol.iterator](), 0, predicate)));
var forAllLoop = (iterator, index, f) => {
  const next6 = iterator.next();
  return next6.done ? succeed(true) : flatMap12(f(next6.value, index), (b) => b ? forAllLoop(iterator, index + 1, f) : succeed(b));
};
var forever = (self) => {
  const loop5 = flatMap12(flatMap12(self, () => yieldNow()), () => loop5);
  return loop5;
};
var fiberRefs3 = withFiberRuntime((state) => succeed(state.getFiberRefs()));
var head6 = (self) => flatMap12(self, (as18) => {
  const iterator = as18[Symbol.iterator]();
  const next6 = iterator.next();
  if (next6.done) {
    return fail2(new NoSuchElementException());
  }
  return succeed(next6.value);
});
var ignore = (self) => match8(self, {
  onFailure: constVoid,
  onSuccess: constVoid
});
var ignoreLogged = (self) => matchCauseEffect(self, {
  onFailure: (cause3) => logDebug(cause3, "An error was silently ignored because it is not anticipated to be useful"),
  onSuccess: () => void_3
});
var inheritFiberRefs = (childFiberRefs) => updateFiberRefs((parentFiberId, parentFiberRefs) => joinAs2(parentFiberRefs, parentFiberId, childFiberRefs));
var isFailure3 = (self) => match8(self, {
  onFailure: constTrue,
  onSuccess: constFalse
});
var isSuccess2 = (self) => match8(self, {
  onFailure: constFalse,
  onSuccess: constTrue
});
var iterate = (initial, options) => suspend(() => {
  if (options.while(initial)) {
    return flatMap12(options.body(initial), (z2) => iterate(z2, options));
  }
  return succeed(initial);
});
var logWithLevel = (level) => (...message) => {
  const levelOption = fromNullable2(level);
  let cause3 = void 0;
  for (let i = 0, len = message.length; i < len; i++) {
    const msg = message[i];
    if (isCause(msg)) {
      if (cause3 !== void 0) {
        cause3 = sequential(cause3, msg);
      } else {
        cause3 = msg;
      }
      message = [...message.slice(0, i), ...message.slice(i + 1)];
      i--;
    }
  }
  if (cause3 === void 0) {
    cause3 = empty22;
  }
  return withFiberRuntime((fiberState) => {
    fiberState.log(message, cause3, levelOption);
    return void_3;
  });
};
var log = logWithLevel();
var logTrace = logWithLevel(Trace);
var logDebug = logWithLevel(Debug);
var logInfo = logWithLevel(Info);
var logWarning = logWithLevel(Warning);
var logError = logWithLevel(Error2);
var logFatal = logWithLevel(Fatal);
var withLogSpan = dual(2, (effect4, label) => flatMap12(currentTimeMillis2, (now3) => fiberRefLocallyWith(effect4, currentLogSpan, prepend4(make34(label, now3)))));
var logAnnotations = fiberRefGet(currentLogAnnotations);
var loop = (initial, options) => options.discard ? loopDiscard(initial, options.while, options.step, options.body) : map14(loopInternal(initial, options.while, options.step, options.body), fromIterable2);
var loopInternal = (initial, cont, inc, body) => suspend(() => cont(initial) ? flatMap12(body(initial), (a) => map14(loopInternal(inc(initial), cont, inc, body), prepend4(a))) : sync(() => empty12()));
var loopDiscard = (initial, cont, inc, body) => suspend(() => cont(initial) ? flatMap12(body(initial), () => loopDiscard(inc(initial), cont, inc, body)) : void_3);
var mapAccum3 = dual(3, (elements, initial, f) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let result = succeed(initial);
  let next6;
  let i = 0;
  while (!(next6 = iterator.next()).done) {
    const index = i++;
    const value10 = next6.value;
    result = flatMap12(result, (state) => map14(f(state, value10, index), ([z, b]) => {
      builder.push(b);
      return z;
    }));
  }
  return map14(result, (z) => [z, builder]);
}));
var mapErrorCause2 = dual(2, (self, f) => matchCauseEffect(self, {
  onFailure: (c) => failCauseSync(() => f(c)),
  onSuccess: succeed
}));
var memoize = (self) => pipe(deferredMake(), flatMap12((deferred) => pipe(diffFiberRefsAndRuntimeFlags(self), intoDeferred(deferred), once, map14((complete6) => zipRight2(complete6, pipe(deferredAwait(deferred), flatMap12(([patch14, a]) => as3(zip5(patchFiberRefs(patch14[0]), updateRuntimeFlags(patch14[1])), a))))))));
var merge5 = (self) => matchEffect(self, {
  onFailure: (e) => succeed(e),
  onSuccess: succeed
});
var negate3 = (self) => map14(self, (b) => !b);
var none6 = (self) => flatMap12(self, (option11) => {
  switch (option11._tag) {
    case "None":
      return void_3;
    case "Some":
      return fail2(new NoSuchElementException());
  }
});
var once = (self) => map14(make37(true), (ref) => asVoid2(whenEffect(self, getAndSet3(ref, false))));
var option2 = (self) => matchEffect(self, {
  onFailure: () => succeed(none2()),
  onSuccess: (a) => succeed(some3(a))
});
var orElseFail = dual(2, (self, evaluate4) => orElse3(self, () => failSync(evaluate4)));
var orElseSucceed = dual(2, (self, evaluate4) => orElse3(self, () => sync(evaluate4)));
var parallelErrors = (self) => matchCauseEffect(self, {
  onFailure: (cause3) => {
    const errors2 = fromIterable2(failures(cause3));
    return errors2.length === 0 ? failCause(cause3) : fail2(errors2);
  },
  onSuccess: succeed
});
var patchFiberRefs = (patch14) => updateFiberRefs((fiberId5, fiberRefs4) => pipe(patch14, patch9(fiberId5, fiberRefs4)));
var promise = (evaluate4) => evaluate4.length >= 1 ? async_((resolve, signal) => {
  try {
    evaluate4(signal).then((a) => resolve(exitSucceed(a)), (e) => resolve(exitDie(e)));
  } catch (e) {
    resolve(exitDie(e));
  }
}) : async_((resolve) => {
  try {
    ;
    evaluate4().then((a) => resolve(exitSucceed(a)), (e) => resolve(exitDie(e)));
  } catch (e) {
    resolve(exitDie(e));
  }
});
var provideService = dual(3, (self, tag5, service4) => contextWithEffect((env) => provideContext(self, add2(env, tag5, service4))));
var provideServiceEffect = dual(3, (self, tag5, effect4) => contextWithEffect((env) => flatMap12(effect4, (service4) => provideContext(self, pipe(env, add2(tag5, service4))))));
var random2 = randomWith(succeed);
var reduce12 = dual(3, (elements, zero3, f) => fromIterable2(elements).reduce((acc, el, i) => flatMap12(acc, (a) => f(a, el, i)), succeed(zero3)));
var reduceRight4 = dual(3, (elements, zero3, f) => fromIterable2(elements).reduceRight((acc, el, i) => flatMap12(acc, (a) => f(el, a, i)), succeed(zero3)));
var reduceWhile = dual(3, (elements, zero3, options) => flatMap12(sync(() => elements[Symbol.iterator]()), (iterator) => reduceWhileLoop(iterator, 0, zero3, options.while, options.body)));
var reduceWhileLoop = (iterator, index, state, predicate, f) => {
  const next6 = iterator.next();
  if (!next6.done && predicate(state)) {
    return flatMap12(f(state, next6.value, index), (nextState) => reduceWhileLoop(iterator, index + 1, nextState, predicate, f));
  }
  return succeed(state);
};
var repeatN = dual(2, (self, n) => suspend(() => repeatNLoop(self, n)));
var repeatNLoop = (self, n) => flatMap12(self, (a) => n <= 0 ? succeed(a) : zipRight2(yieldNow(), repeatNLoop(self, n - 1)));
var sandbox = (self) => matchCauseEffect(self, {
  onFailure: fail2,
  onSuccess: succeed
});
var setFiberRefs = (fiberRefs4) => suspend(() => setAll2(fiberRefs4));
var sleep3 = sleep2;
var succeedNone = succeed(none2());
var succeedSome = (value10) => succeed(some3(value10));
var summarized = dual(3, (self, summary11, f) => flatMap12(summary11, (start5) => flatMap12(self, (value10) => map14(summary11, (end7) => [f(start5, end7), value10]))));
var tagMetrics = dual((args2) => isEffect(args2[0]), function() {
  return labelMetrics(arguments[0], typeof arguments[1] === "string" ? [make39(arguments[1], arguments[2])] : Object.entries(arguments[1]).map(([k, v]) => make39(k, v)));
});
var labelMetrics = dual(2, (self, labels) => fiberRefLocallyWith(self, currentMetricLabels, (old) => union2(old, labels)));
var takeUntil = dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next6;
  let effect4 = succeed(false);
  let i = 0;
  while ((next6 = iterator.next()) && !next6.done) {
    const a = next6.value;
    const index = i++;
    effect4 = flatMap12(effect4, (bool) => {
      if (bool) {
        return succeed(true);
      }
      builder.push(a);
      return predicate(a, index);
    });
  }
  return map14(effect4, () => builder);
}));
var takeWhile4 = dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next6;
  let taking = succeed(true);
  let i = 0;
  while ((next6 = iterator.next()) && !next6.done) {
    const a = next6.value;
    const index = i++;
    taking = flatMap12(taking, (taking2) => pipe(taking2 ? predicate(a, index) : succeed(false), map14((bool) => {
      if (bool) {
        builder.push(a);
      }
      return bool;
    })));
  }
  return map14(taking, () => builder);
}));
var tapBoth = dual(2, (self, {
  onFailure,
  onSuccess
}) => matchCauseEffect(self, {
  onFailure: (cause3) => {
    const either14 = failureOrCause(cause3);
    switch (either14._tag) {
      case "Left": {
        return zipRight2(onFailure(either14.left), failCause(cause3));
      }
      case "Right": {
        return failCause(cause3);
      }
    }
  },
  onSuccess: (a) => as3(onSuccess(a), a)
}));
var tapDefect = dual(2, (self, f) => catchAllCause(self, (cause3) => match2(keepDefects(cause3), {
  onNone: () => failCause(cause3),
  onSome: (a) => zipRight2(f(a), failCause(cause3))
})));
var tapError = dual(2, (self, f) => matchCauseEffect(self, {
  onFailure: (cause3) => {
    const either14 = failureOrCause(cause3);
    switch (either14._tag) {
      case "Left":
        return zipRight2(f(either14.left), failCause(cause3));
      case "Right":
        return failCause(cause3);
    }
  },
  onSuccess: succeed
}));
var tapErrorTag = dual(3, (self, k, f) => tapError(self, (e) => {
  if (isTagged(e, k)) {
    return f(e);
  }
  return void_3;
}));
var tapErrorCause = dual(2, (self, f) => matchCauseEffect(self, {
  onFailure: (cause3) => zipRight2(f(cause3), failCause(cause3)),
  onSuccess: succeed
}));
var timed = (self) => timedWith(self, currentTimeNanos2);
var timedWith = dual(2, (self, nanos2) => summarized(self, nanos2, (start5, end7) => nanos(end7 - start5)));
var tracerWith3 = tracerWith2;
var tracer = tracerWith3(succeed);
var tryPromise = (arg) => {
  let evaluate4;
  let catcher = void 0;
  if (typeof arg === "function") {
    evaluate4 = arg;
  } else {
    evaluate4 = arg.try;
    catcher = arg.catch;
  }
  const fail30 = (e) => catcher ? failSync(() => catcher(e)) : fail2(new UnknownException(e, "An unknown error occurred in Effect.tryPromise"));
  if (evaluate4.length >= 1) {
    return async_((resolve, signal) => {
      try {
        evaluate4(signal).then((a) => resolve(exitSucceed(a)), (e) => resolve(fail30(e)));
      } catch (e) {
        resolve(fail30(e));
      }
    });
  }
  return async_((resolve) => {
    try {
      evaluate4().then((a) => resolve(exitSucceed(a)), (e) => resolve(fail30(e)));
    } catch (e) {
      resolve(fail30(e));
    }
  });
};
var tryMap = dual(2, (self, options) => flatMap12(self, (a) => try_2({
  try: () => options.try(a),
  catch: options.catch
})));
var tryMapPromise = dual(2, (self, options) => flatMap12(self, (a) => tryPromise({
  try: options.try.length >= 1 ? (signal) => options.try(a, signal) : () => options.try(a),
  catch: options.catch
})));
var unless = dual(2, (self, condition) => suspend(() => condition() ? succeedNone : asSome(self)));
var unlessEffect = dual(2, (self, condition) => flatMap12(condition, (b) => b ? succeedNone : asSome(self)));
var unsandbox = (self) => mapErrorCause2(self, flatten7);
var updateFiberRefs = (f) => withFiberRuntime((state) => {
  state.setFiberRefs(f(state.id(), state.getFiberRefs()));
  return void_3;
});
var updateService = dual(3, (self, tag5, f) => mapInputContext(self, (context15) => add2(context15, tag5, f(unsafeGet3(context15, tag5)))));
var when = dual(2, (self, condition) => suspend(() => condition() ? map14(self, some3) : succeed(none2())));
var whenFiberRef = dual(3, (self, fiberRef, predicate) => flatMap12(fiberRefGet(fiberRef), (s) => predicate(s) ? map14(self, (a) => [s, some3(a)]) : succeed([s, none2()])));
var whenRef = dual(3, (self, ref, predicate) => flatMap12(get13(ref), (s) => predicate(s) ? map14(self, (a) => [s, some3(a)]) : succeed([s, none2()])));
var withMetric = dual(2, (self, metric) => metric(self));
var serviceFunctionEffect = (getService, f) => (...args2) => flatMap12(getService, (a) => f(a)(...args2));
var serviceFunction = (getService, f) => (...args2) => map14(getService, (a) => f(a)(...args2));
var serviceFunctions = (getService) => new Proxy({}, {
  get(_target, prop, _receiver) {
    return (...args2) => flatMap12(getService, (s) => s[prop](...args2));
  }
});
var serviceConstants = (getService) => new Proxy({}, {
  get(_target, prop, _receiver) {
    return flatMap12(getService, (s) => isEffect(s[prop]) ? s[prop] : succeed(s[prop]));
  }
});
var serviceMembers = (getService) => ({
  functions: serviceFunctions(getService),
  constants: serviceConstants(getService)
});
var serviceOption = (tag5) => map14(context2(), getOption2(tag5));
var serviceOptional = (tag5) => flatMap12(context2(), getOption2(tag5));
var annotateCurrentSpan = function() {
  const args2 = arguments;
  return ignore(flatMap12(currentSpan, (span4) => sync(() => {
    if (typeof args2[0] === "string") {
      span4.attribute(args2[0], args2[1]);
    } else {
      for (const key in args2[0]) {
        span4.attribute(key, args2[0][key]);
      }
    }
  })));
};
var linkSpanCurrent = function() {
  const args2 = arguments;
  const links = Array.isArray(args2[0]) ? args2[0] : [{
    _tag: "SpanLink",
    span: args2[0],
    attributes: args2[1] ?? {}
  }];
  return ignore(flatMap12(currentSpan, (span4) => sync(() => span4.addLinks(links))));
};
var annotateSpans = dual((args2) => isEffect(args2[0]), function() {
  const args2 = arguments;
  return fiberRefLocallyWith(args2[0], currentTracerSpanAnnotations, typeof args2[1] === "string" ? set4(args2[1], args2[2]) : (annotations4) => Object.entries(args2[1]).reduce((acc, [key, value10]) => set4(acc, key, value10), annotations4));
});
var currentParentSpan = serviceOptional(spanTag);
var currentSpan = flatMap12(context2(), (context15) => {
  const span4 = context15.unsafeMap.get(spanTag.key);
  return span4 !== void 0 && span4._tag === "Span" ? succeed(span4) : fail2(new NoSuchElementException());
});
var linkSpans = dual((args2) => isEffect(args2[0]), (self, span4, attributes) => fiberRefLocallyWith(self, currentTracerSpanLinks, append3({
  _tag: "SpanLink",
  span: span4,
  attributes: attributes ?? {}
})));
var bigint04 = BigInt(0);
var filterDisablePropagation = flatMap2((span4) => get4(span4.context, DisablePropagation) ? span4._tag === "Span" ? filterDisablePropagation(span4.parent) : none2() : some3(span4));
var unsafeMakeSpan = (fiber, name, options) => {
  const disablePropagation = !fiber.getFiberRef(currentTracerEnabled) || options.context && get4(options.context, DisablePropagation);
  const context15 = fiber.getFiberRef(currentContext);
  const parent = options.parent ? some3(options.parent) : options.root ? none2() : filterDisablePropagation(getOption2(context15, spanTag));
  let span4;
  if (disablePropagation) {
    span4 = noopSpan({
      name,
      parent,
      context: add2(options.context ?? empty6(), DisablePropagation, true)
    });
  } else {
    const services = fiber.getFiberRef(currentServices);
    const tracer3 = get4(services, tracerTag);
    const clock3 = get4(services, Clock);
    const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
    const fiberRefs4 = fiber.getFiberRefs();
    const annotationsFromEnv = get11(fiberRefs4, currentTracerSpanAnnotations);
    const linksFromEnv = get11(fiberRefs4, currentTracerSpanLinks);
    const links = linksFromEnv._tag === "Some" ? options.links !== void 0 ? [...toReadonlyArray(linksFromEnv.value), ...options.links ?? []] : toReadonlyArray(linksFromEnv.value) : options.links ?? empty4();
    span4 = tracer3.span(name, parent, options.context ?? empty6(), links, timingEnabled ? clock3.unsafeCurrentTimeNanos() : bigint04, options.kind ?? "internal");
    if (annotationsFromEnv._tag === "Some") {
      forEach7(annotationsFromEnv.value, (value10, key) => span4.attribute(key, value10));
    }
    if (options.attributes !== void 0) {
      Object.entries(options.attributes).forEach(([k, v]) => span4.attribute(k, v));
    }
  }
  if (typeof options.captureStackTrace === "function") {
    spanToTrace.set(span4, options.captureStackTrace);
  }
  return span4;
};
var makeSpan = (name, options) => {
  options = addSpanStackTrace(options);
  return withFiberRuntime((fiber) => succeed(unsafeMakeSpan(fiber, name, options)));
};
var spanAnnotations = fiberRefGet(currentTracerSpanAnnotations);
var spanLinks = fiberRefGet(currentTracerSpanLinks);
var endSpan = (span4, exit4, clock3, timingEnabled) => sync(() => {
  if (span4.status._tag === "Ended") {
    return;
  }
  if (exitIsFailure(exit4) && spanToTrace.has(span4)) {
    span4.attribute("code.stacktrace", spanToTrace.get(span4)());
  }
  span4.end(timingEnabled ? clock3.unsafeCurrentTimeNanos() : bigint04, exit4);
});
var useSpan = (name, ...args2) => {
  const options = addSpanStackTrace(args2.length === 1 ? void 0 : args2[0]);
  const evaluate4 = args2[args2.length - 1];
  return withFiberRuntime((fiber) => {
    const span4 = unsafeMakeSpan(fiber, name, options);
    const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
    const clock3 = get4(fiber.getFiberRef(currentServices), clockTag);
    return onExit(evaluate4(span4), (exit4) => endSpan(span4, exit4, clock3, timingEnabled));
  });
};
var withParentSpan = dual(2, (self, span4) => provideService(self, spanTag, span4));
var withSpan = function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self = arguments[0];
    return useSpan(name, options, (span4) => withParentSpan(self, span4));
  }
  return (self) => useSpan(name, options, (span4) => withParentSpan(self, span4));
};
var functionWithSpan = (options) => function() {
  let captureStackTrace = options.captureStackTrace ?? false;
  if (options.captureStackTrace !== false) {
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const error4 = new Error();
    Error.stackTraceLimit = limit;
    let cache = false;
    captureStackTrace = () => {
      if (cache !== false) {
        return cache;
      }
      if (error4.stack) {
        const stack = error4.stack.trim().split("\n");
        cache = stack.slice(2).join("\n").trim();
        return cache;
      }
    };
  }
  return suspend(() => {
    const opts = typeof options.options === "function" ? options.options.apply(null, arguments) : options.options;
    return withSpan(suspend(() => internalCall(() => options.body.apply(this, arguments))), opts.name, {
      ...opts,
      captureStackTrace
    });
  });
};
var fromNullable4 = (value10) => value10 == null ? fail2(new NoSuchElementException()) : succeed(value10);
var optionFromOptional = (self) => catchAll(map14(self, some3), (error4) => isNoSuchElementException(error4) ? succeedNone : fail2(error4));

// ../../node_modules/effect/dist/esm/ExecutionStrategy.js
var ExecutionStrategy_exports = {};
__export(ExecutionStrategy_exports, {
  isParallel: () => isParallel2,
  isParallelN: () => isParallelN2,
  isSequential: () => isSequential2,
  match: () => match10,
  parallel: () => parallel3,
  parallelN: () => parallelN2,
  sequential: () => sequential3
});

// ../../node_modules/effect/dist/esm/internal/executionStrategy.js
var OP_SEQUENTIAL2 = "Sequential";
var OP_PARALLEL2 = "Parallel";
var OP_PARALLEL_N = "ParallelN";
var sequential2 = {
  _tag: OP_SEQUENTIAL2
};
var parallel2 = {
  _tag: OP_PARALLEL2
};
var parallelN = (parallelism) => ({
  _tag: OP_PARALLEL_N,
  parallelism
});
var isSequential = (self) => self._tag === OP_SEQUENTIAL2;
var isParallel = (self) => self._tag === OP_PARALLEL2;
var isParallelN = (self) => self._tag === OP_PARALLEL_N;
var match9 = dual(2, (self, options) => {
  switch (self._tag) {
    case OP_SEQUENTIAL2: {
      return options.onSequential();
    }
    case OP_PARALLEL2: {
      return options.onParallel();
    }
    case OP_PARALLEL_N: {
      return options.onParallelN(self.parallelism);
    }
  }
});

// ../../node_modules/effect/dist/esm/ExecutionStrategy.js
var sequential3 = sequential2;
var parallel3 = parallel2;
var parallelN2 = parallelN;
var isSequential2 = isSequential;
var isParallel2 = isParallel;
var isParallelN2 = isParallelN;
var match10 = match9;

// ../../node_modules/effect/dist/esm/FiberRefsPatch.js
var FiberRefsPatch_exports = {};
__export(FiberRefsPatch_exports, {
  combine: () => combine13,
  diff: () => diff9,
  empty: () => empty29,
  patch: () => patch10
});
var empty29 = empty28;
var diff9 = diff8;
var combine13 = combine12;
var patch10 = patch9;

// ../../node_modules/effect/dist/esm/FiberStatus.js
var FiberStatus_exports = {};
__export(FiberStatus_exports, {
  FiberStatusTypeId: () => FiberStatusTypeId2,
  done: () => done4,
  isDone: () => isDone3,
  isFiberStatus: () => isFiberStatus2,
  isRunning: () => isRunning2,
  isSuspended: () => isSuspended2,
  running: () => running2,
  suspended: () => suspended2
});

// ../../node_modules/effect/dist/esm/internal/fiberStatus.js
var FiberStatusSymbolKey = "effect/FiberStatus";
var FiberStatusTypeId = Symbol.for(FiberStatusSymbolKey);
var OP_DONE = "Done";
var OP_RUNNING = "Running";
var OP_SUSPENDED = "Suspended";
var DoneHash = string2(`${FiberStatusSymbolKey}-${OP_DONE}`);
var Done = class {
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_DONE;
  [symbol2]() {
    return DoneHash;
  }
  [symbol3](that) {
    return isFiberStatus(that) && that._tag === OP_DONE;
  }
};
var Running = class {
  runtimeFlags;
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_RUNNING;
  constructor(runtimeFlags2) {
    this.runtimeFlags = runtimeFlags2;
  }
  [symbol2]() {
    return pipe(hash(FiberStatusSymbolKey), combine2(hash(this._tag)), combine2(hash(this.runtimeFlags)), cached(this));
  }
  [symbol3](that) {
    return isFiberStatus(that) && that._tag === OP_RUNNING && this.runtimeFlags === that.runtimeFlags;
  }
};
var Suspended = class {
  runtimeFlags;
  blockingOn;
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_SUSPENDED;
  constructor(runtimeFlags2, blockingOn) {
    this.runtimeFlags = runtimeFlags2;
    this.blockingOn = blockingOn;
  }
  [symbol2]() {
    return pipe(hash(FiberStatusSymbolKey), combine2(hash(this._tag)), combine2(hash(this.runtimeFlags)), combine2(hash(this.blockingOn)), cached(this));
  }
  [symbol3](that) {
    return isFiberStatus(that) && that._tag === OP_SUSPENDED && this.runtimeFlags === that.runtimeFlags && equals(this.blockingOn, that.blockingOn);
  }
};
var done3 = new Done();
var running = (runtimeFlags2) => new Running(runtimeFlags2);
var suspended = (runtimeFlags2, blockingOn) => new Suspended(runtimeFlags2, blockingOn);
var isFiberStatus = (u) => hasProperty(u, FiberStatusTypeId);
var isDone2 = (self) => self._tag === OP_DONE;
var isRunning = (self) => self._tag === OP_RUNNING;
var isSuspended = (self) => self._tag === OP_SUSPENDED;

// ../../node_modules/effect/dist/esm/FiberStatus.js
var FiberStatusTypeId2 = FiberStatusTypeId;
var done4 = done3;
var running2 = running;
var suspended2 = suspended;
var isFiberStatus2 = isFiberStatus;
var isDone3 = isDone2;
var isRunning2 = isRunning;
var isSuspended2 = isSuspended;

// ../../node_modules/effect/dist/esm/Micro.js
var Micro_exports = {};
__export(Micro_exports, {
  CurrentConcurrency: () => CurrentConcurrency,
  CurrentScheduler: () => CurrentScheduler,
  Do: () => Do5,
  Error: () => Error3,
  MaxOpsBeforeYield: () => MaxOpsBeforeYield,
  MicroCauseTypeId: () => MicroCauseTypeId,
  MicroExitTypeId: () => MicroExitTypeId,
  MicroFiberTypeId: () => MicroFiberTypeId,
  MicroSchedulerDefault: () => MicroSchedulerDefault,
  MicroScope: () => MicroScope,
  MicroScopeTypeId: () => MicroScopeTypeId,
  NoSuchElementException: () => NoSuchElementException2,
  TaggedError: () => TaggedError,
  TimeoutException: () => TimeoutException2,
  TypeId: () => TypeId16,
  acquireRelease: () => acquireRelease,
  acquireUseRelease: () => acquireUseRelease2,
  addFinalizer: () => addFinalizer,
  all: () => all8,
  andThen: () => andThen8,
  as: () => as5,
  asSome: () => asSome2,
  asVoid: () => asVoid4,
  async: () => async,
  bind: () => bind6,
  bindTo: () => bindTo6,
  catchAll: () => catchAll2,
  catchAllCause: () => catchAllCause2,
  catchAllDefect: () => catchAllDefect2,
  catchCauseIf: () => catchCauseIf,
  catchIf: () => catchIf2,
  catchTag: () => catchTag2,
  causeDie: () => causeDie,
  causeFail: () => causeFail,
  causeInterrupt: () => causeInterrupt,
  causeIsDie: () => causeIsDie,
  causeIsFail: () => causeIsFail,
  causeIsInterrupt: () => causeIsInterrupt,
  causeSquash: () => causeSquash2,
  causeWithTrace: () => causeWithTrace,
  context: () => context3,
  delay: () => delay2,
  die: () => die5,
  either: () => either4,
  ensuring: () => ensuring,
  exit: () => exit2,
  exitDie: () => exitDie2,
  exitFail: () => exitFail2,
  exitFailCause: () => exitFailCause2,
  exitInterrupt: () => exitInterrupt2,
  exitIsDie: () => exitIsDie,
  exitIsFail: () => exitIsFail,
  exitIsFailure: () => exitIsFailure2,
  exitIsInterrupt: () => exitIsInterrupt,
  exitIsSuccess: () => exitIsSuccess2,
  exitSucceed: () => exitSucceed2,
  exitVoid: () => exitVoid2,
  exitVoidAll: () => exitVoidAll,
  fail: () => fail5,
  failCause: () => failCause4,
  failCauseSync: () => failCauseSync3,
  failSync: () => failSync3,
  fiberAwait: () => fiberAwait,
  fiberInterrupt: () => fiberInterrupt,
  fiberInterruptAll: () => fiberInterruptAll,
  fiberJoin: () => fiberJoin,
  filter: () => filter12,
  filterMap: () => filterMap10,
  filterOrFail: () => filterOrFail2,
  filterOrFailCause: () => filterOrFailCause,
  flatMap: () => flatMap14,
  flatten: () => flatten10,
  flip: () => flip4,
  forEach: () => forEach11,
  forever: () => forever2,
  fork: () => fork,
  forkDaemon: () => forkDaemon,
  forkIn: () => forkIn,
  forkScoped: () => forkScoped,
  fromEither: () => fromEither2,
  fromOption: () => fromOption5,
  gen: () => gen5,
  ignore: () => ignore2,
  ignoreLogged: () => ignoreLogged2,
  interrupt: () => interrupt5,
  interruptible: () => interruptible3,
  isMicro: () => isMicro,
  isMicroCause: () => isMicroCause,
  isMicroExit: () => isMicroExit,
  let: () => let_6,
  map: () => map17,
  mapError: () => mapError3,
  mapErrorCause: () => mapErrorCause3,
  match: () => match11,
  matchCause: () => matchCause2,
  matchCauseEffect: () => matchCauseEffect2,
  matchEffect: () => matchEffect3,
  never: () => never2,
  onError: () => onError2,
  onExit: () => onExit2,
  onExitIf: () => onExitIf,
  onInterrupt: () => onInterrupt2,
  option: () => option3,
  orDie: () => orDie2,
  orElseSucceed: () => orElseSucceed2,
  promise: () => promise2,
  provideContext: () => provideContext2,
  provideScope: () => provideScope,
  provideService: () => provideService2,
  provideServiceEffect: () => provideServiceEffect2,
  race: () => race,
  raceAll: () => raceAll,
  raceAllFirst: () => raceAllFirst,
  raceFirst: () => raceFirst,
  repeat: () => repeat,
  repeatExit: () => repeatExit,
  replicate: () => replicate3,
  replicateEffect: () => replicateEffect,
  retry: () => retry,
  runFork: () => runFork,
  runPromise: () => runPromise,
  runPromiseExit: () => runPromiseExit,
  runSync: () => runSync,
  runSyncExit: () => runSyncExit,
  sandbox: () => sandbox2,
  scheduleAddDelay: () => scheduleAddDelay,
  scheduleExponential: () => scheduleExponential,
  scheduleIntersect: () => scheduleIntersect,
  scheduleRecurs: () => scheduleRecurs,
  scheduleSpaced: () => scheduleSpaced,
  scheduleUnion: () => scheduleUnion,
  scheduleWithMaxDelay: () => scheduleWithMaxDelay,
  scheduleWithMaxElapsed: () => scheduleWithMaxElapsed,
  scope: () => scope,
  scopeMake: () => scopeMake,
  scopeUnsafeMake: () => scopeUnsafeMake,
  scoped: () => scoped,
  service: () => service,
  serviceOption: () => serviceOption2,
  sleep: () => sleep4,
  succeed: () => succeed4,
  succeedNone: () => succeedNone2,
  succeedSome: () => succeedSome2,
  suspend: () => suspend2,
  sync: () => sync3,
  tap: () => tap3,
  tapDefect: () => tapDefect2,
  tapError: () => tapError2,
  tapErrorCause: () => tapErrorCause2,
  tapErrorCauseIf: () => tapErrorCauseIf,
  timeout: () => timeout,
  timeoutOption: () => timeoutOption,
  timeoutOrElse: () => timeoutOrElse,
  try: () => try_3,
  tryPromise: () => tryPromise2,
  uninterruptible: () => uninterruptible2,
  uninterruptibleMask: () => uninterruptibleMask2,
  updateContext: () => updateContext,
  updateService: () => updateService2,
  void: () => void_5,
  when: () => when2,
  whileLoop: () => whileLoop2,
  withConcurrency: () => withConcurrency2,
  withMicroFiber: () => withMicroFiber,
  withTrace: () => withTrace,
  yieldFlush: () => yieldFlush,
  yieldNow: () => yieldNow2,
  yieldNowWith: () => yieldNowWith,
  zip: () => zip7,
  zipWith: () => zipWith8
});
var TypeId16 = Symbol.for("effect/Micro");
var MicroExitTypeId = Symbol.for("effect/Micro/MicroExit");
var isMicro = (u) => typeof u === "object" && u !== null && TypeId16 in u;
var MicroCauseTypeId = Symbol.for("effect/Micro/MicroCause");
var isMicroCause = (self) => hasProperty(self, MicroCauseTypeId);
var microCauseVariance = {
  _E: identity
};
var MicroCauseImpl = class extends globalThis.Error {
  _tag;
  traces;
  [MicroCauseTypeId];
  constructor(_tag, originalError2, traces) {
    const causeName = `MicroCause.${_tag}`;
    let name;
    let message;
    let stack;
    if (originalError2 instanceof globalThis.Error) {
      name = `(${causeName}) ${originalError2.name}`;
      message = originalError2.message;
      const messageLines = message.split("\n").length;
      stack = originalError2.stack ? `(${causeName}) ${originalError2.stack.split("\n").slice(0, messageLines + 3).join("\n")}` : `${name}: ${message}`;
    } else {
      name = causeName;
      message = toStringUnknown(originalError2, 0);
      stack = `${name}: ${message}`;
    }
    if (traces.length > 0) {
      stack += `
    ${traces.join("\n    ")}`;
    }
    super(message);
    this._tag = _tag;
    this.traces = traces;
    this[MicroCauseTypeId] = microCauseVariance;
    this.name = name;
    this.stack = stack;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toString() {
    return this.stack;
  }
  [NodeInspectSymbol]() {
    return this.stack;
  }
};
var Fail = class extends MicroCauseImpl {
  error;
  constructor(error4, traces = []) {
    super("Fail", error4, traces);
    this.error = error4;
  }
};
var causeFail = (error4, traces = []) => new Fail(error4, traces);
var Die = class extends MicroCauseImpl {
  defect;
  constructor(defect, traces = []) {
    super("Die", defect, traces);
    this.defect = defect;
  }
};
var causeDie = (defect, traces = []) => new Die(defect, traces);
var Interrupt = class extends MicroCauseImpl {
  constructor(traces = []) {
    super("Interrupt", "interrupted", traces);
  }
};
var causeInterrupt = (traces = []) => new Interrupt(traces);
var causeIsFail = (self) => self._tag === "Fail";
var causeIsDie = (self) => self._tag === "Die";
var causeIsInterrupt = (self) => self._tag === "Interrupt";
var causeSquash2 = (self) => self._tag === "Fail" ? self.error : self._tag === "Die" ? self.defect : self;
var causeWithTrace = dual(2, (self, trace3) => {
  const traces = [...self.traces, trace3];
  switch (self._tag) {
    case "Die":
      return causeDie(self.defect, traces);
    case "Interrupt":
      return causeInterrupt(traces);
    case "Fail":
      return causeFail(self.error, traces);
  }
});
var MicroFiberTypeId = Symbol.for("effect/Micro/MicroFiber");
var fiberVariance = {
  _A: identity,
  _E: identity
};
var MicroFiberImpl = class {
  context;
  interruptible;
  [MicroFiberTypeId];
  _stack = [];
  _observers = [];
  _exit;
  _children;
  currentOpCount = 0;
  constructor(context15, interruptible6 = true) {
    this.context = context15;
    this.interruptible = interruptible6;
    this[MicroFiberTypeId] = fiberVariance;
  }
  getRef(ref) {
    return unsafeGetReference(this.context, ref);
  }
  addObserver(cb) {
    if (this._exit) {
      cb(this._exit);
      return constVoid;
    }
    this._observers.push(cb);
    return () => {
      const index = this._observers.indexOf(cb);
      if (index >= 0) {
        this._observers.splice(index, 1);
      }
    };
  }
  _interrupted = false;
  unsafeInterrupt() {
    if (this._exit) {
      return;
    }
    this._interrupted = true;
    if (this.interruptible) {
      this.evaluate(exitInterrupt2);
    }
  }
  unsafePoll() {
    return this._exit;
  }
  evaluate(effect4) {
    if (this._exit) {
      return;
    } else if (this._yielded !== void 0) {
      const yielded = this._yielded;
      this._yielded = void 0;
      yielded();
    }
    const exit4 = this.runLoop(effect4);
    if (exit4 === Yield) {
      return;
    }
    const interruptChildren = fiberMiddleware.interruptChildren && fiberMiddleware.interruptChildren(this);
    if (interruptChildren !== void 0) {
      return this.evaluate(flatMap14(interruptChildren, () => exit4));
    }
    this._exit = exit4;
    for (let i = 0; i < this._observers.length; i++) {
      this._observers[i](exit4);
    }
    this._observers.length = 0;
  }
  runLoop(effect4) {
    let yielding = false;
    let current2 = effect4;
    this.currentOpCount = 0;
    try {
      while (true) {
        this.currentOpCount++;
        if (!yielding && this.getRef(CurrentScheduler).shouldYield(this)) {
          yielding = true;
          const prev = current2;
          current2 = flatMap14(yieldNow2, () => prev);
        }
        current2 = current2[evaluate](this);
        if (current2 === Yield) {
          const yielded = this._yielded;
          if (MicroExitTypeId in yielded) {
            this._yielded = void 0;
            return yielded;
          }
          return Yield;
        }
      }
    } catch (error4) {
      if (!hasProperty(current2, evaluate)) {
        return exitDie2(`MicroFiber.runLoop: Not a valid effect: ${String(current2)}`);
      }
      return exitDie2(error4);
    }
  }
  getCont(symbol6) {
    while (true) {
      const op = this._stack.pop();
      if (!op) return void 0;
      const cont = op[ensureCont] && op[ensureCont](this);
      if (cont) return {
        [symbol6]: cont
      };
      if (op[symbol6]) return op;
    }
  }
  // cancel the yielded operation, or for the yielded exit value
  _yielded = void 0;
  yieldWith(value10) {
    this._yielded = value10;
    return Yield;
  }
  children() {
    return this._children ??= /* @__PURE__ */ new Set();
  }
};
var fiberMiddleware = globalValue("effect/Micro/fiberMiddleware", () => ({
  interruptChildren: void 0
}));
var fiberInterruptChildren = (fiber) => {
  if (fiber._children === void 0 || fiber._children.size === 0) {
    return void 0;
  }
  return fiberInterruptAll(fiber._children);
};
var fiberAwait = (self) => async((resume2) => sync3(self.addObserver((exit4) => resume2(succeed4(exit4)))));
var fiberJoin = (self) => flatten10(fiberAwait(self));
var fiberInterrupt = (self) => suspend2(() => {
  self.unsafeInterrupt();
  return asVoid4(fiberAwait(self));
});
var fiberInterruptAll = (fibers2) => suspend2(() => {
  for (const fiber of fibers2) fiber.unsafeInterrupt();
  const iter = fibers2[Symbol.iterator]();
  const wait = suspend2(() => {
    let result = iter.next();
    while (!result.done) {
      if (result.value.unsafePoll()) {
        result = iter.next();
        continue;
      }
      const fiber = result.value;
      return async((resume2) => {
        fiber.addObserver((_) => {
          resume2(wait);
        });
      });
    }
    return exitVoid2;
  });
  return wait;
});
var identifier = Symbol.for("effect/Micro/identifier");
var args = Symbol.for("effect/Micro/args");
var evaluate = Symbol.for("effect/Micro/evaluate");
var successCont = Symbol.for("effect/Micro/successCont");
var failureCont = Symbol.for("effect/Micro/failureCont");
var ensureCont = Symbol.for("effect/Micro/ensureCont");
var Yield = Symbol.for("effect/Micro/Yield");
var microVariance = {
  _A: identity,
  _E: identity,
  _R: identity
};
var MicroProto = {
  ...EffectPrototype2,
  _op: "Micro",
  [TypeId16]: microVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  [Symbol.iterator]() {
    return new SingleShotGen(new YieldWrap(this));
  },
  toJSON() {
    return {
      _id: "Micro",
      op: this[identifier],
      ...args in this ? {
        args: this[args]
      } : void 0
    };
  },
  toString() {
    return format(this);
  },
  [NodeInspectSymbol]() {
    return format(this);
  }
};
function defaultEvaluate(_fiber) {
  return exitDie2(`Micro.evaluate: Not implemented`);
}
var makePrimitiveProto = (options) => ({
  ...MicroProto,
  [identifier]: options.op,
  [evaluate]: options.eval ?? defaultEvaluate,
  [successCont]: options.contA,
  [failureCont]: options.contE,
  [ensureCont]: options.ensure
});
var makePrimitive = (options) => {
  const Proto8 = makePrimitiveProto(options);
  return function() {
    const self = Object.create(Proto8);
    self[args] = options.single === false ? arguments : arguments[0];
    return self;
  };
};
var makeExit = (options) => {
  const Proto8 = {
    ...makePrimitiveProto(options),
    [MicroExitTypeId]: MicroExitTypeId,
    _tag: options.op,
    get [options.prop]() {
      return this[args];
    },
    toJSON() {
      return {
        _id: "MicroExit",
        _tag: options.op,
        [options.prop]: this[args]
      };
    },
    [symbol3](that) {
      return isMicroExit(that) && that._tag === options.op && equals(this[args], that[args]);
    },
    [symbol2]() {
      return cached(this, combine2(string2(options.op))(hash(this[args])));
    }
  };
  return function(value10) {
    const self = Object.create(Proto8);
    self[args] = value10;
    self[successCont] = void 0;
    self[failureCont] = void 0;
    self[ensureCont] = void 0;
    return self;
  };
};
var succeed4 = makeExit({
  op: "Success",
  prop: "value",
  eval(fiber) {
    const cont = fiber.getCont(successCont);
    return cont ? cont[successCont](this[args], fiber) : fiber.yieldWith(this);
  }
});
var failCause4 = makeExit({
  op: "Failure",
  prop: "cause",
  eval(fiber) {
    let cont = fiber.getCont(failureCont);
    while (causeIsInterrupt(this[args]) && cont && fiber.interruptible) {
      cont = fiber.getCont(failureCont);
    }
    return cont ? cont[failureCont](this[args], fiber) : fiber.yieldWith(this);
  }
});
var fail5 = (error4) => failCause4(causeFail(error4));
var sync3 = makePrimitive({
  op: "Sync",
  eval(fiber) {
    const value10 = this[args]();
    const cont = fiber.getCont(successCont);
    return cont ? cont[successCont](value10, fiber) : fiber.yieldWith(exitSucceed2(value10));
  }
});
var suspend2 = makePrimitive({
  op: "Suspend",
  eval(_fiber) {
    return this[args]();
  }
});
var yieldNowWith = makePrimitive({
  op: "Yield",
  eval(fiber) {
    let resumed = false;
    fiber.getRef(CurrentScheduler).scheduleTask(() => {
      if (resumed) return;
      fiber.evaluate(exitVoid2);
    }, this[args] ?? 0);
    return fiber.yieldWith(() => {
      resumed = true;
    });
  }
});
var yieldNow2 = yieldNowWith(0);
var succeedSome2 = (a) => succeed4(some3(a));
var succeedNone2 = succeed4(none2());
var failCauseSync3 = (evaluate4) => suspend2(() => failCause4(evaluate4()));
var die5 = (defect) => exitDie2(defect);
var failSync3 = (error4) => suspend2(() => fail5(error4()));
var fromOption5 = (option11) => option11._tag === "Some" ? succeed4(option11.value) : fail5(new NoSuchElementException2({}));
var fromEither2 = (either14) => either14._tag === "Right" ? succeed4(either14.right) : fail5(either14.left);
var void_5 = succeed4(void 0);
var try_3 = (options) => suspend2(() => {
  try {
    return succeed4(options.try());
  } catch (err) {
    return fail5(options.catch(err));
  }
});
var promise2 = (evaluate4) => asyncOptions(function(resume2, signal) {
  evaluate4(signal).then((a) => resume2(succeed4(a)), (e) => resume2(die5(e)));
}, evaluate4.length !== 0);
var tryPromise2 = (options) => asyncOptions(function(resume2, signal) {
  try {
    options.try(signal).then((a) => resume2(succeed4(a)), (e) => resume2(fail5(options.catch(e))));
  } catch (err) {
    resume2(fail5(options.catch(err)));
  }
}, options.try.length !== 0);
var withMicroFiber = makePrimitive({
  op: "WithMicroFiber",
  eval(fiber) {
    return this[args](fiber);
  }
});
var yieldFlush = withMicroFiber((fiber) => {
  fiber.getRef(CurrentScheduler).flush();
  return exitVoid2;
});
var asyncOptions = makePrimitive({
  op: "Async",
  single: false,
  eval(fiber) {
    const register = this[args][0];
    let resumed = false;
    let yielded = false;
    const controller = this[args][1] ? new AbortController() : void 0;
    const onCancel = register((effect4) => {
      if (resumed) return;
      resumed = true;
      if (yielded) {
        fiber.evaluate(effect4);
      } else {
        yielded = effect4;
      }
    }, controller?.signal);
    if (yielded !== false) return yielded;
    yielded = true;
    fiber._yielded = () => {
      resumed = true;
    };
    if (controller === void 0 && onCancel === void 0) {
      return Yield;
    }
    fiber._stack.push(asyncFinalizer(() => {
      resumed = true;
      controller?.abort();
      return onCancel ?? exitVoid2;
    }));
    return Yield;
  }
});
var asyncFinalizer = makePrimitive({
  op: "AsyncFinalizer",
  ensure(fiber) {
    if (fiber.interruptible) {
      fiber.interruptible = false;
      fiber._stack.push(setInterruptible(true));
    }
  },
  contE(cause3, _fiber) {
    return causeIsInterrupt(cause3) ? flatMap14(this[args](), () => failCause4(cause3)) : failCause4(cause3);
  }
});
var async = (register) => asyncOptions(register, register.length >= 2);
var never2 = async(function() {
  const interval = setInterval(constVoid, 2147483646);
  return sync3(() => clearInterval(interval));
});
var gen5 = (...args2) => suspend2(() => fromIterator2(args2.length === 1 ? args2[0]() : args2[1].call(args2[0])));
var fromIterator2 = makePrimitive({
  op: "Iterator",
  contA(value10, fiber) {
    const state = this[args].next(value10);
    if (state.done) return succeed4(state.value);
    fiber._stack.push(this);
    return yieldWrapGet(state.value);
  },
  eval(fiber) {
    return this[successCont](void 0, fiber);
  }
});
var as5 = dual(2, (self, value10) => map17(self, (_) => value10));
var asSome2 = (self) => map17(self, some3);
var flip4 = (self) => matchEffect3(self, {
  onFailure: succeed4,
  onSuccess: fail5
});
var andThen8 = dual(2, (self, f) => flatMap14(self, (a) => {
  const value10 = isMicro(f) ? f : typeof f === "function" ? f(a) : f;
  return isMicro(value10) ? value10 : succeed4(value10);
}));
var tap3 = dual(2, (self, f) => flatMap14(self, (a) => {
  const value10 = isMicro(f) ? f : typeof f === "function" ? f(a) : f;
  return isMicro(value10) ? as5(value10, a) : succeed4(a);
}));
var asVoid4 = (self) => flatMap14(self, (_) => exitVoid2);
var exit2 = (self) => matchCause2(self, {
  onFailure: exitFailCause2,
  onSuccess: exitSucceed2
});
var sandbox2 = (self) => catchAllCause2(self, fail5);
var raceAll = (all16) => withMicroFiber((parent) => async((resume2) => {
  const effects = fromIterable2(all16);
  const len = effects.length;
  let doneCount = 0;
  let done17 = false;
  const fibers2 = /* @__PURE__ */ new Set();
  const causes = [];
  const onExit4 = (exit4) => {
    doneCount++;
    if (exit4._tag === "Failure") {
      causes.push(exit4.cause);
      if (doneCount >= len) {
        resume2(failCause4(causes[0]));
      }
      return;
    }
    done17 = true;
    resume2(fibers2.size === 0 ? exit4 : flatMap14(uninterruptible2(fiberInterruptAll(fibers2)), () => exit4));
  };
  for (let i = 0; i < len; i++) {
    if (done17) break;
    const fiber = unsafeFork(parent, interruptible3(effects[i]), true, true);
    fibers2.add(fiber);
    fiber.addObserver((exit4) => {
      fibers2.delete(fiber);
      onExit4(exit4);
    });
  }
  return fiberInterruptAll(fibers2);
}));
var raceAllFirst = (all16) => withMicroFiber((parent) => async((resume2) => {
  let done17 = false;
  const fibers2 = /* @__PURE__ */ new Set();
  const onExit4 = (exit4) => {
    done17 = true;
    resume2(fibers2.size === 0 ? exit4 : flatMap14(fiberInterruptAll(fibers2), () => exit4));
  };
  for (const effect4 of all16) {
    if (done17) break;
    const fiber = unsafeFork(parent, interruptible3(effect4), true, true);
    fibers2.add(fiber);
    fiber.addObserver((exit4) => {
      fibers2.delete(fiber);
      onExit4(exit4);
    });
  }
  return fiberInterruptAll(fibers2);
}));
var race = dual(2, (self, that) => raceAll([self, that]));
var raceFirst = dual(2, (self, that) => raceAllFirst([self, that]));
var flatMap14 = dual(2, (self, f) => {
  const onSuccess = Object.create(OnSuccessProto);
  onSuccess[args] = self;
  onSuccess[successCont] = f;
  return onSuccess;
});
var OnSuccessProto = makePrimitiveProto({
  op: "OnSuccess",
  eval(fiber) {
    fiber._stack.push(this);
    return this[args];
  }
});
var flatten10 = (self) => flatMap14(self, identity);
var map17 = dual(2, (self, f) => flatMap14(self, (a) => succeed4(f(a))));
var isMicroExit = (u) => hasProperty(u, MicroExitTypeId);
var exitSucceed2 = succeed4;
var exitFailCause2 = failCause4;
var exitInterrupt2 = exitFailCause2(causeInterrupt());
var exitFail2 = (e) => exitFailCause2(causeFail(e));
var exitDie2 = (defect) => exitFailCause2(causeDie(defect));
var exitIsSuccess2 = (self) => self._tag === "Success";
var exitIsFailure2 = (self) => self._tag === "Failure";
var exitIsInterrupt = (self) => exitIsFailure2(self) && self.cause._tag === "Interrupt";
var exitIsFail = (self) => exitIsFailure2(self) && self.cause._tag === "Fail";
var exitIsDie = (self) => exitIsFailure2(self) && self.cause._tag === "Die";
var exitVoid2 = exitSucceed2(void 0);
var exitVoidAll = (exits) => {
  for (const exit4 of exits) {
    if (exit4._tag === "Failure") {
      return exit4;
    }
  }
  return exitVoid2;
};
var setImmediate = "setImmediate" in globalThis ? globalThis.setImmediate : (f) => setTimeout(f, 0);
var MicroSchedulerDefault = class {
  tasks = [];
  running = false;
  /**
   * @since 3.5.9
   */
  scheduleTask(task, _priority) {
    this.tasks.push(task);
    if (!this.running) {
      this.running = true;
      setImmediate(this.afterScheduled);
    }
  }
  /**
   * @since 3.5.9
   */
  afterScheduled = () => {
    this.running = false;
    this.runTasks();
  };
  /**
   * @since 3.5.9
   */
  runTasks() {
    const tasks = this.tasks;
    this.tasks = [];
    for (let i = 0, len = tasks.length; i < len; i++) {
      tasks[i]();
    }
  }
  /**
   * @since 3.5.9
   */
  shouldYield(fiber) {
    return fiber.currentOpCount >= fiber.getRef(MaxOpsBeforeYield);
  }
  /**
   * @since 3.5.9
   */
  flush() {
    while (this.tasks.length > 0) {
      this.runTasks();
    }
  }
};
var service = (tag5) => withMicroFiber((fiber) => succeed4(unsafeGet3(fiber.context, tag5)));
var serviceOption2 = (tag5) => withMicroFiber((fiber) => succeed4(getOption2(fiber.context, tag5)));
var updateContext = dual(2, (self, f) => withMicroFiber((fiber) => {
  const prev = fiber.context;
  fiber.context = f(prev);
  return onExit2(self, () => {
    fiber.context = prev;
    return void_5;
  });
}));
var updateService2 = dual(3, (self, tag5, f) => withMicroFiber((fiber) => {
  const prev = unsafeGet3(fiber.context, tag5);
  fiber.context = add2(fiber.context, tag5, f(prev));
  return onExit2(self, () => {
    fiber.context = add2(fiber.context, tag5, prev);
    return void_5;
  });
}));
var context3 = () => getContext;
var getContext = withMicroFiber((fiber) => succeed4(fiber.context));
var provideContext2 = dual(2, (self, provided) => updateContext(self, merge3(provided)));
var provideService2 = dual(3, (self, tag5, service4) => updateContext(self, add2(tag5, service4)));
var provideServiceEffect2 = dual(3, (self, tag5, acquire4) => flatMap14(acquire4, (service4) => provideService2(self, tag5, service4)));
var MaxOpsBeforeYield = class extends Reference2()("effect/Micro/currentMaxOpsBeforeYield", {
  defaultValue: () => 2048
}) {
};
var CurrentConcurrency = class extends Reference2()("effect/Micro/currentConcurrency", {
  defaultValue: () => "unbounded"
}) {
};
var CurrentScheduler = class extends Reference2()("effect/Micro/currentScheduler", {
  defaultValue: () => new MicroSchedulerDefault()
}) {
};
var withConcurrency2 = dual(2, (self, concurrency) => provideService2(self, CurrentConcurrency, concurrency));
var zip7 = dual((args2) => isMicro(args2[1]), (self, that, options) => zipWith8(self, that, (a, a2) => [a, a2], options));
var zipWith8 = dual((args2) => isMicro(args2[1]), (self, that, f, options) => options?.concurrent ? map17(all8([self, that], {
  concurrency: 2
}), ([a, a2]) => f(a, a2)) : flatMap14(self, (a) => map17(that, (a2) => f(a, a2))));
var filterOrFailCause = dual((args2) => isMicro(args2[0]), (self, refinement, orFailWith) => flatMap14(self, (a) => refinement(a) ? succeed4(a) : failCause4(orFailWith(a))));
var filterOrFail2 = dual((args2) => isMicro(args2[0]), (self, refinement, orFailWith) => flatMap14(self, (a) => refinement(a) ? succeed4(a) : fail5(orFailWith(a))));
var when2 = dual(2, (self, condition) => flatMap14(isMicro(condition) ? condition : sync3(condition), (pass) => pass ? asSome2(self) : succeedNone2));
var repeatExit = dual(2, (self, options) => suspend2(() => {
  const startedAt = options.schedule ? Date.now() : 0;
  let attempt3 = 0;
  const loop5 = flatMap14(exit2(self), (exit4) => {
    if (options.while !== void 0 && !options.while(exit4)) {
      return exit4;
    } else if (options.times !== void 0 && attempt3 >= options.times) {
      return exit4;
    }
    attempt3++;
    let delayEffect = yieldNow2;
    if (options.schedule !== void 0) {
      const elapsed3 = Date.now() - startedAt;
      const duration5 = options.schedule(attempt3, elapsed3);
      if (isNone2(duration5)) {
        return exit4;
      }
      delayEffect = sleep4(duration5.value);
    }
    return flatMap14(delayEffect, () => loop5);
  });
  return loop5;
}));
var repeat = dual((args2) => isMicro(args2[0]), (self, options) => repeatExit(self, {
  ...options,
  while: (exit4) => exit4._tag === "Success" && (options?.while === void 0 || options.while(exit4.value))
}));
var replicate3 = dual(2, (self, n) => Array.from({
  length: n
}, () => self));
var replicateEffect = dual((args2) => isMicro(args2[0]), (self, n, options) => all8(replicate3(self, n), options));
var forever2 = (self) => repeat(self);
var scheduleRecurs = (n) => (attempt3) => attempt3 <= n ? some3(0) : none2();
var scheduleSpaced = (millis2) => () => some3(millis2);
var scheduleExponential = (baseMillis, factor = 2) => (attempt3) => some3(Math.pow(factor, attempt3) * baseMillis);
var scheduleAddDelay = dual(2, (self, f) => (attempt3, elapsed3) => map2(self(attempt3, elapsed3), (duration5) => duration5 + f()));
var scheduleWithMaxDelay = dual(2, (self, max13) => (attempt3, elapsed3) => map2(self(attempt3, elapsed3), (duration5) => Math.min(duration5, max13)));
var scheduleWithMaxElapsed = dual(2, (self, max13) => (attempt3, elapsed3) => elapsed3 < max13 ? self(attempt3, elapsed3) : none2());
var scheduleUnion = dual(2, (self, that) => (attempt3, elapsed3) => zipWith2(self(attempt3, elapsed3), that(attempt3, elapsed3), (d1, d2) => Math.min(d1, d2)));
var scheduleIntersect = dual(2, (self, that) => (attempt3, elapsed3) => zipWith2(self(attempt3, elapsed3), that(attempt3, elapsed3), (d1, d2) => Math.max(d1, d2)));
var catchAllCause2 = dual(2, (self, f) => {
  const onFailure = Object.create(OnFailureProto);
  onFailure[args] = self;
  onFailure[failureCont] = f;
  return onFailure;
});
var OnFailureProto = makePrimitiveProto({
  op: "OnFailure",
  eval(fiber) {
    fiber._stack.push(this);
    return this[args];
  }
});
var catchCauseIf = dual(3, (self, predicate, f) => catchAllCause2(self, (cause3) => predicate(cause3) ? f(cause3) : failCause4(cause3)));
var catchAll2 = dual(2, (self, f) => catchCauseIf(self, causeIsFail, (cause3) => f(cause3.error)));
var catchAllDefect2 = dual(2, (self, f) => catchCauseIf(self, causeIsDie, (die19) => f(die19.defect)));
var tapErrorCause2 = dual(2, (self, f) => tapErrorCauseIf(self, constTrue, f));
var tapErrorCauseIf = dual(3, (self, refinement, f) => catchCauseIf(self, refinement, (cause3) => andThen8(f(cause3), failCause4(cause3))));
var tapError2 = dual(2, (self, f) => tapErrorCauseIf(self, causeIsFail, (fail30) => f(fail30.error)));
var tapDefect2 = dual(2, (self, f) => tapErrorCauseIf(self, causeIsDie, (die19) => f(die19.defect)));
var catchIf2 = dual(3, (self, predicate, f) => catchCauseIf(self, (f2) => causeIsFail(f2) && predicate(f2.error), (fail30) => f(fail30.error)));
var catchTag2 = dual(3, (self, k, f) => catchIf2(self, isTagged(k), f));
var mapErrorCause3 = dual(2, (self, f) => catchAllCause2(self, (cause3) => failCause4(f(cause3))));
var mapError3 = dual(2, (self, f) => catchAll2(self, (error4) => fail5(f(error4))));
var orDie2 = (self) => catchAll2(self, die5);
var orElseSucceed2 = dual(2, (self, f) => catchAll2(self, (_) => sync3(f)));
var ignore2 = (self) => matchEffect3(self, {
  onFailure: (_) => void_5,
  onSuccess: (_) => void_5
});
var ignoreLogged2 = (self) => matchEffect3(self, {
  // eslint-disable-next-line no-console
  onFailure: (error4) => sync3(() => console.error(error4)),
  onSuccess: (_) => void_5
});
var option3 = (self) => match11(self, {
  onFailure: none2,
  onSuccess: some3
});
var either4 = (self) => match11(self, {
  onFailure: left2,
  onSuccess: right2
});
var retry = dual((args2) => isMicro(args2[0]), (self, options) => repeatExit(self, {
  ...options,
  while: (exit4) => exit4._tag === "Failure" && exit4.cause._tag === "Fail" && (options?.while === void 0 || options.while(exit4.cause.error))
}));
var withTrace = function() {
  const prevLimit = globalThis.Error.stackTraceLimit;
  globalThis.Error.stackTraceLimit = 2;
  const error4 = new globalThis.Error();
  globalThis.Error.stackTraceLimit = prevLimit;
  function generate(name, cause3) {
    const stack = error4.stack;
    if (!stack) {
      return cause3;
    }
    const line = stack.split("\n")[2]?.trim().replace(/^at /, "");
    if (!line) {
      return cause3;
    }
    const lineMatch = line.match(/\((.*)\)$/);
    return causeWithTrace(cause3, `at ${name} (${lineMatch ? lineMatch[1] : line})`);
  }
  const f = (name) => (self) => onError2(self, (cause3) => failCause4(generate(name, cause3)));
  if (arguments.length === 2) {
    return f(arguments[1])(arguments[0]);
  }
  return f(arguments[0]);
};
var matchCauseEffect2 = dual(2, (self, options) => {
  const primitive3 = Object.create(OnSuccessAndFailureProto);
  primitive3[args] = self;
  primitive3[successCont] = options.onSuccess;
  primitive3[failureCont] = options.onFailure;
  return primitive3;
});
var OnSuccessAndFailureProto = makePrimitiveProto({
  op: "OnSuccessAndFailure",
  eval(fiber) {
    fiber._stack.push(this);
    return this[args];
  }
});
var matchCause2 = dual(2, (self, options) => matchCauseEffect2(self, {
  onFailure: (cause3) => sync3(() => options.onFailure(cause3)),
  onSuccess: (value10) => sync3(() => options.onSuccess(value10))
}));
var matchEffect3 = dual(2, (self, options) => matchCauseEffect2(self, {
  onFailure: (cause3) => cause3._tag === "Fail" ? options.onFailure(cause3.error) : failCause4(cause3),
  onSuccess: options.onSuccess
}));
var match11 = dual(2, (self, options) => matchEffect3(self, {
  onFailure: (error4) => sync3(() => options.onFailure(error4)),
  onSuccess: (value10) => sync3(() => options.onSuccess(value10))
}));
var sleep4 = (millis2) => async((resume2) => {
  const timeout6 = setTimeout(() => {
    resume2(void_5);
  }, millis2);
  return sync3(() => {
    clearTimeout(timeout6);
  });
});
var delay2 = dual(2, (self, millis2) => andThen8(sleep4(millis2), self));
var timeoutOrElse = dual(2, (self, options) => raceFirst(self, andThen8(interruptible3(sleep4(options.duration)), options.onTimeout)));
var timeout = dual(2, (self, millis2) => timeoutOrElse(self, {
  duration: millis2,
  onTimeout: () => fail5(new TimeoutException2())
}));
var timeoutOption = dual(2, (self, millis2) => raceFirst(asSome2(self), as5(interruptible3(sleep4(millis2)), none2())));
var MicroScopeTypeId = Symbol.for("effect/Micro/MicroScope");
var MicroScope = GenericTag("effect/Micro/MicroScope");
var MicroScopeImpl = class _MicroScopeImpl {
  [MicroScopeTypeId];
  state = {
    _tag: "Open",
    finalizers: /* @__PURE__ */ new Set()
  };
  constructor() {
    this[MicroScopeTypeId] = MicroScopeTypeId;
  }
  unsafeAddFinalizer(finalizer3) {
    if (this.state._tag === "Open") {
      this.state.finalizers.add(finalizer3);
    }
  }
  addFinalizer(finalizer3) {
    return suspend2(() => {
      if (this.state._tag === "Open") {
        this.state.finalizers.add(finalizer3);
        return void_5;
      }
      return finalizer3(this.state.exit);
    });
  }
  unsafeRemoveFinalizer(finalizer3) {
    if (this.state._tag === "Open") {
      this.state.finalizers.delete(finalizer3);
    }
  }
  close(microExit) {
    return suspend2(() => {
      if (this.state._tag === "Open") {
        const finalizers = Array.from(this.state.finalizers).reverse();
        this.state = {
          _tag: "Closed",
          exit: microExit
        };
        return flatMap14(forEach11(finalizers, (finalizer3) => exit2(finalizer3(microExit))), exitVoidAll);
      }
      return void_5;
    });
  }
  get fork() {
    return sync3(() => {
      const newScope = new _MicroScopeImpl();
      if (this.state._tag === "Closed") {
        newScope.state = this.state;
        return newScope;
      }
      function fin(exit4) {
        return newScope.close(exit4);
      }
      this.state.finalizers.add(fin);
      newScope.unsafeAddFinalizer((_) => sync3(() => this.unsafeRemoveFinalizer(fin)));
      return newScope;
    });
  }
};
var scopeMake = sync3(() => new MicroScopeImpl());
var scopeUnsafeMake = () => new MicroScopeImpl();
var scope = service(MicroScope);
var provideScope = dual(2, (self, scope6) => provideService2(self, MicroScope, scope6));
var scoped = (self) => suspend2(() => {
  const scope6 = new MicroScopeImpl();
  return onExit2(provideService2(self, MicroScope, scope6), (exit4) => scope6.close(exit4));
});
var acquireRelease = (acquire4, release4) => uninterruptible2(flatMap14(scope, (scope6) => tap3(acquire4, (a) => scope6.addFinalizer((exit4) => release4(a, exit4)))));
var addFinalizer = (finalizer3) => flatMap14(scope, (scope6) => scope6.addFinalizer(finalizer3));
var onExit2 = dual(2, (self, f) => uninterruptibleMask2((restore) => matchCauseEffect2(restore(self), {
  onFailure: (cause3) => flatMap14(f(exitFailCause2(cause3)), () => failCause4(cause3)),
  onSuccess: (a) => flatMap14(f(exitSucceed2(a)), () => succeed4(a))
})));
var ensuring = dual(2, (self, finalizer3) => onExit2(self, (_) => finalizer3));
var onExitIf = dual(3, (self, refinement, f) => onExit2(self, (exit4) => refinement(exit4) ? f(exit4) : exitVoid2));
var onError2 = dual(2, (self, f) => onExitIf(self, exitIsFailure2, (exit4) => f(exit4.cause)));
var onInterrupt2 = dual(2, (self, finalizer3) => onExitIf(self, exitIsInterrupt, (_) => finalizer3));
var acquireUseRelease2 = (acquire4, use2, release4) => uninterruptibleMask2((restore) => flatMap14(acquire4, (a) => flatMap14(exit2(restore(use2(a))), (exit4) => andThen8(release4(a, exit4), exit4))));
var interrupt5 = failCause4(causeInterrupt());
var uninterruptible2 = (self) => withMicroFiber((fiber) => {
  if (!fiber.interruptible) return self;
  fiber.interruptible = false;
  fiber._stack.push(setInterruptible(true));
  return self;
});
var setInterruptible = makePrimitive({
  op: "SetInterruptible",
  ensure(fiber) {
    fiber.interruptible = this[args];
    if (fiber._interrupted && fiber.interruptible) {
      return () => exitInterrupt2;
    }
  }
});
var interruptible3 = (self) => withMicroFiber((fiber) => {
  if (fiber.interruptible) return self;
  fiber.interruptible = true;
  fiber._stack.push(setInterruptible(false));
  if (fiber._interrupted) return exitInterrupt2;
  return self;
});
var uninterruptibleMask2 = (f) => withMicroFiber((fiber) => {
  if (!fiber.interruptible) return f(identity);
  fiber.interruptible = false;
  fiber._stack.push(setInterruptible(true));
  return f(interruptible3);
});
var all8 = (arg, options) => {
  if (Array.isArray(arg) || isIterable(arg)) {
    return forEach11(arg, identity, options);
  } else if (options?.discard) {
    return forEach11(Object.values(arg), identity, options);
  }
  return suspend2(() => {
    const out = {};
    return as5(forEach11(Object.entries(arg), ([key, effect4]) => map17(effect4, (value10) => {
      out[key] = value10;
    }), {
      discard: true,
      concurrency: options?.concurrency
    }), out);
  });
};
var whileLoop2 = makePrimitive({
  op: "While",
  contA(value10, fiber) {
    this[args].step(value10);
    if (this[args].while()) {
      fiber._stack.push(this);
      return this[args].body();
    }
    return exitVoid2;
  },
  eval(fiber) {
    if (this[args].while()) {
      fiber._stack.push(this);
      return this[args].body();
    }
    return exitVoid2;
  }
});
var forEach11 = (iterable, f, options) => withMicroFiber((parent) => {
  const concurrencyOption = options?.concurrency === "inherit" ? parent.getRef(CurrentConcurrency) : options?.concurrency ?? 1;
  const concurrency = concurrencyOption === "unbounded" ? Number.POSITIVE_INFINITY : Math.max(1, concurrencyOption);
  const items = fromIterable2(iterable);
  let length6 = items.length;
  if (length6 === 0) {
    return options?.discard ? void_5 : succeed4([]);
  }
  const out = options?.discard ? void 0 : new Array(length6);
  let index = 0;
  if (concurrency === 1) {
    return as5(whileLoop2({
      while: () => index < items.length,
      body: () => f(items[index], index),
      step: out ? (b) => out[index++] = b : (_) => index++
    }), out);
  }
  return async((resume2) => {
    const fibers2 = /* @__PURE__ */ new Set();
    let result = void 0;
    let inProgress = 0;
    let doneCount = 0;
    let pumping = false;
    let interrupted4 = false;
    function pump() {
      pumping = true;
      while (inProgress < concurrency && index < length6) {
        const currentIndex = index;
        const item = items[currentIndex];
        index++;
        inProgress++;
        try {
          const child = unsafeFork(parent, f(item, currentIndex), true, true);
          fibers2.add(child);
          child.addObserver((exit4) => {
            fibers2.delete(child);
            if (interrupted4) {
              return;
            } else if (exit4._tag === "Failure") {
              if (result === void 0) {
                result = exit4;
                length6 = index;
                fibers2.forEach((fiber) => fiber.unsafeInterrupt());
              }
            } else if (out !== void 0) {
              out[currentIndex] = exit4.value;
            }
            doneCount++;
            inProgress--;
            if (doneCount === length6) {
              resume2(result ?? succeed4(out));
            } else if (!pumping && inProgress < concurrency) {
              pump();
            }
          });
        } catch (err) {
          result = exitDie2(err);
          length6 = index;
          fibers2.forEach((fiber) => fiber.unsafeInterrupt());
        }
      }
      pumping = false;
    }
    pump();
    return suspend2(() => {
      interrupted4 = true;
      index = length6;
      return fiberInterruptAll(fibers2);
    });
  });
});
var filter12 = (iterable, f, options) => filterMap10(iterable, (a) => map17(f(a), (pass) => {
  pass = options?.negate ? !pass : pass;
  return pass ? some3(a) : none2();
}), options);
var filterMap10 = (iterable, f, options) => suspend2(() => {
  const out = [];
  return as5(forEach11(iterable, (a) => map17(f(a), (o) => {
    if (o._tag === "Some") {
      out.push(o.value);
    }
  }), {
    discard: true,
    concurrency: options?.concurrency
  }), out);
});
var Do5 = succeed4({});
var bindTo6 = bindTo(map17);
var bind6 = bind(map17, flatMap14);
var let_6 = let_(map17);
var fork = (self) => withMicroFiber((fiber) => {
  fiberMiddleware.interruptChildren ??= fiberInterruptChildren;
  return succeed4(unsafeFork(fiber, self));
});
var unsafeFork = (parent, effect4, immediate = false, daemon = false) => {
  const child = new MicroFiberImpl(parent.context, parent.interruptible);
  if (!daemon) {
    parent.children().add(child);
    child.addObserver(() => parent.children().delete(child));
  }
  if (immediate) {
    child.evaluate(effect4);
  } else {
    parent.getRef(CurrentScheduler).scheduleTask(() => child.evaluate(effect4), 0);
  }
  return child;
};
var forkDaemon = (self) => withMicroFiber((fiber) => succeed4(unsafeFork(fiber, self, false, true)));
var forkIn = dual(2, (self, scope6) => uninterruptibleMask2((restore) => flatMap14(scope6.fork, (scope7) => tap3(restore(forkDaemon(onExit2(self, (exit4) => scope7.close(exit4)))), (fiber) => scope7.addFinalizer((_) => fiberInterrupt(fiber))))));
var forkScoped = (self) => flatMap14(scope, (scope6) => forkIn(self, scope6));
var runFork = (effect4, options) => {
  const fiber = new MicroFiberImpl(CurrentScheduler.context(options?.scheduler ?? new MicroSchedulerDefault()));
  fiber.evaluate(effect4);
  if (options?.signal) {
    if (options.signal.aborted) {
      fiber.unsafeInterrupt();
    } else {
      const abort = () => fiber.unsafeInterrupt();
      options.signal.addEventListener("abort", abort, {
        once: true
      });
      fiber.addObserver(() => options.signal.removeEventListener("abort", abort));
    }
  }
  return fiber;
};
var runPromiseExit = (effect4, options) => new Promise((resolve, _reject) => {
  const handle = runFork(effect4, options);
  handle.addObserver(resolve);
});
var runPromise = (effect4, options) => runPromiseExit(effect4, options).then((exit4) => {
  if (exit4._tag === "Failure") {
    throw exit4.cause;
  }
  return exit4.value;
});
var runSyncExit = (effect4) => {
  const scheduler2 = new MicroSchedulerDefault();
  const fiber = runFork(effect4, {
    scheduler: scheduler2
  });
  scheduler2.flush();
  return fiber._exit ?? exitDie2(fiber);
};
var runSync = (effect4) => {
  const exit4 = runSyncExit(effect4);
  if (exit4._tag === "Failure") throw exit4.cause;
  return exit4.value;
};
var YieldableError2 = function() {
  class YieldableError4 extends globalThis.Error {
  }
  Object.assign(YieldableError4.prototype, MicroProto, StructuralPrototype, {
    [identifier]: "Failure",
    [evaluate]() {
      return fail5(this);
    },
    toString() {
      return this.message ? `${this.name}: ${this.message}` : this.name;
    },
    toJSON() {
      return {
        ...this
      };
    },
    [NodeInspectSymbol]() {
      const stack = this.stack;
      if (stack) {
        return `${this.toString()}
${stack.split("\n").slice(1).join("\n")}`;
      }
      return this.toString();
    }
  });
  return YieldableError4;
}();
var Error3 = /* @__PURE__ */ function() {
  return class extends YieldableError2 {
    constructor(args2) {
      super();
      if (args2) {
        Object.assign(this, args2);
      }
    }
  };
}();
var TaggedError = (tag5) => {
  class Base4 extends Error3 {
    _tag = tag5;
  }
  ;
  Base4.prototype.name = tag5;
  return Base4;
};
var NoSuchElementException2 = class extends TaggedError("NoSuchElementException") {
};
var TimeoutException2 = class extends TaggedError("TimeoutException") {
};

// ../../node_modules/effect/dist/esm/Scheduler.js
var Scheduler_exports = {};
__export(Scheduler_exports, {
  ControlledScheduler: () => ControlledScheduler,
  MixedScheduler: () => MixedScheduler,
  PriorityBuckets: () => PriorityBuckets,
  SyncScheduler: () => SyncScheduler,
  currentScheduler: () => currentScheduler,
  defaultScheduler: () => defaultScheduler,
  defaultShouldYield: () => defaultShouldYield,
  make: () => make40,
  makeBatched: () => makeBatched,
  makeMatrix: () => makeMatrix,
  timer: () => timer,
  timerBatched: () => timerBatched,
  withScheduler: () => withScheduler
});
var PriorityBuckets = class {
  /**
   * @since 2.0.0
   */
  buckets = [];
  /**
   * @since 2.0.0
   */
  scheduleTask(task, priority) {
    const length6 = this.buckets.length;
    let bucket = void 0;
    let index = 0;
    for (; index < length6; index++) {
      if (this.buckets[index][0] <= priority) {
        bucket = this.buckets[index];
      } else {
        break;
      }
    }
    if (bucket && bucket[0] === priority) {
      bucket[1].push(task);
    } else if (index === length6) {
      this.buckets.push([priority, [task]]);
    } else {
      this.buckets.splice(index, 0, [priority, [task]]);
    }
  }
};
var MixedScheduler = class {
  maxNextTickBeforeTimer;
  /**
   * @since 2.0.0
   */
  running = false;
  /**
   * @since 2.0.0
   */
  tasks = new PriorityBuckets();
  constructor(maxNextTickBeforeTimer) {
    this.maxNextTickBeforeTimer = maxNextTickBeforeTimer;
  }
  /**
   * @since 2.0.0
   */
  starveInternal(depth) {
    const tasks = this.tasks.buckets;
    this.tasks.buckets = [];
    for (const [_, toRun] of tasks) {
      for (let i = 0; i < toRun.length; i++) {
        toRun[i]();
      }
    }
    if (this.tasks.buckets.length === 0) {
      this.running = false;
    } else {
      this.starve(depth);
    }
  }
  /**
   * @since 2.0.0
   */
  starve(depth = 0) {
    if (depth >= this.maxNextTickBeforeTimer) {
      setTimeout(() => this.starveInternal(0), 0);
    } else {
      Promise.resolve(void 0).then(() => this.starveInternal(depth + 1));
    }
  }
  /**
   * @since 2.0.0
   */
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
  }
  /**
   * @since 2.0.0
   */
  scheduleTask(task, priority) {
    this.tasks.scheduleTask(task, priority);
    if (!this.running) {
      this.running = true;
      this.starve();
    }
  }
};
var defaultScheduler = globalValue(Symbol.for("effect/Scheduler/defaultScheduler"), () => new MixedScheduler(2048));
var SyncScheduler = class {
  /**
   * @since 2.0.0
   */
  tasks = new PriorityBuckets();
  /**
   * @since 2.0.0
   */
  deferred = false;
  /**
   * @since 2.0.0
   */
  scheduleTask(task, priority) {
    if (this.deferred) {
      defaultScheduler.scheduleTask(task, priority);
    } else {
      this.tasks.scheduleTask(task, priority);
    }
  }
  /**
   * @since 2.0.0
   */
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
  }
  /**
   * @since 2.0.0
   */
  flush() {
    while (this.tasks.buckets.length > 0) {
      const tasks = this.tasks.buckets;
      this.tasks.buckets = [];
      for (const [_, toRun] of tasks) {
        for (let i = 0; i < toRun.length; i++) {
          toRun[i]();
        }
      }
    }
    this.deferred = true;
  }
};
var ControlledScheduler = class {
  /**
   * @since 2.0.0
   */
  tasks = new PriorityBuckets();
  /**
   * @since 2.0.0
   */
  deferred = false;
  /**
   * @since 2.0.0
   */
  scheduleTask(task, priority) {
    if (this.deferred) {
      defaultScheduler.scheduleTask(task, priority);
    } else {
      this.tasks.scheduleTask(task, priority);
    }
  }
  /**
   * @since 2.0.0
   */
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
  }
  /**
   * @since 2.0.0
   */
  step() {
    const tasks = this.tasks.buckets;
    this.tasks.buckets = [];
    for (const [_, toRun] of tasks) {
      for (let i = 0; i < toRun.length; i++) {
        toRun[i]();
      }
    }
  }
};
var makeMatrix = (...record4) => {
  const index = record4.sort(([p0], [p1]) => p0 < p1 ? -1 : p0 > p1 ? 1 : 0);
  return {
    shouldYield(fiber) {
      for (const scheduler2 of record4) {
        const priority = scheduler2[1].shouldYield(fiber);
        if (priority !== false) {
          return priority;
        }
      }
      return false;
    },
    scheduleTask(task, priority) {
      let scheduler2 = void 0;
      for (const i of index) {
        if (priority >= i[0]) {
          scheduler2 = i[1];
        } else {
          return (scheduler2 ?? defaultScheduler).scheduleTask(task, priority);
        }
      }
      return (scheduler2 ?? defaultScheduler).scheduleTask(task, priority);
    }
  };
};
var defaultShouldYield = (fiber) => {
  return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
};
var make40 = (scheduleTask, shouldYield = defaultShouldYield) => ({
  scheduleTask,
  shouldYield
});
var makeBatched = (callback, shouldYield = defaultShouldYield) => {
  let running4 = false;
  const tasks = new PriorityBuckets();
  const starveInternal = () => {
    const tasksToRun = tasks.buckets;
    tasks.buckets = [];
    for (const [_, toRun] of tasksToRun) {
      for (let i = 0; i < toRun.length; i++) {
        toRun[i]();
      }
    }
    if (tasks.buckets.length === 0) {
      running4 = false;
    } else {
      starve();
    }
  };
  const starve = () => callback(starveInternal);
  return make40((task, priority) => {
    tasks.scheduleTask(task, priority);
    if (!running4) {
      running4 = true;
      starve();
    }
  }, shouldYield);
};
var timer = (ms, shouldYield = defaultShouldYield) => make40((task) => setTimeout(task, ms), shouldYield);
var timerBatched = (ms, shouldYield = defaultShouldYield) => makeBatched((task) => setTimeout(task, ms), shouldYield);
var currentScheduler = globalValue(Symbol.for("effect/FiberRef/currentScheduler"), () => fiberRefUnsafeMake(defaultScheduler));
var withScheduler = dual(2, (self, scheduler2) => fiberRefLocally(self, currentScheduler, scheduler2));

// ../../node_modules/effect/dist/esm/internal/completedRequestMap.js
var currentRequestMap = globalValue(Symbol.for("effect/FiberRef/currentRequestMap"), () => fiberRefUnsafeMake(/* @__PURE__ */ new Map()));

// ../../node_modules/effect/dist/esm/internal/concurrency.js
var match12 = (concurrency, sequential6, unbounded10, bounded10) => {
  switch (concurrency) {
    case void 0:
      return sequential6();
    case "unbounded":
      return unbounded10();
    case "inherit":
      return fiberRefGetWith(currentConcurrency, (concurrency2) => concurrency2 === "unbounded" ? unbounded10() : concurrency2 > 1 ? bounded10(concurrency2) : sequential6());
    default:
      return concurrency > 1 ? bounded10(concurrency) : sequential6();
  }
};
var matchSimple = (concurrency, sequential6, concurrent) => {
  switch (concurrency) {
    case void 0:
      return sequential6();
    case "unbounded":
      return concurrent();
    case "inherit":
      return fiberRefGetWith(currentConcurrency, (concurrency2) => concurrency2 === "unbounded" || concurrency2 > 1 ? concurrent() : sequential6());
    default:
      return concurrency > 1 ? concurrent() : sequential6();
  }
};

// ../../node_modules/effect/dist/esm/internal/fiberMessage.js
var OP_INTERRUPT_SIGNAL = "InterruptSignal";
var OP_STATEFUL = "Stateful";
var OP_RESUME = "Resume";
var OP_YIELD_NOW = "YieldNow";
var interruptSignal = (cause3) => ({
  _tag: OP_INTERRUPT_SIGNAL,
  cause: cause3
});
var stateful = (onFiber) => ({
  _tag: OP_STATEFUL,
  onFiber
});
var resume = (effect4) => ({
  _tag: OP_RESUME,
  effect: effect4
});
var yieldNow3 = () => ({
  _tag: OP_YIELD_NOW
});

// ../../node_modules/effect/dist/esm/internal/fiberScope.js
var FiberScopeSymbolKey = "effect/FiberScope";
var FiberScopeTypeId = Symbol.for(FiberScopeSymbolKey);
var Global = class {
  [FiberScopeTypeId] = FiberScopeTypeId;
  fiberId = none4;
  roots = /* @__PURE__ */ new Set();
  add(_runtimeFlags, child) {
    this.roots.add(child);
    child.addObserver(() => {
      this.roots.delete(child);
    });
  }
};
var Local = class {
  fiberId;
  parent;
  [FiberScopeTypeId] = FiberScopeTypeId;
  constructor(fiberId5, parent) {
    this.fiberId = fiberId5;
    this.parent = parent;
  }
  add(_runtimeFlags, child) {
    this.parent.tell(stateful((parentFiber) => {
      parentFiber.addChild(child);
      child.addObserver(() => {
        parentFiber.removeChild(child);
      });
    }));
  }
};
var unsafeMake9 = (fiber) => {
  return new Local(fiber.id(), fiber);
};
var globalScope = globalValue(Symbol.for("effect/FiberScope/Global"), () => new Global());

// ../../node_modules/effect/dist/esm/internal/fiber.js
var FiberSymbolKey = "effect/Fiber";
var FiberTypeId = Symbol.for(FiberSymbolKey);
var fiberVariance2 = {
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var fiberProto = {
  [FiberTypeId]: fiberVariance2,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var RuntimeFiberSymbolKey = "effect/Fiber";
var RuntimeFiberTypeId = Symbol.for(RuntimeFiberSymbolKey);
var Order7 = pipe(tuple3(Order, Order), mapInput3((fiber) => [fiber.id().startTimeMillis, fiber.id().id]));
var isFiber = (u) => hasProperty(u, FiberTypeId);
var isRuntimeFiber = (self) => RuntimeFiberTypeId in self;
var _await2 = (self) => self.await;
var children = (self) => self.children;
var done5 = (exit4) => {
  const _fiber = {
    ...CommitPrototype,
    commit() {
      return join3(this);
    },
    ...fiberProto,
    id: () => none4,
    await: succeed(exit4),
    children: succeed([]),
    inheritAll: void_3,
    poll: succeed(some3(exit4)),
    interruptAsFork: () => void_3
  };
  return _fiber;
};
var dump = (self) => map14(self.status, (status3) => ({
  id: self.id(),
  status: status3
}));
var dumpAll = (fibers2) => forEachSequential(fibers2, dump);
var fail6 = (error4) => done5(fail4(error4));
var failCause5 = (cause3) => done5(failCause3(cause3));
var fromEffect = (effect4) => map14(exit(effect4), done5);
var id = (self) => self.id();
var inheritAll = (self) => self.inheritAll;
var interrupted = (fiberId5) => done5(interrupt4(fiberId5));
var interruptAll = (fibers2) => flatMap12(fiberId, (fiberId5) => pipe(fibers2, interruptAllAs(fiberId5)));
var interruptAllAs = dual(2, (fibers2, fiberId5) => pipe(forEachSequentialDiscard(fibers2, interruptAsFork(fiberId5)), zipRight2(pipe(fibers2, forEachSequentialDiscard(_await2)))));
var interruptAsFork = dual(2, (self, fiberId5) => self.interruptAsFork(fiberId5));
var join3 = (self) => zipLeft2(flatten8(self.await), self.inheritAll);
var map18 = dual(2, (self, f) => mapEffect2(self, (a) => sync(() => f(a))));
var mapEffect2 = dual(2, (self, f) => {
  const _fiber = {
    ...CommitPrototype,
    commit() {
      return join3(this);
    },
    ...fiberProto,
    id: () => self.id(),
    await: flatMap12(self.await, forEachEffect(f)),
    children: self.children,
    inheritAll: self.inheritAll,
    poll: flatMap12(self.poll, (result) => {
      switch (result._tag) {
        case "None":
          return succeed(none2());
        case "Some":
          return pipe(forEachEffect(result.value, f), map14(some3));
      }
    }),
    interruptAsFork: (id3) => self.interruptAsFork(id3)
  };
  return _fiber;
});
var mapFiber = dual(2, (self, f) => map14(self.await, match7({
  onFailure: (cause3) => failCause5(cause3),
  onSuccess: (a) => f(a)
})));
var match13 = dual(2, (self, {
  onFiber,
  onRuntimeFiber
}) => {
  if (isRuntimeFiber(self)) {
    return onRuntimeFiber(self);
  }
  return onFiber(self);
});
var _never = {
  ...CommitPrototype,
  commit() {
    return join3(this);
  },
  ...fiberProto,
  id: () => none4,
  await: never,
  children: succeed([]),
  inheritAll: never,
  poll: succeed(none2()),
  interruptAsFork: () => never
};
var never3 = _never;
var orElse5 = dual(2, (self, that) => ({
  ...CommitPrototype,
  commit() {
    return join3(this);
  },
  ...fiberProto,
  id: () => getOrElse6(self.id(), that.id()),
  await: zipWith6(self.await, that.await, (exit1, exit22) => isSuccess(exit1) ? exit1 : exit22),
  children: self.children,
  inheritAll: zipRight2(that.inheritAll, self.inheritAll),
  poll: zipWith6(self.poll, that.poll, (option1, option22) => {
    switch (option1._tag) {
      case "None": {
        return none2();
      }
      case "Some": {
        return isSuccess(option1.value) ? option1 : option22;
      }
    }
  }),
  interruptAsFork: (id3) => pipe(interruptAsFiber(self, id3), zipRight2(pipe(that, interruptAsFiber(id3))), asVoid2)
}));
var orElseEither3 = dual(2, (self, that) => orElse5(map18(self, left2), map18(that, right2)));
var poll3 = (self) => self.poll;
var parseMs = (milliseconds) => {
  const roundTowardsZero = milliseconds > 0 ? Math.floor : Math.ceil;
  return {
    days: roundTowardsZero(milliseconds / 864e5),
    hours: roundTowardsZero(milliseconds / 36e5) % 24,
    minutes: roundTowardsZero(milliseconds / 6e4) % 60,
    seconds: roundTowardsZero(milliseconds / 1e3) % 60,
    milliseconds: roundTowardsZero(milliseconds) % 1e3,
    microseconds: roundTowardsZero(milliseconds * 1e3) % 1e3,
    nanoseconds: roundTowardsZero(milliseconds * 1e6) % 1e3
  };
};
var renderStatus = (status3) => {
  if (isDone3(status3)) {
    return "Done";
  }
  if (isRunning2(status3)) {
    return "Running";
  }
  const isInterruptible = interruptible(status3.runtimeFlags) ? "interruptible" : "uninterruptible";
  return `Suspended(${isInterruptible})`;
};
var pretty2 = (self) => flatMap12(currentTimeMillis2, (now3) => map14(dump(self), (dump3) => {
  const time3 = now3 - dump3.id.startTimeMillis;
  const {
    days: days2,
    hours: hours2,
    milliseconds,
    minutes: minutes2,
    seconds: seconds2
  } = parseMs(time3);
  const lifeMsg = (days2 === 0 ? "" : `${days2}d`) + (days2 === 0 && hours2 === 0 ? "" : `${hours2}h`) + (days2 === 0 && hours2 === 0 && minutes2 === 0 ? "" : `${minutes2}m`) + (days2 === 0 && hours2 === 0 && minutes2 === 0 && seconds2 === 0 ? "" : `${seconds2}s`) + `${milliseconds}ms`;
  const waitMsg = isSuspended2(dump3.status) ? (() => {
    const ids3 = ids2(dump3.status.blockingOn);
    return size6(ids3) > 0 ? `waiting on ` + Array.from(ids3).map((id3) => `${id3}`).join(", ") : "";
  })() : "";
  const statusMsg = renderStatus(dump3.status);
  return `[Fiber](#${dump3.id.id}) (${lifeMsg}) ${waitMsg}
   Status: ${statusMsg}`;
}));
var unsafeRoots = () => Array.from(globalScope.roots);
var roots = sync(unsafeRoots);
var status = (self) => self.status;
var succeed5 = (value10) => done5(succeed3(value10));
var void_6 = succeed5(void 0);
var currentFiberURI = "effect/FiberCurrent";
var getCurrentFiber = () => fromNullable2(globalThis[currentFiberURI]);

// ../../node_modules/effect/dist/esm/internal/logger.js
var LoggerSymbolKey = "effect/Logger";
var LoggerTypeId = Symbol.for(LoggerSymbolKey);
var loggerVariance = {
  /* c8 ignore next */
  _Message: (_) => _,
  /* c8 ignore next */
  _Output: (_) => _
};
var makeLogger = (log5) => ({
  [LoggerTypeId]: loggerVariance,
  log: log5,
  pipe() {
    return pipeArguments(this, arguments);
  }
});
var mapInput4 = dual(2, (self, f) => makeLogger((options) => self.log({
  ...options,
  message: f(options.message)
})));
var mapInputOptions = dual(2, (self, f) => makeLogger((options) => self.log(f(options))));
var filterLogLevel = dual(2, (self, f) => makeLogger((options) => f(options.logLevel) ? some3(self.log(options)) : none2()));
var map19 = dual(2, (self, f) => makeLogger((options) => f(self.log(options))));
var none7 = {
  [LoggerTypeId]: loggerVariance,
  log: constVoid,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var simple = (log5) => ({
  [LoggerTypeId]: loggerVariance,
  log: ({
    message
  }) => log5(message),
  pipe() {
    return pipeArguments(this, arguments);
  }
});
var succeed6 = (value10) => {
  return simple(() => value10);
};
var sync4 = (evaluate4) => {
  return simple(evaluate4);
};
var zip8 = dual(2, (self, that) => makeLogger((options) => [self.log(options), that.log(options)]));
var zipLeft4 = dual(2, (self, that) => map19(zip8(self, that), (tuple7) => tuple7[0]));
var zipRight4 = dual(2, (self, that) => map19(zip8(self, that), (tuple7) => tuple7[1]));
var textOnly = /^[^\s"=]*$/;
var format4 = (quoteValue, whitespace) => ({
  annotations: annotations4,
  cause: cause3,
  date: date5,
  fiberId: fiberId5,
  logLevel: logLevel3,
  message,
  spans
}) => {
  const formatValue = (value10) => value10.match(textOnly) ? value10 : quoteValue(value10);
  const format8 = (label, value10) => `${formatLabel(label)}=${formatValue(value10)}`;
  const append6 = (label, value10) => " " + format8(label, value10);
  let out = format8("timestamp", date5.toISOString());
  out += append6("level", logLevel3.label);
  out += append6("fiber", threadName(fiberId5));
  const messages = ensure(message);
  for (let i = 0; i < messages.length; i++) {
    out += append6("message", toStringUnknown(messages[i], whitespace));
  }
  if (!isEmptyType(cause3)) {
    out += append6("cause", pretty(cause3, {
      renderErrorCause: true
    }));
  }
  for (const span4 of spans) {
    out += " " + render3(date5.getTime())(span4);
  }
  for (const [label, value10] of annotations4) {
    out += append6(label, toStringUnknown(value10, whitespace));
  }
  return out;
};
var escapeDoubleQuotes = (s) => `"${s.replace(/\\([\s\S])|(")/g, "\\$1$2")}"`;
var stringLogger = makeLogger(format4(escapeDoubleQuotes));
var logfmtLogger = makeLogger(format4(JSON.stringify, 0));
var structuredLogger = makeLogger(({
  annotations: annotations4,
  cause: cause3,
  date: date5,
  fiberId: fiberId5,
  logLevel: logLevel3,
  message,
  spans
}) => {
  const now3 = date5.getTime();
  const annotationsObj = {};
  const spansObj = {};
  if (size7(annotations4) > 0) {
    for (const [k, v] of annotations4) {
      annotationsObj[k] = structuredMessage(v);
    }
  }
  if (isCons(spans)) {
    for (const span4 of spans) {
      spansObj[span4.label] = now3 - span4.startTime;
    }
  }
  const messageArr = ensure(message);
  return {
    message: messageArr.length === 1 ? structuredMessage(messageArr[0]) : messageArr.map(structuredMessage),
    logLevel: logLevel3.label,
    timestamp: date5.toISOString(),
    cause: isEmpty7(cause3) ? void 0 : pretty(cause3, {
      renderErrorCause: true
    }),
    annotations: annotationsObj,
    spans: spansObj,
    fiberId: threadName(fiberId5)
  };
});
var structuredMessage = (u) => {
  switch (typeof u) {
    case "bigint":
    case "function":
    case "symbol": {
      return String(u);
    }
    default: {
      return toJSON(u);
    }
  }
};
var jsonLogger = map19(structuredLogger, stringifyCircular);
var isLogger = (u) => {
  return typeof u === "object" && u != null && LoggerTypeId in u;
};
var withColor = (text, ...colors2) => {
  let out = "";
  for (let i = 0; i < colors2.length; i++) {
    out += `\x1B[${colors2[i]}m`;
  }
  return out + text + "\x1B[0m";
};
var withColorNoop = (text, ..._colors) => text;
var colors = {
  bold: "1",
  red: "31",
  green: "32",
  yellow: "33",
  blue: "34",
  cyan: "36",
  white: "37",
  gray: "90",
  black: "30",
  bgBrightRed: "101"
};
var logLevelColors = {
  None: [],
  All: [],
  Trace: [colors.gray],
  Debug: [colors.blue],
  Info: [colors.green],
  Warning: [colors.yellow],
  Error: [colors.red],
  Fatal: [colors.bgBrightRed, colors.black]
};
var logLevelStyle = {
  None: "",
  All: "",
  Trace: "color:gray",
  Debug: "color:blue",
  Info: "color:green",
  Warning: "color:orange",
  Error: "color:red",
  Fatal: "background-color:red;color:white"
};
var defaultDateFormat = (date5) => `${date5.getHours().toString().padStart(2, "0")}:${date5.getMinutes().toString().padStart(2, "0")}:${date5.getSeconds().toString().padStart(2, "0")}.${date5.getMilliseconds().toString().padStart(3, "0")}`;
var hasProcessStdout = typeof process === "object" && process !== null && typeof process.stdout === "object" && process.stdout !== null;
var processStdoutIsTTY = hasProcessStdout && process.stdout.isTTY === true;
var hasProcessStdoutOrDeno = hasProcessStdout || "Deno" in globalThis;
var prettyLogger = (options) => {
  const mode_ = options?.mode ?? "auto";
  const mode = mode_ === "auto" ? hasProcessStdoutOrDeno ? "tty" : "browser" : mode_;
  const isBrowser = mode === "browser";
  const showColors = typeof options?.colors === "boolean" ? options.colors : processStdoutIsTTY || isBrowser;
  const formatDate2 = options?.formatDate ?? defaultDateFormat;
  return isBrowser ? prettyLoggerBrowser({
    colors: showColors,
    formatDate: formatDate2
  }) : prettyLoggerTty({
    colors: showColors,
    formatDate: formatDate2,
    stderr: options?.stderr === true
  });
};
var prettyLoggerTty = (options) => {
  const processIsBun = typeof process === "object" && "isBun" in process && process.isBun === true;
  const color = options.colors ? withColor : withColorNoop;
  return makeLogger(({
    annotations: annotations4,
    cause: cause3,
    context: context15,
    date: date5,
    fiberId: fiberId5,
    logLevel: logLevel3,
    message: message_,
    spans
  }) => {
    const services = getOrDefault2(context15, currentServices);
    const console4 = get4(services, consoleTag).unsafe;
    const log5 = options.stderr === true ? console4.error : console4.log;
    const message = ensure(message_);
    let firstLine = color(`[${options.formatDate(date5)}]`, colors.white) + ` ${color(logLevel3.label, ...logLevelColors[logLevel3._tag])} (${threadName(fiberId5)})`;
    if (isCons(spans)) {
      const now3 = date5.getTime();
      const render6 = render3(now3);
      for (const span4 of spans) {
        firstLine += " " + render6(span4);
      }
    }
    firstLine += ":";
    let messageIndex = 0;
    if (message.length > 0) {
      const firstMaybeString = structuredMessage(message[0]);
      if (typeof firstMaybeString === "string") {
        firstLine += " " + color(firstMaybeString, colors.bold, colors.cyan);
        messageIndex++;
      }
    }
    log5(firstLine);
    if (!processIsBun) console4.group();
    if (!isEmpty7(cause3)) {
      log5(pretty(cause3, {
        renderErrorCause: true
      }));
    }
    if (messageIndex < message.length) {
      for (; messageIndex < message.length; messageIndex++) {
        log5(redact(message[messageIndex]));
      }
    }
    if (size7(annotations4) > 0) {
      for (const [key, value10] of annotations4) {
        log5(color(`${key}:`, colors.bold, colors.white), redact(value10));
      }
    }
    if (!processIsBun) console4.groupEnd();
  });
};
var prettyLoggerBrowser = (options) => {
  const color = options.colors ? "%c" : "";
  return makeLogger(({
    annotations: annotations4,
    cause: cause3,
    context: context15,
    date: date5,
    fiberId: fiberId5,
    logLevel: logLevel3,
    message: message_,
    spans
  }) => {
    const services = getOrDefault2(context15, currentServices);
    const console4 = get4(services, consoleTag).unsafe;
    const message = ensure(message_);
    let firstLine = `${color}[${options.formatDate(date5)}]`;
    const firstParams = [];
    if (options.colors) {
      firstParams.push("color:gray");
    }
    firstLine += ` ${color}${logLevel3.label}${color} (${threadName(fiberId5)})`;
    if (options.colors) {
      firstParams.push(logLevelStyle[logLevel3._tag], "");
    }
    if (isCons(spans)) {
      const now3 = date5.getTime();
      const render6 = render3(now3);
      for (const span4 of spans) {
        firstLine += " " + render6(span4);
      }
    }
    firstLine += ":";
    let messageIndex = 0;
    if (message.length > 0) {
      const firstMaybeString = structuredMessage(message[0]);
      if (typeof firstMaybeString === "string") {
        firstLine += ` ${color}${firstMaybeString}`;
        if (options.colors) {
          firstParams.push("color:deepskyblue");
        }
        messageIndex++;
      }
    }
    console4.groupCollapsed(firstLine, ...firstParams);
    if (!isEmpty7(cause3)) {
      console4.error(pretty(cause3, {
        renderErrorCause: true
      }));
    }
    if (messageIndex < message.length) {
      for (; messageIndex < message.length; messageIndex++) {
        console4.log(redact(message[messageIndex]));
      }
    }
    if (size7(annotations4) > 0) {
      for (const [key, value10] of annotations4) {
        const redacted3 = redact(value10);
        if (options.colors) {
          console4.log(`%c${key}:`, "color:gray", redacted3);
        } else {
          console4.log(`${key}:`, redacted3);
        }
      }
    }
    console4.groupEnd();
  });
};
var prettyLoggerDefault = globalValue("effect/Logger/prettyLoggerDefault", () => prettyLogger());

// ../../node_modules/effect/dist/esm/internal/metric/boundaries.js
var MetricBoundariesSymbolKey = "effect/MetricBoundaries";
var MetricBoundariesTypeId = Symbol.for(MetricBoundariesSymbolKey);
var MetricBoundariesImpl = class {
  values;
  [MetricBoundariesTypeId] = MetricBoundariesTypeId;
  constructor(values15) {
    this.values = values15;
    this._hash = pipe(string2(MetricBoundariesSymbolKey), combine2(array2(this.values)));
  }
  _hash;
  [symbol2]() {
    return this._hash;
  }
  [symbol3](u) {
    return isMetricBoundaries(u) && equals(this.values, u.values);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isMetricBoundaries = (u) => hasProperty(u, MetricBoundariesTypeId);
var fromIterable11 = (iterable) => {
  const values15 = pipe(iterable, appendAll2(of3(Number.POSITIVE_INFINITY)), dedupe);
  return new MetricBoundariesImpl(values15);
};
var linear = (options) => pipe(makeBy2(options.count - 1, (i) => options.start + i * options.width), unsafeFromArray, fromIterable11);
var exponential = (options) => pipe(makeBy2(options.count - 1, (i) => options.start * Math.pow(options.factor, i)), unsafeFromArray, fromIterable11);

// ../../node_modules/effect/dist/esm/internal/metric/keyType.js
var MetricKeyTypeSymbolKey = "effect/MetricKeyType";
var MetricKeyTypeTypeId = Symbol.for(MetricKeyTypeSymbolKey);
var CounterKeyTypeSymbolKey = "effect/MetricKeyType/Counter";
var CounterKeyTypeTypeId = Symbol.for(CounterKeyTypeSymbolKey);
var FrequencyKeyTypeSymbolKey = "effect/MetricKeyType/Frequency";
var FrequencyKeyTypeTypeId = Symbol.for(FrequencyKeyTypeSymbolKey);
var GaugeKeyTypeSymbolKey = "effect/MetricKeyType/Gauge";
var GaugeKeyTypeTypeId = Symbol.for(GaugeKeyTypeSymbolKey);
var HistogramKeyTypeSymbolKey = "effect/MetricKeyType/Histogram";
var HistogramKeyTypeTypeId = Symbol.for(HistogramKeyTypeSymbolKey);
var SummaryKeyTypeSymbolKey = "effect/MetricKeyType/Summary";
var SummaryKeyTypeTypeId = Symbol.for(SummaryKeyTypeSymbolKey);
var metricKeyTypeVariance = {
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _Out: (_) => _
};
var CounterKeyType = class {
  incremental;
  bigint;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [CounterKeyTypeTypeId] = CounterKeyTypeTypeId;
  constructor(incremental, bigint4) {
    this.incremental = incremental;
    this.bigint = bigint4;
    this._hash = string2(CounterKeyTypeSymbolKey);
  }
  _hash;
  [symbol2]() {
    return this._hash;
  }
  [symbol3](that) {
    return isCounterKey(that);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var FrequencyKeyTypeHash = string2(FrequencyKeyTypeSymbolKey);
var FrequencyKeyType = class {
  preregisteredWords;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [FrequencyKeyTypeTypeId] = FrequencyKeyTypeTypeId;
  constructor(preregisteredWords) {
    this.preregisteredWords = preregisteredWords;
  }
  [symbol2]() {
    return FrequencyKeyTypeHash;
  }
  [symbol3](that) {
    return isFrequencyKey(that);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var GaugeKeyTypeHash = string2(GaugeKeyTypeSymbolKey);
var GaugeKeyType = class {
  bigint;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [GaugeKeyTypeTypeId] = GaugeKeyTypeTypeId;
  constructor(bigint4) {
    this.bigint = bigint4;
  }
  [symbol2]() {
    return GaugeKeyTypeHash;
  }
  [symbol3](that) {
    return isGaugeKey(that);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var HistogramKeyType = class {
  boundaries;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [HistogramKeyTypeTypeId] = HistogramKeyTypeTypeId;
  constructor(boundaries) {
    this.boundaries = boundaries;
    this._hash = pipe(string2(HistogramKeyTypeSymbolKey), combine2(hash(this.boundaries)));
  }
  _hash;
  [symbol2]() {
    return this._hash;
  }
  [symbol3](that) {
    return isHistogramKey(that) && equals(this.boundaries, that.boundaries);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var SummaryKeyType = class {
  maxAge;
  maxSize;
  error;
  quantiles;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [SummaryKeyTypeTypeId] = SummaryKeyTypeTypeId;
  constructor(maxAge, maxSize, error4, quantiles) {
    this.maxAge = maxAge;
    this.maxSize = maxSize;
    this.error = error4;
    this.quantiles = quantiles;
    this._hash = pipe(string2(SummaryKeyTypeSymbolKey), combine2(hash(this.maxAge)), combine2(hash(this.maxSize)), combine2(hash(this.error)), combine2(array2(this.quantiles)));
  }
  _hash;
  [symbol2]() {
    return this._hash;
  }
  [symbol3](that) {
    return isSummaryKey(that) && equals(this.maxAge, that.maxAge) && this.maxSize === that.maxSize && this.error === that.error && equals(this.quantiles, that.quantiles);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var counter2 = (options) => new CounterKeyType(options?.incremental ?? false, options?.bigint ?? false);
var frequency = (options) => new FrequencyKeyType(options?.preregisteredWords ?? []);
var gauge = (options) => new GaugeKeyType(options?.bigint ?? false);
var histogram = (boundaries) => {
  return new HistogramKeyType(boundaries);
};
var summary = (options) => {
  return new SummaryKeyType(decode(options.maxAge), options.maxSize, options.error, options.quantiles);
};
var isMetricKeyType = (u) => hasProperty(u, MetricKeyTypeTypeId);
var isCounterKey = (u) => hasProperty(u, CounterKeyTypeTypeId);
var isFrequencyKey = (u) => hasProperty(u, FrequencyKeyTypeTypeId);
var isGaugeKey = (u) => hasProperty(u, GaugeKeyTypeTypeId);
var isHistogramKey = (u) => hasProperty(u, HistogramKeyTypeTypeId);
var isSummaryKey = (u) => hasProperty(u, SummaryKeyTypeTypeId);

// ../../node_modules/effect/dist/esm/internal/metric/key.js
var MetricKeySymbolKey = "effect/MetricKey";
var MetricKeyTypeId = Symbol.for(MetricKeySymbolKey);
var metricKeyVariance = {
  /* c8 ignore next */
  _Type: (_) => _
};
var arrayEquivilence = getEquivalence5(equals);
var MetricKeyImpl = class {
  name;
  keyType;
  description;
  tags;
  [MetricKeyTypeId] = metricKeyVariance;
  constructor(name, keyType, description, tags3 = []) {
    this.name = name;
    this.keyType = keyType;
    this.description = description;
    this.tags = tags3;
    this._hash = pipe(string2(this.name + this.description), combine2(hash(this.keyType)), combine2(array2(this.tags)));
  }
  _hash;
  [symbol2]() {
    return this._hash;
  }
  [symbol3](u) {
    return isMetricKey(u) && this.name === u.name && equals(this.keyType, u.keyType) && equals(this.description, u.description) && arrayEquivilence(this.tags, u.tags);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isMetricKey = (u) => hasProperty(u, MetricKeyTypeId);
var counter3 = (name, options) => new MetricKeyImpl(name, counter2(options), fromNullable2(options?.description));
var frequency2 = (name, options) => new MetricKeyImpl(name, frequency(options), fromNullable2(options?.description));
var gauge2 = (name, options) => new MetricKeyImpl(name, gauge(options), fromNullable2(options?.description));
var histogram2 = (name, boundaries, description) => new MetricKeyImpl(name, histogram(boundaries), fromNullable2(description));
var summary2 = (options) => new MetricKeyImpl(options.name, summary(options), fromNullable2(options.description));
var tagged = dual(3, (self, key, value10) => taggedWithLabels(self, [make39(key, value10)]));
var taggedWithLabels = dual(2, (self, extraTags) => extraTags.length === 0 ? self : new MetricKeyImpl(self.name, self.keyType, self.description, union2(self.tags, extraTags)));

// ../../node_modules/effect/dist/esm/internal/metric/state.js
var MetricStateSymbolKey = "effect/MetricState";
var MetricStateTypeId = Symbol.for(MetricStateSymbolKey);
var CounterStateSymbolKey = "effect/MetricState/Counter";
var CounterStateTypeId = Symbol.for(CounterStateSymbolKey);
var FrequencyStateSymbolKey = "effect/MetricState/Frequency";
var FrequencyStateTypeId = Symbol.for(FrequencyStateSymbolKey);
var GaugeStateSymbolKey = "effect/MetricState/Gauge";
var GaugeStateTypeId = Symbol.for(GaugeStateSymbolKey);
var HistogramStateSymbolKey = "effect/MetricState/Histogram";
var HistogramStateTypeId = Symbol.for(HistogramStateSymbolKey);
var SummaryStateSymbolKey = "effect/MetricState/Summary";
var SummaryStateTypeId = Symbol.for(SummaryStateSymbolKey);
var metricStateVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var CounterState = class {
  count;
  [MetricStateTypeId] = metricStateVariance;
  [CounterStateTypeId] = CounterStateTypeId;
  constructor(count9) {
    this.count = count9;
  }
  [symbol2]() {
    return pipe(hash(CounterStateSymbolKey), combine2(hash(this.count)), cached(this));
  }
  [symbol3](that) {
    return isCounterState(that) && this.count === that.count;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var arrayEquals = getEquivalence5(equals);
var FrequencyState = class {
  occurrences;
  [MetricStateTypeId] = metricStateVariance;
  [FrequencyStateTypeId] = FrequencyStateTypeId;
  constructor(occurrences) {
    this.occurrences = occurrences;
  }
  _hash;
  [symbol2]() {
    return pipe(string2(FrequencyStateSymbolKey), combine2(array2(fromIterable2(this.occurrences.entries()))), cached(this));
  }
  [symbol3](that) {
    return isFrequencyState(that) && arrayEquals(fromIterable2(this.occurrences.entries()), fromIterable2(that.occurrences.entries()));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var GaugeState = class {
  value;
  [MetricStateTypeId] = metricStateVariance;
  [GaugeStateTypeId] = GaugeStateTypeId;
  constructor(value10) {
    this.value = value10;
  }
  [symbol2]() {
    return pipe(hash(GaugeStateSymbolKey), combine2(hash(this.value)), cached(this));
  }
  [symbol3](u) {
    return isGaugeState(u) && this.value === u.value;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var HistogramState = class {
  buckets;
  count;
  min;
  max;
  sum;
  [MetricStateTypeId] = metricStateVariance;
  [HistogramStateTypeId] = HistogramStateTypeId;
  constructor(buckets, count9, min11, max13, sum7) {
    this.buckets = buckets;
    this.count = count9;
    this.min = min11;
    this.max = max13;
    this.sum = sum7;
  }
  [symbol2]() {
    return pipe(hash(HistogramStateSymbolKey), combine2(hash(this.buckets)), combine2(hash(this.count)), combine2(hash(this.min)), combine2(hash(this.max)), combine2(hash(this.sum)), cached(this));
  }
  [symbol3](that) {
    return isHistogramState(that) && equals(this.buckets, that.buckets) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var SummaryState = class {
  error;
  quantiles;
  count;
  min;
  max;
  sum;
  [MetricStateTypeId] = metricStateVariance;
  [SummaryStateTypeId] = SummaryStateTypeId;
  constructor(error4, quantiles, count9, min11, max13, sum7) {
    this.error = error4;
    this.quantiles = quantiles;
    this.count = count9;
    this.min = min11;
    this.max = max13;
    this.sum = sum7;
  }
  [symbol2]() {
    return pipe(hash(SummaryStateSymbolKey), combine2(hash(this.error)), combine2(hash(this.quantiles)), combine2(hash(this.count)), combine2(hash(this.min)), combine2(hash(this.max)), combine2(hash(this.sum)), cached(this));
  }
  [symbol3](that) {
    return isSummaryState(that) && this.error === that.error && equals(this.quantiles, that.quantiles) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var counter4 = (count9) => new CounterState(count9);
var frequency3 = (occurrences) => {
  return new FrequencyState(occurrences);
};
var gauge3 = (count9) => new GaugeState(count9);
var histogram3 = (options) => new HistogramState(options.buckets, options.count, options.min, options.max, options.sum);
var summary3 = (options) => new SummaryState(options.error, options.quantiles, options.count, options.min, options.max, options.sum);
var isMetricState = (u) => hasProperty(u, MetricStateTypeId);
var isCounterState = (u) => hasProperty(u, CounterStateTypeId);
var isFrequencyState = (u) => hasProperty(u, FrequencyStateTypeId);
var isGaugeState = (u) => hasProperty(u, GaugeStateTypeId);
var isHistogramState = (u) => hasProperty(u, HistogramStateTypeId);
var isSummaryState = (u) => hasProperty(u, SummaryStateTypeId);

// ../../node_modules/effect/dist/esm/internal/metric/hook.js
var MetricHookSymbolKey = "effect/MetricHook";
var MetricHookTypeId = Symbol.for(MetricHookSymbolKey);
var metricHookVariance = {
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _Out: (_) => _
};
var make41 = (options) => ({
  [MetricHookTypeId]: metricHookVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  ...options
});
var onModify = dual(2, (self, f) => ({
  [MetricHookTypeId]: metricHookVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  get: self.get,
  update: self.update,
  modify: (input) => {
    self.modify(input);
    return f(input);
  }
}));
var onUpdate = dual(2, (self, f) => ({
  [MetricHookTypeId]: metricHookVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  get: self.get,
  update: (input) => {
    self.update(input);
    return f(input);
  },
  modify: self.modify
}));
var bigint05 = BigInt(0);
var counter5 = (key) => {
  let sum7 = key.keyType.bigint ? bigint05 : 0;
  const canUpdate = key.keyType.incremental ? key.keyType.bigint ? (value10) => value10 >= bigint05 : (value10) => value10 >= 0 : (_value) => true;
  const update18 = (value10) => {
    if (canUpdate(value10)) {
      sum7 = sum7 + value10;
    }
  };
  return make41({
    get: () => counter4(sum7),
    update: update18,
    modify: update18
  });
};
var frequency4 = (key) => {
  const values15 = /* @__PURE__ */ new Map();
  for (const word of key.keyType.preregisteredWords) {
    values15.set(word, 0);
  }
  const update18 = (word) => {
    const slotCount = values15.get(word) ?? 0;
    values15.set(word, slotCount + 1);
  };
  return make41({
    get: () => frequency3(values15),
    update: update18,
    modify: update18
  });
};
var gauge4 = (_key, startAt) => {
  let value10 = startAt;
  return make41({
    get: () => gauge3(value10),
    update: (v) => {
      value10 = v;
    },
    modify: (v) => {
      value10 = value10 + v;
    }
  });
};
var histogram4 = (key) => {
  const bounds = key.keyType.boundaries.values;
  const size40 = bounds.length;
  const values15 = new Uint32Array(size40 + 1);
  const boundaries = new Float32Array(size40);
  let count9 = 0;
  let sum7 = 0;
  let min11 = Number.MAX_VALUE;
  let max13 = Number.MIN_VALUE;
  pipe(bounds, sort(Order), map6((n, i) => {
    boundaries[i] = n;
  }));
  const update18 = (value10) => {
    let from = 0;
    let to = size40;
    while (from !== to) {
      const mid = Math.floor(from + (to - from) / 2);
      const boundary = boundaries[mid];
      if (value10 <= boundary) {
        to = mid;
      } else {
        from = mid;
      }
      if (to === from + 1) {
        if (value10 <= boundaries[from]) {
          to = from;
        } else {
          from = to;
        }
      }
    }
    values15[from] = values15[from] + 1;
    count9 = count9 + 1;
    sum7 = sum7 + value10;
    if (value10 < min11) {
      min11 = value10;
    }
    if (value10 > max13) {
      max13 = value10;
    }
  };
  const getBuckets = () => {
    const builder = allocate(size40);
    let cumulated = 0;
    for (let i = 0; i < size40; i++) {
      const boundary = boundaries[i];
      const value10 = values15[i];
      cumulated = cumulated + value10;
      builder[i] = [boundary, cumulated];
    }
    return builder;
  };
  return make41({
    get: () => histogram3({
      buckets: getBuckets(),
      count: count9,
      min: min11,
      max: max13,
      sum: sum7
    }),
    update: update18,
    modify: update18
  });
};
var summary4 = (key) => {
  const {
    error: error4,
    maxAge,
    maxSize,
    quantiles
  } = key.keyType;
  const sortedQuantiles = pipe(quantiles, sort(Order));
  const values15 = allocate(maxSize);
  let head13 = 0;
  let count9 = 0;
  let sum7 = 0;
  let min11 = 0;
  let max13 = 0;
  const snapshot3 = (now3) => {
    const builder = [];
    let i = 0;
    while (i !== maxSize - 1) {
      const item = values15[i];
      if (item != null) {
        const [t, v] = item;
        const age = millis(now3 - t);
        if (greaterThanOrEqualTo5(age, zero2) && lessThanOrEqualTo5(age, maxAge)) {
          builder.push(v);
        }
      }
      i = i + 1;
    }
    return calculateQuantiles(error4, sortedQuantiles, sort(builder, Order));
  };
  const observe = (value10, timestamp) => {
    if (maxSize > 0) {
      head13 = head13 + 1;
      const target = head13 % maxSize;
      values15[target] = [timestamp, value10];
    }
    min11 = count9 === 0 ? value10 : Math.min(min11, value10);
    max13 = count9 === 0 ? value10 : Math.max(max13, value10);
    count9 = count9 + 1;
    sum7 = sum7 + value10;
  };
  return make41({
    get: () => summary3({
      error: error4,
      quantiles: snapshot3(Date.now()),
      count: count9,
      min: min11,
      max: max13,
      sum: sum7
    }),
    update: ([value10, timestamp]) => observe(value10, timestamp),
    modify: ([value10, timestamp]) => observe(value10, timestamp)
  });
};
var calculateQuantiles = (error4, sortedQuantiles, sortedSamples) => {
  const sampleCount = sortedSamples.length;
  if (!isNonEmptyReadonlyArray(sortedQuantiles)) {
    return empty4();
  }
  const head13 = sortedQuantiles[0];
  const tail5 = sortedQuantiles.slice(1);
  const resolvedHead = resolveQuantile(error4, sampleCount, none2(), 0, head13, sortedSamples);
  const resolved = of2(resolvedHead);
  tail5.forEach((quantile) => {
    resolved.push(resolveQuantile(error4, sampleCount, resolvedHead.value, resolvedHead.consumed, quantile, resolvedHead.rest));
  });
  return map6(resolved, (rq) => [rq.quantile, rq.value]);
};
var resolveQuantile = (error4, sampleCount, current2, consumed, quantile, rest) => {
  let error_1 = error4;
  let sampleCount_1 = sampleCount;
  let current_1 = current2;
  let consumed_1 = consumed;
  let quantile_1 = quantile;
  let rest_1 = rest;
  let error_2 = error4;
  let sampleCount_2 = sampleCount;
  let current_2 = current2;
  let consumed_2 = consumed;
  let quantile_2 = quantile;
  let rest_2 = rest;
  while (1) {
    if (!isNonEmptyReadonlyArray(rest_1)) {
      return {
        quantile: quantile_1,
        value: none2(),
        consumed: consumed_1,
        rest: []
      };
    }
    if (quantile_1 === 1) {
      return {
        quantile: quantile_1,
        value: some3(lastNonEmpty(rest_1)),
        consumed: consumed_1 + rest_1.length,
        rest: []
      };
    }
    const headValue = headNonEmpty(rest_1);
    const sameHead = span(rest_1, (n) => n === headValue);
    const desired = quantile_1 * sampleCount_1;
    const allowedError = error_1 / 2 * desired;
    const candConsumed = consumed_1 + sameHead[0].length;
    const candError = Math.abs(candConsumed - desired);
    if (candConsumed < desired - allowedError) {
      error_2 = error_1;
      sampleCount_2 = sampleCount_1;
      current_2 = head2(rest_1);
      consumed_2 = candConsumed;
      quantile_2 = quantile_1;
      rest_2 = sameHead[1];
      error_1 = error_2;
      sampleCount_1 = sampleCount_2;
      current_1 = current_2;
      consumed_1 = consumed_2;
      quantile_1 = quantile_2;
      rest_1 = rest_2;
      continue;
    }
    if (candConsumed > desired + allowedError) {
      const valueToReturn = isNone2(current_1) ? some3(headValue) : current_1;
      return {
        quantile: quantile_1,
        value: valueToReturn,
        consumed: consumed_1,
        rest: rest_1
      };
    }
    switch (current_1._tag) {
      case "None": {
        error_2 = error_1;
        sampleCount_2 = sampleCount_1;
        current_2 = head2(rest_1);
        consumed_2 = candConsumed;
        quantile_2 = quantile_1;
        rest_2 = sameHead[1];
        error_1 = error_2;
        sampleCount_1 = sampleCount_2;
        current_1 = current_2;
        consumed_1 = consumed_2;
        quantile_1 = quantile_2;
        rest_1 = rest_2;
        continue;
      }
      case "Some": {
        const prevError = Math.abs(desired - current_1.value);
        if (candError < prevError) {
          error_2 = error_1;
          sampleCount_2 = sampleCount_1;
          current_2 = head2(rest_1);
          consumed_2 = candConsumed;
          quantile_2 = quantile_1;
          rest_2 = sameHead[1];
          error_1 = error_2;
          sampleCount_1 = sampleCount_2;
          current_1 = current_2;
          consumed_1 = consumed_2;
          quantile_1 = quantile_2;
          rest_1 = rest_2;
          continue;
        }
        return {
          quantile: quantile_1,
          value: some3(current_1.value),
          consumed: consumed_1,
          rest: rest_1
        };
      }
    }
  }
  throw new Error("BUG: MetricHook.resolveQuantiles - please report an issue at https://github.com/Effect-TS/effect/issues");
};

// ../../node_modules/effect/dist/esm/internal/metric/pair.js
var MetricPairSymbolKey = "effect/MetricPair";
var MetricPairTypeId = Symbol.for(MetricPairSymbolKey);
var metricPairVariance = {
  /* c8 ignore next */
  _Type: (_) => _
};
var make42 = (metricKey, metricState) => {
  return {
    [MetricPairTypeId]: metricPairVariance,
    metricKey,
    metricState,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
};
var unsafeMake10 = (metricKey, metricState) => {
  return {
    [MetricPairTypeId]: metricPairVariance,
    metricKey,
    metricState,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
};

// ../../node_modules/effect/dist/esm/internal/metric/registry.js
var MetricRegistrySymbolKey = "effect/MetricRegistry";
var MetricRegistryTypeId = Symbol.for(MetricRegistrySymbolKey);
var MetricRegistryImpl = class {
  [MetricRegistryTypeId] = MetricRegistryTypeId;
  map = empty23();
  snapshot() {
    const result = [];
    for (const [key, hook] of this.map) {
      result.push(unsafeMake10(key, hook.get()));
    }
    return result;
  }
  get(key) {
    const hook = pipe(this.map, get9(key), getOrUndefined2);
    if (hook == null) {
      if (isCounterKey(key.keyType)) {
        return this.getCounter(key);
      }
      if (isGaugeKey(key.keyType)) {
        return this.getGauge(key);
      }
      if (isFrequencyKey(key.keyType)) {
        return this.getFrequency(key);
      }
      if (isHistogramKey(key.keyType)) {
        return this.getHistogram(key);
      }
      if (isSummaryKey(key.keyType)) {
        return this.getSummary(key);
      }
      throw new Error("BUG: MetricRegistry.get - unknown MetricKeyType - please report an issue at https://github.com/Effect-TS/effect/issues");
    } else {
      return hook;
    }
  }
  getCounter(key) {
    let value10 = pipe(this.map, get9(key), getOrUndefined2);
    if (value10 == null) {
      const counter12 = counter5(key);
      if (!pipe(this.map, has6(key))) {
        pipe(this.map, set5(key, counter12));
      }
      value10 = counter12;
    }
    return value10;
  }
  getFrequency(key) {
    let value10 = pipe(this.map, get9(key), getOrUndefined2);
    if (value10 == null) {
      const frequency11 = frequency4(key);
      if (!pipe(this.map, has6(key))) {
        pipe(this.map, set5(key, frequency11));
      }
      value10 = frequency11;
    }
    return value10;
  }
  getGauge(key) {
    let value10 = pipe(this.map, get9(key), getOrUndefined2);
    if (value10 == null) {
      const gauge11 = gauge4(key, key.keyType.bigint ? BigInt(0) : 0);
      if (!pipe(this.map, has6(key))) {
        pipe(this.map, set5(key, gauge11));
      }
      value10 = gauge11;
    }
    return value10;
  }
  getHistogram(key) {
    let value10 = pipe(this.map, get9(key), getOrUndefined2);
    if (value10 == null) {
      const histogram11 = histogram4(key);
      if (!pipe(this.map, has6(key))) {
        pipe(this.map, set5(key, histogram11));
      }
      value10 = histogram11;
    }
    return value10;
  }
  getSummary(key) {
    let value10 = pipe(this.map, get9(key), getOrUndefined2);
    if (value10 == null) {
      const summary11 = summary4(key);
      if (!pipe(this.map, has6(key))) {
        pipe(this.map, set5(key, summary11));
      }
      value10 = summary11;
    }
    return value10;
  }
};
var make43 = () => {
  return new MetricRegistryImpl();
};

// ../../node_modules/effect/dist/esm/internal/metric.js
var MetricSymbolKey = "effect/Metric";
var MetricTypeId = Symbol.for(MetricSymbolKey);
var metricVariance = {
  /* c8 ignore next */
  _Type: (_) => _,
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _Out: (_) => _
};
var globalMetricRegistry = globalValue(Symbol.for("effect/Metric/globalMetricRegistry"), () => make43());
var make44 = function(keyType, unsafeUpdate, unsafeValue, unsafeModify) {
  const metric = Object.assign((effect4) => tap2(effect4, (a) => update5(metric, a)), {
    [MetricTypeId]: metricVariance,
    keyType,
    unsafeUpdate,
    unsafeValue,
    unsafeModify,
    register() {
      this.unsafeValue([]);
      return this;
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  });
  return metric;
};
var mapInput5 = dual(2, (self, f) => make44(self.keyType, (input, extraTags) => self.unsafeUpdate(f(input), extraTags), self.unsafeValue, (input, extraTags) => self.unsafeModify(f(input), extraTags)));
var counter6 = (name, options) => fromMetricKey(counter3(name, options));
var frequency5 = (name, options) => fromMetricKey(frequency2(name, options));
var withConstantInput = dual(2, (self, input) => mapInput5(self, () => input));
var fromMetricKey = (key) => {
  let untaggedHook;
  const hookCache = /* @__PURE__ */ new WeakMap();
  const hook = (extraTags) => {
    if (extraTags.length === 0) {
      if (untaggedHook !== void 0) {
        return untaggedHook;
      }
      untaggedHook = globalMetricRegistry.get(key);
      return untaggedHook;
    }
    let hook2 = hookCache.get(extraTags);
    if (hook2 !== void 0) {
      return hook2;
    }
    hook2 = globalMetricRegistry.get(taggedWithLabels(key, extraTags));
    hookCache.set(extraTags, hook2);
    return hook2;
  };
  return make44(key.keyType, (input, extraTags) => hook(extraTags).update(input), (extraTags) => hook(extraTags).get(), (input, extraTags) => hook(extraTags).modify(input));
};
var gauge5 = (name, options) => fromMetricKey(gauge2(name, options));
var histogram5 = (name, boundaries, description) => fromMetricKey(histogram2(name, boundaries, description));
var increment4 = (self) => isCounterKey(self.keyType) ? update5(self, self.keyType.bigint ? BigInt(1) : 1) : modify9(self, self.keyType.bigint ? BigInt(1) : 1);
var incrementBy = dual(2, (self, amount) => isCounterKey(self.keyType) ? update5(self, amount) : modify9(self, amount));
var map20 = dual(2, (self, f) => make44(self.keyType, self.unsafeUpdate, (extraTags) => f(self.unsafeValue(extraTags)), self.unsafeModify));
var mapType = dual(2, (self, f) => make44(f(self.keyType), self.unsafeUpdate, self.unsafeValue, self.unsafeModify));
var modify9 = dual(2, (self, input) => fiberRefGetWith(currentMetricLabels, (tags3) => sync(() => self.unsafeModify(input, tags3))));
var set8 = dual(2, (self, value10) => update5(self, value10));
var succeed7 = (out) => make44(void 0, constVoid, () => out, constVoid);
var sync5 = (evaluate4) => make44(void 0, constVoid, evaluate4, constVoid);
var summary5 = (options) => withNow(summaryTimestamp(options));
var summaryTimestamp = (options) => fromMetricKey(summary2(options));
var tagged2 = dual(3, (self, key, value10) => taggedWithLabels2(self, [make39(key, value10)]));
var taggedWithLabelsInput = dual(2, (self, f) => map20(make44(self.keyType, (input, extraTags) => self.unsafeUpdate(input, union2(f(input), extraTags)), self.unsafeValue, (input, extraTags) => self.unsafeModify(input, union2(f(input), extraTags))), constVoid));
var taggedWithLabels2 = dual(2, (self, extraTags) => {
  return make44(self.keyType, (input, extraTags1) => self.unsafeUpdate(input, union2(extraTags, extraTags1)), (extraTags1) => self.unsafeValue(union2(extraTags, extraTags1)), (input, extraTags1) => self.unsafeModify(input, union2(extraTags, extraTags1)));
});
var timer2 = (name, description) => {
  const boundaries = exponential({
    start: 0.5,
    factor: 2,
    count: 35
  });
  const base = pipe(histogram5(name, boundaries, description), tagged2("time_unit", "milliseconds"));
  return mapInput5(base, toMillis);
};
var timerWithBoundaries = (name, boundaries, description) => {
  const base = pipe(histogram5(name, fromIterable11(boundaries), description), tagged2("time_unit", "milliseconds"));
  return mapInput5(base, toMillis);
};
var trackAll = dual(2, (self, input) => (effect4) => matchCauseEffect(effect4, {
  onFailure: (cause3) => zipRight2(update5(self, input), failCause(cause3)),
  onSuccess: (value10) => zipRight2(update5(self, input), succeed(value10))
}));
var trackDefect = dual(2, (self, metric) => trackDefectWith(self, metric, identity));
var trackDefectWith = dual(3, (self, metric, f) => {
  const updater = (defect) => update5(metric, f(defect));
  return tapDefect(self, (cause3) => forEachSequentialDiscard(defects(cause3), updater));
});
var trackDuration = dual(2, (self, metric) => trackDurationWith(self, metric, identity));
var trackDurationWith = dual(3, (self, metric, f) => clockWith2((clock3) => {
  const startTime = clock3.unsafeCurrentTimeNanos();
  return tap2(self, (_) => {
    const endTime = clock3.unsafeCurrentTimeNanos();
    const duration5 = nanos(endTime - startTime);
    return update5(metric, f(duration5));
  });
}));
var trackError = dual(2, (self, metric) => trackErrorWith(self, metric, (a) => a));
var trackErrorWith = dual(3, (self, metric, f) => {
  const updater = (error4) => update5(metric, f(error4));
  return tapError(self, updater);
});
var trackSuccess = dual(2, (self, metric) => trackSuccessWith(self, metric, (a) => a));
var trackSuccessWith = dual(3, (self, metric, f) => {
  const updater = (value10) => update5(metric, f(value10));
  return tap2(self, updater);
});
var update5 = dual(2, (self, input) => fiberRefGetWith(currentMetricLabels, (tags3) => sync(() => self.unsafeUpdate(input, tags3))));
var value = (self) => fiberRefGetWith(currentMetricLabels, (tags3) => sync(() => self.unsafeValue(tags3)));
var withNow = (self) => mapInput5(self, (input) => [input, Date.now()]);
var zip9 = dual(2, (self, that) => make44([self.keyType, that.keyType], (input, extraTags) => {
  const [l, r] = input;
  self.unsafeUpdate(l, extraTags);
  that.unsafeUpdate(r, extraTags);
}, (extraTags) => [self.unsafeValue(extraTags), that.unsafeValue(extraTags)], (input, extraTags) => {
  const [l, r] = input;
  self.unsafeModify(l, extraTags);
  that.unsafeModify(r, extraTags);
}));
var unsafeSnapshot = () => globalMetricRegistry.snapshot();
var snapshot = sync(unsafeSnapshot);

// ../../node_modules/effect/dist/esm/internal/request.js
var RequestSymbolKey = "effect/Request";
var RequestTypeId = Symbol.for(RequestSymbolKey);
var requestVariance = {
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var RequestPrototype = {
  ...StructuralPrototype,
  [RequestTypeId]: requestVariance
};
var isRequest = (u) => hasProperty(u, RequestTypeId);
var of5 = () => (args2) => Object.assign(Object.create(RequestPrototype), args2);
var tagged3 = (tag5) => (args2) => {
  const request2 = Object.assign(Object.create(RequestPrototype), args2);
  request2._tag = tag5;
  return request2;
};
var Class4 = function() {
  function Class9(args2) {
    if (args2) {
      Object.assign(this, args2);
    }
  }
  Class9.prototype = RequestPrototype;
  return Class9;
}();
var TaggedClass = (tag5) => {
  return class TaggedClass extends Class4 {
    _tag = tag5;
  };
};
var complete2 = dual(2, (self, result) => fiberRefGetWith(currentRequestMap, (map49) => sync(() => {
  if (map49.has(self)) {
    const entry = map49.get(self);
    if (!entry.state.completed) {
      entry.state.completed = true;
      deferredUnsafeDone(entry.result, result);
    }
  }
})));
var completeEffect = dual(2, (self, effect4) => matchEffect(effect4, {
  onFailure: (error4) => complete2(self, exitFail(error4)),
  onSuccess: (value10) => complete2(self, exitSucceed(value10))
}));
var fail7 = dual(2, (self, error4) => complete2(self, exitFail(error4)));
var failCause6 = dual(2, (self, cause3) => complete2(self, exitFailCause(cause3)));
var succeed8 = dual(2, (self, value10) => complete2(self, exitSucceed(value10)));
var Listeners = class {
  count = 0;
  observers = /* @__PURE__ */ new Set();
  interrupted = false;
  addObserver(f) {
    this.observers.add(f);
  }
  removeObserver(f) {
    this.observers.delete(f);
  }
  increment() {
    this.count++;
    this.observers.forEach((f) => f(this.count));
  }
  decrement() {
    this.count--;
    this.observers.forEach((f) => f(this.count));
  }
};

// ../../node_modules/effect/dist/esm/SortedSet.js
var SortedSet_exports = {};
__export(SortedSet_exports, {
  add: () => add5,
  difference: () => difference6,
  empty: () => empty32,
  every: () => every12,
  filter: () => filter13,
  flatMap: () => flatMap15,
  forEach: () => forEach14,
  fromIterable: () => fromIterable14,
  getEquivalence: () => getEquivalence8,
  has: () => has9,
  intersection: () => intersection7,
  isSortedSet: () => isSortedSet,
  isSubset: () => isSubset3,
  make: () => make47,
  map: () => map21,
  partition: () => partition7,
  remove: () => remove10,
  size: () => size13,
  some: () => some14,
  toggle: () => toggle4,
  union: () => union8,
  values: () => values9
});

// ../../node_modules/effect/dist/esm/RedBlackTree.js
var RedBlackTree_exports = {};
__export(RedBlackTree_exports, {
  Direction: () => Direction2,
  at: () => at3,
  atReversed: () => atReversed,
  empty: () => empty31,
  findAll: () => findAll2,
  findFirst: () => findFirst10,
  first: () => first2,
  forEach: () => forEach13,
  forEachBetween: () => forEachBetween2,
  forEachGreaterThanEqual: () => forEachGreaterThanEqual2,
  forEachLessThan: () => forEachLessThan2,
  fromIterable: () => fromIterable13,
  getAt: () => getAt2,
  getOrder: () => getOrder5,
  greaterThan: () => greaterThan8,
  greaterThanEqual: () => greaterThanEqual3,
  greaterThanEqualReversed: () => greaterThanEqualReversed,
  greaterThanReversed: () => greaterThanReversed,
  has: () => has8,
  insert: () => insert2,
  isRedBlackTree: () => isRedBlackTree2,
  keys: () => keys6,
  keysReversed: () => keysReversed,
  last: () => last5,
  lessThan: () => lessThan8,
  lessThanEqual: () => lessThanEqual3,
  lessThanEqualReversed: () => lessThanEqualReversed,
  lessThanReversed: () => lessThanReversed,
  make: () => make46,
  reduce: () => reduce14,
  removeFirst: () => removeFirst2,
  reversed: () => reversed2,
  size: () => size12,
  values: () => values8,
  valuesReversed: () => valuesReversed
});

// ../../node_modules/effect/dist/esm/internal/redBlackTree/iterator.js
var Direction = {
  Forward: 0,
  Backward: 1 << 0
};
var RedBlackTreeIterator = class _RedBlackTreeIterator {
  self;
  stack;
  direction;
  count = 0;
  constructor(self, stack, direction) {
    this.self = self;
    this.stack = stack;
    this.direction = direction;
  }
  /**
   * Clones the iterator
   */
  clone() {
    return new _RedBlackTreeIterator(this.self, this.stack.slice(), this.direction);
  }
  /**
   * Reverse the traversal direction
   */
  reversed() {
    return new _RedBlackTreeIterator(this.self, this.stack.slice(), this.direction === Direction.Forward ? Direction.Backward : Direction.Forward);
  }
  /**
   * Iterator next
   */
  next() {
    const entry = this.entry;
    this.count++;
    if (this.direction === Direction.Forward) {
      this.moveNext();
    } else {
      this.movePrev();
    }
    switch (entry._tag) {
      case "None": {
        return {
          done: true,
          value: this.count
        };
      }
      case "Some": {
        return {
          done: false,
          value: entry.value
        };
      }
    }
  }
  /**
   * Returns the key
   */
  get key() {
    if (this.stack.length > 0) {
      return some3(this.stack[this.stack.length - 1].key);
    }
    return none2();
  }
  /**
   * Returns the value
   */
  get value() {
    if (this.stack.length > 0) {
      return some3(this.stack[this.stack.length - 1].value);
    }
    return none2();
  }
  /**
   * Returns the key
   */
  get entry() {
    return map2(last(this.stack), (node) => [node.key, node.value]);
  }
  /**
   * Returns the position of this iterator in the sorted list
   */
  get index() {
    let idx = 0;
    const stack = this.stack;
    if (stack.length === 0) {
      const r = this.self._root;
      if (r != null) {
        return r.count;
      }
      return 0;
    } else if (stack[stack.length - 1].left != null) {
      idx = stack[stack.length - 1].left.count;
    }
    for (let s = stack.length - 2; s >= 0; --s) {
      if (stack[s + 1] === stack[s].right) {
        ++idx;
        if (stack[s].left != null) {
          idx += stack[s].left.count;
        }
      }
    }
    return idx;
  }
  /**
   * Advances iterator to next element in list
   */
  moveNext() {
    const stack = this.stack;
    if (stack.length === 0) {
      return;
    }
    let n = stack[stack.length - 1];
    if (n.right != null) {
      n = n.right;
      while (n != null) {
        stack.push(n);
        n = n.left;
      }
    } else {
      stack.pop();
      while (stack.length > 0 && stack[stack.length - 1].right === n) {
        n = stack[stack.length - 1];
        stack.pop();
      }
    }
  }
  /**
   * Checks if there is a next element
   */
  get hasNext() {
    const stack = this.stack;
    if (stack.length === 0) {
      return false;
    }
    if (stack[stack.length - 1].right != null) {
      return true;
    }
    for (let s = stack.length - 1; s > 0; --s) {
      if (stack[s - 1].left === stack[s]) {
        return true;
      }
    }
    return false;
  }
  /**
   * Advances iterator to previous element in list
   */
  movePrev() {
    const stack = this.stack;
    if (stack.length === 0) {
      return;
    }
    let n = stack[stack.length - 1];
    if (n != null && n.left != null) {
      n = n.left;
      while (n != null) {
        stack.push(n);
        n = n.right;
      }
    } else {
      stack.pop();
      while (stack.length > 0 && stack[stack.length - 1].left === n) {
        n = stack[stack.length - 1];
        stack.pop();
      }
    }
  }
  /**
   * Checks if there is a previous element
   */
  get hasPrev() {
    const stack = this.stack;
    if (stack.length === 0) {
      return false;
    }
    if (stack[stack.length - 1].left != null) {
      return true;
    }
    for (let s = stack.length - 1; s > 0; --s) {
      if (stack[s - 1].right === stack[s]) {
        return true;
      }
    }
    return false;
  }
};

// ../../node_modules/effect/dist/esm/internal/redBlackTree/node.js
var Color = {
  Red: 0,
  Black: 1 << 0
};
var clone2 = ({
  color,
  count: count9,
  key,
  left: left3,
  right: right3,
  value: value10
}) => ({
  color,
  key,
  value: value10,
  left: left3,
  right: right3,
  count: count9
});
function swap3(n, v) {
  n.key = v.key;
  n.value = v.value;
  n.left = v.left;
  n.right = v.right;
  n.color = v.color;
  n.count = v.count;
}
var repaint = ({
  count: count9,
  key,
  left: left3,
  right: right3,
  value: value10
}, color) => ({
  color,
  key,
  value: value10,
  left: left3,
  right: right3,
  count: count9
});
var recount = (node) => {
  node.count = 1 + (node.left?.count ?? 0) + (node.right?.count ?? 0);
};

// ../../node_modules/effect/dist/esm/internal/redBlackTree.js
var RedBlackTreeSymbolKey = "effect/RedBlackTree";
var RedBlackTreeTypeId = Symbol.for(RedBlackTreeSymbolKey);
var redBlackTreeVariance = {
  /* c8 ignore next */
  _Key: (_) => _,
  /* c8 ignore next */
  _Value: (_) => _
};
var RedBlackTreeProto = {
  [RedBlackTreeTypeId]: redBlackTreeVariance,
  [symbol2]() {
    let hash4 = hash(RedBlackTreeSymbolKey);
    for (const item of this) {
      hash4 ^= pipe(hash(item[0]), combine2(hash(item[1])));
    }
    return cached(this, hash4);
  },
  [symbol3](that) {
    if (isRedBlackTree(that)) {
      if ((this._root?.count ?? 0) !== (that._root?.count ?? 0)) {
        return false;
      }
      const entries7 = Array.from(that);
      return Array.from(this).every((itemSelf, i) => {
        const itemThat = entries7[i];
        return equals(itemSelf[0], itemThat[0]) && equals(itemSelf[1], itemThat[1]);
      });
    }
    return false;
  },
  [Symbol.iterator]() {
    const stack = [];
    let n = this._root;
    while (n != null) {
      stack.push(n);
      n = n.left;
    }
    return new RedBlackTreeIterator(this, stack, Direction.Forward);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "RedBlackTree",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl3 = (ord, root) => {
  const tree = Object.create(RedBlackTreeProto);
  tree._ord = ord;
  tree._root = root;
  return tree;
};
var isRedBlackTree = (u) => hasProperty(u, RedBlackTreeTypeId);
var empty30 = (ord) => makeImpl3(ord, void 0);
var fromIterable12 = dual(2, (entries7, ord) => {
  let tree = empty30(ord);
  for (const [key, value10] of entries7) {
    tree = insert(tree, key, value10);
  }
  return tree;
});
var make45 = (ord) => (...entries7) => {
  return fromIterable12(entries7, ord);
};
var atBackwards = dual(2, (self, index) => at2(self, index, Direction.Backward));
var atForwards = dual(2, (self, index) => at2(self, index, Direction.Forward));
var at2 = (self, index, direction) => {
  return {
    [Symbol.iterator]: () => {
      if (index < 0) {
        return new RedBlackTreeIterator(self, [], direction);
      }
      let node = self._root;
      const stack = [];
      while (node !== void 0) {
        stack.push(node);
        if (node.left !== void 0) {
          if (index < node.left.count) {
            node = node.left;
            continue;
          }
          index -= node.left.count;
        }
        if (!index) {
          return new RedBlackTreeIterator(self, stack, direction);
        }
        index -= 1;
        if (node.right !== void 0) {
          if (index >= node.right.count) {
            break;
          }
          node = node.right;
        } else {
          break;
        }
      }
      return new RedBlackTreeIterator(self, [], direction);
    }
  };
};
var findAll = dual(2, (self, key) => {
  const stack = [];
  let node = self._root;
  let result = empty7();
  while (node !== void 0 || stack.length > 0) {
    if (node) {
      stack.push(node);
      node = node.left;
    } else {
      const current2 = stack.pop();
      if (equals(key, current2.key)) {
        result = prepend3(current2.value)(result);
      }
      node = current2.right;
    }
  }
  return result;
});
var findFirst9 = dual(2, (self, key) => {
  const cmp = self._ord;
  let node = self._root;
  while (node !== void 0) {
    const d = cmp(key, node.key);
    if (equals(key, node.key)) {
      return some3(node.value);
    }
    if (d <= 0) {
      node = node.left;
    } else {
      node = node.right;
    }
  }
  return none2();
});
var first = (self) => {
  let node = self._root;
  let current2 = self._root;
  while (node !== void 0) {
    current2 = node;
    node = node.left;
  }
  return current2 ? some3([current2.key, current2.value]) : none2();
};
var getAt = dual(2, (self, index) => {
  if (index < 0) {
    return none2();
  }
  let root = self._root;
  let node = void 0;
  while (root !== void 0) {
    node = root;
    if (root.left) {
      if (index < root.left.count) {
        root = root.left;
        continue;
      }
      index -= root.left.count;
    }
    if (!index) {
      return some3([node.key, node.value]);
    }
    index -= 1;
    if (root.right) {
      if (index >= root.right.count) {
        break;
      }
      root = root.right;
    } else {
      break;
    }
  }
  return none2();
});
var getOrder4 = (tree) => tree._ord;
var has7 = dual(2, (self, key) => isSome2(findFirst9(self, key)));
var insert = dual(3, (self, key, value10) => {
  const cmp = self._ord;
  let n = self._root;
  const n_stack = [];
  const d_stack = [];
  while (n != null) {
    const d = cmp(key, n.key);
    n_stack.push(n);
    d_stack.push(d);
    if (d <= 0) {
      n = n.left;
    } else {
      n = n.right;
    }
  }
  n_stack.push({
    color: Color.Red,
    key,
    value: value10,
    left: void 0,
    right: void 0,
    count: 1
  });
  for (let s = n_stack.length - 2; s >= 0; --s) {
    const n2 = n_stack[s];
    if (d_stack[s] <= 0) {
      n_stack[s] = {
        color: n2.color,
        key: n2.key,
        value: n2.value,
        left: n_stack[s + 1],
        right: n2.right,
        count: n2.count + 1
      };
    } else {
      n_stack[s] = {
        color: n2.color,
        key: n2.key,
        value: n2.value,
        left: n2.left,
        right: n_stack[s + 1],
        count: n2.count + 1
      };
    }
  }
  for (let s = n_stack.length - 1; s > 1; --s) {
    const p = n_stack[s - 1];
    const n3 = n_stack[s];
    if (p.color === Color.Black || n3.color === Color.Black) {
      break;
    }
    const pp = n_stack[s - 2];
    if (pp.left === p) {
      if (p.left === n3) {
        const y = pp.right;
        if (y && y.color === Color.Red) {
          p.color = Color.Black;
          pp.right = repaint(y, Color.Black);
          pp.color = Color.Red;
          s -= 1;
        } else {
          pp.color = Color.Red;
          pp.left = p.right;
          p.color = Color.Black;
          p.right = pp;
          n_stack[s - 2] = p;
          n_stack[s - 1] = n3;
          recount(pp);
          recount(p);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.left === pp) {
              ppp.left = p;
            } else {
              ppp.right = p;
            }
          }
          break;
        }
      } else {
        const y = pp.right;
        if (y && y.color === Color.Red) {
          p.color = Color.Black;
          pp.right = repaint(y, Color.Black);
          pp.color = Color.Red;
          s -= 1;
        } else {
          p.right = n3.left;
          pp.color = Color.Red;
          pp.left = n3.right;
          n3.color = Color.Black;
          n3.left = p;
          n3.right = pp;
          n_stack[s - 2] = n3;
          n_stack[s - 1] = p;
          recount(pp);
          recount(p);
          recount(n3);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.left === pp) {
              ppp.left = n3;
            } else {
              ppp.right = n3;
            }
          }
          break;
        }
      }
    } else {
      if (p.right === n3) {
        const y = pp.left;
        if (y && y.color === Color.Red) {
          p.color = Color.Black;
          pp.left = repaint(y, Color.Black);
          pp.color = Color.Red;
          s -= 1;
        } else {
          pp.color = Color.Red;
          pp.right = p.left;
          p.color = Color.Black;
          p.left = pp;
          n_stack[s - 2] = p;
          n_stack[s - 1] = n3;
          recount(pp);
          recount(p);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.right === pp) {
              ppp.right = p;
            } else {
              ppp.left = p;
            }
          }
          break;
        }
      } else {
        const y = pp.left;
        if (y && y.color === Color.Red) {
          p.color = Color.Black;
          pp.left = repaint(y, Color.Black);
          pp.color = Color.Red;
          s -= 1;
        } else {
          p.left = n3.right;
          pp.color = Color.Red;
          pp.right = n3.left;
          n3.color = Color.Black;
          n3.right = p;
          n3.left = pp;
          n_stack[s - 2] = n3;
          n_stack[s - 1] = p;
          recount(pp);
          recount(p);
          recount(n3);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.right === pp) {
              ppp.right = n3;
            } else {
              ppp.left = n3;
            }
          }
          break;
        }
      }
    }
  }
  n_stack[0].color = Color.Black;
  return makeImpl3(self._ord, n_stack[0]);
});
var keysForward = (self) => keys5(self, Direction.Forward);
var keysBackward = (self) => keys5(self, Direction.Backward);
var keys5 = (self, direction) => {
  const begin = self[Symbol.iterator]();
  let count9 = 0;
  return {
    [Symbol.iterator]: () => keys5(self, direction),
    next: () => {
      count9++;
      const entry = begin.key;
      if (direction === Direction.Forward) {
        begin.moveNext();
      } else {
        begin.movePrev();
      }
      switch (entry._tag) {
        case "None": {
          return {
            done: true,
            value: count9
          };
        }
        case "Some": {
          return {
            done: false,
            value: entry.value
          };
        }
      }
    }
  };
};
var last4 = (self) => {
  let node = self._root;
  let current2 = self._root;
  while (node !== void 0) {
    current2 = node;
    node = node.right;
  }
  return current2 ? some3([current2.key, current2.value]) : none2();
};
var reversed = (self) => {
  return {
    [Symbol.iterator]: () => {
      const stack = [];
      let node = self._root;
      while (node !== void 0) {
        stack.push(node);
        node = node.right;
      }
      return new RedBlackTreeIterator(self, stack, Direction.Backward);
    }
  };
};
var greaterThanBackwards = dual(2, (self, key) => greaterThan7(self, key, Direction.Backward));
var greaterThanForwards = dual(2, (self, key) => greaterThan7(self, key, Direction.Forward));
var greaterThan7 = (self, key, direction) => {
  return {
    [Symbol.iterator]: () => {
      const cmp = self._ord;
      let node = self._root;
      const stack = [];
      let last_ptr = 0;
      while (node !== void 0) {
        const d = cmp(key, node.key);
        stack.push(node);
        if (d < 0) {
          last_ptr = stack.length;
        }
        if (d < 0) {
          node = node.left;
        } else {
          node = node.right;
        }
      }
      stack.length = last_ptr;
      return new RedBlackTreeIterator(self, stack, direction);
    }
  };
};
var greaterThanEqualBackwards = dual(2, (self, key) => greaterThanEqual2(self, key, Direction.Backward));
var greaterThanEqualForwards = dual(2, (self, key) => greaterThanEqual2(self, key, Direction.Forward));
var greaterThanEqual2 = (self, key, direction = Direction.Forward) => {
  return {
    [Symbol.iterator]: () => {
      const cmp = self._ord;
      let node = self._root;
      const stack = [];
      let last_ptr = 0;
      while (node !== void 0) {
        const d = cmp(key, node.key);
        stack.push(node);
        if (d <= 0) {
          last_ptr = stack.length;
        }
        if (d <= 0) {
          node = node.left;
        } else {
          node = node.right;
        }
      }
      stack.length = last_ptr;
      return new RedBlackTreeIterator(self, stack, direction);
    }
  };
};
var lessThanBackwards = dual(2, (self, key) => lessThan7(self, key, Direction.Backward));
var lessThanForwards = dual(2, (self, key) => lessThan7(self, key, Direction.Forward));
var lessThan7 = (self, key, direction) => {
  return {
    [Symbol.iterator]: () => {
      const cmp = self._ord;
      let node = self._root;
      const stack = [];
      let last_ptr = 0;
      while (node !== void 0) {
        const d = cmp(key, node.key);
        stack.push(node);
        if (d > 0) {
          last_ptr = stack.length;
        }
        if (d <= 0) {
          node = node.left;
        } else {
          node = node.right;
        }
      }
      stack.length = last_ptr;
      return new RedBlackTreeIterator(self, stack, direction);
    }
  };
};
var lessThanEqualBackwards = dual(2, (self, key) => lessThanEqual2(self, key, Direction.Backward));
var lessThanEqualForwards = dual(2, (self, key) => lessThanEqual2(self, key, Direction.Forward));
var lessThanEqual2 = (self, key, direction) => {
  return {
    [Symbol.iterator]: () => {
      const cmp = self._ord;
      let node = self._root;
      const stack = [];
      let last_ptr = 0;
      while (node !== void 0) {
        const d = cmp(key, node.key);
        stack.push(node);
        if (d >= 0) {
          last_ptr = stack.length;
        }
        if (d < 0) {
          node = node.left;
        } else {
          node = node.right;
        }
      }
      stack.length = last_ptr;
      return new RedBlackTreeIterator(self, stack, direction);
    }
  };
};
var forEach12 = dual(2, (self, f) => {
  const root = self._root;
  if (root !== void 0) {
    visitFull(root, (key, value10) => {
      f(key, value10);
      return none2();
    });
  }
});
var forEachGreaterThanEqual = dual(3, (self, min11, f) => {
  const root = self._root;
  const ord = self._ord;
  if (root !== void 0) {
    visitGreaterThanEqual(root, min11, ord, (key, value10) => {
      f(key, value10);
      return none2();
    });
  }
});
var forEachLessThan = dual(3, (self, max13, f) => {
  const root = self._root;
  const ord = self._ord;
  if (root !== void 0) {
    visitLessThan(root, max13, ord, (key, value10) => {
      f(key, value10);
      return none2();
    });
  }
});
var forEachBetween = dual(2, (self, {
  body,
  max: max13,
  min: min11
}) => {
  const root = self._root;
  const ord = self._ord;
  if (root) {
    visitBetween(root, min11, max13, ord, (key, value10) => {
      body(key, value10);
      return none2();
    });
  }
});
var reduce13 = dual(3, (self, zero3, f) => {
  let accumulator = zero3;
  for (const entry of self) {
    accumulator = f(accumulator, entry[1], entry[0]);
  }
  return accumulator;
});
var removeFirst = dual(2, (self, key) => {
  if (!has7(self, key)) {
    return self;
  }
  const ord = self._ord;
  const cmp = ord;
  let node = self._root;
  const stack = [];
  while (node !== void 0) {
    const d = cmp(key, node.key);
    stack.push(node);
    if (equals(key, node.key)) {
      node = void 0;
    } else if (d <= 0) {
      node = node.left;
    } else {
      node = node.right;
    }
  }
  if (stack.length === 0) {
    return self;
  }
  const cstack = new Array(stack.length);
  let n = stack[stack.length - 1];
  cstack[cstack.length - 1] = {
    color: n.color,
    key: n.key,
    value: n.value,
    left: n.left,
    right: n.right,
    count: n.count
  };
  for (let i = stack.length - 2; i >= 0; --i) {
    n = stack[i];
    if (n.left === stack[i + 1]) {
      cstack[i] = {
        color: n.color,
        key: n.key,
        value: n.value,
        left: cstack[i + 1],
        right: n.right,
        count: n.count
      };
    } else {
      cstack[i] = {
        color: n.color,
        key: n.key,
        value: n.value,
        left: n.left,
        right: cstack[i + 1],
        count: n.count
      };
    }
  }
  n = cstack[cstack.length - 1];
  if (n.left !== void 0 && n.right !== void 0) {
    const split7 = cstack.length;
    n = n.left;
    while (n.right != null) {
      cstack.push(n);
      n = n.right;
    }
    const v = cstack[split7 - 1];
    cstack.push({
      color: n.color,
      key: v.key,
      value: v.value,
      left: n.left,
      right: n.right,
      count: n.count
    });
    cstack[split7 - 1].key = n.key;
    cstack[split7 - 1].value = n.value;
    for (let i = cstack.length - 2; i >= split7; --i) {
      n = cstack[i];
      cstack[i] = {
        color: n.color,
        key: n.key,
        value: n.value,
        left: n.left,
        right: cstack[i + 1],
        count: n.count
      };
    }
    cstack[split7 - 1].left = cstack[split7];
  }
  n = cstack[cstack.length - 1];
  if (n.color === Color.Red) {
    const p = cstack[cstack.length - 2];
    if (p.left === n) {
      p.left = void 0;
    } else if (p.right === n) {
      p.right = void 0;
    }
    cstack.pop();
    for (let i = 0; i < cstack.length; ++i) {
      cstack[i].count--;
    }
    return makeImpl3(ord, cstack[0]);
  } else {
    if (n.left !== void 0 || n.right !== void 0) {
      if (n.left !== void 0) {
        swap3(n, n.left);
      } else if (n.right !== void 0) {
        swap3(n, n.right);
      }
      n.color = Color.Black;
      for (let i = 0; i < cstack.length - 1; ++i) {
        cstack[i].count--;
      }
      return makeImpl3(ord, cstack[0]);
    } else if (cstack.length === 1) {
      return makeImpl3(ord, void 0);
    } else {
      for (let i = 0; i < cstack.length; ++i) {
        cstack[i].count--;
      }
      const parent = cstack[cstack.length - 2];
      fixDoubleBlack(cstack);
      if (parent.left === n) {
        parent.left = void 0;
      } else {
        parent.right = void 0;
      }
    }
  }
  return makeImpl3(ord, cstack[0]);
});
var size11 = (self) => self._root?.count ?? 0;
var valuesForward = (self) => values7(self, Direction.Forward);
var valuesBackward = (self) => values7(self, Direction.Backward);
var values7 = (self, direction) => {
  const begin = self[Symbol.iterator]();
  let count9 = 0;
  return {
    [Symbol.iterator]: () => values7(self, direction),
    next: () => {
      count9++;
      const entry = begin.value;
      if (direction === Direction.Forward) {
        begin.moveNext();
      } else {
        begin.movePrev();
      }
      switch (entry._tag) {
        case "None": {
          return {
            done: true,
            value: count9
          };
        }
        case "Some": {
          return {
            done: false,
            value: entry.value
          };
        }
      }
    }
  };
};
var visitFull = (node, visit) => {
  let current2 = node;
  let stack = void 0;
  let done17 = false;
  while (!done17) {
    if (current2 != null) {
      stack = make11(current2, stack);
      current2 = current2.left;
    } else if (stack != null) {
      const value10 = visit(stack.value.key, stack.value.value);
      if (isSome2(value10)) {
        return value10;
      }
      current2 = stack.value.right;
      stack = stack.previous;
    } else {
      done17 = true;
    }
  }
  return none2();
};
var visitGreaterThanEqual = (node, min11, ord, visit) => {
  let current2 = node;
  let stack = void 0;
  let done17 = false;
  while (!done17) {
    if (current2 !== void 0) {
      stack = make11(current2, stack);
      if (ord(min11, current2.key) <= 0) {
        current2 = current2.left;
      } else {
        current2 = void 0;
      }
    } else if (stack !== void 0) {
      if (ord(min11, stack.value.key) <= 0) {
        const value10 = visit(stack.value.key, stack.value.value);
        if (isSome2(value10)) {
          return value10;
        }
      }
      current2 = stack.value.right;
      stack = stack.previous;
    } else {
      done17 = true;
    }
  }
  return none2();
};
var visitLessThan = (node, max13, ord, visit) => {
  let current2 = node;
  let stack = void 0;
  let done17 = false;
  while (!done17) {
    if (current2 !== void 0) {
      stack = make11(current2, stack);
      current2 = current2.left;
    } else if (stack !== void 0 && ord(max13, stack.value.key) > 0) {
      const value10 = visit(stack.value.key, stack.value.value);
      if (isSome2(value10)) {
        return value10;
      }
      current2 = stack.value.right;
      stack = stack.previous;
    } else {
      done17 = true;
    }
  }
  return none2();
};
var visitBetween = (node, min11, max13, ord, visit) => {
  let current2 = node;
  let stack = void 0;
  let done17 = false;
  while (!done17) {
    if (current2 !== void 0) {
      stack = make11(current2, stack);
      if (ord(min11, current2.key) <= 0) {
        current2 = current2.left;
      } else {
        current2 = void 0;
      }
    } else if (stack !== void 0 && ord(max13, stack.value.key) > 0) {
      if (ord(min11, stack.value.key) <= 0) {
        const value10 = visit(stack.value.key, stack.value.value);
        if (isSome2(value10)) {
          return value10;
        }
      }
      current2 = stack.value.right;
      stack = stack.previous;
    } else {
      done17 = true;
    }
  }
  return none2();
};
var fixDoubleBlack = (stack) => {
  let n, p, s, z;
  for (let i = stack.length - 1; i >= 0; --i) {
    n = stack[i];
    if (i === 0) {
      n.color = Color.Black;
      return;
    }
    p = stack[i - 1];
    if (p.left === n) {
      s = p.right;
      if (s !== void 0 && s.right !== void 0 && s.right.color === Color.Red) {
        s = p.right = clone2(s);
        z = s.right = clone2(s.right);
        p.right = s.left;
        s.left = p;
        s.right = z;
        s.color = p.color;
        n.color = Color.Black;
        p.color = Color.Black;
        z.color = Color.Black;
        recount(p);
        recount(s);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.left === p) {
            pp.left = s;
          } else {
            pp.right = s;
          }
        }
        stack[i - 1] = s;
        return;
      } else if (s !== void 0 && s.left !== void 0 && s.left.color === Color.Red) {
        s = p.right = clone2(s);
        z = s.left = clone2(s.left);
        p.right = z.left;
        s.left = z.right;
        z.left = p;
        z.right = s;
        z.color = p.color;
        p.color = Color.Black;
        s.color = Color.Black;
        n.color = Color.Black;
        recount(p);
        recount(s);
        recount(z);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.left === p) {
            pp.left = z;
          } else {
            pp.right = z;
          }
        }
        stack[i - 1] = z;
        return;
      }
      if (s !== void 0 && s.color === Color.Black) {
        if (p.color === Color.Red) {
          p.color = Color.Black;
          p.right = repaint(s, Color.Red);
          return;
        } else {
          p.right = repaint(s, Color.Red);
          continue;
        }
      } else if (s !== void 0) {
        s = clone2(s);
        p.right = s.left;
        s.left = p;
        s.color = p.color;
        p.color = Color.Red;
        recount(p);
        recount(s);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.left === p) {
            pp.left = s;
          } else {
            pp.right = s;
          }
        }
        stack[i - 1] = s;
        stack[i] = p;
        if (i + 1 < stack.length) {
          stack[i + 1] = n;
        } else {
          stack.push(n);
        }
        i = i + 2;
      }
    } else {
      s = p.left;
      if (s !== void 0 && s.left !== void 0 && s.left.color === Color.Red) {
        s = p.left = clone2(s);
        z = s.left = clone2(s.left);
        p.left = s.right;
        s.right = p;
        s.left = z;
        s.color = p.color;
        n.color = Color.Black;
        p.color = Color.Black;
        z.color = Color.Black;
        recount(p);
        recount(s);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.right === p) {
            pp.right = s;
          } else {
            pp.left = s;
          }
        }
        stack[i - 1] = s;
        return;
      } else if (s !== void 0 && s.right !== void 0 && s.right.color === Color.Red) {
        s = p.left = clone2(s);
        z = s.right = clone2(s.right);
        p.left = z.right;
        s.right = z.left;
        z.right = p;
        z.left = s;
        z.color = p.color;
        p.color = Color.Black;
        s.color = Color.Black;
        n.color = Color.Black;
        recount(p);
        recount(s);
        recount(z);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.right === p) {
            pp.right = z;
          } else {
            pp.left = z;
          }
        }
        stack[i - 1] = z;
        return;
      }
      if (s !== void 0 && s.color === Color.Black) {
        if (p.color === Color.Red) {
          p.color = Color.Black;
          p.left = repaint(s, Color.Red);
          return;
        } else {
          p.left = repaint(s, Color.Red);
          continue;
        }
      } else if (s !== void 0) {
        s = clone2(s);
        p.left = s.right;
        s.right = p;
        s.color = p.color;
        p.color = Color.Red;
        recount(p);
        recount(s);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.right === p) {
            pp.right = s;
          } else {
            pp.left = s;
          }
        }
        stack[i - 1] = s;
        stack[i] = p;
        if (i + 1 < stack.length) {
          stack[i + 1] = n;
        } else {
          stack.push(n);
        }
        i = i + 2;
      }
    }
  }
};

// ../../node_modules/effect/dist/esm/RedBlackTree.js
var Direction2 = Direction;
var isRedBlackTree2 = isRedBlackTree;
var empty31 = empty30;
var fromIterable13 = fromIterable12;
var make46 = make45;
var at3 = atForwards;
var atReversed = atBackwards;
var findAll2 = findAll;
var findFirst10 = findFirst9;
var first2 = first;
var getAt2 = getAt;
var getOrder5 = getOrder4;
var greaterThan8 = greaterThanForwards;
var greaterThanReversed = greaterThanBackwards;
var greaterThanEqual3 = greaterThanEqualForwards;
var greaterThanEqualReversed = greaterThanEqualBackwards;
var has8 = has7;
var insert2 = insert;
var keys6 = keysForward;
var keysReversed = keysBackward;
var last5 = last4;
var lessThan8 = lessThanForwards;
var lessThanReversed = lessThanBackwards;
var lessThanEqual3 = lessThanEqualForwards;
var lessThanEqualReversed = lessThanEqualBackwards;
var forEach13 = forEach12;
var forEachGreaterThanEqual2 = forEachGreaterThanEqual;
var forEachLessThan2 = forEachLessThan;
var forEachBetween2 = forEachBetween;
var reduce14 = reduce13;
var removeFirst2 = removeFirst;
var reversed2 = reversed;
var size12 = size11;
var values8 = valuesForward;
var valuesReversed = valuesBackward;

// ../../node_modules/effect/dist/esm/SortedSet.js
var TypeId17 = Symbol.for("effect/SortedSet");
var SortedSetProto = {
  [TypeId17]: {
    _A: (_) => _
  },
  [symbol2]() {
    return pipe(hash(this.keyTree), combine2(hash(TypeId17)), cached(this));
  },
  [symbol3](that) {
    return isSortedSet(that) && equals(this.keyTree, that.keyTree);
  },
  [Symbol.iterator]() {
    return keys6(this.keyTree);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "SortedSet",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var fromTree = (keyTree) => {
  const a = Object.create(SortedSetProto);
  a.keyTree = keyTree;
  return a;
};
var isSortedSet = (u) => hasProperty(u, TypeId17);
var empty32 = (O) => fromTree(empty31(O));
var fromIterable14 = dual(2, (iterable, ord) => fromTree(fromIterable13(Array.from(iterable).map((k) => [k, true]), ord)));
var make47 = (ord) => (...entries7) => fromIterable14(entries7, ord);
var add5 = dual(2, (self, value10) => has8(self.keyTree, value10) ? self : fromTree(insert2(self.keyTree, value10, true)));
var difference6 = dual(2, (self, that) => {
  let out = self;
  for (const value10 of that) {
    out = remove10(out, value10);
  }
  return out;
});
var every12 = dual(2, (self, predicate) => {
  for (const value10 of self) {
    if (!predicate(value10)) {
      return false;
    }
  }
  return true;
});
var filter13 = dual(2, (self, predicate) => {
  const ord = getOrder5(self.keyTree);
  let out = empty32(ord);
  for (const value10 of self) {
    if (predicate(value10)) {
      out = add5(out, value10);
    }
  }
  return out;
});
var flatMap15 = dual(3, (self, O, f) => {
  let out = empty32(O);
  forEach14(self, (a) => {
    for (const b of f(a)) {
      out = add5(out, b);
    }
  });
  return out;
});
var forEach14 = dual(2, (self, f) => forEach13(self.keyTree, f));
var has9 = dual(2, (self, value10) => has8(self.keyTree, value10));
var intersection7 = dual(2, (self, that) => {
  const ord = getOrder5(self.keyTree);
  let out = empty32(ord);
  for (const value10 of that) {
    if (has9(self, value10)) {
      out = add5(out, value10);
    }
  }
  return out;
});
var isSubset3 = dual(2, (self, that) => every12(self, (a) => has9(that, a)));
var map21 = dual(3, (self, O, f) => {
  let out = empty32(O);
  forEach14(self, (a) => {
    const b = f(a);
    if (!has9(out, b)) {
      out = add5(out, b);
    }
  });
  return out;
});
var partition7 = dual(2, (self, predicate) => {
  const ord = getOrder5(self.keyTree);
  let right3 = empty32(ord);
  let left3 = empty32(ord);
  for (const value10 of self) {
    if (predicate(value10)) {
      right3 = add5(right3, value10);
    } else {
      left3 = add5(left3, value10);
    }
  }
  return [left3, right3];
});
var remove10 = dual(2, (self, value10) => fromTree(removeFirst2(self.keyTree, value10)));
var size13 = (self) => size12(self.keyTree);
var some14 = dual(2, (self, predicate) => {
  for (const value10 of self) {
    if (predicate(value10)) {
      return true;
    }
  }
  return false;
});
var toggle4 = dual(2, (self, value10) => has9(self, value10) ? remove10(self, value10) : add5(self, value10));
var union8 = dual(2, (self, that) => {
  const ord = getOrder5(self.keyTree);
  let out = empty32(ord);
  for (const value10 of self) {
    out = add5(value10)(out);
  }
  for (const value10 of that) {
    out = add5(value10)(out);
  }
  return out;
});
var values9 = (self) => keys6(self.keyTree);
var getEquivalence8 = () => (a, b) => isSubset3(a, b) && isSubset3(b, a);

// ../../node_modules/effect/dist/esm/internal/supervisor.js
var SupervisorSymbolKey = "effect/Supervisor";
var SupervisorTypeId = Symbol.for(SupervisorSymbolKey);
var supervisorVariance = {
  /* c8 ignore next */
  _T: (_) => _
};
var ProxySupervisor = class _ProxySupervisor {
  underlying;
  value0;
  [SupervisorTypeId] = supervisorVariance;
  constructor(underlying, value0) {
    this.underlying = underlying;
    this.value0 = value0;
  }
  get value() {
    return this.value0;
  }
  onStart(context15, effect4, parent, fiber) {
    this.underlying.onStart(context15, effect4, parent, fiber);
  }
  onEnd(value10, fiber) {
    this.underlying.onEnd(value10, fiber);
  }
  onEffect(fiber, effect4) {
    this.underlying.onEffect(fiber, effect4);
  }
  onSuspend(fiber) {
    this.underlying.onSuspend(fiber);
  }
  onResume(fiber) {
    this.underlying.onResume(fiber);
  }
  map(f) {
    return new _ProxySupervisor(this, pipe(this.value, map14(f)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
};
var Zip = class _Zip {
  left;
  right;
  _tag = "Zip";
  [SupervisorTypeId] = supervisorVariance;
  constructor(left3, right3) {
    this.left = left3;
    this.right = right3;
  }
  get value() {
    return zip5(this.left.value, this.right.value);
  }
  onStart(context15, effect4, parent, fiber) {
    this.left.onStart(context15, effect4, parent, fiber);
    this.right.onStart(context15, effect4, parent, fiber);
  }
  onEnd(value10, fiber) {
    this.left.onEnd(value10, fiber);
    this.right.onEnd(value10, fiber);
  }
  onEffect(fiber, effect4) {
    this.left.onEffect(fiber, effect4);
    this.right.onEffect(fiber, effect4);
  }
  onSuspend(fiber) {
    this.left.onSuspend(fiber);
    this.right.onSuspend(fiber);
  }
  onResume(fiber) {
    this.left.onResume(fiber);
    this.right.onResume(fiber);
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map14(f)));
  }
  zip(right3) {
    return new _Zip(this, right3);
  }
};
var isZip = (self) => hasProperty(self, SupervisorTypeId) && isTagged(self, "Zip");
var Track = class {
  [SupervisorTypeId] = supervisorVariance;
  fibers = /* @__PURE__ */ new Set();
  get value() {
    return sync(() => Array.from(this.fibers));
  }
  onStart(_context, _effect, _parent, fiber) {
    this.fibers.add(fiber);
  }
  onEnd(_value, fiber) {
    this.fibers.delete(fiber);
  }
  onEffect(_fiber, _effect) {
  }
  onSuspend(_fiber) {
  }
  onResume(_fiber) {
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map14(f)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
  onRun(execution, _fiber) {
    return execution();
  }
};
var Const = class {
  effect;
  [SupervisorTypeId] = supervisorVariance;
  constructor(effect4) {
    this.effect = effect4;
  }
  get value() {
    return this.effect;
  }
  onStart(_context, _effect, _parent, _fiber) {
  }
  onEnd(_value, _fiber) {
  }
  onEffect(_fiber, _effect) {
  }
  onSuspend(_fiber) {
  }
  onResume(_fiber) {
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map14(f)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
  onRun(execution, _fiber) {
    return execution();
  }
};
var FibersIn = class {
  ref;
  [SupervisorTypeId] = supervisorVariance;
  constructor(ref) {
    this.ref = ref;
  }
  get value() {
    return sync(() => get7(this.ref));
  }
  onStart(_context, _effect, _parent, fiber) {
    pipe(this.ref, set3(pipe(get7(this.ref), add5(fiber))));
  }
  onEnd(_value, fiber) {
    pipe(this.ref, set3(pipe(get7(this.ref), remove10(fiber))));
  }
  onEffect(_fiber, _effect) {
  }
  onSuspend(_fiber) {
  }
  onResume(_fiber) {
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map14(f)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
  onRun(execution, _fiber) {
    return execution();
  }
};
var unsafeTrack = () => {
  return new Track();
};
var track = sync(unsafeTrack);
var fromEffect2 = (effect4) => {
  return new Const(effect4);
};
var none8 = globalValue("effect/Supervisor/none", () => fromEffect2(void_3));
var fibersIn = (ref) => sync(() => new FibersIn(ref));

// ../../node_modules/effect/dist/esm/Differ.js
var Differ_exports = {};
__export(Differ_exports, {
  TypeId: () => TypeId18,
  chunk: () => chunk2,
  combine: () => combine14,
  diff: () => diff10,
  empty: () => empty33,
  environment: () => environment2,
  hashMap: () => hashMap2,
  hashSet: () => hashSet2,
  make: () => make48,
  orElseEither: () => orElseEither4,
  patch: () => patch11,
  readonlyArray: () => readonlyArray2,
  transform: () => transform2,
  update: () => update6,
  updateWith: () => updateWith2,
  zip: () => zip10
});
var TypeId18 = DifferTypeId;
var empty33 = (self) => self.empty;
var diff10 = dual(3, (self, oldValue, newValue) => self.diff(oldValue, newValue));
var combine14 = dual(3, (self, first5, second) => self.combine(first5, second));
var patch11 = dual(3, (self, patch14, oldValue) => self.patch(patch14, oldValue));
var make48 = make20;
var environment2 = environment;
var chunk2 = chunk;
var hashMap2 = hashMap;
var hashSet2 = hashSet;
var orElseEither4 = orElseEither2;
var readonlyArray2 = readonlyArray;
var transform2 = transform;
var update6 = update2;
var updateWith2 = updateWith;
var zip10 = zip4;

// ../../node_modules/effect/dist/esm/internal/supervisor/patch.js
var OP_EMPTY3 = "Empty";
var OP_ADD_SUPERVISOR = "AddSupervisor";
var OP_REMOVE_SUPERVISOR = "RemoveSupervisor";
var OP_AND_THEN2 = "AndThen";
var empty34 = {
  _tag: OP_EMPTY3
};
var combine15 = (self, that) => {
  return {
    _tag: OP_AND_THEN2,
    first: self,
    second: that
  };
};
var patch12 = (self, supervisor) => {
  return patchLoop(supervisor, of3(self));
};
var patchLoop = (_supervisor, _patches) => {
  let supervisor = _supervisor;
  let patches = _patches;
  while (isNonEmpty2(patches)) {
    const head13 = headNonEmpty2(patches);
    switch (head13._tag) {
      case OP_EMPTY3: {
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_ADD_SUPERVISOR: {
        supervisor = supervisor.zip(head13.supervisor);
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_REMOVE_SUPERVISOR: {
        supervisor = removeSupervisor(supervisor, head13.supervisor);
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_AND_THEN2: {
        patches = prepend3(head13.first)(prepend3(head13.second)(tailNonEmpty2(patches)));
        break;
      }
    }
  }
  return supervisor;
};
var removeSupervisor = (self, that) => {
  if (equals(self, that)) {
    return none8;
  } else {
    if (isZip(self)) {
      return removeSupervisor(self.left, that).zip(removeSupervisor(self.right, that));
    } else {
      return self;
    }
  }
};
var toSet4 = (self) => {
  if (equals(self, none8)) {
    return empty10();
  } else {
    if (isZip(self)) {
      return pipe(toSet4(self.left), union6(toSet4(self.right)));
    } else {
      return make14(self);
    }
  }
};
var diff11 = (oldValue, newValue) => {
  if (equals(oldValue, newValue)) {
    return empty34;
  }
  const oldSupervisors = toSet4(oldValue);
  const newSupervisors = toSet4(newValue);
  const added = pipe(newSupervisors, difference5(oldSupervisors), reduce7(empty34, (patch14, supervisor) => combine15(patch14, {
    _tag: OP_ADD_SUPERVISOR,
    supervisor
  })));
  const removed = pipe(oldSupervisors, difference5(newSupervisors), reduce7(empty34, (patch14, supervisor) => combine15(patch14, {
    _tag: OP_REMOVE_SUPERVISOR,
    supervisor
  })));
  return combine15(added, removed);
};
var differ2 = make48({
  empty: empty34,
  patch: patch12,
  combine: combine15,
  diff: diff11
});

// ../../node_modules/effect/dist/esm/internal/fiberRuntime.js
var fiberStarted = counter6("effect_fiber_started", {
  incremental: true
});
var fiberActive = counter6("effect_fiber_active");
var fiberSuccesses = counter6("effect_fiber_successes", {
  incremental: true
});
var fiberFailures = counter6("effect_fiber_failures", {
  incremental: true
});
var fiberLifetimes = tagged2(histogram5("effect_fiber_lifetimes", exponential({
  start: 0.5,
  factor: 2,
  count: 35
})), "time_unit", "milliseconds");
var EvaluationSignalContinue = "Continue";
var EvaluationSignalDone = "Done";
var EvaluationSignalYieldNow = "Yield";
var runtimeFiberVariance = {
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var absurd3 = (_) => {
  throw new Error(`BUG: FiberRuntime - ${toStringUnknown(_)} - please report an issue at https://github.com/Effect-TS/effect/issues`);
};
var YieldedOp = Symbol.for("effect/internal/fiberRuntime/YieldedOp");
var yieldedOpChannel = globalValue("effect/internal/fiberRuntime/yieldedOpChannel", () => ({
  currentOp: null
}));
var contOpSuccess = {
  [OP_ON_SUCCESS]: (_, cont, value10) => {
    return internalCall(() => cont.effect_instruction_i1(value10));
  },
  ["OnStep"]: (_, _cont, value10) => {
    return exitSucceed(exitSucceed(value10));
  },
  [OP_ON_SUCCESS_AND_FAILURE]: (_, cont, value10) => {
    return internalCall(() => cont.effect_instruction_i2(value10));
  },
  [OP_REVERT_FLAGS]: (self, cont, value10) => {
    self.patchRuntimeFlags(self.currentRuntimeFlags, cont.patch);
    if (interruptible(self.currentRuntimeFlags) && self.isInterrupted()) {
      return exitFailCause(self.getInterruptedCause());
    } else {
      return exitSucceed(value10);
    }
  },
  [OP_WHILE]: (self, cont, value10) => {
    internalCall(() => cont.effect_instruction_i2(value10));
    if (internalCall(() => cont.effect_instruction_i0())) {
      self.pushStack(cont);
      return internalCall(() => cont.effect_instruction_i1());
    } else {
      return void_3;
    }
  },
  [OP_ITERATOR]: (self, cont, value10) => {
    const state = internalCall(() => cont.effect_instruction_i0.next(value10));
    if (state.done) return exitSucceed(state.value);
    self.pushStack(cont);
    return yieldWrapGet(state.value);
  }
};
var drainQueueWhileRunningTable = {
  [OP_INTERRUPT_SIGNAL]: (self, runtimeFlags2, cur, message) => {
    self.processNewInterruptSignal(message.cause);
    return interruptible(runtimeFlags2) ? exitFailCause(message.cause) : cur;
  },
  [OP_RESUME]: (_self, _runtimeFlags, _cur, _message) => {
    throw new Error("It is illegal to have multiple concurrent run loops in a single fiber");
  },
  [OP_STATEFUL]: (self, runtimeFlags2, cur, message) => {
    message.onFiber(self, running2(runtimeFlags2));
    return cur;
  },
  [OP_YIELD_NOW]: (_self, _runtimeFlags, cur, _message) => {
    return flatMap12(yieldNow(), () => cur);
  }
};
var runBlockedRequests = (self) => forEachSequentialDiscard(flatten6(self), (requestsByRequestResolver) => forEachConcurrentDiscard(sequentialCollectionToChunk(requestsByRequestResolver), ([dataSource, sequential6]) => {
  const map49 = /* @__PURE__ */ new Map();
  const arr = [];
  for (const block of sequential6) {
    arr.push(toReadonlyArray(block));
    for (const entry of block) {
      map49.set(entry.request, entry);
    }
  }
  const flat = arr.flat();
  return fiberRefLocally(invokeWithInterrupt(dataSource.runAll(arr), flat, () => flat.forEach((entry) => {
    entry.listeners.interrupted = true;
  })), currentRequestMap, map49);
}, false, false));
var _version = getCurrentVersion();
var FiberRuntime = class extends Class3 {
  [FiberTypeId] = fiberVariance2;
  [RuntimeFiberTypeId] = runtimeFiberVariance;
  _fiberRefs;
  _fiberId;
  _queue = new Array();
  _children = null;
  _observers = new Array();
  _running = false;
  _stack = [];
  _asyncInterruptor = null;
  _asyncBlockingOn = null;
  _exitValue = null;
  _steps = [];
  _isYielding = false;
  currentRuntimeFlags;
  currentOpCount = 0;
  currentSupervisor;
  currentScheduler;
  currentTracer;
  currentSpan;
  currentContext;
  currentDefaultServices;
  constructor(fiberId5, fiberRefs0, runtimeFlags0) {
    super();
    this.currentRuntimeFlags = runtimeFlags0;
    this._fiberId = fiberId5;
    this._fiberRefs = fiberRefs0;
    if (runtimeMetrics(runtimeFlags0)) {
      const tags3 = this.getFiberRef(currentMetricLabels);
      fiberStarted.unsafeUpdate(1, tags3);
      fiberActive.unsafeUpdate(1, tags3);
    }
    this.refreshRefCache();
  }
  commit() {
    return join3(this);
  }
  /**
   * The identity of the fiber.
   */
  id() {
    return this._fiberId;
  }
  /**
   * Begins execution of the effect associated with this fiber on in the
   * background. This can be called to "kick off" execution of a fiber after
   * it has been created.
   */
  resume(effect4) {
    this.tell(resume(effect4));
  }
  /**
   * The status of the fiber.
   */
  get status() {
    return this.ask((_, status3) => status3);
  }
  /**
   * Gets the fiber runtime flags.
   */
  get runtimeFlags() {
    return this.ask((state, status3) => {
      if (isDone3(status3)) {
        return state.currentRuntimeFlags;
      }
      return status3.runtimeFlags;
    });
  }
  /**
   * Returns the current `FiberScope` for the fiber.
   */
  scope() {
    return unsafeMake9(this);
  }
  /**
   * Retrieves the immediate children of the fiber.
   */
  get children() {
    return this.ask((fiber) => Array.from(fiber.getChildren()));
  }
  /**
   * Gets the fiber's set of children.
   */
  getChildren() {
    if (this._children === null) {
      this._children = /* @__PURE__ */ new Set();
    }
    return this._children;
  }
  /**
   * Retrieves the interrupted cause of the fiber, which will be `Cause.empty`
   * if the fiber has not been interrupted.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  getInterruptedCause() {
    return this.getFiberRef(currentInterruptedCause);
  }
  /**
   * Retrieves the whole set of fiber refs.
   */
  fiberRefs() {
    return this.ask((fiber) => fiber.getFiberRefs());
  }
  /**
   * Returns an effect that will contain information computed from the fiber
   * state and status while running on the fiber.
   *
   * This allows the outside world to interact safely with mutable fiber state
   * without locks or immutable data.
   */
  ask(f) {
    return suspend(() => {
      const deferred = deferredUnsafeMake(this._fiberId);
      this.tell(stateful((fiber, status3) => {
        deferredUnsafeDone(deferred, sync(() => f(fiber, status3)));
      }));
      return deferredAwait(deferred);
    });
  }
  /**
   * Adds a message to be processed by the fiber on the fiber.
   */
  tell(message) {
    this._queue.push(message);
    if (!this._running) {
      this._running = true;
      this.drainQueueLaterOnExecutor();
    }
  }
  get await() {
    return async_((resume2) => {
      const cb = (exit4) => resume2(succeed(exit4));
      this.tell(stateful((fiber, _) => {
        if (fiber._exitValue !== null) {
          cb(this._exitValue);
        } else {
          fiber.addObserver(cb);
        }
      }));
      return sync(() => this.tell(stateful((fiber, _) => {
        fiber.removeObserver(cb);
      })));
    }, this.id());
  }
  get inheritAll() {
    return withFiberRuntime((parentFiber, parentStatus) => {
      const parentFiberId = parentFiber.id();
      const parentFiberRefs = parentFiber.getFiberRefs();
      const parentRuntimeFlags = parentStatus.runtimeFlags;
      const childFiberRefs = this.getFiberRefs();
      const updatedFiberRefs = joinAs(parentFiberRefs, parentFiberId, childFiberRefs);
      parentFiber.setFiberRefs(updatedFiberRefs);
      const updatedRuntimeFlags = parentFiber.getFiberRef(currentRuntimeFlags);
      const patch14 = pipe(
        diff7(parentRuntimeFlags, updatedRuntimeFlags),
        // Do not inherit WindDown or Interruption!
        exclude2(Interruption),
        exclude2(WindDown)
      );
      return updateRuntimeFlags(patch14);
    });
  }
  /**
   * Tentatively observes the fiber, but returns immediately if it is not
   * already done.
   */
  get poll() {
    return sync(() => fromNullable2(this._exitValue));
  }
  /**
   * Unsafely observes the fiber, but returns immediately if it is not
   * already done.
   */
  unsafePoll() {
    return this._exitValue;
  }
  /**
   * In the background, interrupts the fiber as if interrupted from the specified fiber.
   */
  interruptAsFork(fiberId5) {
    return sync(() => this.tell(interruptSignal(interrupt(fiberId5))));
  }
  /**
   * In the background, interrupts the fiber as if interrupted from the specified fiber.
   */
  unsafeInterruptAsFork(fiberId5) {
    this.tell(interruptSignal(interrupt(fiberId5)));
  }
  /**
   * Adds an observer to the list of observers.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  addObserver(observer) {
    if (this._exitValue !== null) {
      observer(this._exitValue);
    } else {
      this._observers.push(observer);
    }
  }
  /**
   * Removes the specified observer from the list of observers that will be
   * notified when the fiber exits.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  removeObserver(observer) {
    this._observers = this._observers.filter((o) => o !== observer);
  }
  /**
   * Retrieves all fiber refs of the fiber.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  getFiberRefs() {
    this.setFiberRef(currentRuntimeFlags, this.currentRuntimeFlags);
    return this._fiberRefs;
  }
  /**
   * Deletes the specified fiber ref.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  unsafeDeleteFiberRef(fiberRef) {
    this._fiberRefs = delete_(this._fiberRefs, fiberRef);
  }
  /**
   * Retrieves the state of the fiber ref, or else its initial value.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  getFiberRef(fiberRef) {
    if (this._fiberRefs.locals.has(fiberRef)) {
      return this._fiberRefs.locals.get(fiberRef)[0][1];
    }
    return fiberRef.initial;
  }
  /**
   * Sets the fiber ref to the specified value.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  setFiberRef(fiberRef, value10) {
    this._fiberRefs = updateAs(this._fiberRefs, {
      fiberId: this._fiberId,
      fiberRef,
      value: value10
    });
    this.refreshRefCache();
  }
  refreshRefCache() {
    this.currentDefaultServices = this.getFiberRef(currentServices);
    this.currentTracer = this.currentDefaultServices.unsafeMap.get(tracerTag.key);
    this.currentSupervisor = this.getFiberRef(currentSupervisor);
    this.currentScheduler = this.getFiberRef(currentScheduler);
    this.currentContext = this.getFiberRef(currentContext);
    this.currentSpan = this.currentContext.unsafeMap.get(spanTag.key);
  }
  /**
   * Wholesale replaces all fiber refs of this fiber.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  setFiberRefs(fiberRefs4) {
    this._fiberRefs = fiberRefs4;
    this.refreshRefCache();
  }
  /**
   * Adds a reference to the specified fiber inside the children set.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  addChild(child) {
    this.getChildren().add(child);
  }
  /**
   * Removes a reference to the specified fiber inside the children set.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  removeChild(child) {
    this.getChildren().delete(child);
  }
  /**
   * Transfers all children of this fiber that are currently running to the
   * specified fiber scope.
   *
   * **NOTE**: This method must be invoked by the fiber itself after it has
   * evaluated the effects but prior to exiting.
   */
  transferChildren(scope6) {
    const children3 = this._children;
    this._children = null;
    if (children3 !== null && children3.size > 0) {
      for (const child of children3) {
        if (child._exitValue === null) {
          scope6.add(this.currentRuntimeFlags, child);
        }
      }
    }
  }
  /**
   * On the current thread, executes all messages in the fiber's inbox. This
   * method may return before all work is done, in the event the fiber executes
   * an asynchronous operation.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  drainQueueOnCurrentThread() {
    let recurse = true;
    while (recurse) {
      let evaluationSignal = EvaluationSignalContinue;
      const prev = globalThis[currentFiberURI];
      globalThis[currentFiberURI] = this;
      try {
        while (evaluationSignal === EvaluationSignalContinue) {
          evaluationSignal = this._queue.length === 0 ? EvaluationSignalDone : this.evaluateMessageWhileSuspended(this._queue.splice(0, 1)[0]);
        }
      } finally {
        this._running = false;
        globalThis[currentFiberURI] = prev;
      }
      if (this._queue.length > 0 && !this._running) {
        this._running = true;
        if (evaluationSignal === EvaluationSignalYieldNow) {
          this.drainQueueLaterOnExecutor();
          recurse = false;
        } else {
          recurse = true;
        }
      } else {
        recurse = false;
      }
    }
  }
  /**
   * Schedules the execution of all messages in the fiber's inbox.
   *
   * This method will return immediately after the scheduling
   * operation is completed, but potentially before such messages have been
   * executed.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  drainQueueLaterOnExecutor() {
    this.currentScheduler.scheduleTask(this.run, this.getFiberRef(currentSchedulingPriority));
  }
  /**
   * Drains the fiber's message queue while the fiber is actively running,
   * returning the next effect to execute, which may be the input effect if no
   * additional effect needs to be executed.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  drainQueueWhileRunning(runtimeFlags2, cur0) {
    let cur = cur0;
    while (this._queue.length > 0) {
      const message = this._queue.splice(0, 1)[0];
      cur = drainQueueWhileRunningTable[message._tag](this, runtimeFlags2, cur, message);
    }
    return cur;
  }
  /**
   * Determines if the fiber is interrupted.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  isInterrupted() {
    return !isEmpty7(this.getFiberRef(currentInterruptedCause));
  }
  /**
   * Adds an interruptor to the set of interruptors that are interrupting this
   * fiber.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  addInterruptedCause(cause3) {
    const oldSC = this.getFiberRef(currentInterruptedCause);
    this.setFiberRef(currentInterruptedCause, sequential(oldSC, cause3));
  }
  /**
   * Processes a new incoming interrupt signal.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  processNewInterruptSignal(cause3) {
    this.addInterruptedCause(cause3);
    this.sendInterruptSignalToAllChildren();
  }
  /**
   * Interrupts all children of the current fiber, returning an effect that will
   * await the exit of the children. This method will return null if the fiber
   * has no children.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  sendInterruptSignalToAllChildren() {
    if (this._children === null || this._children.size === 0) {
      return false;
    }
    let told = false;
    for (const child of this._children) {
      child.tell(interruptSignal(interrupt(this.id())));
      told = true;
    }
    return told;
  }
  /**
   * Interrupts all children of the current fiber, returning an effect that will
   * await the exit of the children. This method will return null if the fiber
   * has no children.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  interruptAllChildren() {
    if (this.sendInterruptSignalToAllChildren()) {
      const it = this._children.values();
      this._children = null;
      let isDone9 = false;
      const body = () => {
        const next6 = it.next();
        if (!next6.done) {
          return asVoid2(next6.value.await);
        } else {
          return sync(() => {
            isDone9 = true;
          });
        }
      };
      return whileLoop({
        while: () => !isDone9,
        body,
        step: () => {
        }
      });
    }
    return null;
  }
  reportExitValue(exit4) {
    if (runtimeMetrics(this.currentRuntimeFlags)) {
      const tags3 = this.getFiberRef(currentMetricLabels);
      const startTimeMillis = this.id().startTimeMillis;
      const endTimeMillis = Date.now();
      fiberLifetimes.unsafeUpdate(endTimeMillis - startTimeMillis, tags3);
      fiberActive.unsafeUpdate(-1, tags3);
      switch (exit4._tag) {
        case OP_SUCCESS: {
          fiberSuccesses.unsafeUpdate(1, tags3);
          break;
        }
        case OP_FAILURE: {
          fiberFailures.unsafeUpdate(1, tags3);
          break;
        }
      }
    }
    if (exit4._tag === "Failure") {
      const level = this.getFiberRef(currentUnhandledErrorLogLevel);
      if (!isInterruptedOnly(exit4.cause) && level._tag === "Some") {
        this.log("Fiber terminated with an unhandled error", exit4.cause, level);
      }
    }
  }
  setExitValue(exit4) {
    this._exitValue = exit4;
    this.reportExitValue(exit4);
    for (let i = this._observers.length - 1; i >= 0; i--) {
      this._observers[i](exit4);
    }
    this._observers = [];
  }
  getLoggers() {
    return this.getFiberRef(currentLoggers);
  }
  log(message, cause3, overrideLogLevel) {
    const logLevel3 = isSome2(overrideLogLevel) ? overrideLogLevel.value : this.getFiberRef(currentLogLevel);
    const minimumLogLevel3 = this.getFiberRef(currentMinimumLogLevel);
    if (greaterThan6(minimumLogLevel3, logLevel3)) {
      return;
    }
    const spans = this.getFiberRef(currentLogSpan);
    const annotations4 = this.getFiberRef(currentLogAnnotations);
    const loggers = this.getLoggers();
    const contextMap = this.getFiberRefs();
    if (size6(loggers) > 0) {
      const clockService = get4(this.getFiberRef(currentServices), clockTag);
      const date5 = new Date(clockService.unsafeCurrentTimeMillis());
      withRedactableContext(contextMap, () => {
        for (const logger of loggers) {
          logger.log({
            fiberId: this.id(),
            logLevel: logLevel3,
            message,
            cause: cause3,
            context: contextMap,
            spans,
            annotations: annotations4,
            date: date5
          });
        }
      });
    }
  }
  /**
   * Evaluates a single message on the current thread, while the fiber is
   * suspended. This method should only be called while evaluation of the
   * fiber's effect is suspended due to an asynchronous operation.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  evaluateMessageWhileSuspended(message) {
    switch (message._tag) {
      case OP_YIELD_NOW: {
        return EvaluationSignalYieldNow;
      }
      case OP_INTERRUPT_SIGNAL: {
        this.processNewInterruptSignal(message.cause);
        if (this._asyncInterruptor !== null) {
          this._asyncInterruptor(exitFailCause(message.cause));
          this._asyncInterruptor = null;
        }
        return EvaluationSignalContinue;
      }
      case OP_RESUME: {
        this._asyncInterruptor = null;
        this._asyncBlockingOn = null;
        this.evaluateEffect(message.effect);
        return EvaluationSignalContinue;
      }
      case OP_STATEFUL: {
        message.onFiber(this, this._exitValue !== null ? done4 : suspended2(this.currentRuntimeFlags, this._asyncBlockingOn));
        return EvaluationSignalContinue;
      }
      default: {
        return absurd3(message);
      }
    }
  }
  /**
   * Evaluates an effect until completion, potentially asynchronously.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  evaluateEffect(effect0) {
    this.currentSupervisor.onResume(this);
    try {
      let effect4 = interruptible(this.currentRuntimeFlags) && this.isInterrupted() ? exitFailCause(this.getInterruptedCause()) : effect0;
      while (effect4 !== null) {
        const eff = effect4;
        const exit4 = this.runLoop(eff);
        if (exit4 === YieldedOp) {
          const op = yieldedOpChannel.currentOp;
          yieldedOpChannel.currentOp = null;
          if (op._op === OP_YIELD) {
            if (cooperativeYielding(this.currentRuntimeFlags)) {
              this.tell(yieldNow3());
              this.tell(resume(exitVoid));
              effect4 = null;
            } else {
              effect4 = exitVoid;
            }
          } else if (op._op === OP_ASYNC) {
            effect4 = null;
          }
        } else {
          this.currentRuntimeFlags = pipe(this.currentRuntimeFlags, enable2(WindDown));
          const interruption3 = this.interruptAllChildren();
          if (interruption3 !== null) {
            effect4 = flatMap12(interruption3, () => exit4);
          } else {
            if (this._queue.length === 0) {
              this.setExitValue(exit4);
            } else {
              this.tell(resume(exit4));
            }
            effect4 = null;
          }
        }
      }
    } finally {
      this.currentSupervisor.onSuspend(this);
    }
  }
  /**
   * Begins execution of the effect associated with this fiber on the current
   * thread. This can be called to "kick off" execution of a fiber after it has
   * been created, in hopes that the effect can be executed synchronously.
   *
   * This is not the normal way of starting a fiber, but it is useful when the
   * express goal of executing the fiber is to synchronously produce its exit.
   */
  start(effect4) {
    if (!this._running) {
      this._running = true;
      const prev = globalThis[currentFiberURI];
      globalThis[currentFiberURI] = this;
      try {
        this.evaluateEffect(effect4);
      } finally {
        this._running = false;
        globalThis[currentFiberURI] = prev;
        if (this._queue.length > 0) {
          this.drainQueueLaterOnExecutor();
        }
      }
    } else {
      this.tell(resume(effect4));
    }
  }
  /**
   * Begins execution of the effect associated with this fiber on in the
   * background, and on the correct thread pool. This can be called to "kick
   * off" execution of a fiber after it has been created, in hopes that the
   * effect can be executed synchronously.
   */
  startFork(effect4) {
    this.tell(resume(effect4));
  }
  /**
   * Takes the current runtime flags, patches them to return the new runtime
   * flags, and then makes any changes necessary to fiber state based on the
   * specified patch.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  patchRuntimeFlags(oldRuntimeFlags, patch14) {
    const newRuntimeFlags = patch7(oldRuntimeFlags, patch14);
    globalThis[currentFiberURI] = this;
    this.currentRuntimeFlags = newRuntimeFlags;
    return newRuntimeFlags;
  }
  /**
   * Initiates an asynchronous operation, by building a callback that will
   * resume execution, and then feeding that callback to the registration
   * function, handling error cases and repeated resumptions appropriately.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  initiateAsync(runtimeFlags2, asyncRegister) {
    let alreadyCalled = false;
    const callback = (effect4) => {
      if (!alreadyCalled) {
        alreadyCalled = true;
        this.tell(resume(effect4));
      }
    };
    if (interruptible(runtimeFlags2)) {
      this._asyncInterruptor = callback;
    }
    try {
      asyncRegister(callback);
    } catch (e) {
      callback(failCause(die(e)));
    }
  }
  pushStack(cont) {
    this._stack.push(cont);
    if (cont._op === "OnStep") {
      this._steps.push({
        refs: this.getFiberRefs(),
        flags: this.currentRuntimeFlags
      });
    }
  }
  popStack() {
    const item = this._stack.pop();
    if (item) {
      if (item._op === "OnStep") {
        this._steps.pop();
      }
      return item;
    }
    return;
  }
  getNextSuccessCont() {
    let frame = this.popStack();
    while (frame) {
      if (frame._op !== OP_ON_FAILURE) {
        return frame;
      }
      frame = this.popStack();
    }
  }
  getNextFailCont() {
    let frame = this.popStack();
    while (frame) {
      if (frame._op !== OP_ON_SUCCESS && frame._op !== OP_WHILE && frame._op !== OP_ITERATOR) {
        return frame;
      }
      frame = this.popStack();
    }
  }
  [OP_TAG](op) {
    return sync(() => unsafeGet3(this.currentContext, op));
  }
  ["Left"](op) {
    return fail2(op.left);
  }
  ["None"](_) {
    return fail2(new NoSuchElementException());
  }
  ["Right"](op) {
    return exitSucceed(op.right);
  }
  ["Some"](op) {
    return exitSucceed(op.value);
  }
  ["Micro"](op) {
    return unsafeAsync((microResume) => {
      let resume2 = microResume;
      const fiber = runFork(provideContext2(op, this.currentContext));
      fiber.addObserver((exit4) => {
        if (exit4._tag === "Success") {
          return resume2(exitSucceed(exit4.value));
        }
        switch (exit4.cause._tag) {
          case "Interrupt": {
            return resume2(exitFailCause(interrupt(none4)));
          }
          case "Fail": {
            return resume2(fail2(exit4.cause.error));
          }
          case "Die": {
            return resume2(die2(exit4.cause.defect));
          }
        }
      });
      return unsafeAsync((abortResume) => {
        resume2 = (_) => {
          abortResume(void_3);
        };
        fiber.unsafeInterrupt();
      });
    });
  }
  [OP_SYNC](op) {
    const value10 = internalCall(() => op.effect_instruction_i0());
    const cont = this.getNextSuccessCont();
    if (cont !== void 0) {
      if (!(cont._op in contOpSuccess)) {
        absurd3(cont);
      }
      return contOpSuccess[cont._op](this, cont, value10);
    } else {
      yieldedOpChannel.currentOp = exitSucceed(value10);
      return YieldedOp;
    }
  }
  [OP_SUCCESS](op) {
    const oldCur = op;
    const cont = this.getNextSuccessCont();
    if (cont !== void 0) {
      if (!(cont._op in contOpSuccess)) {
        absurd3(cont);
      }
      return contOpSuccess[cont._op](this, cont, oldCur.effect_instruction_i0);
    } else {
      yieldedOpChannel.currentOp = oldCur;
      return YieldedOp;
    }
  }
  [OP_FAILURE](op) {
    const cause3 = op.effect_instruction_i0;
    const cont = this.getNextFailCont();
    if (cont !== void 0) {
      switch (cont._op) {
        case OP_ON_FAILURE:
        case OP_ON_SUCCESS_AND_FAILURE: {
          if (!(interruptible(this.currentRuntimeFlags) && this.isInterrupted())) {
            return internalCall(() => cont.effect_instruction_i1(cause3));
          } else {
            return exitFailCause(stripFailures(cause3));
          }
        }
        case "OnStep": {
          if (!(interruptible(this.currentRuntimeFlags) && this.isInterrupted())) {
            return exitSucceed(exitFailCause(cause3));
          } else {
            return exitFailCause(stripFailures(cause3));
          }
        }
        case OP_REVERT_FLAGS: {
          this.patchRuntimeFlags(this.currentRuntimeFlags, cont.patch);
          if (interruptible(this.currentRuntimeFlags) && this.isInterrupted()) {
            return exitFailCause(sequential(cause3, this.getInterruptedCause()));
          } else {
            return exitFailCause(cause3);
          }
        }
        default: {
          absurd3(cont);
        }
      }
    } else {
      yieldedOpChannel.currentOp = exitFailCause(cause3);
      return YieldedOp;
    }
  }
  [OP_WITH_RUNTIME](op) {
    return internalCall(() => op.effect_instruction_i0(this, running2(this.currentRuntimeFlags)));
  }
  ["Blocked"](op) {
    const refs = this.getFiberRefs();
    const flags = this.currentRuntimeFlags;
    if (this._steps.length > 0) {
      const frames = [];
      const snap = this._steps[this._steps.length - 1];
      let frame = this.popStack();
      while (frame && frame._op !== "OnStep") {
        frames.push(frame);
        frame = this.popStack();
      }
      this.setFiberRefs(snap.refs);
      this.currentRuntimeFlags = snap.flags;
      const patchRefs = diff9(snap.refs, refs);
      const patchFlags = diff7(snap.flags, flags);
      return exitSucceed(blocked(op.effect_instruction_i0, withFiberRuntime((newFiber) => {
        while (frames.length > 0) {
          newFiber.pushStack(frames.pop());
        }
        newFiber.setFiberRefs(patch10(newFiber.id(), newFiber.getFiberRefs())(patchRefs));
        newFiber.currentRuntimeFlags = patch7(patchFlags)(newFiber.currentRuntimeFlags);
        return op.effect_instruction_i1;
      })));
    }
    return uninterruptibleMask((restore) => flatMap12(forkDaemon2(runRequestBlock(op.effect_instruction_i0)), () => restore(op.effect_instruction_i1)));
  }
  ["RunBlocked"](op) {
    return runBlockedRequests(op.effect_instruction_i0);
  }
  [OP_UPDATE_RUNTIME_FLAGS](op) {
    const updateFlags = op.effect_instruction_i0;
    const oldRuntimeFlags = this.currentRuntimeFlags;
    const newRuntimeFlags = patch7(oldRuntimeFlags, updateFlags);
    if (interruptible(newRuntimeFlags) && this.isInterrupted()) {
      return exitFailCause(this.getInterruptedCause());
    } else {
      this.patchRuntimeFlags(this.currentRuntimeFlags, updateFlags);
      if (op.effect_instruction_i1) {
        const revertFlags = diff7(newRuntimeFlags, oldRuntimeFlags);
        this.pushStack(new RevertFlags(revertFlags, op));
        return internalCall(() => op.effect_instruction_i1(oldRuntimeFlags));
      } else {
        return exitVoid;
      }
    }
  }
  [OP_ON_SUCCESS](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  ["OnStep"](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ON_FAILURE](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ON_SUCCESS_AND_FAILURE](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ASYNC](op) {
    this._asyncBlockingOn = op.effect_instruction_i1;
    this.initiateAsync(this.currentRuntimeFlags, op.effect_instruction_i0);
    yieldedOpChannel.currentOp = op;
    return YieldedOp;
  }
  [OP_YIELD](op) {
    this._isYielding = false;
    yieldedOpChannel.currentOp = op;
    return YieldedOp;
  }
  [OP_WHILE](op) {
    const check6 = op.effect_instruction_i0;
    const body = op.effect_instruction_i1;
    if (check6()) {
      this.pushStack(op);
      return body();
    } else {
      return exitVoid;
    }
  }
  [OP_ITERATOR](op) {
    return contOpSuccess[OP_ITERATOR](this, op, void 0);
  }
  [OP_COMMIT](op) {
    return internalCall(() => op.commit());
  }
  /**
   * The main run-loop for evaluating effects.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  runLoop(effect0) {
    let cur = effect0;
    this.currentOpCount = 0;
    while (true) {
      if ((this.currentRuntimeFlags & OpSupervision) !== 0) {
        this.currentSupervisor.onEffect(this, cur);
      }
      if (this._queue.length > 0) {
        cur = this.drainQueueWhileRunning(this.currentRuntimeFlags, cur);
      }
      if (!this._isYielding) {
        this.currentOpCount += 1;
        const shouldYield = this.currentScheduler.shouldYield(this);
        if (shouldYield !== false) {
          this._isYielding = true;
          this.currentOpCount = 0;
          const oldCur = cur;
          cur = flatMap12(yieldNow({
            priority: shouldYield
          }), () => oldCur);
        }
      }
      try {
        cur = this.currentTracer.context(() => {
          if (_version !== cur[EffectTypeId2]._V) {
            const level = this.getFiberRef(currentVersionMismatchErrorLogLevel);
            if (level._tag === "Some") {
              const effectVersion = cur[EffectTypeId2]._V;
              this.log(`Executing an Effect versioned ${effectVersion} with a Runtime of version ${getCurrentVersion()}, you may want to dedupe the effect dependencies, you can use the language service plugin to detect this at compile time: https://github.com/Effect-TS/language-service`, empty22, level);
            }
          }
          return this[cur._op](cur);
        }, this);
        if (cur === YieldedOp) {
          const op = yieldedOpChannel.currentOp;
          if (op._op === OP_YIELD || op._op === OP_ASYNC) {
            return YieldedOp;
          }
          yieldedOpChannel.currentOp = null;
          return op._op === OP_SUCCESS || op._op === OP_FAILURE ? op : exitFailCause(die(op));
        }
      } catch (e) {
        if (cur !== YieldedOp && !hasProperty(cur, "_op") || !(cur._op in this)) {
          cur = dieMessage(`Not a valid effect: ${toStringUnknown(cur)}`);
        } else if (isInterruptedException(e)) {
          cur = exitFailCause(sequential(die(e), interrupt(none4)));
        } else {
          cur = die2(e);
        }
      }
    }
  }
  run = () => {
    this.drainQueueOnCurrentThread();
  };
};
var currentMinimumLogLevel = globalValue("effect/FiberRef/currentMinimumLogLevel", () => fiberRefUnsafeMake(fromLiteral("Info")));
var loggerWithConsoleLog = (self) => makeLogger((opts) => {
  const services = getOrDefault2(opts.context, currentServices);
  get4(services, consoleTag).unsafe.log(self.log(opts));
});
var loggerWithLeveledLog = (self) => makeLogger((opts) => {
  const services = getOrDefault2(opts.context, currentServices);
  const unsafeLogger = get4(services, consoleTag).unsafe;
  switch (opts.logLevel._tag) {
    case "Debug":
      return unsafeLogger.debug(self.log(opts));
    case "Info":
      return unsafeLogger.info(self.log(opts));
    case "Trace":
      return unsafeLogger.trace(self.log(opts));
    case "Warning":
      return unsafeLogger.warn(self.log(opts));
    case "Error":
    case "Fatal":
      return unsafeLogger.error(self.log(opts));
    default:
      return unsafeLogger.log(self.log(opts));
  }
});
var loggerWithConsoleError = (self) => makeLogger((opts) => {
  const services = getOrDefault2(opts.context, currentServices);
  get4(services, consoleTag).unsafe.error(self.log(opts));
});
var defaultLogger = globalValue(Symbol.for("effect/Logger/defaultLogger"), () => loggerWithConsoleLog(stringLogger));
var jsonLogger2 = globalValue(Symbol.for("effect/Logger/jsonLogger"), () => loggerWithConsoleLog(jsonLogger));
var logFmtLogger = globalValue(Symbol.for("effect/Logger/logFmtLogger"), () => loggerWithConsoleLog(logfmtLogger));
var prettyLogger2 = globalValue(Symbol.for("effect/Logger/prettyLogger"), () => prettyLoggerDefault);
var structuredLogger2 = globalValue(Symbol.for("effect/Logger/structuredLogger"), () => loggerWithConsoleLog(structuredLogger));
var tracerLogger = globalValue(Symbol.for("effect/Logger/tracerLogger"), () => makeLogger(({
  annotations: annotations4,
  cause: cause3,
  context: context15,
  fiberId: fiberId5,
  logLevel: logLevel3,
  message
}) => {
  const span4 = getOption2(getOrDefault(context15, currentContext), spanTag);
  if (span4._tag === "None" || span4.value._tag === "ExternalSpan") {
    return;
  }
  const clockService = unsafeGet3(getOrDefault(context15, currentServices), clockTag);
  const attributes = {};
  for (const [key, value10] of annotations4) {
    attributes[key] = value10;
  }
  attributes["effect.fiberId"] = threadName2(fiberId5);
  attributes["effect.logLevel"] = logLevel3.label;
  if (cause3 !== null && cause3._tag !== "Empty") {
    attributes["effect.cause"] = pretty(cause3, {
      renderErrorCause: true
    });
  }
  span4.value.event(toStringUnknown(Array.isArray(message) ? message[0] : message), clockService.unsafeCurrentTimeNanos(), attributes);
}));
var loggerWithSpanAnnotations = (self) => mapInputOptions(self, (options) => {
  const span4 = flatMap2(get10(options.context, currentContext), getOption2(spanTag));
  if (span4._tag === "None") {
    return options;
  }
  return {
    ...options,
    annotations: pipe(options.annotations, set4("effect.traceId", span4.value.traceId), set4("effect.spanId", span4.value.spanId), span4.value._tag === "Span" ? set4("effect.spanName", span4.value.name) : identity)
  };
});
var currentLoggers = globalValue(Symbol.for("effect/FiberRef/currentLoggers"), () => fiberRefUnsafeMakeHashSet(make14(defaultLogger, tracerLogger)));
var batchedLogger = dual(3, (self, window2, f) => flatMap12(scope2, (scope6) => {
  let buffer5 = [];
  const flush = suspend(() => {
    if (buffer5.length === 0) {
      return void_3;
    }
    const arr = buffer5;
    buffer5 = [];
    return f(arr);
  });
  return uninterruptibleMask((restore) => pipe(sleep3(window2), zipRight2(flush), forever, restore, forkDaemon2, flatMap12((fiber) => scopeAddFinalizer(scope6, interruptFiber(fiber))), zipRight2(addFinalizer2(() => flush)), as3(makeLogger((options) => {
    buffer5.push(self.log(options));
  }))));
}));
var annotateLogsScoped = function() {
  if (typeof arguments[0] === "string") {
    return fiberRefLocallyScopedWith(currentLogAnnotations, set4(arguments[0], arguments[1]));
  }
  const entries7 = Object.entries(arguments[0]);
  return fiberRefLocallyScopedWith(currentLogAnnotations, mutate4((annotations4) => {
    for (let i = 0; i < entries7.length; i++) {
      const [key, value10] = entries7[i];
      set4(annotations4, key, value10);
    }
    return annotations4;
  }));
};
var whenLogLevel = dual(2, (effect4, level) => {
  const requiredLogLevel = typeof level === "string" ? fromLiteral(level) : level;
  return withFiberRuntime((fiberState) => {
    const minimumLogLevel3 = fiberState.getFiberRef(currentMinimumLogLevel);
    if (greaterThan6(minimumLogLevel3, requiredLogLevel)) {
      return succeed(none2());
    }
    return map14(effect4, some3);
  });
});
var acquireRelease2 = dual((args2) => isEffect(args2[0]), (acquire4, release4) => uninterruptible(tap2(acquire4, (a) => addFinalizer2((exit4) => release4(a, exit4)))));
var acquireReleaseInterruptible = dual((args2) => isEffect(args2[0]), (acquire4, release4) => ensuring2(acquire4, addFinalizer2((exit4) => release4(exit4))));
var addFinalizer2 = (finalizer3) => withFiberRuntime((runtime8) => {
  const acquireRefs = runtime8.getFiberRefs();
  const acquireFlags = disable2(runtime8.currentRuntimeFlags, Interruption);
  return flatMap12(scope2, (scope6) => scopeAddFinalizerExit(scope6, (exit4) => withFiberRuntime((runtimeFinalizer) => {
    const preRefs = runtimeFinalizer.getFiberRefs();
    const preFlags = runtimeFinalizer.currentRuntimeFlags;
    const patchRefs = diff9(preRefs, acquireRefs);
    const patchFlags = diff7(preFlags, acquireFlags);
    const inverseRefs = diff9(acquireRefs, preRefs);
    runtimeFinalizer.setFiberRefs(patch10(patchRefs, runtimeFinalizer.id(), acquireRefs));
    return ensuring2(withRuntimeFlags(finalizer3(exit4), patchFlags), sync(() => {
      runtimeFinalizer.setFiberRefs(patch10(inverseRefs, runtimeFinalizer.id(), runtimeFinalizer.getFiberRefs()));
    }));
  })));
});
var daemonChildren = (self) => {
  const forkScope = fiberRefLocally(currentForkScopeOverride, some3(globalScope));
  return forkScope(self);
};
var _existsParFound = Symbol.for("effect/Effect/existsPar/found");
var exists3 = dual((args2) => isIterable(args2[0]) && !isEffect(args2[0]), (elements, predicate, options) => matchSimple(options?.concurrency, () => suspend(() => existsLoop(elements[Symbol.iterator](), 0, predicate)), () => matchEffect(forEach15(elements, (a, i) => if_(predicate(a, i), {
  onTrue: () => fail2(_existsParFound),
  onFalse: () => void_3
}), options), {
  onFailure: (e) => e === _existsParFound ? succeed(true) : fail2(e),
  onSuccess: () => succeed(false)
})));
var existsLoop = (iterator, index, f) => {
  const next6 = iterator.next();
  if (next6.done) {
    return succeed(false);
  }
  return flatMap12(f(next6.value, index), (b) => b ? succeed(b) : existsLoop(iterator, index + 1, f));
};
var filter14 = dual((args2) => isIterable(args2[0]) && !isEffect(args2[0]), (elements, predicate, options) => {
  const predicate_ = options?.negate ? (a, i) => map14(predicate(a, i), not2) : predicate;
  return matchSimple(options?.concurrency, () => suspend(() => fromIterable2(elements).reduceRight((effect4, a, i) => zipWith6(effect4, suspend(() => predicate_(a, i)), (list, b) => b ? [a, ...list] : list), sync(() => new Array()))), () => map14(forEach15(elements, (a, i) => map14(predicate_(a, i), (b) => b ? some3(a) : none2()), options), getSomes3));
});
var allResolveInput = (input) => {
  if (Array.isArray(input) || isIterable(input)) {
    return [input, none2()];
  }
  const keys15 = Object.keys(input);
  const size40 = keys15.length;
  return [keys15.map((k) => input[k]), some3((values15) => {
    const res = {};
    for (let i = 0; i < size40; i++) {
      ;
      res[keys15[i]] = values15[i];
    }
    return res;
  })];
};
var allValidate = (effects, reconcile, options) => {
  const eitherEffects = [];
  for (const effect4 of effects) {
    eitherEffects.push(either3(effect4));
  }
  return flatMap12(forEach15(eitherEffects, identity, {
    concurrency: options?.concurrency,
    batching: options?.batching,
    concurrentFinalizers: options?.concurrentFinalizers
  }), (eithers) => {
    const none15 = none2();
    const size40 = eithers.length;
    const errors2 = new Array(size40);
    const successes = new Array(size40);
    let errored = false;
    for (let i = 0; i < size40; i++) {
      const either14 = eithers[i];
      if (either14._tag === "Left") {
        errors2[i] = some3(either14.left);
        errored = true;
      } else {
        successes[i] = either14.right;
        errors2[i] = none15;
      }
    }
    if (errored) {
      return reconcile._tag === "Some" ? fail2(reconcile.value(errors2)) : fail2(errors2);
    } else if (options?.discard) {
      return void_3;
    }
    return reconcile._tag === "Some" ? succeed(reconcile.value(successes)) : succeed(successes);
  });
};
var allEither = (effects, reconcile, options) => {
  const eitherEffects = [];
  for (const effect4 of effects) {
    eitherEffects.push(either3(effect4));
  }
  if (options?.discard) {
    return forEach15(eitherEffects, identity, {
      concurrency: options?.concurrency,
      batching: options?.batching,
      discard: true,
      concurrentFinalizers: options?.concurrentFinalizers
    });
  }
  return map14(forEach15(eitherEffects, identity, {
    concurrency: options?.concurrency,
    batching: options?.batching,
    concurrentFinalizers: options?.concurrentFinalizers
  }), (eithers) => reconcile._tag === "Some" ? reconcile.value(eithers) : eithers);
};
var all9 = (arg, options) => {
  const [effects, reconcile] = allResolveInput(arg);
  if (options?.mode === "validate") {
    return allValidate(effects, reconcile, options);
  } else if (options?.mode === "either") {
    return allEither(effects, reconcile, options);
  }
  return options?.discard !== true && reconcile._tag === "Some" ? map14(forEach15(effects, identity, options), reconcile.value) : forEach15(effects, identity, options);
};
var allWith = (options) => (arg) => all9(arg, options);
var allSuccesses = (elements, options) => map14(all9(fromIterable2(elements).map(exit), options), filterMap4((exit4) => exitIsSuccess(exit4) ? some3(exit4.effect_instruction_i0) : none2()));
var replicate4 = dual(2, (self, n) => Array.from({
  length: n
}, () => self));
var replicateEffect2 = dual((args2) => isEffect(args2[0]), (self, n, options) => all9(replicate4(self, n), options));
var forEach15 = dual((args2) => isIterable(args2[0]), (self, f, options) => withFiberRuntime((r) => {
  const isRequestBatchingEnabled = options?.batching === true || options?.batching === "inherit" && r.getFiberRef(currentRequestBatching);
  if (options?.discard) {
    return match12(options.concurrency, () => finalizersMaskInternal(sequential3, options?.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachConcurrentDiscard(self, (a, i) => restore(f(a, i)), true, false, 1) : forEachSequentialDiscard(self, (a, i) => restore(f(a, i)))), () => finalizersMaskInternal(parallel3, options?.concurrentFinalizers)((restore) => forEachConcurrentDiscard(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false)), (n) => finalizersMaskInternal(parallelN2(n), options?.concurrentFinalizers)((restore) => forEachConcurrentDiscard(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false, n)));
  }
  return match12(options?.concurrency, () => finalizersMaskInternal(sequential3, options?.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachParN(self, 1, (a, i) => restore(f(a, i)), true) : forEachSequential(self, (a, i) => restore(f(a, i)))), () => finalizersMaskInternal(parallel3, options?.concurrentFinalizers)((restore) => forEachParUnbounded(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)), (n) => finalizersMaskInternal(parallelN2(n), options?.concurrentFinalizers)((restore) => forEachParN(self, n, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)));
}));
var forEachParUnbounded = (self, f, batching) => suspend(() => {
  const as18 = fromIterable2(self);
  const array8 = new Array(as18.length);
  const fn2 = (a, i) => flatMap12(f(a, i), (b) => sync(() => array8[i] = b));
  return zipRight2(forEachConcurrentDiscard(as18, fn2, batching, false), succeed(array8));
});
var forEachConcurrentDiscard = (self, f, batching, processAll, n) => uninterruptibleMask((restore) => transplant((graft) => withFiberRuntime((parent) => {
  let todos = Array.from(self).reverse();
  let target = todos.length;
  if (target === 0) {
    return void_3;
  }
  let counter12 = 0;
  let interrupted4 = false;
  const fibersCount = n ? Math.min(todos.length, n) : todos.length;
  const fibers2 = /* @__PURE__ */ new Set();
  const results = new Array();
  const interruptAll3 = () => fibers2.forEach((fiber) => {
    fiber.currentScheduler.scheduleTask(() => {
      fiber.unsafeInterruptAsFork(parent.id());
    }, 0);
  });
  const startOrder = new Array();
  const joinOrder = new Array();
  const residual = new Array();
  const collectExits = () => {
    const exits = results.filter(({
      exit: exit4
    }) => exit4._tag === "Failure").sort((a, b) => a.index < b.index ? -1 : a.index === b.index ? 0 : 1).map(({
      exit: exit4
    }) => exit4);
    if (exits.length === 0) {
      exits.push(exitVoid);
    }
    return exits;
  };
  const runFiber = (eff, interruptImmediately = false) => {
    const runnable = uninterruptible(graft(eff));
    const fiber = unsafeForkUnstarted(runnable, parent, parent.currentRuntimeFlags, globalScope);
    parent.currentScheduler.scheduleTask(() => {
      if (interruptImmediately) {
        fiber.unsafeInterruptAsFork(parent.id());
      }
      fiber.resume(runnable);
    }, 0);
    return fiber;
  };
  const onInterruptSignal = () => {
    if (!processAll) {
      target -= todos.length;
      todos = [];
    }
    interrupted4 = true;
    interruptAll3();
  };
  const stepOrExit = batching ? step2 : exit;
  const processingFiber = runFiber(async_((resume2) => {
    const pushResult = (res, index) => {
      if (res._op === "Blocked") {
        residual.push(res);
      } else {
        results.push({
          index,
          exit: res
        });
        if (res._op === "Failure" && !interrupted4) {
          onInterruptSignal();
        }
      }
    };
    const next6 = () => {
      if (todos.length > 0) {
        const a = todos.pop();
        let index = counter12++;
        const returnNextElement = () => {
          const a2 = todos.pop();
          index = counter12++;
          return flatMap12(yieldNow(), () => flatMap12(stepOrExit(restore(f(a2, index))), onRes));
        };
        const onRes = (res) => {
          if (todos.length > 0) {
            pushResult(res, index);
            if (todos.length > 0) {
              return returnNextElement();
            }
          }
          return succeed(res);
        };
        const todo = flatMap12(stepOrExit(restore(f(a, index))), onRes);
        const fiber = runFiber(todo);
        startOrder.push(fiber);
        fibers2.add(fiber);
        if (interrupted4) {
          fiber.currentScheduler.scheduleTask(() => {
            fiber.unsafeInterruptAsFork(parent.id());
          }, 0);
        }
        fiber.addObserver((wrapped) => {
          let exit4;
          if (wrapped._op === "Failure") {
            exit4 = wrapped;
          } else {
            exit4 = wrapped.effect_instruction_i0;
          }
          joinOrder.push(fiber);
          fibers2.delete(fiber);
          pushResult(exit4, index);
          if (results.length === target) {
            resume2(succeed(getOrElse2(exitCollectAll(collectExits(), {
              parallel: true
            }), () => exitVoid)));
          } else if (residual.length + results.length === target) {
            const exits = collectExits();
            const requests = residual.map((blocked3) => blocked3.effect_instruction_i0).reduce(par);
            resume2(succeed(blocked(requests, forEachConcurrentDiscard([getOrElse2(exitCollectAll(exits, {
              parallel: true
            }), () => exitVoid), ...residual.map((blocked3) => blocked3.effect_instruction_i1)], (i) => i, batching, true, n))));
          } else {
            next6();
          }
        });
      }
    };
    for (let i = 0; i < fibersCount; i++) {
      next6();
    }
  }));
  return asVoid2(onExit(flatten8(restore(join3(processingFiber))), exitMatch({
    onFailure: (cause3) => {
      onInterruptSignal();
      const target2 = residual.length + 1;
      const concurrency = Math.min(typeof n === "number" ? n : residual.length, residual.length);
      const toPop = Array.from(residual);
      return async_((cb) => {
        const exits = [];
        let count9 = 0;
        let index = 0;
        const check6 = (index2, hitNext) => (exit4) => {
          exits[index2] = exit4;
          count9++;
          if (count9 === target2) {
            cb(exitSucceed(exitFailCause(cause3)));
          }
          if (toPop.length > 0 && hitNext) {
            next6();
          }
        };
        const next6 = () => {
          runFiber(toPop.pop(), true).addObserver(check6(index, true));
          index++;
        };
        processingFiber.addObserver(check6(index, false));
        index++;
        for (let i = 0; i < concurrency; i++) {
          next6();
        }
      });
    },
    onSuccess: () => forEachSequential(joinOrder, (f2) => f2.inheritAll)
  })));
})));
var forEachParN = (self, n, f, batching) => suspend(() => {
  const as18 = fromIterable2(self);
  const array8 = new Array(as18.length);
  const fn2 = (a, i) => map14(f(a, i), (b) => array8[i] = b);
  return zipRight2(forEachConcurrentDiscard(as18, fn2, batching, false, n), succeed(array8));
});
var fork2 = (self) => withFiberRuntime((state, status3) => succeed(unsafeFork2(self, state, status3.runtimeFlags)));
var forkDaemon2 = (self) => forkWithScopeOverride(self, globalScope);
var forkWithErrorHandler = dual(2, (self, handler) => fork2(onError(self, (cause3) => {
  const either14 = failureOrCause(cause3);
  switch (either14._tag) {
    case "Left":
      return handler(either14.left);
    case "Right":
      return failCause(either14.right);
  }
})));
var unsafeFork2 = (effect4, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childFiber = unsafeMakeChildFiber(effect4, parentFiber, parentRuntimeFlags, overrideScope);
  childFiber.resume(effect4);
  return childFiber;
};
var unsafeForkUnstarted = (effect4, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childFiber = unsafeMakeChildFiber(effect4, parentFiber, parentRuntimeFlags, overrideScope);
  return childFiber;
};
var unsafeMakeChildFiber = (effect4, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childId = unsafeMake3();
  const parentFiberRefs = parentFiber.getFiberRefs();
  const childFiberRefs = forkAs(parentFiberRefs, childId);
  const childFiber = new FiberRuntime(childId, childFiberRefs, parentRuntimeFlags);
  const childContext = getOrDefault(childFiberRefs, currentContext);
  const supervisor = childFiber.currentSupervisor;
  supervisor.onStart(childContext, effect4, some3(parentFiber), childFiber);
  childFiber.addObserver((exit4) => supervisor.onEnd(exit4, childFiber));
  const parentScope = overrideScope !== null ? overrideScope : pipe(parentFiber.getFiberRef(currentForkScopeOverride), getOrElse2(() => parentFiber.scope()));
  parentScope.add(parentRuntimeFlags, childFiber);
  return childFiber;
};
var forkWithScopeOverride = (self, scopeOverride) => withFiberRuntime((parentFiber, parentStatus) => succeed(unsafeFork2(self, parentFiber, parentStatus.runtimeFlags, scopeOverride)));
var mergeAll3 = dual((args2) => isFunction2(args2[2]), (elements, zero3, f, options) => matchSimple(options?.concurrency, () => fromIterable2(elements).reduce((acc, a, i) => zipWith6(acc, a, (acc2, a2) => f(acc2, a2, i)), succeed(zero3)), () => flatMap12(make37(zero3), (acc) => flatMap12(forEach15(elements, (effect4, i) => flatMap12(effect4, (a) => update4(acc, (b) => f(b, a, i))), options), () => get13(acc)))));
var partition8 = dual((args2) => isIterable(args2[0]), (elements, f, options) => pipe(forEach15(elements, (a, i) => either3(f(a, i)), options), map14((chunk7) => partitionMap6(chunk7, identity))));
var validateAll = dual((args2) => isIterable(args2[0]), (elements, f, options) => flatMap12(partition8(elements, f, {
  concurrency: options?.concurrency,
  batching: options?.batching,
  concurrentFinalizers: options?.concurrentFinalizers
}), ([es, bs]) => isNonEmptyArray2(es) ? fail2(es) : options?.discard ? void_3 : succeed(bs)));
var raceAll2 = (all16) => {
  const list = fromIterable3(all16);
  if (!isNonEmpty2(list)) {
    return dieSync(() => new IllegalArgumentException(`Received an empty collection of effects`));
  }
  const self = headNonEmpty2(list);
  const effects = tailNonEmpty2(list);
  const inheritAll3 = (res) => pipe(inheritAll(res[1]), as3(res[0]));
  return pipe(deferredMake(), flatMap12((done17) => pipe(make37(effects.length), flatMap12((fails) => uninterruptibleMask((restore) => pipe(fork2(interruptible2(self)), flatMap12((head13) => pipe(effects, forEachSequential((effect4) => fork2(interruptible2(effect4))), map14((fibers2) => unsafeFromArray(fibers2)), map14((tail5) => pipe(tail5, prepend3(head13))), tap2((fibers2) => pipe(fibers2, reduce3(void_3, (effect4, fiber) => pipe(effect4, zipRight2(pipe(_await2(fiber), flatMap12(raceAllArbiter(fibers2, fiber, done17, fails)), fork2, asVoid2)))))), flatMap12((fibers2) => pipe(restore(pipe(_await(done17), flatMap12(inheritAll3))), onInterrupt(() => pipe(fibers2, reduce3(void_3, (effect4, fiber) => pipe(effect4, zipLeft2(interruptFiber(fiber))))))))))))))));
};
var raceAllArbiter = (fibers2, winner, deferred, fails) => (exit4) => exitMatchEffect(exit4, {
  onFailure: (cause3) => pipe(modify8(fails, (fails2) => [fails2 === 0 ? pipe(deferredFailCause(deferred, cause3), asVoid2) : void_3, fails2 - 1]), flatten8),
  onSuccess: (value10) => pipe(deferredSucceed(deferred, [value10, winner]), flatMap12((set26) => set26 ? pipe(fromIterable3(fibers2), reduce3(void_3, (effect4, fiber) => fiber === winner ? effect4 : pipe(effect4, zipLeft2(interruptFiber(fiber))))) : void_3))
});
var reduceEffect = dual((args2) => isIterable(args2[0]) && !isEffect(args2[0]), (elements, zero3, f, options) => matchSimple(options?.concurrency, () => fromIterable2(elements).reduce((acc, a, i) => zipWith6(acc, a, (acc2, a2) => f(acc2, a2, i)), zero3), () => suspend(() => pipe(mergeAll3([zero3, ...elements], none2(), (acc, elem, i) => {
  switch (acc._tag) {
    case "None": {
      return some3(elem);
    }
    case "Some": {
      return some3(f(acc.value, elem, i));
    }
  }
}, options), map14((option11) => {
  switch (option11._tag) {
    case "None": {
      throw new Error("BUG: Effect.reduceEffect - please report an issue at https://github.com/Effect-TS/effect/issues");
    }
    case "Some": {
      return option11.value;
    }
  }
})))));
var parallelFinalizers = (self) => contextWithEffect((context15) => match2(getOption2(context15, scopeTag), {
  onNone: () => self,
  onSome: (scope6) => {
    switch (scope6.strategy._tag) {
      case "Parallel":
        return self;
      case "Sequential":
      case "ParallelN":
        return flatMap12(scopeFork(scope6, parallel3), (inner) => scopeExtend(self, inner));
    }
  }
}));
var parallelNFinalizers = (parallelism) => (self) => contextWithEffect((context15) => match2(getOption2(context15, scopeTag), {
  onNone: () => self,
  onSome: (scope6) => {
    if (scope6.strategy._tag === "ParallelN" && scope6.strategy.parallelism === parallelism) {
      return self;
    }
    return flatMap12(scopeFork(scope6, parallelN2(parallelism)), (inner) => scopeExtend(self, inner));
  }
}));
var finalizersMask = (strategy) => (self) => finalizersMaskInternal(strategy, true)(self);
var finalizersMaskInternal = (strategy, concurrentFinalizers) => (self) => contextWithEffect((context15) => match2(getOption2(context15, scopeTag), {
  onNone: () => self(identity),
  onSome: (scope6) => {
    if (concurrentFinalizers === true) {
      const patch14 = strategy._tag === "Parallel" ? parallelFinalizers : strategy._tag === "Sequential" ? sequentialFinalizers : parallelNFinalizers(strategy.parallelism);
      switch (scope6.strategy._tag) {
        case "Parallel":
          return patch14(self(parallelFinalizers));
        case "Sequential":
          return patch14(self(sequentialFinalizers));
        case "ParallelN":
          return patch14(self(parallelNFinalizers(scope6.strategy.parallelism)));
      }
    } else {
      return self(identity);
    }
  }
}));
var scopeWith = (f) => flatMap12(scopeTag, f);
var scopedWith = (f) => flatMap12(scopeMake2(), (scope6) => onExit(f(scope6), (exit4) => scope6.close(exit4)));
var scopedEffect = (effect4) => flatMap12(scopeMake2(), (scope6) => scopeUse(effect4, scope6));
var sequentialFinalizers = (self) => contextWithEffect((context15) => match2(getOption2(context15, scopeTag), {
  onNone: () => self,
  onSome: (scope6) => {
    switch (scope6.strategy._tag) {
      case "Sequential":
        return self;
      case "Parallel":
      case "ParallelN":
        return flatMap12(scopeFork(scope6, sequential3), (inner) => scopeExtend(self, inner));
    }
  }
}));
var tagMetricsScoped = (key, value10) => labelMetricsScoped([make39(key, value10)]);
var labelMetricsScoped = (labels) => fiberRefLocallyScopedWith(currentMetricLabels, (old) => union2(old, labels));
var using = dual(2, (self, use2) => scopedWith((scope6) => flatMap12(scopeExtend(self, scope6), use2)));
var validate = dual((args2) => isEffect(args2[1]), (self, that, options) => validateWith(self, that, (a, b) => [a, b], options));
var validateWith = dual((args2) => isEffect(args2[1]), (self, that, f, options) => flatten8(zipWithOptions(exit(self), exit(that), (ea, eb) => exitZipWith(ea, eb, {
  onSuccess: f,
  onFailure: (ca, cb) => options?.concurrent ? parallel(ca, cb) : sequential(ca, cb)
}), options)));
var validateAllPar = dual(2, (elements, f) => flatMap12(partition8(elements, f), ([es, bs]) => es.length === 0 ? succeed(bs) : fail2(es)));
var validateAllParDiscard = dual(2, (elements, f) => flatMap12(partition8(elements, f), ([es, _]) => es.length === 0 ? void_3 : fail2(es)));
var validateFirst = dual((args2) => isIterable(args2[0]), (elements, f, options) => flip3(forEach15(elements, (a, i) => flip3(f(a, i)), options)));
var withClockScoped = (c) => fiberRefLocallyScopedWith(currentServices, add2(clockTag, c));
var withRandomScoped = (value10) => fiberRefLocallyScopedWith(currentServices, add2(randomTag, value10));
var withConfigProviderScoped = (provider) => fiberRefLocallyScopedWith(currentServices, add2(configProviderTag, provider));
var withEarlyRelease = (self) => scopeWith((parent) => flatMap12(scopeFork(parent, sequential2), (child) => pipe(self, scopeExtend(child), map14((value10) => [fiberIdWith((fiberId5) => scopeClose(child, exitInterrupt(fiberId5))), value10]))));
var zipOptions = dual((args2) => isEffect(args2[1]), (self, that, options) => zipWithOptions(self, that, (a, b) => [a, b], options));
var zipLeftOptions = dual((args2) => isEffect(args2[1]), (self, that, options) => {
  if (options?.concurrent !== true && (options?.batching === void 0 || options.batching === false)) {
    return zipLeft2(self, that);
  }
  return zipWithOptions(self, that, (a, _) => a, options);
});
var zipRightOptions = dual((args2) => isEffect(args2[1]), (self, that, options) => {
  if (options?.concurrent !== true && (options?.batching === void 0 || options.batching === false)) {
    return zipRight2(self, that);
  }
  return zipWithOptions(self, that, (_, b) => b, options);
});
var zipWithOptions = dual((args2) => isEffect(args2[1]), (self, that, f, options) => map14(all9([self, that], {
  concurrency: options?.concurrent ? 2 : 1,
  batching: options?.batching,
  concurrentFinalizers: options?.concurrentFinalizers
}), ([a, a2]) => f(a, a2)));
var withRuntimeFlagsScoped = (update18) => {
  if (update18 === empty20) {
    return void_3;
  }
  return pipe(runtimeFlags, flatMap12((runtimeFlags2) => {
    const updatedRuntimeFlags = patch7(runtimeFlags2, update18);
    const revertRuntimeFlags = diff7(updatedRuntimeFlags, runtimeFlags2);
    return pipe(updateRuntimeFlags(update18), zipRight2(addFinalizer2(() => updateRuntimeFlags(revertRuntimeFlags))), asVoid2);
  }), uninterruptible);
};
var scopeTag = GenericTag("effect/Scope");
var scope2 = scopeTag;
var scopeUnsafeAddFinalizer = (scope6, fin) => {
  if (scope6.state._tag === "Open") {
    scope6.state.finalizers.set({}, fin);
  }
};
var ScopeImplProto = {
  [ScopeTypeId]: ScopeTypeId,
  [CloseableScopeTypeId]: CloseableScopeTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  fork(strategy) {
    return sync(() => {
      const newScope = scopeUnsafeMake2(strategy);
      if (this.state._tag === "Closed") {
        newScope.state = this.state;
        return newScope;
      }
      const key = {};
      const fin = (exit4) => newScope.close(exit4);
      this.state.finalizers.set(key, fin);
      scopeUnsafeAddFinalizer(newScope, (_) => sync(() => {
        if (this.state._tag === "Open") {
          this.state.finalizers.delete(key);
        }
      }));
      return newScope;
    });
  },
  close(exit4) {
    return suspend(() => {
      if (this.state._tag === "Closed") {
        return void_3;
      }
      const finalizers = Array.from(this.state.finalizers.values()).reverse();
      this.state = {
        _tag: "Closed",
        exit: exit4
      };
      if (finalizers.length === 0) {
        return void_3;
      }
      return isSequential(this.strategy) ? pipe(forEachSequential(finalizers, (fin) => exit(fin(exit4))), flatMap12((results) => pipe(exitCollectAll(results), map2(exitAsVoid), getOrElse2(() => exitVoid)))) : isParallel(this.strategy) ? pipe(forEachParUnbounded(finalizers, (fin) => exit(fin(exit4)), false), flatMap12((results) => pipe(exitCollectAll(results, {
        parallel: true
      }), map2(exitAsVoid), getOrElse2(() => exitVoid)))) : pipe(forEachParN(finalizers, this.strategy.parallelism, (fin) => exit(fin(exit4)), false), flatMap12((results) => pipe(exitCollectAll(results, {
        parallel: true
      }), map2(exitAsVoid), getOrElse2(() => exitVoid))));
    });
  },
  addFinalizer(fin) {
    return suspend(() => {
      if (this.state._tag === "Closed") {
        return fin(this.state.exit);
      }
      this.state.finalizers.set({}, fin);
      return void_3;
    });
  }
};
var scopeUnsafeMake2 = (strategy = sequential2) => {
  const scope6 = Object.create(ScopeImplProto);
  scope6.strategy = strategy;
  scope6.state = {
    _tag: "Open",
    finalizers: /* @__PURE__ */ new Map()
  };
  return scope6;
};
var scopeMake2 = (strategy = sequential2) => sync(() => scopeUnsafeMake2(strategy));
var scopeExtend = dual(2, (effect4, scope6) => mapInputContext(
  effect4,
  // @ts-expect-error
  merge3(make8(scopeTag, scope6))
));
var scopeUse = dual(2, (effect4, scope6) => pipe(effect4, scopeExtend(scope6), onExit((exit4) => scope6.close(exit4))));
var fiberRefUnsafeMakeSupervisor = (initial) => fiberRefUnsafeMakePatch(initial, {
  differ: differ2,
  fork: empty34
});
var fiberRefLocallyScoped = dual(2, (self, value10) => asVoid2(acquireRelease2(flatMap12(fiberRefGet(self), (oldValue) => as3(fiberRefSet(self, value10), oldValue)), (oldValue) => fiberRefSet(self, oldValue))));
var fiberRefLocallyScopedWith = dual(2, (self, f) => fiberRefGetWith(self, (a) => fiberRefLocallyScoped(self, f(a))));
var fiberRefMake = (initial, options) => fiberRefMakeWith(() => fiberRefUnsafeMake(initial, options));
var fiberRefMakeWith = (ref) => acquireRelease2(tap2(sync(ref), (ref2) => fiberRefUpdate(ref2, identity)), (fiberRef) => fiberRefDelete(fiberRef));
var fiberRefMakeContext = (initial) => fiberRefMakeWith(() => fiberRefUnsafeMakeContext(initial));
var fiberRefMakeRuntimeFlags = (initial) => fiberRefMakeWith(() => fiberRefUnsafeMakeRuntimeFlags(initial));
var currentRuntimeFlags = fiberRefUnsafeMakeRuntimeFlags(none5);
var currentSupervisor = fiberRefUnsafeMakeSupervisor(none8);
var fiberAwaitAll = (fibers2) => forEach15(fibers2, _await2);
var fiberAll = (fibers2) => {
  const _fiberAll = {
    ...CommitPrototype2,
    commit() {
      return join3(this);
    },
    [FiberTypeId]: fiberVariance2,
    id: () => fromIterable2(fibers2).reduce((id3, fiber) => combine5(id3, fiber.id()), none4),
    await: exit(forEachParUnbounded(fibers2, (fiber) => flatten8(fiber.await), false)),
    children: map14(forEachParUnbounded(fibers2, (fiber) => fiber.children, false), flatten3),
    inheritAll: forEachSequentialDiscard(fibers2, (fiber) => fiber.inheritAll),
    poll: map14(forEachSequential(fibers2, (fiber) => fiber.poll), reduceRight(some3(exitSucceed(new Array())), (optionB, optionA) => {
      switch (optionA._tag) {
        case "None": {
          return none2();
        }
        case "Some": {
          switch (optionB._tag) {
            case "None": {
              return none2();
            }
            case "Some": {
              return some3(exitZipWith(optionA.value, optionB.value, {
                onSuccess: (a, chunk7) => [a, ...chunk7],
                onFailure: parallel
              }));
            }
          }
        }
      }
    })),
    interruptAsFork: (fiberId5) => forEachSequentialDiscard(fibers2, (fiber) => fiber.interruptAsFork(fiberId5))
  };
  return _fiberAll;
};
var fiberInterruptFork = (self) => asVoid2(forkDaemon2(interruptFiber(self)));
var fiberJoinAll = (fibers2) => join3(fiberAll(fibers2));
var fiberScoped = (self) => acquireRelease2(succeed(self), interruptFiber);
var raceWith = dual(3, (self, other, options) => raceFibersWith(self, other, {
  onSelfWin: (winner, loser) => flatMap12(winner.await, (exit4) => {
    switch (exit4._tag) {
      case OP_SUCCESS: {
        return flatMap12(winner.inheritAll, () => options.onSelfDone(exit4, loser));
      }
      case OP_FAILURE: {
        return options.onSelfDone(exit4, loser);
      }
    }
  }),
  onOtherWin: (winner, loser) => flatMap12(winner.await, (exit4) => {
    switch (exit4._tag) {
      case OP_SUCCESS: {
        return flatMap12(winner.inheritAll, () => options.onOtherDone(exit4, loser));
      }
      case OP_FAILURE: {
        return options.onOtherDone(exit4, loser);
      }
    }
  })
}));
var disconnect = (self) => uninterruptibleMask((restore) => fiberIdWith((fiberId5) => flatMap12(forkDaemon2(restore(self)), (fiber) => pipe(restore(join3(fiber)), onInterrupt(() => pipe(fiber, interruptAsFork(fiberId5)))))));
var race2 = dual(2, (self, that) => fiberIdWith((parentFiberId) => raceWith(self, that, {
  onSelfDone: (exit4, right3) => exitMatchEffect(exit4, {
    onFailure: (cause3) => pipe(join3(right3), mapErrorCause2((cause22) => parallel(cause3, cause22))),
    onSuccess: (value10) => pipe(right3, interruptAsFiber(parentFiberId), as3(value10))
  }),
  onOtherDone: (exit4, left3) => exitMatchEffect(exit4, {
    onFailure: (cause3) => pipe(join3(left3), mapErrorCause2((cause22) => parallel(cause22, cause3))),
    onSuccess: (value10) => pipe(left3, interruptAsFiber(parentFiberId), as3(value10))
  })
})));
var raceFibersWith = dual(3, (self, other, options) => withFiberRuntime((parentFiber, parentStatus) => {
  const parentRuntimeFlags = parentStatus.runtimeFlags;
  const raceIndicator = make15(true);
  const leftFiber = unsafeMakeChildFiber(self, parentFiber, parentRuntimeFlags, options.selfScope);
  const rightFiber = unsafeMakeChildFiber(other, parentFiber, parentRuntimeFlags, options.otherScope);
  return async_((cb) => {
    leftFiber.addObserver(() => completeRace(leftFiber, rightFiber, options.onSelfWin, raceIndicator, cb));
    rightFiber.addObserver(() => completeRace(rightFiber, leftFiber, options.onOtherWin, raceIndicator, cb));
    leftFiber.startFork(self);
    rightFiber.startFork(other);
  }, combine5(leftFiber.id(), rightFiber.id()));
}));
var completeRace = (winner, loser, cont, ab, cb) => {
  if (compareAndSet(true, false)(ab)) {
    cb(cont(winner, loser));
  }
};
var ensuring2 = dual(2, (self, finalizer3) => uninterruptibleMask((restore) => matchCauseEffect(restore(self), {
  onFailure: (cause1) => matchCauseEffect(finalizer3, {
    onFailure: (cause22) => failCause(sequential(cause1, cause22)),
    onSuccess: () => failCause(cause1)
  }),
  onSuccess: (a) => as3(finalizer3, a)
})));
var invokeWithInterrupt = (self, entries7, onInterrupt4) => fiberIdWith((id3) => flatMap12(flatMap12(forkDaemon2(interruptible2(self)), (processing) => async_((cb) => {
  const counts = entries7.map((_) => _.listeners.count);
  const checkDone = () => {
    if (counts.every((count9) => count9 === 0)) {
      if (entries7.every((_) => {
        if (_.result.state.current._tag === "Pending") {
          return true;
        } else if (_.result.state.current._tag === "Done" && exitIsExit(_.result.state.current.effect) && _.result.state.current.effect._tag === "Failure" && isInterrupted(_.result.state.current.effect.cause)) {
          return true;
        } else {
          return false;
        }
      })) {
        cleanup.forEach((f) => f());
        onInterrupt4?.();
        cb(interruptFiber(processing));
      }
    }
  };
  processing.addObserver((exit4) => {
    cleanup.forEach((f) => f());
    cb(exit4);
  });
  const cleanup = entries7.map((r, i) => {
    const observer = (count9) => {
      counts[i] = count9;
      checkDone();
    };
    r.listeners.addObserver(observer);
    return () => r.listeners.removeObserver(observer);
  });
  checkDone();
  return sync(() => {
    cleanup.forEach((f) => f());
  });
})), () => suspend(() => {
  const residual = entries7.flatMap((entry) => {
    if (!entry.state.completed) {
      return [entry];
    }
    return [];
  });
  return forEachSequentialDiscard(residual, (entry) => complete2(entry.request, exitInterrupt(id3)));
})));
var interruptWhenPossible = dual(2, (self, all16) => fiberRefGetWith(currentRequestMap, (map49) => suspend(() => {
  const entries7 = fromIterable2(all16).flatMap((_) => map49.has(_) ? [map49.get(_)] : []);
  return invokeWithInterrupt(self, entries7);
})));
var makeSpanScoped = (name, options) => {
  options = addSpanStackTrace(options);
  return uninterruptible(withFiberRuntime((fiber) => {
    const scope6 = unsafeGet3(fiber.getFiberRef(currentContext), scopeTag);
    const span4 = unsafeMakeSpan(fiber, name, options);
    const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
    const clock_ = get4(fiber.getFiberRef(currentServices), clockTag);
    return as3(scopeAddFinalizerExit(scope6, (exit4) => endSpan(span4, exit4, clock_, timingEnabled)), span4);
  }));
};
var withTracerScoped = (value10) => fiberRefLocallyScopedWith(currentServices, add2(tracerTag, value10));
var withSpanScoped = function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self = arguments[0];
    return flatMap12(makeSpanScoped(name, addSpanStackTrace(options)), (span4) => provideService(self, spanTag, span4));
  }
  return (self) => flatMap12(makeSpanScoped(name, addSpanStackTrace(options)), (span4) => provideService(self, spanTag, span4));
};

// ../../node_modules/effect/dist/esm/internal/cache.js
var complete3 = (key, exit4, entryStats, timeToLiveMillis) => struct4({
  _tag: "Complete",
  key,
  exit: exit4,
  entryStats,
  timeToLiveMillis
});
var pending2 = (key, deferred) => struct4({
  _tag: "Pending",
  key,
  deferred
});
var refreshing = (deferred, complete6) => struct4({
  _tag: "Refreshing",
  deferred,
  complete: complete6
});
var MapKeyTypeId = Symbol.for("effect/Cache/MapKey");
var MapKeyImpl = class {
  current;
  [MapKeyTypeId] = MapKeyTypeId;
  previous = void 0;
  next = void 0;
  constructor(current2) {
    this.current = current2;
  }
  [symbol2]() {
    return pipe(hash(this.current), combine2(hash(this.previous)), combine2(hash(this.next)), cached(this));
  }
  [symbol3](that) {
    if (this === that) {
      return true;
    }
    return isMapKey(that) && equals(this.current, that.current) && equals(this.previous, that.previous) && equals(this.next, that.next);
  }
};
var makeMapKey = (current2) => new MapKeyImpl(current2);
var isMapKey = (u) => hasProperty(u, MapKeyTypeId);
var KeySetImpl = class {
  head = void 0;
  tail = void 0;
  add(key) {
    if (key !== this.tail) {
      if (this.tail === void 0) {
        this.head = key;
        this.tail = key;
      } else {
        const previous2 = key.previous;
        const next6 = key.next;
        if (next6 !== void 0) {
          key.next = void 0;
          if (previous2 !== void 0) {
            previous2.next = next6;
            next6.previous = previous2;
          } else {
            this.head = next6;
            this.head.previous = void 0;
          }
        }
        this.tail.next = key;
        key.previous = this.tail;
        this.tail = key;
      }
    }
  }
  remove() {
    const key = this.head;
    if (key !== void 0) {
      const next6 = key.next;
      if (next6 !== void 0) {
        key.next = void 0;
        this.head = next6;
        this.head.previous = void 0;
      } else {
        this.head = void 0;
        this.tail = void 0;
      }
    }
    return key;
  }
};
var makeKeySet = () => new KeySetImpl();
var makeCacheState = (map49, keys15, accesses, updating, hits, misses) => ({
  map: map49,
  keys: keys15,
  accesses,
  updating,
  hits,
  misses
});
var initialCacheState = () => makeCacheState(empty23(), makeKeySet(), unbounded(), make15(false), 0, 0);
var CacheSymbolKey = "effect/Cache";
var CacheTypeId = Symbol.for(CacheSymbolKey);
var cacheVariance = {
  /* c8 ignore next */
  _Key: (_) => _,
  /* c8 ignore next */
  _Error: (_) => _,
  /* c8 ignore next */
  _Value: (_) => _
};
var ConsumerCacheSymbolKey = "effect/ConsumerCache";
var ConsumerCacheTypeId = Symbol.for(ConsumerCacheSymbolKey);
var consumerCacheVariance = {
  /* c8 ignore next */
  _Key: (_) => _,
  /* c8 ignore next */
  _Error: (_) => _,
  /* c8 ignore next */
  _Value: (_) => _
};
var makeCacheStats = (options) => options;
var makeEntryStats = (loadedMillis) => ({
  loadedMillis
});
var CacheImpl = class {
  capacity;
  context;
  fiberId;
  lookup;
  timeToLive;
  [CacheTypeId] = cacheVariance;
  [ConsumerCacheTypeId] = consumerCacheVariance;
  cacheState;
  constructor(capacity10, context15, fiberId5, lookup, timeToLive) {
    this.capacity = capacity10;
    this.context = context15;
    this.fiberId = fiberId5;
    this.lookup = lookup;
    this.timeToLive = timeToLive;
    this.cacheState = initialCacheState();
  }
  get(key) {
    return map14(this.getEither(key), merge);
  }
  get cacheStats() {
    return sync(() => makeCacheStats({
      hits: this.cacheState.hits,
      misses: this.cacheState.misses,
      size: size10(this.cacheState.map)
    }));
  }
  getOption(key) {
    return suspend(() => match2(get9(this.cacheState.map, key), {
      onNone: () => {
        const mapKey = makeMapKey(key);
        this.trackAccess(mapKey);
        this.trackMiss();
        return succeed(none2());
      },
      onSome: (value10) => this.resolveMapValue(value10)
    }));
  }
  getOptionComplete(key) {
    return suspend(() => match2(get9(this.cacheState.map, key), {
      onNone: () => {
        const mapKey = makeMapKey(key);
        this.trackAccess(mapKey);
        this.trackMiss();
        return succeed(none2());
      },
      onSome: (value10) => this.resolveMapValue(value10, true)
    }));
  }
  contains(key) {
    return sync(() => has6(this.cacheState.map, key));
  }
  entryStats(key) {
    return sync(() => {
      const option11 = get9(this.cacheState.map, key);
      if (isSome2(option11)) {
        switch (option11.value._tag) {
          case "Complete": {
            const loaded = option11.value.entryStats.loadedMillis;
            return some3(makeEntryStats(loaded));
          }
          case "Pending": {
            return none2();
          }
          case "Refreshing": {
            const loaded = option11.value.complete.entryStats.loadedMillis;
            return some3(makeEntryStats(loaded));
          }
        }
      }
      return none2();
    });
  }
  getEither(key) {
    return suspend(() => {
      const k = key;
      let mapKey = void 0;
      let deferred = void 0;
      let value10 = getOrUndefined2(get9(this.cacheState.map, k));
      if (value10 === void 0) {
        deferred = unsafeMake4(this.fiberId);
        mapKey = makeMapKey(k);
        if (has6(this.cacheState.map, k)) {
          value10 = getOrUndefined2(get9(this.cacheState.map, k));
        } else {
          set5(this.cacheState.map, k, pending2(mapKey, deferred));
        }
      }
      if (value10 === void 0) {
        this.trackAccess(mapKey);
        this.trackMiss();
        return map14(this.lookupValueOf(key, deferred), right2);
      } else {
        return flatMap12(this.resolveMapValue(value10), match2({
          onNone: () => this.getEither(key),
          onSome: (value11) => succeed(left2(value11))
        }));
      }
    });
  }
  invalidate(key) {
    return sync(() => {
      remove8(this.cacheState.map, key);
    });
  }
  invalidateWhen(key, when10) {
    return sync(() => {
      const value10 = get9(this.cacheState.map, key);
      if (isSome2(value10) && value10.value._tag === "Complete") {
        if (value10.value.exit._tag === "Success") {
          if (when10(value10.value.exit.value)) {
            remove8(this.cacheState.map, key);
          }
        }
      }
    });
  }
  get invalidateAll() {
    return sync(() => {
      this.cacheState.map = empty23();
    });
  }
  refresh(key) {
    return clockWith3((clock3) => suspend(() => {
      const k = key;
      const deferred = unsafeMake4(this.fiberId);
      let value10 = getOrUndefined2(get9(this.cacheState.map, k));
      if (value10 === void 0) {
        if (has6(this.cacheState.map, k)) {
          value10 = getOrUndefined2(get9(this.cacheState.map, k));
        } else {
          set5(this.cacheState.map, k, pending2(makeMapKey(k), deferred));
        }
      }
      if (value10 === void 0) {
        return asVoid2(this.lookupValueOf(key, deferred));
      } else {
        switch (value10._tag) {
          case "Complete": {
            if (this.hasExpired(clock3, value10.timeToLiveMillis)) {
              const found = getOrUndefined2(get9(this.cacheState.map, k));
              if (equals(found, value10)) {
                remove8(this.cacheState.map, k);
              }
              return asVoid2(this.get(key));
            }
            return pipe(this.lookupValueOf(key, deferred), when(() => {
              const current2 = getOrUndefined2(get9(this.cacheState.map, k));
              if (equals(current2, value10)) {
                const mapValue = refreshing(deferred, value10);
                set5(this.cacheState.map, k, mapValue);
                return true;
              }
              return false;
            }), asVoid2);
          }
          case "Pending": {
            return _await(value10.deferred);
          }
          case "Refreshing": {
            return _await(value10.deferred);
          }
        }
      }
    }));
  }
  set(key, value10) {
    return clockWith3((clock3) => sync(() => {
      const now3 = clock3.unsafeCurrentTimeMillis();
      const k = key;
      const lookupResult = succeed3(value10);
      const mapValue = complete3(makeMapKey(k), lookupResult, makeEntryStats(now3), now3 + toMillis(decode(this.timeToLive(lookupResult))));
      set5(this.cacheState.map, k, mapValue);
    }));
  }
  get size() {
    return sync(() => {
      return size10(this.cacheState.map);
    });
  }
  get values() {
    return sync(() => {
      const values15 = [];
      for (const entry of this.cacheState.map) {
        if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
          values15.push(entry[1].exit.value);
        }
      }
      return values15;
    });
  }
  get entries() {
    return sync(() => {
      const values15 = [];
      for (const entry of this.cacheState.map) {
        if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
          values15.push([entry[0], entry[1].exit.value]);
        }
      }
      return values15;
    });
  }
  get keys() {
    return sync(() => {
      const keys15 = [];
      for (const entry of this.cacheState.map) {
        if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
          keys15.push(entry[0]);
        }
      }
      return keys15;
    });
  }
  resolveMapValue(value10, ignorePending = false) {
    return clockWith3((clock3) => {
      switch (value10._tag) {
        case "Complete": {
          this.trackAccess(value10.key);
          if (this.hasExpired(clock3, value10.timeToLiveMillis)) {
            remove8(this.cacheState.map, value10.key.current);
            return succeed(none2());
          }
          this.trackHit();
          return map14(value10.exit, some3);
        }
        case "Pending": {
          this.trackAccess(value10.key);
          this.trackHit();
          if (ignorePending) {
            return succeed(none2());
          }
          return map14(_await(value10.deferred), some3);
        }
        case "Refreshing": {
          this.trackAccess(value10.complete.key);
          this.trackHit();
          if (this.hasExpired(clock3, value10.complete.timeToLiveMillis)) {
            if (ignorePending) {
              return succeed(none2());
            }
            return map14(_await(value10.deferred), some3);
          }
          return map14(value10.complete.exit, some3);
        }
      }
    });
  }
  trackHit() {
    this.cacheState.hits = this.cacheState.hits + 1;
  }
  trackMiss() {
    this.cacheState.misses = this.cacheState.misses + 1;
  }
  trackAccess(key) {
    offer(this.cacheState.accesses, key);
    if (compareAndSet(this.cacheState.updating, false, true)) {
      let loop5 = true;
      while (loop5) {
        const key2 = poll2(this.cacheState.accesses, EmptyMutableQueue);
        if (key2 === EmptyMutableQueue) {
          loop5 = false;
        } else {
          this.cacheState.keys.add(key2);
        }
      }
      let size40 = size10(this.cacheState.map);
      loop5 = size40 > this.capacity;
      while (loop5) {
        const key2 = this.cacheState.keys.remove();
        if (key2 !== void 0) {
          if (has6(this.cacheState.map, key2.current)) {
            remove8(this.cacheState.map, key2.current);
            size40 = size40 - 1;
            loop5 = size40 > this.capacity;
          }
        } else {
          loop5 = false;
        }
      }
      set3(this.cacheState.updating, false);
    }
  }
  hasExpired(clock3, timeToLiveMillis) {
    return clock3.unsafeCurrentTimeMillis() > timeToLiveMillis;
  }
  lookupValueOf(input, deferred) {
    return clockWith3((clock3) => suspend(() => {
      const key = input;
      return pipe(this.lookup(input), provideContext(this.context), exit, flatMap12((exit4) => {
        const now3 = clock3.unsafeCurrentTimeMillis();
        const stats = makeEntryStats(now3);
        const value10 = complete3(makeMapKey(key), exit4, stats, now3 + toMillis(decode(this.timeToLive(exit4))));
        set5(this.cacheState.map, key, value10);
        return zipRight2(done2(deferred, exit4), exit4);
      }), onInterrupt(() => zipRight2(interrupt3(deferred), sync(() => {
        remove8(this.cacheState.map, key);
      }))));
    }));
  }
};
var make49 = (options) => {
  const timeToLive = decode(options.timeToLive);
  return makeWith({
    capacity: options.capacity,
    lookup: options.lookup,
    timeToLive: () => timeToLive
  });
};
var makeWith = (options) => map14(all9([context2(), fiberId]), ([context15, fiberId5]) => new CacheImpl(options.capacity, context15, fiberId5, options.lookup, (exit4) => decode(options.timeToLive(exit4))));
var unsafeMakeWith = (capacity10, lookup, timeToLive) => new CacheImpl(capacity10, empty6(), none3, lookup, (exit4) => decode(timeToLive(exit4)));

// ../../node_modules/effect/dist/esm/Cache.js
var CacheTypeId2 = CacheTypeId;
var ConsumerCacheTypeId2 = ConsumerCacheTypeId;
var make50 = make49;
var makeWith2 = makeWith;
var makeCacheStats2 = makeCacheStats;
var makeEntryStats2 = makeEntryStats;

// ../../node_modules/effect/dist/esm/Cause.js
var Cause_exports = {};
__export(Cause_exports, {
  CauseTypeId: () => CauseTypeId2,
  ExceededCapacityException: () => ExceededCapacityException2,
  ExceededCapacityExceptionTypeId: () => ExceededCapacityExceptionTypeId2,
  IllegalArgumentException: () => IllegalArgumentException2,
  IllegalArgumentExceptionTypeId: () => IllegalArgumentExceptionTypeId2,
  InterruptedException: () => InterruptedException2,
  InterruptedExceptionTypeId: () => InterruptedExceptionTypeId2,
  InvalidPubSubCapacityExceptionTypeId: () => InvalidPubSubCapacityExceptionTypeId2,
  NoSuchElementException: () => NoSuchElementException3,
  NoSuchElementExceptionTypeId: () => NoSuchElementExceptionTypeId2,
  RuntimeException: () => RuntimeException2,
  RuntimeExceptionTypeId: () => RuntimeExceptionTypeId2,
  TimeoutException: () => TimeoutException3,
  TimeoutExceptionTypeId: () => TimeoutExceptionTypeId2,
  UnknownException: () => UnknownException2,
  UnknownExceptionTypeId: () => UnknownExceptionTypeId2,
  YieldableError: () => YieldableError3,
  andThen: () => andThen9,
  as: () => as6,
  contains: () => contains6,
  defects: () => defects2,
  die: () => die6,
  dieOption: () => dieOption2,
  empty: () => empty35,
  fail: () => fail8,
  failureOption: () => failureOption2,
  failureOrCause: () => failureOrCause2,
  failures: () => failures2,
  filter: () => filter15,
  find: () => find2,
  flatMap: () => flatMap16,
  flatten: () => flatten11,
  flipCauseOption: () => flipCauseOption2,
  interrupt: () => interrupt6,
  interruptOption: () => interruptOption2,
  interruptors: () => interruptors2,
  isCause: () => isCause2,
  isDie: () => isDie2,
  isDieType: () => isDieType2,
  isEmpty: () => isEmpty11,
  isEmptyType: () => isEmptyType2,
  isExceededCapacityException: () => isExceededCapacityException2,
  isFailType: () => isFailType2,
  isFailure: () => isFailure4,
  isIllegalArgumentException: () => isIllegalArgumentException2,
  isInterruptType: () => isInterruptType2,
  isInterrupted: () => isInterrupted3,
  isInterruptedException: () => isInterruptedException2,
  isInterruptedOnly: () => isInterruptedOnly2,
  isNoSuchElementException: () => isNoSuchElementException2,
  isParallelType: () => isParallelType2,
  isRuntimeException: () => isRuntimeException2,
  isSequentialType: () => isSequentialType2,
  isTimeoutException: () => isTimeoutException2,
  isUnknownException: () => isUnknownException2,
  keepDefects: () => keepDefects2,
  linearize: () => linearize2,
  map: () => map22,
  match: () => match14,
  originalError: () => originalError,
  parallel: () => parallel4,
  pretty: () => pretty3,
  prettyErrors: () => prettyErrors2,
  reduce: () => reduce15,
  reduceWithContext: () => reduceWithContext3,
  sequential: () => sequential4,
  size: () => size14,
  squash: () => squash,
  squashWith: () => squashWith,
  stripFailures: () => stripFailures2,
  stripSomeDefects: () => stripSomeDefects2
});
var CauseTypeId2 = CauseTypeId;
var RuntimeExceptionTypeId2 = RuntimeExceptionTypeId;
var InterruptedExceptionTypeId2 = InterruptedExceptionTypeId;
var IllegalArgumentExceptionTypeId2 = IllegalArgumentExceptionTypeId;
var NoSuchElementExceptionTypeId2 = NoSuchElementExceptionTypeId;
var InvalidPubSubCapacityExceptionTypeId2 = InvalidPubSubCapacityExceptionTypeId;
var ExceededCapacityExceptionTypeId2 = ExceededCapacityExceptionTypeId;
var TimeoutExceptionTypeId2 = TimeoutExceptionTypeId;
var UnknownExceptionTypeId2 = UnknownExceptionTypeId;
var YieldableError3 = YieldableError;
var empty35 = empty22;
var fail8 = fail;
var die6 = die;
var interrupt6 = interrupt;
var parallel4 = parallel;
var sequential4 = sequential;
var isCause2 = isCause;
var isEmptyType2 = isEmptyType;
var isFailType2 = isFailType;
var isDieType2 = isDieType;
var isInterruptType2 = isInterruptType;
var isSequentialType2 = isSequentialType;
var isParallelType2 = isParallelType;
var size14 = size9;
var isEmpty11 = isEmpty7;
var isFailure4 = isFailure;
var isDie2 = isDie;
var isInterrupted3 = isInterrupted;
var isInterruptedOnly2 = isInterruptedOnly;
var failures2 = failures;
var defects2 = defects;
var interruptors2 = interruptors;
var failureOption2 = failureOption;
var failureOrCause2 = failureOrCause;
var flipCauseOption2 = flipCauseOption;
var dieOption2 = dieOption;
var interruptOption2 = interruptOption;
var keepDefects2 = keepDefects;
var linearize2 = linearize;
var stripFailures2 = stripFailures;
var stripSomeDefects2 = stripSomeDefects;
var as6 = as2;
var map22 = map13;
var flatMap16 = flatMap11;
var andThen9 = andThen5;
var flatten11 = flatten7;
var contains6 = contains5;
var squash = causeSquash;
var squashWith = causeSquashWith;
var find2 = find;
var filter15 = filter11;
var match14 = match6;
var reduce15 = reduce11;
var reduceWithContext3 = reduceWithContext;
var InterruptedException2 = InterruptedException;
var isInterruptedException2 = isInterruptedException;
var IllegalArgumentException2 = IllegalArgumentException;
var isIllegalArgumentException2 = isIllegalArgumentException;
var NoSuchElementException3 = NoSuchElementException;
var isNoSuchElementException2 = isNoSuchElementException;
var RuntimeException2 = RuntimeException;
var isRuntimeException2 = isRuntimeException;
var TimeoutException3 = TimeoutException;
var isTimeoutException2 = isTimeoutException;
var UnknownException2 = UnknownException;
var isUnknownException2 = isUnknownException;
var ExceededCapacityException2 = ExceededCapacityException;
var isExceededCapacityException2 = isExceededCapacityException;
var pretty3 = pretty;
var prettyErrors2 = prettyErrors;
var originalError = originalInstance;

// ../../node_modules/effect/dist/esm/Channel.js
var Channel_exports = {};
__export(Channel_exports, {
  ChannelException: () => ChannelException2,
  ChannelExceptionTypeId: () => ChannelExceptionTypeId2,
  ChannelTypeId: () => ChannelTypeId4,
  acquireReleaseOut: () => acquireReleaseOut2,
  acquireUseRelease: () => acquireUseRelease6,
  as: () => as14,
  asVoid: () => asVoid10,
  buffer: () => buffer3,
  bufferChunk: () => bufferChunk2,
  catchAll: () => catchAll9,
  catchAllCause: () => catchAllCause8,
  collect: () => collect4,
  concatAll: () => concatAll3,
  concatAllWith: () => concatAllWith2,
  concatMap: () => concatMap2,
  concatMapWith: () => concatMapWith2,
  concatMapWithCustom: () => concatMapWithCustom2,
  concatOut: () => concatOut2,
  context: () => context11,
  contextWith: () => contextWith7,
  contextWithChannel: () => contextWithChannel2,
  contextWithEffect: () => contextWithEffect6,
  doneCollect: () => doneCollect2,
  drain: () => drain4,
  embedInput: () => embedInput2,
  emitCollect: () => emitCollect2,
  ensuring: () => ensuring10,
  ensuringWith: () => ensuringWith4,
  fail: () => fail20,
  failCause: () => failCause17,
  failCauseSync: () => failCauseSync10,
  failSync: () => failSync11,
  flatMap: () => flatMap24,
  flatten: () => flatten18,
  foldCauseChannel: () => foldCauseChannel2,
  foldChannel: () => foldChannel2,
  fromEffect: () => fromEffect10,
  fromEither: () => fromEither5,
  fromInput: () => fromInput4,
  fromOption: () => fromOption8,
  fromPubSub: () => fromPubSub4,
  fromPubSubScoped: () => fromPubSubScoped2,
  fromQueue: () => fromQueue4,
  identity: () => identity5,
  interruptWhen: () => interruptWhen3,
  interruptWhenDeferred: () => interruptWhenDeferred3,
  isChannel: () => isChannel2,
  isChannelException: () => isChannelException2,
  map: () => map34,
  mapEffect: () => mapEffect8,
  mapError: () => mapError11,
  mapErrorCause: () => mapErrorCause7,
  mapInput: () => mapInput10,
  mapInputContext: () => mapInputContext8,
  mapInputEffect: () => mapInputEffect5,
  mapInputError: () => mapInputError2,
  mapInputErrorEffect: () => mapInputErrorEffect2,
  mapInputIn: () => mapInputIn2,
  mapInputInEffect: () => mapInputInEffect2,
  mapOut: () => mapOut2,
  mapOutEffect: () => mapOutEffect2,
  mapOutEffectPar: () => mapOutEffectPar2,
  mergeAll: () => mergeAll10,
  mergeAllUnbounded: () => mergeAllUnbounded2,
  mergeAllUnboundedWith: () => mergeAllUnboundedWith2,
  mergeAllWith: () => mergeAllWith2,
  mergeMap: () => mergeMap2,
  mergeOut: () => mergeOut2,
  mergeOutWith: () => mergeOutWith2,
  mergeWith: () => mergeWith4,
  never: () => never9,
  orDie: () => orDie9,
  orDieWith: () => orDieWith6,
  orElse: () => orElse14,
  pipeTo: () => pipeTo2,
  pipeToOrFail: () => pipeToOrFail2,
  provideContext: () => provideContext9,
  provideLayer: () => provideLayer3,
  provideService: () => provideService11,
  provideSomeLayer: () => provideSomeLayer4,
  read: () => read2,
  readOrFail: () => readOrFail2,
  readWith: () => readWith2,
  readWithCause: () => readWithCause2,
  repeated: () => repeated2,
  run: () => run5,
  runCollect: () => runCollect3,
  runDrain: () => runDrain3,
  runScoped: () => runScoped3,
  scoped: () => scoped8,
  scopedWith: () => scopedWith5,
  splitLines: () => splitLines3,
  succeed: () => succeed21,
  suspend: () => suspend11,
  sync: () => sync15,
  toPubSub: () => toPubSub3,
  toPull: () => toPull3,
  toPullIn: () => toPullIn2,
  toQueue: () => toQueue3,
  toSink: () => toSink,
  toStream: () => toStream,
  unwrap: () => unwrap5,
  unwrapScoped: () => unwrapScoped6,
  unwrapScopedWith: () => unwrapScopedWith4,
  updateService: () => updateService7,
  void: () => void_12,
  withSpan: () => withSpan7,
  write: () => write2,
  writeAll: () => writeAll2,
  writeChunk: () => writeChunk2,
  zip: () => zip17,
  zipLeft: () => zipLeft13,
  zipRight: () => zipRight13
});

// ../../node_modules/effect/dist/esm/Effect.js
var Effect_exports = {};
__export(Effect_exports, {
  Do: () => Do6,
  EffectTypeId: () => EffectTypeId4,
  Service: () => Service,
  Tag: () => Tag3,
  acquireRelease: () => acquireRelease3,
  acquireReleaseInterruptible: () => acquireReleaseInterruptible2,
  acquireUseRelease: () => acquireUseRelease3,
  addFinalizer: () => addFinalizer4,
  all: () => all11,
  allSuccesses: () => allSuccesses2,
  allWith: () => allWith2,
  allowInterrupt: () => allowInterrupt2,
  andThen: () => andThen11,
  annotateCurrentSpan: () => annotateCurrentSpan2,
  annotateLogs: () => annotateLogs3,
  annotateLogsScoped: () => annotateLogsScoped2,
  annotateSpans: () => annotateSpans3,
  ap: () => ap3,
  as: () => as8,
  asSome: () => asSome3,
  asSomeError: () => asSomeError2,
  asVoid: () => asVoid6,
  async: () => async2,
  asyncEffect: () => asyncEffect2,
  awaitAllChildren: () => awaitAllChildren2,
  bind: () => bind7,
  bindAll: () => bindAll2,
  bindTo: () => bindTo7,
  blocked: () => blocked2,
  cacheRequestResult: () => cacheRequestResult,
  cached: () => cached3,
  cachedFunction: () => cachedFunction2,
  cachedInvalidateWithTTL: () => cachedInvalidateWithTTL2,
  cachedWithTTL: () => cachedWithTTL,
  catch: () => _catch2,
  catchAll: () => catchAll4,
  catchAllCause: () => catchAllCause4,
  catchAllDefect: () => catchAllDefect3,
  catchIf: () => catchIf3,
  catchSome: () => catchSome2,
  catchSomeCause: () => catchSomeCause2,
  catchSomeDefect: () => catchSomeDefect2,
  catchTag: () => catchTag3,
  catchTags: () => catchTags2,
  cause: () => cause2,
  checkInterruptible: () => checkInterruptible2,
  clock: () => clock2,
  clockWith: () => clockWith4,
  configProviderWith: () => configProviderWith2,
  console: () => console3,
  consoleWith: () => consoleWith2,
  context: () => context5,
  contextWith: () => contextWith2,
  contextWithEffect: () => contextWithEffect2,
  currentParentSpan: () => currentParentSpan2,
  currentSpan: () => currentSpan2,
  custom: () => custom2,
  daemonChildren: () => daemonChildren2,
  delay: () => delay3,
  descriptor: () => descriptor2,
  descriptorWith: () => descriptorWith2,
  die: () => die8,
  dieMessage: () => dieMessage2,
  dieSync: () => dieSync4,
  diffFiberRefs: () => diffFiberRefs2,
  disconnect: () => disconnect2,
  dropUntil: () => dropUntil2,
  dropWhile: () => dropWhile4,
  either: () => either6,
  ensureErrorType: () => ensureErrorType,
  ensureRequirementsType: () => ensureRequirementsType,
  ensureSuccessType: () => ensureSuccessType,
  ensuring: () => ensuring4,
  ensuringChild: () => ensuringChild2,
  ensuringChildren: () => ensuringChildren2,
  eventually: () => eventually2,
  every: () => every13,
  exists: () => exists4,
  exit: () => exit3,
  fail: () => fail12,
  failCause: () => failCause10,
  failCauseSync: () => failCauseSync5,
  failSync: () => failSync5,
  fiberId: () => fiberId2,
  fiberIdWith: () => fiberIdWith2,
  filter: () => filter16,
  filterEffectOrElse: () => filterEffectOrElse2,
  filterEffectOrFail: () => filterEffectOrFail2,
  filterMap: () => filterMap11,
  filterOrDie: () => filterOrDie2,
  filterOrDieMessage: () => filterOrDieMessage2,
  filterOrElse: () => filterOrElse2,
  filterOrFail: () => filterOrFail3,
  finalizersMask: () => finalizersMask2,
  findFirst: () => findFirst11,
  firstSuccessOf: () => firstSuccessOf2,
  flatMap: () => flatMap18,
  flatten: () => flatten13,
  flip: () => flip5,
  flipWith: () => flipWith2,
  fn: () => fn,
  fnUntraced: () => fnUntraced2,
  forEach: () => forEach16,
  forever: () => forever4,
  fork: () => fork4,
  forkAll: () => forkAll2,
  forkDaemon: () => forkDaemon3,
  forkIn: () => forkIn3,
  forkScoped: () => forkScoped3,
  forkWithErrorHandler: () => forkWithErrorHandler2,
  fromFiber: () => fromFiber2,
  fromFiberEffect: () => fromFiberEffect2,
  fromNullable: () => fromNullable5,
  functionWithSpan: () => functionWithSpan2,
  gen: () => gen6,
  getFiberRefs: () => getFiberRefs,
  getRuntimeFlags: () => getRuntimeFlags,
  head: () => head7,
  if: () => if_2,
  ignore: () => ignore3,
  ignoreLogged: () => ignoreLogged3,
  inheritFiberRefs: () => inheritFiberRefs2,
  interrupt: () => interrupt8,
  interruptWith: () => interruptWith3,
  interruptible: () => interruptible4,
  interruptibleMask: () => interruptibleMask2,
  intoDeferred: () => intoDeferred2,
  isEffect: () => isEffect2,
  isFailure: () => isFailure5,
  isSuccess: () => isSuccess3,
  iterate: () => iterate2,
  labelMetrics: () => labelMetrics2,
  labelMetricsScoped: () => labelMetricsScoped2,
  let: () => let_7,
  liftPredicate: () => liftPredicate5,
  linkSpanCurrent: () => linkSpanCurrent2,
  linkSpans: () => linkSpans2,
  locally: () => locally2,
  locallyScoped: () => locallyScoped,
  locallyScopedWith: () => locallyScopedWith,
  locallyWith: () => locallyWith,
  log: () => log3,
  logAnnotations: () => logAnnotations2,
  logDebug: () => logDebug2,
  logError: () => logError2,
  logFatal: () => logFatal2,
  logInfo: () => logInfo2,
  logTrace: () => logTrace2,
  logWarning: () => logWarning2,
  logWithLevel: () => logWithLevel2,
  loop: () => loop2,
  makeLatch: () => makeLatch2,
  makeSemaphore: () => makeSemaphore2,
  makeSpan: () => makeSpan2,
  makeSpanScoped: () => makeSpanScoped2,
  map: () => map26,
  mapAccum: () => mapAccum4,
  mapBoth: () => mapBoth6,
  mapError: () => mapError5,
  mapErrorCause: () => mapErrorCause4,
  mapInputContext: () => mapInputContext3,
  match: () => match20,
  matchCause: () => matchCause4,
  matchCauseEffect: () => matchCauseEffect3,
  matchEffect: () => matchEffect4,
  merge: () => merge7,
  mergeAll: () => mergeAll5,
  metricLabels: () => metricLabels2,
  negate: () => negate4,
  never: () => never5,
  none: () => none9,
  onError: () => onError3,
  onExit: () => onExit3,
  onInterrupt: () => onInterrupt3,
  once: () => once3,
  option: () => option4,
  optionFromOptional: () => optionFromOptional2,
  orDie: () => orDie4,
  orDieWith: () => orDieWith2,
  orElse: () => orElse8,
  orElseFail: () => orElseFail2,
  orElseSucceed: () => orElseSucceed3,
  parallelErrors: () => parallelErrors2,
  parallelFinalizers: () => parallelFinalizers2,
  partition: () => partition9,
  patchFiberRefs: () => patchFiberRefs2,
  patchRuntimeFlags: () => patchRuntimeFlags,
  promise: () => promise3,
  provide: () => provide2,
  provideService: () => provideService5,
  provideServiceEffect: () => provideServiceEffect3,
  race: () => race3,
  raceAll: () => raceAll3,
  raceFirst: () => raceFirst3,
  raceWith: () => raceWith2,
  random: () => random3,
  randomWith: () => randomWith3,
  reduce: () => reduce17,
  reduceEffect: () => reduceEffect3,
  reduceRight: () => reduceRight5,
  reduceWhile: () => reduceWhile2,
  repeat: () => repeat3,
  repeatN: () => repeatN2,
  repeatOrElse: () => repeatOrElse,
  replicate: () => replicate5,
  replicateEffect: () => replicateEffect3,
  request: () => request,
  retry: () => retry3,
  retryOrElse: () => retryOrElse,
  runCallback: () => runCallback,
  runFork: () => runFork2,
  runPromise: () => runPromise2,
  runPromiseExit: () => runPromiseExit2,
  runRequestBlock: () => runRequestBlock2,
  runSync: () => runSync2,
  runSyncExit: () => runSyncExit2,
  runtime: () => runtime4,
  sandbox: () => sandbox3,
  schedule: () => schedule,
  scheduleForked: () => scheduleForked2,
  scheduleFrom: () => scheduleFrom,
  scope: () => scope4,
  scopeWith: () => scopeWith2,
  scoped: () => scoped4,
  scopedWith: () => scopedWith2,
  sequentialFinalizers: () => sequentialFinalizers2,
  serviceConstants: () => serviceConstants2,
  serviceFunction: () => serviceFunction2,
  serviceFunctionEffect: () => serviceFunctionEffect2,
  serviceFunctions: () => serviceFunctions2,
  serviceMembers: () => serviceMembers2,
  serviceOption: () => serviceOption3,
  serviceOptional: () => serviceOptional2,
  setFiberRefs: () => setFiberRefs2,
  sleep: () => sleep5,
  spanAnnotations: () => spanAnnotations2,
  spanLinks: () => spanLinks2,
  step: () => step3,
  succeed: () => succeed13,
  succeedNone: () => succeedNone3,
  succeedSome: () => succeedSome3,
  summarized: () => summarized2,
  supervised: () => supervised2,
  suspend: () => suspend4,
  sync: () => sync8,
  tagMetrics: () => tagMetrics2,
  tagMetricsScoped: () => tagMetricsScoped2,
  takeUntil: () => takeUntil2,
  takeWhile: () => takeWhile5,
  tap: () => tap5,
  tapBoth: () => tapBoth2,
  tapDefect: () => tapDefect3,
  tapError: () => tapError4,
  tapErrorCause: () => tapErrorCause4,
  tapErrorTag: () => tapErrorTag2,
  timed: () => timed2,
  timedWith: () => timedWith2,
  timeout: () => timeout3,
  timeoutFail: () => timeoutFail2,
  timeoutFailCause: () => timeoutFailCause2,
  timeoutOption: () => timeoutOption3,
  timeoutTo: () => timeoutTo2,
  tracer: () => tracer2,
  tracerWith: () => tracerWith4,
  transplant: () => transplant2,
  transposeMapOption: () => transposeMapOption2,
  transposeOption: () => transposeOption2,
  try: () => try_4,
  tryMap: () => tryMap2,
  tryMapPromise: () => tryMapPromise2,
  tryPromise: () => tryPromise3,
  uninterruptible: () => uninterruptible3,
  uninterruptibleMask: () => uninterruptibleMask3,
  unless: () => unless2,
  unlessEffect: () => unlessEffect2,
  unsafeMakeLatch: () => unsafeMakeLatch2,
  unsafeMakeSemaphore: () => unsafeMakeSemaphore2,
  unsandbox: () => unsandbox2,
  updateFiberRefs: () => updateFiberRefs3,
  updateService: () => updateService3,
  useSpan: () => useSpan2,
  using: () => using2,
  validate: () => validate2,
  validateAll: () => validateAll2,
  validateFirst: () => validateFirst2,
  validateWith: () => validateWith2,
  void: () => _void,
  when: () => when3,
  whenEffect: () => whenEffect2,
  whenFiberRef: () => whenFiberRef2,
  whenLogLevel: () => whenLogLevel2,
  whenRef: () => whenRef2,
  whileLoop: () => whileLoop3,
  withClock: () => withClock2,
  withClockScoped: () => withClockScoped2,
  withConcurrency: () => withConcurrency3,
  withConfigProvider: () => withConfigProvider2,
  withConfigProviderScoped: () => withConfigProviderScoped2,
  withConsole: () => withConsole2,
  withConsoleScoped: () => withConsoleScoped2,
  withEarlyRelease: () => withEarlyRelease2,
  withExecutionPlan: () => withExecutionPlan2,
  withFiberRuntime: () => withFiberRuntime2,
  withLogSpan: () => withLogSpan2,
  withMaxOpsBeforeYield: () => withMaxOpsBeforeYield2,
  withMetric: () => withMetric2,
  withParentSpan: () => withParentSpan3,
  withRandom: () => withRandom2,
  withRandomFixed: () => withRandomFixed,
  withRandomScoped: () => withRandomScoped2,
  withRequestBatching: () => withRequestBatching2,
  withRequestCache: () => withRequestCache2,
  withRequestCaching: () => withRequestCaching2,
  withRuntimeFlagsPatch: () => withRuntimeFlagsPatch,
  withRuntimeFlagsPatchScoped: () => withRuntimeFlagsPatchScoped,
  withScheduler: () => withScheduler2,
  withSchedulingPriority: () => withSchedulingPriority2,
  withSpan: () => withSpan3,
  withSpanScoped: () => withSpanScoped2,
  withTracer: () => withTracer2,
  withTracerEnabled: () => withTracerEnabled2,
  withTracerScoped: () => withTracerScoped2,
  withTracerTiming: () => withTracerTiming2,
  withUnhandledErrorLogLevel: () => withUnhandledErrorLogLevel2,
  yieldNow: () => yieldNow4,
  zip: () => zip12,
  zipLeft: () => zipLeft7,
  zipRight: () => zipRight7,
  zipWith: () => zipWith12
});

// ../../node_modules/effect/dist/esm/ScheduleDecision.js
var ScheduleDecision_exports = {};
__export(ScheduleDecision_exports, {
  continue: () => _continue2,
  continueWith: () => continueWith2,
  done: () => done7,
  isContinue: () => isContinue2,
  isDone: () => isDone5
});

// ../../node_modules/effect/dist/esm/ScheduleIntervals.js
var ScheduleIntervals_exports = {};
__export(ScheduleIntervals_exports, {
  IntervalsTypeId: () => IntervalsTypeId2,
  empty: () => empty39,
  end: () => end2,
  fromIterable: () => fromIterable16,
  intersect: () => intersect4,
  isNonEmpty: () => isNonEmpty6,
  lessThan: () => lessThan12,
  make: () => make54,
  max: () => max10,
  start: () => start2,
  union: () => union12
});

// ../../node_modules/effect/dist/esm/ScheduleInterval.js
var ScheduleInterval_exports = {};
__export(ScheduleInterval_exports, {
  IntervalTypeId: () => IntervalTypeId2,
  after: () => after2,
  before: () => before2,
  empty: () => empty37,
  intersect: () => intersect2,
  isEmpty: () => isEmpty13,
  isNonEmpty: () => isNonEmpty4,
  lessThan: () => lessThan10,
  make: () => make52,
  max: () => max8,
  min: () => min8,
  size: () => size16,
  union: () => union10
});

// ../../node_modules/effect/dist/esm/internal/schedule/interval.js
var IntervalSymbolKey = "effect/ScheduleInterval";
var IntervalTypeId = Symbol.for(IntervalSymbolKey);
var empty36 = {
  [IntervalTypeId]: IntervalTypeId,
  startMillis: 0,
  endMillis: 0
};
var make51 = (startMillis, endMillis) => {
  if (startMillis > endMillis) {
    return empty36;
  }
  return {
    [IntervalTypeId]: IntervalTypeId,
    startMillis,
    endMillis
  };
};
var lessThan9 = dual(2, (self, that) => min7(self, that) === self);
var min7 = dual(2, (self, that) => {
  if (self.endMillis <= that.startMillis) return self;
  if (that.endMillis <= self.startMillis) return that;
  if (self.startMillis < that.startMillis) return self;
  if (that.startMillis < self.startMillis) return that;
  if (self.endMillis <= that.endMillis) return self;
  return that;
});
var max7 = dual(2, (self, that) => min7(self, that) === self ? that : self);
var isEmpty12 = (self) => {
  return self.startMillis >= self.endMillis;
};
var isNonEmpty3 = (self) => {
  return !isEmpty12(self);
};
var intersect = dual(2, (self, that) => {
  const start5 = Math.max(self.startMillis, that.startMillis);
  const end7 = Math.min(self.endMillis, that.endMillis);
  return make51(start5, end7);
});
var size15 = (self) => {
  return millis(self.endMillis - self.startMillis);
};
var union9 = dual(2, (self, that) => {
  const start5 = Math.max(self.startMillis, that.startMillis);
  const end7 = Math.min(self.endMillis, that.endMillis);
  return start5 < end7 ? none2() : some3(make51(start5, end7));
});
var after = (startMilliseconds) => {
  return make51(startMilliseconds, Number.POSITIVE_INFINITY);
};
var before = (endMilliseconds) => {
  return make51(Number.NEGATIVE_INFINITY, endMilliseconds);
};

// ../../node_modules/effect/dist/esm/ScheduleInterval.js
var IntervalTypeId2 = IntervalTypeId;
var make52 = make51;
var empty37 = empty36;
var lessThan10 = lessThan9;
var min8 = min7;
var max8 = max7;
var isEmpty13 = isEmpty12;
var isNonEmpty4 = isNonEmpty3;
var intersect2 = intersect;
var size16 = size15;
var union10 = union9;
var after2 = after;
var before2 = before;

// ../../node_modules/effect/dist/esm/internal/schedule/intervals.js
var IntervalsSymbolKey = "effect/ScheduleIntervals";
var IntervalsTypeId = Symbol.for(IntervalsSymbolKey);
var make53 = (intervals) => {
  return {
    [IntervalsTypeId]: IntervalsTypeId,
    intervals
  };
};
var empty38 = make53(empty7());
var fromIterable15 = (intervals) => Array.from(intervals).reduce((intervals2, interval) => pipe(intervals2, union11(make53(of3(interval)))), empty38);
var union11 = dual(2, (self, that) => {
  if (!isNonEmpty2(that.intervals)) {
    return self;
  }
  if (!isNonEmpty2(self.intervals)) {
    return that;
  }
  if (headNonEmpty2(self.intervals).startMillis < headNonEmpty2(that.intervals).startMillis) {
    return unionLoop(tailNonEmpty2(self.intervals), that.intervals, headNonEmpty2(self.intervals), empty7());
  }
  return unionLoop(self.intervals, tailNonEmpty2(that.intervals), headNonEmpty2(that.intervals), empty7());
});
var unionLoop = (_self, _that, _interval, _acc) => {
  let self = _self;
  let that = _that;
  let interval = _interval;
  let acc = _acc;
  while (isNonEmpty2(self) || isNonEmpty2(that)) {
    if (!isNonEmpty2(self) && isNonEmpty2(that)) {
      if (interval.endMillis < headNonEmpty2(that).startMillis) {
        acc = pipe(acc, prepend3(interval));
        interval = headNonEmpty2(that);
        that = tailNonEmpty2(that);
        self = empty7();
      } else {
        interval = make52(interval.startMillis, headNonEmpty2(that).endMillis);
        that = tailNonEmpty2(that);
        self = empty7();
      }
    } else if (isNonEmpty2(self) && isEmpty2(that)) {
      if (interval.endMillis < headNonEmpty2(self).startMillis) {
        acc = pipe(acc, prepend3(interval));
        interval = headNonEmpty2(self);
        that = empty7();
        self = tailNonEmpty2(self);
      } else {
        interval = make52(interval.startMillis, headNonEmpty2(self).endMillis);
        that = empty7();
        self = tailNonEmpty2(self);
      }
    } else if (isNonEmpty2(self) && isNonEmpty2(that)) {
      if (headNonEmpty2(self).startMillis < headNonEmpty2(that).startMillis) {
        if (interval.endMillis < headNonEmpty2(self).startMillis) {
          acc = pipe(acc, prepend3(interval));
          interval = headNonEmpty2(self);
          self = tailNonEmpty2(self);
        } else {
          interval = make52(interval.startMillis, headNonEmpty2(self).endMillis);
          self = tailNonEmpty2(self);
        }
      } else if (interval.endMillis < headNonEmpty2(that).startMillis) {
        acc = pipe(acc, prepend3(interval));
        interval = headNonEmpty2(that);
        that = tailNonEmpty2(that);
      } else {
        interval = make52(interval.startMillis, headNonEmpty2(that).endMillis);
        that = tailNonEmpty2(that);
      }
    } else {
      throw new Error(getBugErrorMessage("Intervals.unionLoop"));
    }
  }
  return make53(pipe(acc, prepend3(interval), reverse3));
};
var intersect3 = dual(2, (self, that) => intersectLoop(self.intervals, that.intervals, empty7()));
var intersectLoop = (_left, _right, _acc) => {
  let left3 = _left;
  let right3 = _right;
  let acc = _acc;
  while (isNonEmpty2(left3) && isNonEmpty2(right3)) {
    const interval = pipe(headNonEmpty2(left3), intersect2(headNonEmpty2(right3)));
    const intervals = isEmpty13(interval) ? acc : pipe(acc, prepend3(interval));
    if (pipe(headNonEmpty2(left3), lessThan10(headNonEmpty2(right3)))) {
      left3 = tailNonEmpty2(left3);
    } else {
      right3 = tailNonEmpty2(right3);
    }
    acc = intervals;
  }
  return make53(reverse3(acc));
};
var start = (self) => {
  return pipe(self.intervals, head3, getOrElse2(() => empty37)).startMillis;
};
var end = (self) => {
  return pipe(self.intervals, head3, getOrElse2(() => empty37)).endMillis;
};
var lessThan11 = dual(2, (self, that) => start(self) < start(that));
var isNonEmpty5 = (self) => {
  return isNonEmpty2(self.intervals);
};
var max9 = dual(2, (self, that) => lessThan11(self, that) ? that : self);

// ../../node_modules/effect/dist/esm/ScheduleIntervals.js
var IntervalsTypeId2 = IntervalsTypeId;
var make54 = make53;
var empty39 = empty38;
var fromIterable16 = fromIterable15;
var union12 = union11;
var intersect4 = intersect3;
var start2 = start;
var end2 = end;
var lessThan12 = lessThan11;
var isNonEmpty6 = isNonEmpty5;
var max10 = max9;

// ../../node_modules/effect/dist/esm/internal/schedule/decision.js
var OP_CONTINUE = "Continue";
var OP_DONE2 = "Done";
var _continue = (intervals) => {
  return {
    _tag: OP_CONTINUE,
    intervals
  };
};
var continueWith = (interval) => {
  return {
    _tag: OP_CONTINUE,
    intervals: make54(of3(interval))
  };
};
var done6 = {
  _tag: OP_DONE2
};
var isContinue = (self) => {
  return self._tag === OP_CONTINUE;
};
var isDone4 = (self) => {
  return self._tag === OP_DONE2;
};

// ../../node_modules/effect/dist/esm/ScheduleDecision.js
var _continue2 = _continue;
var continueWith2 = continueWith;
var done7 = done6;
var isContinue2 = isContinue;
var isDone5 = isDone4;

// ../../node_modules/effect/dist/esm/Scope.js
var Scope_exports = {};
__export(Scope_exports, {
  CloseableScopeTypeId: () => CloseableScopeTypeId2,
  Scope: () => Scope,
  ScopeTypeId: () => ScopeTypeId2,
  addFinalizer: () => addFinalizer3,
  addFinalizerExit: () => addFinalizerExit,
  close: () => close,
  extend: () => extend3,
  fork: () => fork3,
  make: () => make55,
  use: () => use
});
var ScopeTypeId2 = ScopeTypeId;
var CloseableScopeTypeId2 = CloseableScopeTypeId;
var Scope = scopeTag;
var addFinalizer3 = scopeAddFinalizer;
var addFinalizerExit = scopeAddFinalizerExit;
var close = scopeClose;
var extend3 = scopeExtend;
var fork3 = scopeFork;
var use = scopeUse;
var make55 = scopeMake2;

// ../../node_modules/effect/dist/esm/internal/effect/circular.js
var Semaphore = class {
  permits;
  waiters = /* @__PURE__ */ new Set();
  taken = 0;
  constructor(permits) {
    this.permits = permits;
  }
  get free() {
    return this.permits - this.taken;
  }
  take = (n) => asyncInterrupt((resume2) => {
    if (this.free < n) {
      const observer = () => {
        if (this.free < n) {
          return;
        }
        this.waiters.delete(observer);
        this.taken += n;
        resume2(succeed(n));
      };
      this.waiters.add(observer);
      return sync(() => {
        this.waiters.delete(observer);
      });
    }
    this.taken += n;
    return resume2(succeed(n));
  });
  updateTaken = (f) => withFiberRuntime((fiber) => {
    this.taken = f(this.taken);
    if (this.waiters.size > 0) {
      fiber.getFiberRef(currentScheduler).scheduleTask(() => {
        const iter = this.waiters.values();
        let item = iter.next();
        while (item.done === false && this.free > 0) {
          item.value();
          item = iter.next();
        }
      }, fiber.getFiberRef(currentSchedulingPriority));
    }
    return succeed(this.free);
  });
  release = (n) => this.updateTaken((taken) => taken - n);
  releaseAll = this.updateTaken((_) => 0);
  withPermits = (n) => (self) => uninterruptibleMask((restore) => flatMap12(restore(this.take(n)), (permits) => ensuring2(restore(self), this.release(permits))));
  withPermitsIfAvailable = (n) => (self) => uninterruptibleMask((restore) => suspend(() => {
    if (this.free < n) {
      return succeedNone;
    }
    this.taken += n;
    return ensuring2(restore(asSome(self)), this.release(n));
  }));
};
var unsafeMakeSemaphore = (permits) => new Semaphore(permits);
var makeSemaphore = (permits) => sync(() => unsafeMakeSemaphore(permits));
var Latch = class extends Class3 {
  isOpen;
  waiters = [];
  scheduled = false;
  constructor(isOpen) {
    super();
    this.isOpen = isOpen;
  }
  commit() {
    return this.await;
  }
  unsafeSchedule(fiber) {
    if (this.scheduled || this.waiters.length === 0) {
      return void_3;
    }
    this.scheduled = true;
    fiber.currentScheduler.scheduleTask(this.flushWaiters, fiber.getFiberRef(currentSchedulingPriority));
    return void_3;
  }
  flushWaiters = () => {
    this.scheduled = false;
    const waiters = this.waiters;
    this.waiters = [];
    for (let i = 0; i < waiters.length; i++) {
      waiters[i](exitVoid);
    }
  };
  open = withFiberRuntime((fiber) => {
    if (this.isOpen) {
      return void_3;
    }
    this.isOpen = true;
    return this.unsafeSchedule(fiber);
  });
  unsafeOpen() {
    if (this.isOpen) return;
    this.isOpen = true;
    this.flushWaiters();
  }
  release = withFiberRuntime((fiber) => {
    if (this.isOpen) {
      return void_3;
    }
    return this.unsafeSchedule(fiber);
  });
  await = asyncInterrupt((resume2) => {
    if (this.isOpen) {
      return resume2(void_3);
    }
    this.waiters.push(resume2);
    return sync(() => {
      const index = this.waiters.indexOf(resume2);
      if (index !== -1) {
        this.waiters.splice(index, 1);
      }
    });
  });
  unsafeClose() {
    this.isOpen = false;
  }
  close = sync(() => {
    this.isOpen = false;
  });
  whenOpen = (self) => {
    return zipRight2(this.await, self);
  };
};
var unsafeMakeLatch = (open) => new Latch(open ?? false);
var makeLatch = (open) => sync(() => unsafeMakeLatch(open));
var awaitAllChildren = (self) => ensuringChildren(self, fiberAwaitAll);
var cached2 = dual(2, (self, timeToLive) => map14(cachedInvalidateWithTTL(self, timeToLive), (tuple7) => tuple7[0]));
var cachedInvalidateWithTTL = dual(2, (self, timeToLive) => {
  const duration5 = decode(timeToLive);
  return flatMap12(context2(), (env) => map14(makeSynchronized(none2()), (cache) => [provideContext(getCachedValue(self, duration5, cache), env), invalidateCache(cache)]));
});
var computeCachedValue = (self, timeToLive, start5) => {
  const timeToLiveMillis = toMillis(decode(timeToLive));
  return pipe(deferredMake(), tap2((deferred) => intoDeferred(self, deferred)), map14((deferred) => some3([start5 + timeToLiveMillis, deferred])));
};
var getCachedValue = (self, timeToLive, cache) => uninterruptibleMask((restore) => pipe(clockWith3((clock3) => clock3.currentTimeMillis), flatMap12((time3) => updateSomeAndGetEffectSynchronized(cache, (option11) => {
  switch (option11._tag) {
    case "None": {
      return some3(computeCachedValue(self, timeToLive, time3));
    }
    case "Some": {
      const [end7] = option11.value;
      return end7 - time3 <= 0 ? some3(computeCachedValue(self, timeToLive, time3)) : none2();
    }
  }
})), flatMap12((option11) => isNone2(option11) ? dieMessage("BUG: Effect.cachedInvalidate - please report an issue at https://github.com/Effect-TS/effect/issues") : restore(deferredAwait(option11.value[1])))));
var invalidateCache = (cache) => set6(cache, none2());
var ensuringChild = dual(2, (self, f) => ensuringChildren(self, (children3) => f(fiberAll(children3))));
var ensuringChildren = dual(2, (self, children3) => flatMap12(track, (supervisor) => pipe(supervised(self, supervisor), ensuring2(flatMap12(supervisor.value, children3)))));
var forkAll = dual((args2) => isIterable(args2[0]), (effects, options) => options?.discard ? forEachSequentialDiscard(effects, fork2) : map14(forEachSequential(effects, fork2), fiberAll));
var forkIn2 = dual(2, (self, scope6) => withFiberRuntime((parent, parentStatus) => {
  const scopeImpl = scope6;
  const fiber = unsafeFork2(self, parent, parentStatus.runtimeFlags, globalScope);
  if (scopeImpl.state._tag === "Open") {
    const finalizer3 = () => fiberIdWith((fiberId5) => equals(fiberId5, fiber.id()) ? void_3 : asVoid2(interruptFiber(fiber)));
    const key = {};
    scopeImpl.state.finalizers.set(key, finalizer3);
    fiber.addObserver(() => {
      if (scopeImpl.state._tag === "Closed") return;
      scopeImpl.state.finalizers.delete(key);
    });
  } else {
    fiber.unsafeInterruptAsFork(parent.id());
  }
  return succeed(fiber);
}));
var forkScoped2 = (self) => scopeWith((scope6) => forkIn2(self, scope6));
var fromFiber = (fiber) => join3(fiber);
var fromFiberEffect = (fiber) => suspend(() => flatMap12(fiber, join3));
var memoKeySymbol = Symbol.for("effect/Effect/memoizeFunction.key");
var Key = class {
  a;
  eq;
  [memoKeySymbol] = memoKeySymbol;
  constructor(a, eq) {
    this.a = a;
    this.eq = eq;
  }
  [symbol3](that) {
    if (hasProperty(that, memoKeySymbol)) {
      if (this.eq) {
        return this.eq(this.a, that.a);
      } else {
        return equals(this.a, that.a);
      }
    }
    return false;
  }
  [symbol2]() {
    return this.eq ? 0 : cached(this, hash(this.a));
  }
};
var cachedFunction = (f, eq) => {
  return pipe(sync(() => empty23()), flatMap12(makeSynchronized), map14((ref) => (a) => pipe(ref.modifyEffect((map49) => {
    const result = pipe(map49, get9(new Key(a, eq)));
    if (isNone2(result)) {
      return pipe(deferredMake(), tap2((deferred) => pipe(diffFiberRefs(f(a)), intoDeferred(deferred), fork2)), map14((deferred) => [deferred, pipe(map49, set5(new Key(a, eq), deferred))]));
    }
    return succeed([result.value, map49]);
  }), flatMap12(deferredAwait), flatMap12(([patch14, b]) => pipe(patchFiberRefs(patch14), as3(b))))));
};
var raceFirst2 = dual(2, (self, that) => pipe(exit(self), race2(exit(that)), (effect4) => flatten8(effect4)));
var supervised = dual(2, (self, supervisor) => {
  const supervise = fiberRefLocallyWith(currentSupervisor, (s) => s.zip(supervisor));
  return supervise(self);
});
var timeout2 = dual(2, (self, duration5) => timeoutFail(self, {
  onTimeout: () => timeoutExceptionFromDuration(duration5),
  duration: duration5
}));
var timeoutFail = dual(2, (self, {
  duration: duration5,
  onTimeout
}) => flatten8(timeoutTo(self, {
  onTimeout: () => failSync(onTimeout),
  onSuccess: succeed,
  duration: duration5
})));
var timeoutFailCause = dual(2, (self, {
  duration: duration5,
  onTimeout
}) => flatten8(timeoutTo(self, {
  onTimeout: () => failCauseSync(onTimeout),
  onSuccess: succeed,
  duration: duration5
})));
var timeoutOption2 = dual(2, (self, duration5) => timeoutTo(self, {
  duration: duration5,
  onSuccess: some3,
  onTimeout: none2
}));
var timeoutTo = dual(2, (self, {
  duration: duration5,
  onSuccess,
  onTimeout
}) => fiberIdWith((parentFiberId) => uninterruptibleMask((restore) => raceFibersWith(restore(self), interruptible2(sleep3(duration5)), {
  onSelfWin: (winner, loser) => flatMap12(winner.await, (exit4) => {
    if (exit4._tag === "Success") {
      return flatMap12(winner.inheritAll, () => as3(interruptAsFiber(loser, parentFiberId), onSuccess(exit4.value)));
    } else {
      return flatMap12(interruptAsFiber(loser, parentFiberId), () => exitFailCause(exit4.cause));
    }
  }),
  onOtherWin: (winner, loser) => flatMap12(winner.await, (exit4) => {
    if (exit4._tag === "Success") {
      return flatMap12(winner.inheritAll, () => as3(interruptAsFiber(loser, parentFiberId), onTimeout()));
    } else {
      return flatMap12(interruptAsFiber(loser, parentFiberId), () => exitFailCause(exit4.cause));
    }
  }),
  otherScope: globalScope
}))));
var SynchronizedSymbolKey = "effect/Ref/SynchronizedRef";
var SynchronizedTypeId = Symbol.for(SynchronizedSymbolKey);
var synchronizedVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var SynchronizedImpl = class extends Class3 {
  ref;
  withLock;
  [SynchronizedTypeId] = synchronizedVariance;
  [RefTypeId] = refVariance;
  [TypeId15] = TypeId15;
  constructor(ref, withLock3) {
    super();
    this.ref = ref;
    this.withLock = withLock3;
    this.get = get12(this.ref);
  }
  get;
  commit() {
    return this.get;
  }
  modify(f) {
    return this.modifyEffect((a) => succeed(f(a)));
  }
  modifyEffect(f) {
    return this.withLock(pipe(flatMap12(get12(this.ref), f), flatMap12(([b, a]) => as3(set6(this.ref, a), b))));
  }
};
var makeSynchronized = (value10) => sync(() => unsafeMakeSynchronized(value10));
var unsafeMakeSynchronized = (value10) => {
  const ref = unsafeMake7(value10);
  const sem = unsafeMakeSemaphore(1);
  return new SynchronizedImpl(ref, sem.withPermits(1));
};
var updateSomeAndGetEffectSynchronized = dual(2, (self, pf) => self.modifyEffect((value10) => {
  const result = pf(value10);
  switch (result._tag) {
    case "None": {
      return succeed([value10, value10]);
    }
    case "Some": {
      return map14(result.value, (a) => [a, a]);
    }
  }
}));
var zipFiber = dual(2, (self, that) => zipWithFiber(self, that, (a, b) => [a, b]));
var zipLeftFiber = dual(2, (self, that) => zipWithFiber(self, that, (a, _) => a));
var zipRightFiber = dual(2, (self, that) => zipWithFiber(self, that, (_, b) => b));
var zipWithFiber = dual(3, (self, that, f) => ({
  ...CommitPrototype2,
  commit() {
    return join3(this);
  },
  [FiberTypeId]: fiberVariance2,
  id: () => pipe(self.id(), getOrElse6(that.id())),
  await: pipe(self.await, flatten8, zipWithOptions(flatten8(that.await), f, {
    concurrent: true
  }), exit),
  children: self.children,
  inheritAll: zipRight2(that.inheritAll, self.inheritAll),
  poll: zipWith6(self.poll, that.poll, (optionA, optionB) => pipe(optionA, flatMap2((exitA) => pipe(optionB, map2((exitB) => zipWith7(exitA, exitB, {
    onSuccess: f,
    onFailure: parallel
  })))))),
  interruptAsFork: (id3) => zipRight2(self.interruptAsFork(id3), that.interruptAsFork(id3)),
  pipe() {
    return pipeArguments(this, arguments);
  }
}));
var bindAll = dual((args2) => isEffect(args2[0]), (self, f, options) => flatMap12(self, (a) => all9(f(a), options).pipe(map14((record4) => Object.assign({}, a, record4)))));

// ../../node_modules/effect/dist/esm/internal/managedRuntime/circular.js
var TypeId19 = Symbol.for("effect/ManagedRuntime");

// ../../node_modules/effect/dist/esm/internal/opCodes/layer.js
var OP_EXTEND_SCOPE = "ExtendScope";
var OP_FOLD = "Fold";
var OP_FRESH = "Fresh";
var OP_FROM_EFFECT = "FromEffect";
var OP_SCOPED = "Scoped";
var OP_SUSPEND = "Suspend";
var OP_PROVIDE = "Provide";
var OP_PROVIDE_MERGE = "ProvideMerge";
var OP_ZIP_WITH2 = "ZipWith";

// ../../node_modules/effect/dist/esm/Fiber.js
var Fiber_exports = {};
__export(Fiber_exports, {
  FiberTypeId: () => FiberTypeId2,
  Order: () => Order8,
  RuntimeFiberTypeId: () => RuntimeFiberTypeId2,
  all: () => all10,
  await: () => _await3,
  awaitAll: () => awaitAll,
  children: () => children2,
  done: () => done8,
  dump: () => dump2,
  dumpAll: () => dumpAll2,
  fail: () => fail9,
  failCause: () => failCause7,
  fromEffect: () => fromEffect3,
  getCurrentFiber: () => getCurrentFiber2,
  id: () => id2,
  inheritAll: () => inheritAll2,
  interrupt: () => interrupt7,
  interruptAll: () => interruptAll2,
  interruptAllAs: () => interruptAllAs2,
  interruptAs: () => interruptAs,
  interruptAsFork: () => interruptAsFork2,
  interruptFork: () => interruptFork,
  interrupted: () => interrupted2,
  isFiber: () => isFiber2,
  isRuntimeFiber: () => isRuntimeFiber2,
  join: () => join4,
  joinAll: () => joinAll,
  map: () => map23,
  mapEffect: () => mapEffect3,
  mapFiber: () => mapFiber2,
  match: () => match15,
  never: () => never4,
  orElse: () => orElse6,
  orElseEither: () => orElseEither5,
  poll: () => poll4,
  pretty: () => pretty4,
  roots: () => roots2,
  scoped: () => scoped2,
  status: () => status2,
  succeed: () => succeed9,
  unsafeRoots: () => unsafeRoots2,
  void: () => void_7,
  zip: () => zip11,
  zipLeft: () => zipLeft5,
  zipRight: () => zipRight5,
  zipWith: () => zipWith9
});
var FiberTypeId2 = FiberTypeId;
var RuntimeFiberTypeId2 = RuntimeFiberTypeId;
var Order8 = Order7;
var isFiber2 = isFiber;
var isRuntimeFiber2 = isRuntimeFiber;
var id2 = id;
var _await3 = _await2;
var awaitAll = fiberAwaitAll;
var children2 = children;
var all10 = fiberAll;
var done8 = done5;
var dump2 = dump;
var dumpAll2 = dumpAll;
var fail9 = fail6;
var failCause7 = failCause5;
var fromEffect3 = fromEffect;
var getCurrentFiber2 = getCurrentFiber;
var inheritAll2 = inheritAll;
var interrupt7 = interruptFiber;
var interrupted2 = interrupted;
var interruptAs = interruptAsFiber;
var interruptAsFork2 = interruptAsFork;
var interruptAll2 = interruptAll;
var interruptAllAs2 = interruptAllAs;
var interruptFork = fiberInterruptFork;
var join4 = join3;
var joinAll = fiberJoinAll;
var map23 = map18;
var mapEffect3 = mapEffect2;
var mapFiber2 = mapFiber;
var match15 = match13;
var never4 = never3;
var orElse6 = orElse5;
var orElseEither5 = orElseEither3;
var poll4 = poll3;
var pretty4 = pretty2;
var roots2 = roots;
var unsafeRoots2 = unsafeRoots;
var scoped2 = fiberScoped;
var status2 = status;
var succeed9 = succeed5;
var void_7 = void_6;
var zip11 = zipFiber;
var zipLeft5 = zipLeftFiber;
var zipRight5 = zipRightFiber;
var zipWith9 = zipWithFiber;

// ../../node_modules/effect/dist/esm/internal/runtime.js
var makeDual = (f) => function() {
  if (arguments.length === 1) {
    const runtime8 = arguments[0];
    return (effect4, ...args2) => f(runtime8, effect4, ...args2);
  }
  return f.apply(this, arguments);
};
var unsafeFork3 = makeDual((runtime8, self, options) => {
  const fiberId5 = unsafeMake3();
  const fiberRefUpdates = [[currentContext, [[fiberId5, runtime8.context]]]];
  if (options?.scheduler) {
    fiberRefUpdates.push([currentScheduler, [[fiberId5, options.scheduler]]]);
  }
  let fiberRefs4 = updateManyAs2(runtime8.fiberRefs, {
    entries: fiberRefUpdates,
    forkAs: fiberId5
  });
  if (options?.updateRefs) {
    fiberRefs4 = options.updateRefs(fiberRefs4, fiberId5);
  }
  const fiberRuntime = new FiberRuntime(fiberId5, fiberRefs4, runtime8.runtimeFlags);
  let effect4 = self;
  if (options?.scope) {
    effect4 = flatMap12(fork3(options.scope, sequential2), (closeableScope) => zipRight2(scopeAddFinalizer(closeableScope, fiberIdWith((id3) => equals(id3, fiberRuntime.id()) ? void_3 : interruptAsFiber(fiberRuntime, id3))), onExit(self, (exit4) => close(closeableScope, exit4))));
  }
  const supervisor = fiberRuntime.currentSupervisor;
  if (supervisor !== none8) {
    supervisor.onStart(runtime8.context, effect4, none2(), fiberRuntime);
    fiberRuntime.addObserver((exit4) => supervisor.onEnd(exit4, fiberRuntime));
  }
  globalScope.add(runtime8.runtimeFlags, fiberRuntime);
  if (options?.immediate === false) {
    fiberRuntime.resume(effect4);
  } else {
    fiberRuntime.start(effect4);
  }
  return fiberRuntime;
});
var unsafeRunCallback = makeDual((runtime8, effect4, options = {}) => {
  const fiberRuntime = unsafeFork3(runtime8, effect4, options);
  if (options.onExit) {
    fiberRuntime.addObserver((exit4) => {
      options.onExit(exit4);
    });
  }
  return (id3, cancelOptions) => unsafeRunCallback(runtime8)(pipe(fiberRuntime, interruptAs(id3 ?? none4)), {
    ...cancelOptions,
    onExit: cancelOptions?.onExit ? (exit4) => cancelOptions.onExit(flatten9(exit4)) : void 0
  });
});
var unsafeRunSync = makeDual((runtime8, effect4) => {
  const result = unsafeRunSyncExit(runtime8)(effect4);
  if (result._tag === "Failure") {
    throw fiberFailure(result.effect_instruction_i0);
  }
  return result.effect_instruction_i0;
});
var AsyncFiberExceptionImpl = class extends Error {
  fiber;
  _tag = "AsyncFiberException";
  constructor(fiber) {
    super(`Fiber #${fiber.id().id} cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work`);
    this.fiber = fiber;
    this.name = this._tag;
    this.stack = this.message;
  }
};
var asyncFiberException = (fiber) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  const error4 = new AsyncFiberExceptionImpl(fiber);
  Error.stackTraceLimit = limit;
  return error4;
};
var isAsyncFiberException = (u) => isTagged(u, "AsyncFiberException") && "fiber" in u;
var FiberFailureId = Symbol.for("effect/Runtime/FiberFailure");
var FiberFailureCauseId = Symbol.for("effect/Runtime/FiberFailure/Cause");
var FiberFailureImpl = class extends Error {
  [FiberFailureId];
  [FiberFailureCauseId];
  constructor(cause3) {
    const head13 = prettyErrors(cause3)[0];
    super(head13?.message || "An error has occurred");
    this[FiberFailureId] = FiberFailureId;
    this[FiberFailureCauseId] = cause3;
    this.name = head13 ? `(FiberFailure) ${head13.name}` : "FiberFailure";
    if (head13?.stack) {
      this.stack = head13.stack;
    }
  }
  toJSON() {
    return {
      _id: "FiberFailure",
      cause: this[FiberFailureCauseId].toJSON()
    };
  }
  toString() {
    return "(FiberFailure) " + pretty(this[FiberFailureCauseId], {
      renderErrorCause: true
    });
  }
  [NodeInspectSymbol]() {
    return this.toString();
  }
};
var fiberFailure = (cause3) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  const error4 = new FiberFailureImpl(cause3);
  Error.stackTraceLimit = limit;
  return error4;
};
var isFiberFailure = (u) => hasProperty(u, FiberFailureId);
var fastPath = (effect4) => {
  const op = effect4;
  switch (op._op) {
    case "Failure":
    case "Success": {
      return op;
    }
    case "Left": {
      return exitFail(op.left);
    }
    case "Right": {
      return exitSucceed(op.right);
    }
    case "Some": {
      return exitSucceed(op.value);
    }
    case "None": {
      return exitFail(NoSuchElementException());
    }
  }
};
var unsafeRunSyncExit = makeDual((runtime8, effect4) => {
  const op = fastPath(effect4);
  if (op) {
    return op;
  }
  const scheduler2 = new SyncScheduler();
  const fiberRuntime = unsafeFork3(runtime8)(effect4, {
    scheduler: scheduler2
  });
  scheduler2.flush();
  const result = fiberRuntime.unsafePoll();
  if (result) {
    return result;
  }
  return exitDie(capture(asyncFiberException(fiberRuntime), currentSpanFromFiber(fiberRuntime)));
});
var unsafeRunPromise = makeDual((runtime8, effect4, options) => unsafeRunPromiseExit(runtime8, effect4, options).then((result) => {
  switch (result._tag) {
    case OP_SUCCESS: {
      return result.effect_instruction_i0;
    }
    case OP_FAILURE: {
      throw fiberFailure(result.effect_instruction_i0);
    }
  }
}));
var unsafeRunPromiseExit = makeDual((runtime8, effect4, options) => new Promise((resolve) => {
  const op = fastPath(effect4);
  if (op) {
    resolve(op);
  }
  const fiber = unsafeFork3(runtime8)(effect4);
  fiber.addObserver((exit4) => {
    resolve(exit4);
  });
  if (options?.signal !== void 0) {
    if (options.signal.aborted) {
      fiber.unsafeInterruptAsFork(fiber.id());
    } else {
      options.signal.addEventListener("abort", () => {
        fiber.unsafeInterruptAsFork(fiber.id());
      }, {
        once: true
      });
    }
  }
}));
var RuntimeImpl = class {
  context;
  runtimeFlags;
  fiberRefs;
  constructor(context15, runtimeFlags2, fiberRefs4) {
    this.context = context15;
    this.runtimeFlags = runtimeFlags2;
    this.fiberRefs = fiberRefs4;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make56 = (options) => new RuntimeImpl(options.context, options.runtimeFlags, options.fiberRefs);
var runtime3 = () => withFiberRuntime((state, status3) => succeed(new RuntimeImpl(state.getFiberRef(currentContext), status3.runtimeFlags, state.getFiberRefs())));
var defaultRuntimeFlags = make22(Interruption, CooperativeYielding, RuntimeMetrics);
var defaultRuntime = make56({
  context: empty6(),
  runtimeFlags: defaultRuntimeFlags,
  fiberRefs: empty27()
});
var updateRuntimeFlags2 = dual(2, (self, f) => make56({
  context: self.context,
  runtimeFlags: f(self.runtimeFlags),
  fiberRefs: self.fiberRefs
}));
var disableRuntimeFlag = dual(2, (self, flag) => updateRuntimeFlags2(self, disable2(flag)));
var enableRuntimeFlag = dual(2, (self, flag) => updateRuntimeFlags2(self, enable2(flag)));
var updateContext2 = dual(2, (self, f) => make56({
  context: f(self.context),
  runtimeFlags: self.runtimeFlags,
  fiberRefs: self.fiberRefs
}));
var provideService3 = dual(3, (self, tag5, service4) => updateContext2(self, add2(tag5, service4)));
var updateFiberRefs2 = dual(2, (self, f) => make56({
  context: self.context,
  runtimeFlags: self.runtimeFlags,
  fiberRefs: f(self.fiberRefs)
}));
var setFiberRef = dual(3, (self, fiberRef, value10) => updateFiberRefs2(self, updateAs2({
  fiberId: none4,
  fiberRef,
  value: value10
})));
var deleteFiberRef = dual(2, (self, fiberRef) => updateFiberRefs2(self, delete_2(fiberRef)));
var unsafeRunEffect = unsafeRunCallback(defaultRuntime);
var unsafeForkEffect = unsafeFork3(defaultRuntime);
var unsafeRunPromiseEffect = unsafeRunPromise(defaultRuntime);
var unsafeRunPromiseExitEffect = unsafeRunPromiseExit(defaultRuntime);
var unsafeRunSyncEffect = unsafeRunSync(defaultRuntime);
var unsafeRunSyncExitEffect = unsafeRunSyncExit(defaultRuntime);
var asyncEffect = (register) => suspend(() => {
  let cleanup = void 0;
  return flatMap12(deferredMake(), (deferred) => flatMap12(runtime3(), (runtime8) => uninterruptibleMask((restore) => zipRight2(fork2(restore(matchCauseEffect(register((cb) => unsafeRunCallback(runtime8)(intoDeferred(cb, deferred))), {
    onFailure: (cause3) => deferredFailCause(deferred, cause3),
    onSuccess: (cleanup_) => {
      cleanup = cleanup_;
      return void_3;
    }
  }))), restore(onInterrupt(deferredAwait(deferred), () => cleanup ?? void_3))))));
});

// ../../node_modules/effect/dist/esm/internal/synchronizedRef.js
var getAndUpdateEffect = dual(2, (self, f) => self.modifyEffect((value10) => map14(f(value10), (result) => [value10, result])));
var getAndUpdateSomeEffect = dual(2, (self, pf) => self.modifyEffect((value10) => {
  const result = pf(value10);
  switch (result._tag) {
    case "None": {
      return succeed([value10, value10]);
    }
    case "Some": {
      return map14(result.value, (newValue) => [value10, newValue]);
    }
  }
}));
var modify10 = dual(2, (self, f) => self.modify(f));
var modifyEffect = dual(2, (self, f) => self.modifyEffect(f));
var modifySomeEffect = dual(3, (self, fallback, pf) => self.modifyEffect((value10) => pipe(pf(value10), getOrElse2(() => succeed([fallback, value10])))));
var updateEffect = dual(2, (self, f) => self.modifyEffect((value10) => map14(f(value10), (result) => [void 0, result])));
var updateAndGetEffect = dual(2, (self, f) => self.modifyEffect((value10) => map14(f(value10), (result) => [result, result])));
var updateSomeEffect = dual(2, (self, pf) => self.modifyEffect((value10) => {
  const result = pf(value10);
  switch (result._tag) {
    case "None": {
      return succeed([void 0, value10]);
    }
    case "Some": {
      return map14(result.value, (a) => [void 0, a]);
    }
  }
}));

// ../../node_modules/effect/dist/esm/internal/layer.js
var LayerSymbolKey = "effect/Layer";
var LayerTypeId = Symbol.for(LayerSymbolKey);
var layerVariance = {
  /* c8 ignore next */
  _RIn: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _ROut: (_) => _
};
var proto3 = {
  [LayerTypeId]: layerVariance,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var MemoMapTypeIdKey = "effect/Layer/MemoMap";
var MemoMapTypeId = Symbol.for(MemoMapTypeIdKey);
var CurrentMemoMap = Reference2()("effect/Layer/CurrentMemoMap", {
  defaultValue: () => unsafeMakeMemoMap()
});
var isLayer = (u) => hasProperty(u, LayerTypeId);
var isFresh = (self) => {
  return self._op_layer === OP_FRESH;
};
var MemoMapImpl = class {
  ref;
  [MemoMapTypeId];
  constructor(ref) {
    this.ref = ref;
    this[MemoMapTypeId] = MemoMapTypeId;
  }
  /**
   * Checks the memo map to see if a layer exists. If it is, immediately
   * returns it. Otherwise, obtains the layer, stores it in the memo map,
   * and adds a finalizer to the `Scope`.
   */
  getOrElseMemoize(layer, scope6) {
    return pipe(modifyEffect(this.ref, (map49) => {
      const inMap = map49.get(layer);
      if (inMap !== void 0) {
        const [acquire4, release4] = inMap;
        const cached4 = pipe(acquire4, flatMap12(([patch14, b]) => pipe(patchFiberRefs(patch14), as3(b))), onExit(exitMatch({
          onFailure: () => void_3,
          onSuccess: () => scopeAddFinalizerExit(scope6, release4)
        })));
        return succeed([cached4, map49]);
      }
      return pipe(make36(0), flatMap12((observers) => pipe(deferredMake(), flatMap12((deferred) => pipe(make36(() => void_3), map14((finalizerRef) => {
        const resource = uninterruptibleMask((restore) => pipe(scopeMake2(), flatMap12((innerScope) => pipe(restore(flatMap12(makeBuilder(layer, innerScope, true), (f) => diffFiberRefs(f(this)))), exit, flatMap12((exit4) => {
          switch (exit4._tag) {
            case OP_FAILURE: {
              return pipe(deferredFailCause(deferred, exit4.effect_instruction_i0), zipRight2(scopeClose(innerScope, exit4)), zipRight2(failCause(exit4.effect_instruction_i0)));
            }
            case OP_SUCCESS: {
              return pipe(set6(finalizerRef, (exit5) => pipe(scopeClose(innerScope, exit5), whenEffect(modify7(observers, (n) => [n === 1, n - 1])), asVoid2)), zipRight2(update3(observers, (n) => n + 1)), zipRight2(scopeAddFinalizerExit(scope6, (exit5) => pipe(sync(() => map49.delete(layer)), zipRight2(get12(finalizerRef)), flatMap12((finalizer3) => finalizer3(exit5))))), zipRight2(deferredSucceed(deferred, exit4.effect_instruction_i0)), as3(exit4.effect_instruction_i0[1]));
            }
          }
        })))));
        const memoized = [pipe(deferredAwait(deferred), onExit(exitMatchEffect({
          onFailure: () => void_3,
          onSuccess: () => update3(observers, (n) => n + 1)
        }))), (exit4) => pipe(get12(finalizerRef), flatMap12((finalizer3) => finalizer3(exit4)))];
        return [resource, isFresh(layer) ? map49 : map49.set(layer, memoized)];
      }))))));
    }), flatten8);
  }
};
var makeMemoMap = suspend(() => map14(makeSynchronized(/* @__PURE__ */ new Map()), (ref) => new MemoMapImpl(ref)));
var unsafeMakeMemoMap = () => new MemoMapImpl(unsafeMakeSynchronized(/* @__PURE__ */ new Map()));
var build = (self) => scopeWith((scope6) => buildWithScope(self, scope6));
var buildWithScope = dual(2, (self, scope6) => flatMap12(makeMemoMap, (memoMap) => buildWithMemoMap(self, memoMap, scope6)));
var buildWithMemoMap = dual(3, (self, memoMap, scope6) => flatMap12(makeBuilder(self, scope6), (run10) => provideService(run10(memoMap), CurrentMemoMap, memoMap)));
var makeBuilder = (self, scope6, inMemoMap = false) => {
  const op = self;
  switch (op._op_layer) {
    case "Locally": {
      return sync(() => (memoMap) => op.f(memoMap.getOrElseMemoize(op.self, scope6)));
    }
    case "ExtendScope": {
      return sync(() => (memoMap) => scopeWith((scope7) => memoMap.getOrElseMemoize(op.layer, scope7)));
    }
    case "Fold": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.layer, scope6), matchCauseEffect({
        onFailure: (cause3) => memoMap.getOrElseMemoize(op.failureK(cause3), scope6),
        onSuccess: (value10) => memoMap.getOrElseMemoize(op.successK(value10), scope6)
      })));
    }
    case "Fresh": {
      return sync(() => (_) => pipe(op.layer, buildWithScope(scope6)));
    }
    case "FromEffect": {
      return inMemoMap ? sync(() => (_) => op.effect) : sync(() => (memoMap) => memoMap.getOrElseMemoize(self, scope6));
    }
    case "Provide": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope6), flatMap12((env) => pipe(memoMap.getOrElseMemoize(op.second, scope6), provideContext(env)))));
    }
    case "Scoped": {
      return inMemoMap ? sync(() => (_) => scopeExtend(op.effect, scope6)) : sync(() => (memoMap) => memoMap.getOrElseMemoize(self, scope6));
    }
    case "Suspend": {
      return sync(() => (memoMap) => memoMap.getOrElseMemoize(op.evaluate(), scope6));
    }
    case "ProvideMerge": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope6), zipWith6(memoMap.getOrElseMemoize(op.second, scope6), op.zipK)));
    }
    case "ZipWith": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope6), zipWithOptions(memoMap.getOrElseMemoize(op.second, scope6), op.zipK, {
        concurrent: true
      })));
    }
  }
};
var catchAll3 = dual(2, (self, onFailure) => match16(self, {
  onFailure,
  onSuccess: succeedContext
}));
var catchAllCause3 = dual(2, (self, onFailure) => matchCause3(self, {
  onFailure,
  onSuccess: succeedContext
}));
var die7 = (defect) => failCause8(die6(defect));
var dieSync3 = (evaluate4) => failCauseSync4(() => die6(evaluate4()));
var discard = (self) => map24(self, () => empty6());
var context4 = () => fromEffectContext(context2());
var extendScope = (self) => {
  const extendScope3 = Object.create(proto3);
  extendScope3._op_layer = OP_EXTEND_SCOPE;
  extendScope3.layer = self;
  return extendScope3;
};
var fail10 = (error4) => failCause8(fail8(error4));
var failSync4 = (evaluate4) => failCauseSync4(() => fail8(evaluate4()));
var failCause8 = (cause3) => fromEffectContext(failCause(cause3));
var failCauseSync4 = (evaluate4) => fromEffectContext(failCauseSync(evaluate4));
var flatMap17 = dual(2, (self, f) => match16(self, {
  onFailure: fail10,
  onSuccess: f
}));
var flatten12 = dual(2, (self, tag5) => flatMap17(self, get4(tag5)));
var fresh = (self) => {
  const fresh3 = Object.create(proto3);
  fresh3._op_layer = OP_FRESH;
  fresh3.layer = self;
  return fresh3;
};
var fromEffect4 = dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag5 = tagFirst ? a : b;
  const effect4 = tagFirst ? b : a;
  return fromEffectContext(map14(effect4, (service4) => make8(tag5, service4)));
});
var fromEffectDiscard = (effect4) => fromEffectContext(map14(effect4, () => empty6()));
function fromEffectContext(effect4) {
  const fromEffect17 = Object.create(proto3);
  fromEffect17._op_layer = OP_FROM_EFFECT;
  fromEffect17.effect = effect4;
  return fromEffect17;
}
var fiberRefLocally2 = dual(3, (self, ref, value10) => locallyEffect(self, fiberRefLocally(ref, value10)));
var locallyEffect = dual(2, (self, f) => {
  const locally5 = Object.create(proto3);
  locally5._op_layer = "Locally";
  locally5.self = self;
  locally5.f = f;
  return locally5;
});
var fiberRefLocallyWith2 = dual(3, (self, ref, value10) => locallyEffect(self, fiberRefLocallyWith(ref, value10)));
var fiberRefLocallyScoped2 = (self, value10) => scopedDiscard(fiberRefLocallyScoped(self, value10));
var fiberRefLocallyScopedWith2 = (self, value10) => scopedDiscard(fiberRefLocallyScopedWith(self, value10));
var fromFunction = (tagA, tagB, f) => fromEffectContext(map14(tagA, (a) => make8(tagB, f(a))));
var launch = (self) => scopedEffect(zipRight2(scopeWith((scope6) => pipe(self, buildWithScope(scope6))), never));
var mock = dual(2, (tag5, service4) => succeed10(tag5, new Proxy({
  ...service4
}, {
  get(target, prop, _receiver) {
    if (prop in target) {
      return target[prop];
    }
    const prevLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const error4 = new Error(`${tag5.key}: Unimplemented method "${prop.toString()}"`);
    Error.stackTraceLimit = prevLimit;
    error4.name = "UnimplementedError";
    return makeUnimplemented(error4);
  },
  has: constTrue
})));
var makeUnimplemented = (error4) => {
  const dead = die2(error4);
  function unimplemented() {
    return dead;
  }
  Object.assign(unimplemented, dead);
  Object.setPrototypeOf(unimplemented, Object.getPrototypeOf(dead));
  return unimplemented;
};
var map24 = dual(2, (self, f) => flatMap17(self, (context15) => succeedContext(f(context15))));
var mapError4 = dual(2, (self, f) => catchAll3(self, (error4) => failSync4(() => f(error4))));
var matchCause3 = dual(2, (self, {
  onFailure,
  onSuccess
}) => {
  const fold3 = Object.create(proto3);
  fold3._op_layer = OP_FOLD;
  fold3.layer = self;
  fold3.failureK = onFailure;
  fold3.successK = onSuccess;
  return fold3;
});
var match16 = dual(2, (self, {
  onFailure,
  onSuccess
}) => matchCause3(self, {
  onFailure: (cause3) => {
    const failureOrCause3 = failureOrCause2(cause3);
    switch (failureOrCause3._tag) {
      case "Left": {
        return onFailure(failureOrCause3.left);
      }
      case "Right": {
        return failCause8(failureOrCause3.right);
      }
    }
  },
  onSuccess
}));
var memoize2 = (self) => scopeWith((scope6) => map14(memoize(buildWithScope(self, scope6)), fromEffectContext));
var merge6 = dual(2, (self, that) => zipWith10(self, that, (a, b) => merge3(a, b)));
var mergeAll4 = (...layers) => {
  let final = layers[0];
  for (let i = 1; i < layers.length; i++) {
    final = merge6(final, layers[i]);
  }
  return final;
};
var orDie3 = (self) => catchAll3(self, (defect) => die7(defect));
var orElse7 = dual(2, (self, that) => catchAll3(self, that));
var passthrough = (self) => merge6(context4(), self);
var project = dual(4, (self, tagA, tagB, f) => map24(self, (context15) => make8(tagB, f(unsafeGet3(context15, tagA)))));
var retry2 = dual(2, (self, schedule4) => suspend3(() => {
  const stateTag = GenericTag("effect/Layer/retry/{ state: unknown }");
  return pipe(succeed10(stateTag, {
    state: schedule4.initial
  }), flatMap17((env) => retryLoop(self, schedule4, stateTag, pipe(env, get4(stateTag)).state)));
}));
var retryLoop = (self, schedule4, stateTag, state) => {
  return pipe(self, catchAll3((error4) => pipe(retryUpdate(schedule4, stateTag, error4, state), flatMap17((env) => fresh(retryLoop(self, schedule4, stateTag, pipe(env, get4(stateTag)).state))))));
};
var retryUpdate = (schedule4, stateTag, error4, state) => {
  return fromEffect4(stateTag, pipe(currentTimeMillis2, flatMap12((now3) => pipe(schedule4.step(now3, error4, state), flatMap12(([state2, _, decision]) => isDone5(decision) ? fail2(error4) : pipe(sleep2(millis(start2(decision.intervals) - now3)), as3({
    state: state2
  })))))));
};
var scoped3 = dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag5 = tagFirst ? a : b;
  const effect4 = tagFirst ? b : a;
  return scopedContext(map14(effect4, (service4) => make8(tag5, service4)));
});
var scopedDiscard = (effect4) => scopedContext(pipe(effect4, as3(empty6())));
var scopedContext = (effect4) => {
  const scoped10 = Object.create(proto3);
  scoped10._op_layer = OP_SCOPED;
  scoped10.effect = effect4;
  return scoped10;
};
var scope3 = scopedContext(map14(acquireRelease2(scopeMake2(), (scope6, exit4) => scope6.close(exit4)), (scope6) => make8(Scope, scope6)));
var service2 = (tag5) => fromEffect4(tag5, tag5);
var succeed10 = dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag5 = tagFirst ? a : b;
  const resource = tagFirst ? b : a;
  return fromEffectContext(succeed(make8(tag5, resource)));
});
var succeedContext = (context15) => {
  return fromEffectContext(succeed(context15));
};
var empty40 = succeedContext(empty6());
var suspend3 = (evaluate4) => {
  const suspend18 = Object.create(proto3);
  suspend18._op_layer = OP_SUSPEND;
  suspend18.evaluate = evaluate4;
  return suspend18;
};
var sync6 = dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag5 = tagFirst ? a : b;
  const evaluate4 = tagFirst ? b : a;
  return fromEffectContext(sync(() => make8(tag5, evaluate4())));
});
var syncContext = (evaluate4) => {
  return fromEffectContext(sync(evaluate4));
};
var tap4 = dual(2, (self, f) => flatMap17(self, (context15) => fromEffectContext(as3(f(context15), context15))));
var tapError3 = dual(2, (self, f) => catchAll3(self, (e) => fromEffectContext(flatMap12(f(e), () => fail2(e)))));
var tapErrorCause3 = dual(2, (self, f) => catchAllCause3(self, (cause3) => fromEffectContext(flatMap12(f(cause3), () => failCause(cause3)))));
var toRuntime = (self) => pipe(scopeWith((scope6) => buildWithScope(self, scope6)), flatMap12((context15) => pipe(runtime3(), provideContext(context15))));
var toRuntimeWithMemoMap = dual(2, (self, memoMap) => flatMap12(scopeWith((scope6) => buildWithMemoMap(self, memoMap, scope6)), (context15) => pipe(runtime3(), provideContext(context15))));
var provide = dual(2, (self, that) => suspend3(() => {
  const provideTo = Object.create(proto3);
  provideTo._op_layer = OP_PROVIDE;
  provideTo.first = Object.create(proto3, {
    _op_layer: {
      value: OP_PROVIDE_MERGE,
      enumerable: true
    },
    first: {
      value: context4(),
      enumerable: true
    },
    second: {
      value: Array.isArray(that) ? mergeAll4(...that) : that
    },
    zipK: {
      value: (a, b) => pipe(a, merge3(b))
    }
  });
  provideTo.second = self;
  return provideTo;
}));
var provideMerge = dual(2, (that, self) => {
  const zipWith23 = Object.create(proto3);
  zipWith23._op_layer = OP_PROVIDE_MERGE;
  zipWith23.first = self;
  zipWith23.second = provide(that, self);
  zipWith23.zipK = (a, b) => {
    return pipe(a, merge3(b));
  };
  return zipWith23;
});
var zipWith10 = dual(3, (self, that, f) => suspend3(() => {
  const zipWith23 = Object.create(proto3);
  zipWith23._op_layer = OP_ZIP_WITH2;
  zipWith23.first = self;
  zipWith23.second = that;
  zipWith23.zipK = f;
  return zipWith23;
}));
var unwrapEffect = (self) => {
  const tag5 = GenericTag("effect/Layer/unwrapEffect/Layer.Layer<R1, E1, A>");
  return flatMap17(fromEffect4(tag5, self), (context15) => get4(context15, tag5));
};
var unwrapScoped = (self) => {
  const tag5 = GenericTag("effect/Layer/unwrapScoped/Layer.Layer<R1, E1, A>");
  return flatMap17(scoped3(tag5, self), (context15) => get4(context15, tag5));
};
var annotateLogs2 = dual((args2) => isLayer(args2[0]), function() {
  const args2 = arguments;
  return fiberRefLocallyWith2(args2[0], currentLogAnnotations, typeof args2[1] === "string" ? set4(args2[1], args2[2]) : (annotations4) => Object.entries(args2[1]).reduce((acc, [key, value10]) => set4(acc, key, value10), annotations4));
});
var annotateSpans2 = dual((args2) => isLayer(args2[0]), function() {
  const args2 = arguments;
  return fiberRefLocallyWith2(args2[0], currentTracerSpanAnnotations, typeof args2[1] === "string" ? set4(args2[1], args2[2]) : (annotations4) => Object.entries(args2[1]).reduce((acc, [key, value10]) => set4(acc, key, value10), annotations4));
});
var withSpan2 = function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self = arguments[0];
    return unwrapScoped(map14(options?.onEnd ? tap2(makeSpanScoped(name, options), (span4) => addFinalizer2((exit4) => options.onEnd(span4, exit4))) : makeSpanScoped(name, options), (span4) => withParentSpan2(self, span4)));
  }
  return (self) => unwrapScoped(map14(options?.onEnd ? tap2(makeSpanScoped(name, options), (span4) => addFinalizer2((exit4) => options.onEnd(span4, exit4))) : makeSpanScoped(name, options), (span4) => withParentSpan2(self, span4)));
};
var withParentSpan2 = dual(2, (self, span4) => provide(self, succeedContext(make8(spanTag, span4))));
var provideSomeLayer = dual(2, (self, layer) => scopedWith((scope6) => flatMap12(buildWithScope(layer, scope6), (context15) => provideSomeContext(self, context15))));
var provideSomeRuntime = dual(2, (self, rt) => {
  const patchRefs = diff9(defaultRuntime.fiberRefs, rt.fiberRefs);
  const patchFlags = diff7(defaultRuntime.runtimeFlags, rt.runtimeFlags);
  return uninterruptibleMask((restore) => withFiberRuntime((fiber) => {
    const oldContext = fiber.getFiberRef(currentContext);
    const oldRefs = fiber.getFiberRefs();
    const newRefs = patch10(fiber.id(), oldRefs)(patchRefs);
    const oldFlags = fiber.currentRuntimeFlags;
    const newFlags = patch7(patchFlags)(oldFlags);
    const rollbackRefs = diff9(newRefs, oldRefs);
    const rollbackFlags = diff7(newFlags, oldFlags);
    fiber.setFiberRefs(newRefs);
    fiber.currentRuntimeFlags = newFlags;
    return ensuring2(provideSomeContext(restore(self), merge3(oldContext, rt.context)), withFiberRuntime((fiber2) => {
      fiber2.setFiberRefs(patch10(fiber2.id(), fiber2.getFiberRefs())(rollbackRefs));
      fiber2.currentRuntimeFlags = patch7(rollbackFlags)(fiber2.currentRuntimeFlags);
      return void_3;
    }));
  }));
});
var effect_provide = dual(2, (self, source) => {
  if (Array.isArray(source)) {
    return provideSomeLayer(self, mergeAll4(...source));
  } else if (isLayer(source)) {
    return provideSomeLayer(self, source);
  } else if (isContext2(source)) {
    return provideSomeContext(self, source);
  } else if (TypeId19 in source) {
    return flatMap12(source.runtimeEffect, (rt) => provideSomeRuntime(self, rt));
  } else {
    return provideSomeRuntime(self, source);
  }
});

// ../../node_modules/effect/dist/esm/internal/console.js
var console2 = map14(fiberRefGet(currentServices), get4(consoleTag));
var consoleWith = (f) => fiberRefGetWith(currentServices, (services) => f(get4(services, consoleTag)));
var withConsole = dual(2, (effect4, value10) => fiberRefLocallyWith(effect4, currentServices, add2(consoleTag, value10)));
var withConsoleScoped = (console4) => fiberRefLocallyScopedWith(currentServices, add2(consoleTag, console4));
var setConsole = (console4) => scopedDiscard(fiberRefLocallyScopedWith(currentServices, add2(consoleTag, console4)));
var assert2 = (condition, ...args2) => consoleWith((_) => _.assert(condition, ...args2));
var clear2 = consoleWith((_) => _.clear);
var count = (label) => consoleWith((_) => _.count(label));
var countReset = (label) => consoleWith((_) => _.countReset(label));
var debug = (...args2) => consoleWith((_) => _.debug(...args2));
var dir = (item, options) => consoleWith((_) => _.dir(item, options));
var dirxml = (...args2) => consoleWith((_) => _.dirxml(...args2));
var error2 = (...args2) => consoleWith((_) => _.error(...args2));
var group3 = (options) => consoleWith((_) => acquireRelease2(_.group(options), () => _.groupEnd));
var info = (...args2) => consoleWith((_) => _.info(...args2));
var log2 = (...args2) => consoleWith((_) => _.log(...args2));
var table = (tabularData, properties) => consoleWith((_) => _.table(tabularData, properties));
var time = (label) => consoleWith((_) => acquireRelease2(_.time(label), () => _.timeEnd(label)));
var timeLog = (label, ...args2) => consoleWith((_) => _.timeLog(label, ...args2));
var trace = (...args2) => consoleWith((_) => _.trace(...args2));
var warn = (...args2) => consoleWith((_) => _.warn(...args2));
var withGroup = dual((args2) => isEffect(args2[0]), (self, options) => consoleWith((_) => acquireUseRelease(_.group(options), () => self, () => _.groupEnd)));
var withTime = dual((args2) => isEffect(args2[0]), (self, label) => consoleWith((_) => acquireUseRelease(_.time(label), () => self, () => _.timeEnd(label))));

// ../../node_modules/effect/dist/esm/Cron.js
var Cron_exports = {};
__export(Cron_exports, {
  Equivalence: () => Equivalence8,
  ParseError: () => ParseError,
  ParseErrorTypeId: () => ParseErrorTypeId,
  TypeId: () => TypeId21,
  equals: () => equals5,
  isCron: () => isCron,
  isParseError: () => isParseError,
  make: () => make58,
  match: () => match19,
  next: () => next2,
  parse: () => parse2,
  sequence: () => sequence,
  unsafeParse: () => unsafeParse
});

// ../../node_modules/effect/dist/esm/Data.js
var Data_exports = {};
__export(Data_exports, {
  Class: () => Class5,
  Error: () => Error4,
  Structural: () => Structural2,
  TaggedClass: () => TaggedClass2,
  TaggedError: () => TaggedError2,
  array: () => array5,
  case: () => _case,
  struct: () => struct5,
  tagged: () => tagged4,
  taggedEnum: () => taggedEnum,
  tuple: () => tuple5,
  unsafeArray: () => unsafeArray,
  unsafeStruct: () => unsafeStruct
});
var struct5 = struct4;
var unsafeStruct = (as18) => Object.setPrototypeOf(as18, StructuralPrototype);
var tuple5 = (...as18) => unsafeArray(as18);
var array5 = (as18) => unsafeArray(as18.slice(0));
var unsafeArray = (as18) => Object.setPrototypeOf(as18, ArrayProto);
var _case = () => (args2) => args2 === void 0 ? Object.create(StructuralPrototype) : struct5(args2);
var tagged4 = (tag5) => (args2) => {
  const value10 = args2 === void 0 ? Object.create(StructuralPrototype) : struct5(args2);
  value10._tag = tag5;
  return value10;
};
var Class5 = Structural;
var TaggedClass2 = (tag5) => {
  class Base4 extends Class5 {
    _tag = tag5;
  }
  return Base4;
};
var Structural2 = Structural;
var taggedEnum = () => new Proxy({}, {
  get(_target, tag5, _receiver) {
    if (tag5 === "$is") {
      return isTagged;
    } else if (tag5 === "$match") {
      return taggedMatch;
    }
    return tagged4(tag5);
  }
});
function taggedMatch() {
  if (arguments.length === 1) {
    const cases2 = arguments[0];
    return function(value11) {
      return cases2[value11._tag](value11);
    };
  }
  const value10 = arguments[0];
  const cases = arguments[1];
  return cases[value10._tag](value10);
}
var Error4 = function() {
  const plainArgsSymbol = Symbol.for("effect/Data/Error/plainArgs");
  const O = {
    BaseEffectError: class extends YieldableError {
      constructor(args2) {
        super(args2?.message, args2?.cause ? {
          cause: args2.cause
        } : void 0);
        if (args2) {
          Object.assign(this, args2);
          Object.defineProperty(this, plainArgsSymbol, {
            value: args2,
            enumerable: false
          });
        }
      }
      toJSON() {
        return {
          ...this[plainArgsSymbol],
          ...this
        };
      }
    }
  };
  return O.BaseEffectError;
}();
var TaggedError2 = (tag5) => {
  const O = {
    BaseEffectError: class extends Error4 {
      _tag = tag5;
    }
  };
  O.BaseEffectError.prototype.name = tag5;
  return O.BaseEffectError;
};

// ../../node_modules/effect/dist/esm/internal/dateTime.js
var TypeId20 = Symbol.for("effect/DateTime");
var TimeZoneTypeId = Symbol.for("effect/DateTime/TimeZone");
var Proto2 = {
  [TypeId20]: TypeId20,
  pipe() {
    return pipeArguments(this, arguments);
  },
  [NodeInspectSymbol]() {
    return this.toString();
  },
  toJSON() {
    return toDateUtc(this).toJSON();
  }
};
var ProtoUtc = {
  ...Proto2,
  _tag: "Utc",
  [symbol2]() {
    return cached(this, number2(this.epochMillis));
  },
  [symbol3](that) {
    return isDateTime(that) && that._tag === "Utc" && this.epochMillis === that.epochMillis;
  },
  toString() {
    return `DateTime.Utc(${toDateUtc(this).toJSON()})`;
  }
};
var ProtoZoned = {
  ...Proto2,
  _tag: "Zoned",
  [symbol2]() {
    return pipe(number2(this.epochMillis), combine2(hash(this.zone)), cached(this));
  },
  [symbol3](that) {
    return isDateTime(that) && that._tag === "Zoned" && this.epochMillis === that.epochMillis && equals(this.zone, that.zone);
  },
  toString() {
    return `DateTime.Zoned(${formatIsoZoned(this)})`;
  }
};
var ProtoTimeZone = {
  [TimeZoneTypeId]: TimeZoneTypeId,
  [NodeInspectSymbol]() {
    return this.toString();
  }
};
var ProtoTimeZoneNamed = {
  ...ProtoTimeZone,
  _tag: "Named",
  [symbol2]() {
    return cached(this, string2(`Named:${this.id}`));
  },
  [symbol3](that) {
    return isTimeZone(that) && that._tag === "Named" && this.id === that.id;
  },
  toString() {
    return `TimeZone.Named(${this.id})`;
  },
  toJSON() {
    return {
      _id: "TimeZone",
      _tag: "Named",
      id: this.id
    };
  }
};
var ProtoTimeZoneOffset = {
  ...ProtoTimeZone,
  _tag: "Offset",
  [symbol2]() {
    return cached(this, string2(`Offset:${this.offset}`));
  },
  [symbol3](that) {
    return isTimeZone(that) && that._tag === "Offset" && this.offset === that.offset;
  },
  toString() {
    return `TimeZone.Offset(${offsetToString(this.offset)})`;
  },
  toJSON() {
    return {
      _id: "TimeZone",
      _tag: "Offset",
      offset: this.offset
    };
  }
};
var makeZonedProto = (epochMillis, zone, partsUtc) => {
  const self = Object.create(ProtoZoned);
  self.epochMillis = epochMillis;
  self.zone = zone;
  Object.defineProperty(self, "partsUtc", {
    value: partsUtc,
    enumerable: false,
    writable: true
  });
  Object.defineProperty(self, "adjustedEpochMillis", {
    value: void 0,
    enumerable: false,
    writable: true
  });
  Object.defineProperty(self, "partsAdjusted", {
    value: void 0,
    enumerable: false,
    writable: true
  });
  return self;
};
var isDateTime = (u) => hasProperty(u, TypeId20);
var isDateTimeArgs = (args2) => isDateTime(args2[0]);
var isTimeZone = (u) => hasProperty(u, TimeZoneTypeId);
var isTimeZoneOffset = (u) => isTimeZone(u) && u._tag === "Offset";
var isTimeZoneNamed = (u) => isTimeZone(u) && u._tag === "Named";
var isUtc = (self) => self._tag === "Utc";
var isZoned = (self) => self._tag === "Zoned";
var Equivalence6 = make((a, b) => a.epochMillis === b.epochMillis);
var Order9 = make2((self, that) => self.epochMillis < that.epochMillis ? -1 : self.epochMillis > that.epochMillis ? 1 : 0);
var clamp7 = clamp(Order9);
var makeUtc = (epochMillis) => {
  const self = Object.create(ProtoUtc);
  self.epochMillis = epochMillis;
  Object.defineProperty(self, "partsUtc", {
    value: void 0,
    enumerable: false,
    writable: true
  });
  return self;
};
var unsafeFromDate = (date5) => {
  const epochMillis = date5.getTime();
  if (Number.isNaN(epochMillis)) {
    throw new IllegalArgumentException2("Invalid date");
  }
  return makeUtc(epochMillis);
};
var unsafeMake11 = (input) => {
  if (isDateTime(input)) {
    return input;
  } else if (input instanceof Date) {
    return unsafeFromDate(input);
  } else if (typeof input === "object") {
    const date5 = /* @__PURE__ */ new Date(0);
    setPartsDate(date5, input);
    return unsafeFromDate(date5);
  } else if (typeof input === "string" && !hasZone(input)) {
    return unsafeFromDate(/* @__PURE__ */ new Date(input + "Z"));
  }
  return unsafeFromDate(new Date(input));
};
var hasZone = (input) => /Z|[+-]\d{2}$|[+-]\d{2}:?\d{2}$|\]$/.test(input);
var minEpochMillis = -864e13 + 12 * 60 * 60 * 1e3;
var maxEpochMillis = 864e13 - 14 * 60 * 60 * 1e3;
var unsafeMakeZoned = (input, options) => {
  if (options?.timeZone === void 0 && isDateTime(input) && isZoned(input)) {
    return input;
  }
  const self = unsafeMake11(input);
  if (self.epochMillis < minEpochMillis || self.epochMillis > maxEpochMillis) {
    throw new IllegalArgumentException2(`Epoch millis out of range: ${self.epochMillis}`);
  }
  let zone;
  if (options?.timeZone === void 0) {
    const offset = new Date(self.epochMillis).getTimezoneOffset() * -60 * 1e3;
    zone = zoneMakeOffset(offset);
  } else if (isTimeZone(options?.timeZone)) {
    zone = options.timeZone;
  } else if (typeof options?.timeZone === "number") {
    zone = zoneMakeOffset(options.timeZone);
  } else {
    const parsedZone = zoneFromString(options.timeZone);
    if (isNone2(parsedZone)) {
      throw new IllegalArgumentException2(`Invalid time zone: ${options.timeZone}`);
    }
    zone = parsedZone.value;
  }
  if (options?.adjustForTimeZone !== true) {
    return makeZonedProto(self.epochMillis, zone, self.partsUtc);
  }
  return makeZonedFromAdjusted(self.epochMillis, zone);
};
var makeZoned = liftThrowable(unsafeMakeZoned);
var make57 = liftThrowable(unsafeMake11);
var zonedStringRegex = /^(.{17,35})\[(.+)\]$/;
var makeZonedFromString = (input) => {
  const match43 = zonedStringRegex.exec(input);
  if (match43 === null) {
    const offset = parseOffset(input);
    return offset !== null ? makeZoned(input, {
      timeZone: offset
    }) : none2();
  }
  const [, isoString, timeZone] = match43;
  return makeZoned(isoString, {
    timeZone
  });
};
var now = map14(currentTimeMillis2, makeUtc);
var nowAsDate = map14(currentTimeMillis2, (millis2) => new Date(millis2));
var unsafeNow = () => makeUtc(Date.now());
var toUtc = (self) => makeUtc(self.epochMillis);
var setZone = dual(isDateTimeArgs, (self, zone, options) => options?.adjustForTimeZone === true ? makeZonedFromAdjusted(self.epochMillis, zone) : makeZonedProto(self.epochMillis, zone, self.partsUtc));
var setZoneOffset = dual(isDateTimeArgs, (self, offset, options) => setZone(self, zoneMakeOffset(offset), options));
var validZoneCache = globalValue("effect/DateTime/validZoneCache", () => /* @__PURE__ */ new Map());
var formatOptions = {
  day: "numeric",
  month: "numeric",
  year: "numeric",
  hour: "numeric",
  minute: "numeric",
  second: "numeric",
  timeZoneName: "longOffset",
  fractionalSecondDigits: 3,
  hourCycle: "h23"
};
var zoneMakeIntl = (format8) => {
  const zoneId = format8.resolvedOptions().timeZone;
  if (validZoneCache.has(zoneId)) {
    return validZoneCache.get(zoneId);
  }
  const zone = Object.create(ProtoTimeZoneNamed);
  zone.id = zoneId;
  zone.format = format8;
  validZoneCache.set(zoneId, zone);
  return zone;
};
var zoneUnsafeMakeNamed = (zoneId) => {
  if (validZoneCache.has(zoneId)) {
    return validZoneCache.get(zoneId);
  }
  try {
    return zoneMakeIntl(new Intl.DateTimeFormat("en-US", {
      ...formatOptions,
      timeZone: zoneId
    }));
  } catch {
    throw new IllegalArgumentException2(`Invalid time zone: ${zoneId}`);
  }
};
var zoneMakeOffset = (offset) => {
  const zone = Object.create(ProtoTimeZoneOffset);
  zone.offset = offset;
  return zone;
};
var zoneMakeNamed = liftThrowable(zoneUnsafeMakeNamed);
var zoneMakeNamedEffect = (zoneId) => try_2({
  try: () => zoneUnsafeMakeNamed(zoneId),
  catch: (e) => e
});
var zoneMakeLocal = () => zoneMakeIntl(new Intl.DateTimeFormat("en-US", formatOptions));
var offsetZoneRegex = /^(?:GMT|[+-])/;
var zoneFromString = (zone) => {
  if (offsetZoneRegex.test(zone)) {
    const offset = parseOffset(zone);
    return offset === null ? none2() : some3(zoneMakeOffset(offset));
  }
  return zoneMakeNamed(zone);
};
var zoneToString = (self) => {
  if (self._tag === "Offset") {
    return offsetToString(self.offset);
  }
  return self.id;
};
var setZoneNamed = dual(isDateTimeArgs, (self, zoneId, options) => map2(zoneMakeNamed(zoneId), (zone) => setZone(self, zone, options)));
var unsafeSetZoneNamed = dual(isDateTimeArgs, (self, zoneId, options) => setZone(self, zoneUnsafeMakeNamed(zoneId), options));
var distance = dual(2, (self, other) => toEpochMillis(other) - toEpochMillis(self));
var distanceDurationEither = dual(2, (self, other) => {
  const diffMillis = distance(self, other);
  return diffMillis > 0 ? right2(millis(diffMillis)) : left2(millis(-diffMillis));
});
var distanceDuration = dual(2, (self, other) => millis(Math.abs(distance(self, other))));
var min9 = min(Order9);
var max11 = max(Order9);
var greaterThan9 = greaterThan(Order9);
var greaterThanOrEqualTo6 = greaterThanOrEqualTo(Order9);
var lessThan13 = lessThan(Order9);
var lessThanOrEqualTo6 = lessThanOrEqualTo(Order9);
var between6 = between(Order9);
var isFuture = (self) => map14(now, lessThan13(self));
var unsafeIsFuture = (self) => lessThan13(unsafeNow(), self);
var isPast = (self) => map14(now, greaterThan9(self));
var unsafeIsPast = (self) => greaterThan9(unsafeNow(), self);
var toDateUtc = (self) => new Date(self.epochMillis);
var toDate = (self) => {
  if (self._tag === "Utc") {
    return new Date(self.epochMillis);
  } else if (self.zone._tag === "Offset") {
    return new Date(self.epochMillis + self.zone.offset);
  } else if (self.adjustedEpochMillis !== void 0) {
    return new Date(self.adjustedEpochMillis);
  }
  const parts2 = self.zone.format.formatToParts(self.epochMillis).filter((_) => _.type !== "literal");
  const date5 = /* @__PURE__ */ new Date(0);
  date5.setUTCFullYear(Number(parts2[2].value), Number(parts2[0].value) - 1, Number(parts2[1].value));
  date5.setUTCHours(Number(parts2[3].value), Number(parts2[4].value), Number(parts2[5].value), Number(parts2[6].value));
  self.adjustedEpochMillis = date5.getTime();
  return date5;
};
var zonedOffset = (self) => {
  const date5 = toDate(self);
  return date5.getTime() - toEpochMillis(self);
};
var offsetToString = (offset) => {
  const abs3 = Math.abs(offset);
  let hours2 = Math.floor(abs3 / (60 * 60 * 1e3));
  let minutes2 = Math.round(abs3 % (60 * 60 * 1e3) / (60 * 1e3));
  if (minutes2 === 60) {
    hours2 += 1;
    minutes2 = 0;
  }
  return `${offset < 0 ? "-" : "+"}${String(hours2).padStart(2, "0")}:${String(minutes2).padStart(2, "0")}`;
};
var zonedOffsetIso = (self) => offsetToString(zonedOffset(self));
var toEpochMillis = (self) => self.epochMillis;
var removeTime = (self) => withDate(self, (date5) => {
  date5.setUTCHours(0, 0, 0, 0);
  return makeUtc(date5.getTime());
});
var dateToParts = (date5) => ({
  millis: date5.getUTCMilliseconds(),
  seconds: date5.getUTCSeconds(),
  minutes: date5.getUTCMinutes(),
  hours: date5.getUTCHours(),
  day: date5.getUTCDate(),
  weekDay: date5.getUTCDay(),
  month: date5.getUTCMonth() + 1,
  year: date5.getUTCFullYear()
});
var toParts = (self) => {
  if (self._tag === "Utc") {
    return toPartsUtc(self);
  } else if (self.partsAdjusted !== void 0) {
    return self.partsAdjusted;
  }
  self.partsAdjusted = withDate(self, dateToParts);
  return self.partsAdjusted;
};
var toPartsUtc = (self) => {
  if (self.partsUtc !== void 0) {
    return self.partsUtc;
  }
  self.partsUtc = withDateUtc(self, dateToParts);
  return self.partsUtc;
};
var getPartUtc = dual(2, (self, part) => toPartsUtc(self)[part]);
var getPart = dual(2, (self, part) => toParts(self)[part]);
var setPartsDate = (date5, parts2) => {
  if (parts2.year !== void 0) {
    date5.setUTCFullYear(parts2.year);
  }
  if (parts2.month !== void 0) {
    date5.setUTCMonth(parts2.month - 1);
  }
  if (parts2.day !== void 0) {
    date5.setUTCDate(parts2.day);
  }
  if (parts2.weekDay !== void 0) {
    const diff13 = parts2.weekDay - date5.getUTCDay();
    date5.setUTCDate(date5.getUTCDate() + diff13);
  }
  if (parts2.hours !== void 0) {
    date5.setUTCHours(parts2.hours);
  }
  if (parts2.minutes !== void 0) {
    date5.setUTCMinutes(parts2.minutes);
  }
  if (parts2.seconds !== void 0) {
    date5.setUTCSeconds(parts2.seconds);
  }
  if (parts2.millis !== void 0) {
    date5.setUTCMilliseconds(parts2.millis);
  }
};
var setParts = dual(2, (self, parts2) => mutate5(self, (date5) => setPartsDate(date5, parts2)));
var setPartsUtc = dual(2, (self, parts2) => mutateUtc(self, (date5) => setPartsDate(date5, parts2)));
var makeZonedFromAdjusted = (adjustedMillis, zone) => {
  const offset = zone._tag === "Offset" ? zone.offset : calculateNamedOffset(adjustedMillis, zone);
  return makeZonedProto(adjustedMillis - offset, zone);
};
var offsetRegex = /([+-])(\d{2}):(\d{2})$/;
var parseOffset = (offset) => {
  const match43 = offsetRegex.exec(offset);
  if (match43 === null) {
    return null;
  }
  const [, sign4, hours2, minutes2] = match43;
  return (sign4 === "+" ? 1 : -1) * (Number(hours2) * 60 + Number(minutes2)) * 60 * 1e3;
};
var calculateNamedOffset = (adjustedMillis, zone) => {
  const offset = zone.format.formatToParts(adjustedMillis).find((_) => _.type === "timeZoneName")?.value ?? "";
  if (offset === "GMT") {
    return 0;
  }
  const result = parseOffset(offset);
  if (result === null) {
    return zonedOffset(makeZonedProto(adjustedMillis, zone));
  }
  return result;
};
var mutate5 = dual(2, (self, f) => {
  if (self._tag === "Utc") {
    const date5 = toDateUtc(self);
    f(date5);
    return makeUtc(date5.getTime());
  }
  const adjustedDate = toDate(self);
  const newAdjustedDate = new Date(adjustedDate.getTime());
  f(newAdjustedDate);
  return makeZonedFromAdjusted(newAdjustedDate.getTime(), self.zone);
});
var mutateUtc = dual(2, (self, f) => mapEpochMillis(self, (millis2) => {
  const date5 = new Date(millis2);
  f(date5);
  return date5.getTime();
}));
var mapEpochMillis = dual(2, (self, f) => {
  const millis2 = f(toEpochMillis(self));
  return self._tag === "Utc" ? makeUtc(millis2) : makeZonedProto(millis2, self.zone);
});
var withDate = dual(2, (self, f) => f(toDate(self)));
var withDateUtc = dual(2, (self, f) => f(toDateUtc(self)));
var match17 = dual(2, (self, options) => self._tag === "Utc" ? options.onUtc(self) : options.onZoned(self));
var addDuration = dual(2, (self, duration5) => mapEpochMillis(self, (millis2) => millis2 + toMillis(duration5)));
var subtractDuration = dual(2, (self, duration5) => mapEpochMillis(self, (millis2) => millis2 - toMillis(duration5)));
var addMillis = (date5, amount) => {
  date5.setTime(date5.getTime() + amount);
};
var add6 = dual(2, (self, parts2) => mutate5(self, (date5) => {
  if (parts2.millis) {
    addMillis(date5, parts2.millis);
  }
  if (parts2.seconds) {
    addMillis(date5, parts2.seconds * 1e3);
  }
  if (parts2.minutes) {
    addMillis(date5, parts2.minutes * 60 * 1e3);
  }
  if (parts2.hours) {
    addMillis(date5, parts2.hours * 60 * 60 * 1e3);
  }
  if (parts2.days) {
    date5.setUTCDate(date5.getUTCDate() + parts2.days);
  }
  if (parts2.weeks) {
    date5.setUTCDate(date5.getUTCDate() + parts2.weeks * 7);
  }
  if (parts2.months) {
    const day = date5.getUTCDate();
    date5.setUTCMonth(date5.getUTCMonth() + parts2.months + 1, 0);
    if (day < date5.getUTCDate()) {
      date5.setUTCDate(day);
    }
  }
  if (parts2.years) {
    const day = date5.getUTCDate();
    const month = date5.getUTCMonth();
    date5.setUTCFullYear(date5.getUTCFullYear() + parts2.years, month + 1, 0);
    if (day < date5.getUTCDate()) {
      date5.setUTCDate(day);
    }
  }
}));
var subtract5 = dual(2, (self, parts2) => {
  const newParts = {};
  for (const key in parts2) {
    newParts[key] = -1 * parts2[key];
  }
  return add6(self, newParts);
});
var startOfDate = (date5, part, options) => {
  switch (part) {
    case "second": {
      date5.setUTCMilliseconds(0);
      break;
    }
    case "minute": {
      date5.setUTCSeconds(0, 0);
      break;
    }
    case "hour": {
      date5.setUTCMinutes(0, 0, 0);
      break;
    }
    case "day": {
      date5.setUTCHours(0, 0, 0, 0);
      break;
    }
    case "week": {
      const weekStartsOn = options?.weekStartsOn ?? 0;
      const day = date5.getUTCDay();
      const diff13 = (day - weekStartsOn + 7) % 7;
      date5.setUTCDate(date5.getUTCDate() - diff13);
      date5.setUTCHours(0, 0, 0, 0);
      break;
    }
    case "month": {
      date5.setUTCDate(1);
      date5.setUTCHours(0, 0, 0, 0);
      break;
    }
    case "year": {
      date5.setUTCMonth(0, 1);
      date5.setUTCHours(0, 0, 0, 0);
      break;
    }
  }
};
var startOf = dual(isDateTimeArgs, (self, part, options) => mutate5(self, (date5) => startOfDate(date5, part, options)));
var endOfDate = (date5, part, options) => {
  switch (part) {
    case "second": {
      date5.setUTCMilliseconds(999);
      break;
    }
    case "minute": {
      date5.setUTCSeconds(59, 999);
      break;
    }
    case "hour": {
      date5.setUTCMinutes(59, 59, 999);
      break;
    }
    case "day": {
      date5.setUTCHours(23, 59, 59, 999);
      break;
    }
    case "week": {
      const weekStartsOn = options?.weekStartsOn ?? 0;
      const day = date5.getUTCDay();
      const diff13 = (day - weekStartsOn + 7) % 7;
      date5.setUTCDate(date5.getUTCDate() - diff13 + 6);
      date5.setUTCHours(23, 59, 59, 999);
      break;
    }
    case "month": {
      date5.setUTCMonth(date5.getUTCMonth() + 1, 0);
      date5.setUTCHours(23, 59, 59, 999);
      break;
    }
    case "year": {
      date5.setUTCMonth(11, 31);
      date5.setUTCHours(23, 59, 59, 999);
      break;
    }
  }
};
var endOf = dual(isDateTimeArgs, (self, part, options) => mutate5(self, (date5) => endOfDate(date5, part, options)));
var nearest = dual(isDateTimeArgs, (self, part, options) => mutate5(self, (date5) => {
  if (part === "milli") return;
  const millis2 = date5.getTime();
  const start5 = new Date(millis2);
  startOfDate(start5, part, options);
  const startMillis = start5.getTime();
  const end7 = new Date(millis2);
  endOfDate(end7, part, options);
  const endMillis = end7.getTime() + 1;
  const diffStart = millis2 - startMillis;
  const diffEnd = endMillis - millis2;
  if (diffStart < diffEnd) {
    date5.setTime(startMillis);
  } else {
    date5.setTime(endMillis);
  }
}));
var intlTimeZone = (self) => {
  if (self._tag === "Named") {
    return self.id;
  }
  return offsetToString(self.offset);
};
var format5 = dual(isDateTimeArgs, (self, options) => {
  try {
    return new Intl.DateTimeFormat(options?.locale, {
      timeZone: self._tag === "Utc" ? "UTC" : intlTimeZone(self.zone),
      ...options
    }).format(self.epochMillis);
  } catch {
    return new Intl.DateTimeFormat(options?.locale, {
      timeZone: "UTC",
      ...options
    }).format(toDate(self));
  }
});
var formatLocal = dual(isDateTimeArgs, (self, options) => new Intl.DateTimeFormat(options?.locale, options).format(self.epochMillis));
var formatUtc = dual(isDateTimeArgs, (self, options) => new Intl.DateTimeFormat(options?.locale, {
  ...options,
  timeZone: "UTC"
}).format(self.epochMillis));
var formatIntl = dual(2, (self, format8) => format8.format(self.epochMillis));
var formatIso2 = (self) => toDateUtc(self).toISOString();
var formatIsoDate = (self) => toDate(self).toISOString().slice(0, 10);
var formatIsoDateUtc = (self) => toDateUtc(self).toISOString().slice(0, 10);
var formatIsoOffset = (self) => {
  const date5 = toDate(self);
  return self._tag === "Utc" ? date5.toISOString() : `${date5.toISOString().slice(0, -1)}${zonedOffsetIso(self)}`;
};
var formatIsoZoned = (self) => self.zone._tag === "Offset" ? formatIsoOffset(self) : `${formatIsoOffset(self)}[${self.zone.id}]`;

// ../../node_modules/effect/dist/esm/String.js
var String_exports = {};
__export(String_exports, {
  Equivalence: () => Equivalence7,
  Order: () => Order10,
  at: () => at4,
  camelToSnake: () => camelToSnake,
  capitalize: () => capitalize,
  charAt: () => charAt,
  charCodeAt: () => charCodeAt,
  codePointAt: () => codePointAt,
  concat: () => concat2,
  empty: () => empty41,
  endsWith: () => endsWith,
  includes: () => includes2,
  indexOf: () => indexOf,
  isEmpty: () => isEmpty14,
  isNonEmpty: () => isNonEmpty7,
  isString: () => isString2,
  kebabToSnake: () => kebabToSnake,
  lastIndexOf: () => lastIndexOf,
  length: () => length4,
  linesIterator: () => linesIterator,
  linesWithSeparators: () => linesWithSeparators,
  localeCompare: () => localeCompare,
  match: () => match18,
  matchAll: () => matchAll,
  normalize: () => normalize2,
  padEnd: () => padEnd,
  padStart: () => padStart,
  pascalToSnake: () => pascalToSnake,
  repeat: () => repeat2,
  replace: () => replace5,
  replaceAll: () => replaceAll,
  search: () => search,
  slice: () => slice,
  snakeToCamel: () => snakeToCamel,
  snakeToKebab: () => snakeToKebab,
  snakeToPascal: () => snakeToPascal,
  split: () => split3,
  startsWith: () => startsWith,
  stripMargin: () => stripMargin,
  stripMarginWith: () => stripMarginWith,
  substring: () => substring,
  takeLeft: () => takeLeft,
  takeRight: () => takeRight3,
  toLocaleLowerCase: () => toLocaleLowerCase,
  toLocaleUpperCase: () => toLocaleUpperCase,
  toLowerCase: () => toLowerCase,
  toUpperCase: () => toUpperCase,
  trim: () => trim,
  trimEnd: () => trimEnd,
  trimStart: () => trimStart,
  uncapitalize: () => uncapitalize
});
var isString2 = isString;
var Equivalence7 = string;
var Order10 = string3;
var empty41 = "";
var concat2 = dual(2, (self, that) => self + that);
var toUpperCase = (self) => self.toUpperCase();
var toLowerCase = (self) => self.toLowerCase();
var capitalize = (self) => {
  if (self.length === 0) return self;
  return toUpperCase(self[0]) + self.slice(1);
};
var uncapitalize = (self) => {
  if (self.length === 0) return self;
  return toLowerCase(self[0]) + self.slice(1);
};
var replace5 = (searchValue, replaceValue) => (self) => self.replace(searchValue, replaceValue);
var trim = (self) => self.trim();
var trimStart = (self) => self.trimStart();
var trimEnd = (self) => self.trimEnd();
var slice = (start5, end7) => (self) => self.slice(start5, end7);
var isEmpty14 = (self) => self.length === 0;
var isNonEmpty7 = (self) => self.length > 0;
var length4 = (self) => self.length;
var split3 = dual(2, (self, separator) => {
  const out = self.split(separator);
  return isNonEmptyArray(out) ? out : [self];
});
var includes2 = (searchString, position) => (self) => self.includes(searchString, position);
var startsWith = (searchString, position) => (self) => self.startsWith(searchString, position);
var endsWith = (searchString, position) => (self) => self.endsWith(searchString, position);
var charCodeAt = dual(2, (self, index) => filter(some3(self.charCodeAt(index)), (charCode) => !isNaN(charCode)));
var substring = (start5, end7) => (self) => self.substring(start5, end7);
var at4 = dual(2, (self, index) => fromNullable2(self.at(index)));
var charAt = dual(2, (self, index) => filter(some3(self.charAt(index)), isNonEmpty7));
var codePointAt = dual(2, (self, index) => fromNullable2(self.codePointAt(index)));
var indexOf = (searchString) => (self) => filter(some3(self.indexOf(searchString)), greaterThanOrEqualTo2(0));
var lastIndexOf = (searchString) => (self) => filter(some3(self.lastIndexOf(searchString)), greaterThanOrEqualTo2(0));
var localeCompare = (that, locales, options) => (self) => sign(self.localeCompare(that, locales, options));
var match18 = (regexp) => (self) => fromNullable2(self.match(regexp));
var matchAll = (regexp) => (self) => self.matchAll(regexp);
var normalize2 = (form) => (self) => self.normalize(form);
var padEnd = (maxLength2, fillString) => (self) => self.padEnd(maxLength2, fillString);
var padStart = (maxLength2, fillString) => (self) => self.padStart(maxLength2, fillString);
var repeat2 = (count9) => (self) => self.repeat(count9);
var replaceAll = (searchValue, replaceValue) => (self) => self.replaceAll(searchValue, replaceValue);
var search = dual(2, (self, regexp) => filter(some3(self.search(regexp)), greaterThanOrEqualTo2(0)));
var toLocaleLowerCase = (locale) => (self) => self.toLocaleLowerCase(locale);
var toLocaleUpperCase = (locale) => (self) => self.toLocaleUpperCase(locale);
var takeLeft = dual(2, (self, n) => self.slice(0, Math.max(n, 0)));
var takeRight3 = dual(2, (self, n) => self.slice(Math.max(0, self.length - Math.floor(n)), Infinity));
var CR = 13;
var LF = 10;
var linesIterator = (self) => linesSeparated(self, true);
var linesWithSeparators = (s) => linesSeparated(s, false);
var stripMarginWith = dual(2, (self, marginChar) => {
  let out = "";
  for (const line of linesWithSeparators(self)) {
    let index = 0;
    while (index < line.length && line.charAt(index) <= " ") {
      index = index + 1;
    }
    const stripped = index < line.length && line.charAt(index) === marginChar ? line.substring(index + 1) : line;
    out = out + stripped;
  }
  return out;
});
var stripMargin = (self) => stripMarginWith(self, "|");
var snakeToCamel = (self) => {
  let str = self[0];
  for (let i = 1; i < self.length; i++) {
    str += self[i] === "_" ? self[++i].toUpperCase() : self[i];
  }
  return str;
};
var snakeToPascal = (self) => {
  let str = self[0].toUpperCase();
  for (let i = 1; i < self.length; i++) {
    str += self[i] === "_" ? self[++i].toUpperCase() : self[i];
  }
  return str;
};
var snakeToKebab = (self) => self.replace(/_/g, "-");
var camelToSnake = (self) => self.replace(/([A-Z])/g, "_$1").toLowerCase();
var pascalToSnake = (self) => (self.slice(0, 1) + self.slice(1).replace(/([A-Z])/g, "_$1")).toLowerCase();
var kebabToSnake = (self) => self.replace(/-/g, "_");
var LinesIterator = class _LinesIterator {
  s;
  stripped;
  index;
  length;
  constructor(s, stripped = false) {
    this.s = s;
    this.stripped = stripped;
    this.index = 0;
    this.length = s.length;
  }
  next() {
    if (this.done) {
      return {
        done: true,
        value: void 0
      };
    }
    const start5 = this.index;
    while (!this.done && !isLineBreak(this.s[this.index])) {
      this.index = this.index + 1;
    }
    let end7 = this.index;
    if (!this.done) {
      const char2 = this.s[this.index];
      this.index = this.index + 1;
      if (!this.done && isLineBreak2(char2, this.s[this.index])) {
        this.index = this.index + 1;
      }
      if (!this.stripped) {
        end7 = this.index;
      }
    }
    return {
      done: false,
      value: this.s.substring(start5, end7)
    };
  }
  [Symbol.iterator]() {
    return new _LinesIterator(this.s, this.stripped);
  }
  get done() {
    return this.index >= this.length;
  }
};
var isLineBreak = (char2) => {
  const code = char2.charCodeAt(0);
  return code === CR || code === LF;
};
var isLineBreak2 = (char0, char1) => char0.charCodeAt(0) === CR && char1.charCodeAt(0) === LF;
var linesSeparated = (self, stripped) => new LinesIterator(self, stripped);

// ../../node_modules/effect/dist/esm/Cron.js
var TypeId21 = Symbol.for("effect/Cron");
var CronProto = {
  [TypeId21]: TypeId21,
  [symbol3](that) {
    return isCron(that) && equals5(this, that);
  },
  [symbol2]() {
    return pipe(hash(this.tz), combine2(array2(fromIterable2(this.seconds))), combine2(array2(fromIterable2(this.minutes))), combine2(array2(fromIterable2(this.hours))), combine2(array2(fromIterable2(this.days))), combine2(array2(fromIterable2(this.months))), combine2(array2(fromIterable2(this.weekdays))), cached(this));
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Cron",
      tz: this.tz,
      seconds: fromIterable2(this.seconds),
      minutes: fromIterable2(this.minutes),
      hours: fromIterable2(this.hours),
      days: fromIterable2(this.days),
      months: fromIterable2(this.months),
      weekdays: fromIterable2(this.weekdays)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isCron = (u) => hasProperty(u, TypeId21);
var make58 = (values15) => {
  const o = Object.create(CronProto);
  o.seconds = new Set(sort(values15.seconds ?? [0], Order));
  o.minutes = new Set(sort(values15.minutes, Order));
  o.hours = new Set(sort(values15.hours, Order));
  o.days = new Set(sort(values15.days, Order));
  o.months = new Set(sort(values15.months, Order));
  o.weekdays = new Set(sort(values15.weekdays, Order));
  o.tz = fromNullable2(values15.tz);
  const seconds2 = Array.from(o.seconds);
  const minutes2 = Array.from(o.minutes);
  const hours2 = Array.from(o.hours);
  const days2 = Array.from(o.days);
  const months = Array.from(o.months);
  const weekdays = Array.from(o.weekdays);
  o.first = {
    second: seconds2[0] ?? 0,
    minute: minutes2[0] ?? 0,
    hour: hours2[0] ?? 0,
    day: days2[0] ?? 1,
    month: (months[0] ?? 1) - 1,
    weekday: weekdays[0] ?? 0
  };
  o.next = {
    second: nextLookupTable(seconds2, 60),
    minute: nextLookupTable(minutes2, 60),
    hour: nextLookupTable(hours2, 24),
    day: nextLookupTable(days2, 32),
    month: nextLookupTable(months, 13),
    weekday: nextLookupTable(weekdays, 7)
  };
  return o;
};
var nextLookupTable = (values15, size40) => {
  const result = new Array(size40).fill(void 0);
  if (values15.length === 0) {
    return result;
  }
  let current2 = void 0;
  let index = values15.length - 1;
  for (let i = size40 - 1; i >= 0; i--) {
    while (index >= 0 && values15[index] >= i) {
      current2 = values15[index--];
    }
    result[i] = current2;
  }
  return result;
};
var ParseErrorTypeId = Symbol.for("effect/Cron/errors/ParseError");
var ParseError = class extends TaggedError2("CronParseError") {
  /**
   * @since 2.0.0
   */
  [ParseErrorTypeId] = ParseErrorTypeId;
};
var isParseError = (u) => hasProperty(u, ParseErrorTypeId);
var parse2 = (cron3, tz) => {
  const segments = cron3.split(" ").filter(isNonEmpty7);
  if (segments.length !== 5 && segments.length !== 6) {
    return left2(new ParseError({
      message: `Invalid number of segments in cron expression`,
      input: cron3
    }));
  }
  if (segments.length === 5) {
    segments.unshift("0");
  }
  const [seconds2, minutes2, hours2, days2, months, weekdays] = segments;
  const zone = tz === void 0 || isTimeZone(tz) ? right2(tz) : fromOption2(zoneFromString(tz), () => new ParseError({
    message: `Invalid time zone in cron expression`,
    input: tz
  }));
  return all3({
    tz: zone,
    seconds: parseSegment(seconds2, secondOptions),
    minutes: parseSegment(minutes2, minuteOptions),
    hours: parseSegment(hours2, hourOptions),
    days: parseSegment(days2, dayOptions),
    months: parseSegment(months, monthOptions),
    weekdays: parseSegment(weekdays, weekdayOptions)
  }).pipe(map(make58));
};
var unsafeParse = (cron3, tz) => getOrThrowWith(parse2(cron3, tz), identity);
var match19 = (cron3, date5) => {
  const parts2 = unsafeMakeZoned(date5, {
    timeZone: getOrUndefined2(cron3.tz)
  }).pipe(toParts);
  if (cron3.seconds.size !== 0 && !cron3.seconds.has(parts2.seconds)) {
    return false;
  }
  if (cron3.minutes.size !== 0 && !cron3.minutes.has(parts2.minutes)) {
    return false;
  }
  if (cron3.hours.size !== 0 && !cron3.hours.has(parts2.hours)) {
    return false;
  }
  if (cron3.months.size !== 0 && !cron3.months.has(parts2.month)) {
    return false;
  }
  if (cron3.days.size === 0 && cron3.weekdays.size === 0) {
    return true;
  }
  if (cron3.weekdays.size === 0) {
    return cron3.days.has(parts2.day);
  }
  if (cron3.days.size === 0) {
    return cron3.weekdays.has(parts2.weekDay);
  }
  return cron3.days.has(parts2.day) || cron3.weekdays.has(parts2.weekDay);
};
var daysInMonth = (date5) => new Date(Date.UTC(date5.getUTCFullYear(), date5.getUTCMonth() + 1, 0)).getUTCDate();
var next2 = (cron3, startFrom) => {
  const tz = getOrUndefined2(cron3.tz);
  const zoned = unsafeMakeZoned(startFrom ?? /* @__PURE__ */ new Date(), {
    timeZone: tz
  });
  const utc = tz !== void 0 && isTimeZoneNamed(tz) && tz.id === "UTC";
  const adjustDst = utc ? constVoid : (current2) => {
    const adjusted = unsafeMakeZoned(current2, {
      timeZone: zoned.zone,
      adjustForTimeZone: true
    }).pipe(toDate);
    const drift = current2.getTime() - adjusted.getTime();
    if (drift > 0) {
      current2.setTime(current2.getTime() + drift);
    }
  };
  const result = mutate5(zoned, (current2) => {
    current2.setUTCSeconds(current2.getUTCSeconds() + 1, 0);
    for (let i = 0; i < 1e4; i++) {
      if (cron3.seconds.size !== 0) {
        const currentSecond = current2.getUTCSeconds();
        const nextSecond2 = cron3.next.second[currentSecond];
        if (nextSecond2 === void 0) {
          current2.setUTCMinutes(current2.getUTCMinutes() + 1, cron3.first.second);
          adjustDst(current2);
          continue;
        }
        if (nextSecond2 > currentSecond) {
          current2.setUTCSeconds(nextSecond2);
          adjustDst(current2);
          continue;
        }
      }
      if (cron3.minutes.size !== 0) {
        const currentMinute = current2.getUTCMinutes();
        const nextMinute2 = cron3.next.minute[currentMinute];
        if (nextMinute2 === void 0) {
          current2.setUTCHours(current2.getUTCHours() + 1, cron3.first.minute, cron3.first.second);
          adjustDst(current2);
          continue;
        }
        if (nextMinute2 > currentMinute) {
          current2.setUTCMinutes(nextMinute2, cron3.first.second);
          adjustDst(current2);
          continue;
        }
      }
      if (cron3.hours.size !== 0) {
        const currentHour = current2.getUTCHours();
        const nextHour2 = cron3.next.hour[currentHour];
        if (nextHour2 === void 0) {
          current2.setUTCDate(current2.getUTCDate() + 1);
          current2.setUTCHours(cron3.first.hour, cron3.first.minute, cron3.first.second);
          adjustDst(current2);
          continue;
        }
        if (nextHour2 > currentHour) {
          current2.setUTCHours(nextHour2, cron3.first.minute, cron3.first.second);
          adjustDst(current2);
          continue;
        }
      }
      if (cron3.weekdays.size !== 0 || cron3.days.size !== 0) {
        let a = Infinity;
        let b = Infinity;
        if (cron3.weekdays.size !== 0) {
          const currentWeekday = current2.getUTCDay();
          const nextWeekday = cron3.next.weekday[currentWeekday];
          a = nextWeekday === void 0 ? 7 - currentWeekday + cron3.first.weekday : nextWeekday - currentWeekday;
        }
        if (cron3.days.size !== 0 && a !== 0) {
          const currentDay = current2.getUTCDate();
          const nextDay2 = cron3.next.day[currentDay];
          b = nextDay2 === void 0 ? daysInMonth(current2) - currentDay + cron3.first.day : nextDay2 - currentDay;
        }
        const addDays = Math.min(a, b);
        if (addDays !== 0) {
          current2.setUTCDate(current2.getUTCDate() + addDays);
          current2.setUTCHours(cron3.first.hour, cron3.first.minute, cron3.first.second);
          adjustDst(current2);
          continue;
        }
      }
      if (cron3.months.size !== 0) {
        const currentMonth = current2.getUTCMonth() + 1;
        const nextMonth = cron3.next.month[currentMonth];
        if (nextMonth === void 0) {
          current2.setUTCFullYear(current2.getUTCFullYear() + 1);
          current2.setUTCMonth(cron3.first.month, cron3.first.day);
          current2.setUTCHours(cron3.first.hour, cron3.first.minute, cron3.first.second);
          adjustDst(current2);
          continue;
        }
        if (nextMonth > currentMonth) {
          current2.setUTCMonth(nextMonth - 1, cron3.first.day);
          current2.setUTCHours(cron3.first.hour, cron3.first.minute, cron3.first.second);
          adjustDst(current2);
          continue;
        }
      }
      return;
    }
    throw new Error("Unable to find next cron date");
  });
  return toDateUtc(result);
};
var sequence = function* (cron3, startFrom) {
  while (true) {
    yield startFrom = next2(cron3, startFrom);
  }
};
var Equivalence8 = make((self, that) => restrictionsEquals(self.seconds, that.seconds) && restrictionsEquals(self.minutes, that.minutes) && restrictionsEquals(self.hours, that.hours) && restrictionsEquals(self.days, that.days) && restrictionsEquals(self.months, that.months) && restrictionsEquals(self.weekdays, that.weekdays));
var restrictionsArrayEquals = array(number);
var restrictionsEquals = (self, that) => restrictionsArrayEquals(fromIterable2(self), fromIterable2(that));
var equals5 = dual(2, (self, that) => Equivalence8(self, that));
var secondOptions = {
  min: 0,
  max: 59
};
var minuteOptions = {
  min: 0,
  max: 59
};
var hourOptions = {
  min: 0,
  max: 23
};
var dayOptions = {
  min: 1,
  max: 31
};
var monthOptions = {
  min: 1,
  max: 12,
  aliases: {
    jan: 1,
    feb: 2,
    mar: 3,
    apr: 4,
    may: 5,
    jun: 6,
    jul: 7,
    aug: 8,
    sep: 9,
    oct: 10,
    nov: 11,
    dec: 12
  }
};
var weekdayOptions = {
  min: 0,
  max: 6,
  aliases: {
    sun: 0,
    mon: 1,
    tue: 2,
    wed: 3,
    thu: 4,
    fri: 5,
    sat: 6
  }
};
var parseSegment = (input, options) => {
  const capacity10 = options.max - options.min + 1;
  const values15 = /* @__PURE__ */ new Set();
  const fields = input.split(",");
  for (const field of fields) {
    const [raw, step4] = splitStep(field);
    if (raw === "*" && step4 === void 0) {
      return right2(/* @__PURE__ */ new Set());
    }
    if (step4 !== void 0) {
      if (!Number.isInteger(step4)) {
        return left2(new ParseError({
          message: `Expected step value to be a positive integer`,
          input
        }));
      }
      if (step4 < 1) {
        return left2(new ParseError({
          message: `Expected step value to be greater than 0`,
          input
        }));
      }
      if (step4 > options.max) {
        return left2(new ParseError({
          message: `Expected step value to be less than ${options.max}`,
          input
        }));
      }
    }
    if (raw === "*") {
      for (let i = options.min; i <= options.max; i += step4 ?? 1) {
        values15.add(i);
      }
    } else {
      const [left3, right3] = splitRange(raw, options.aliases);
      if (!Number.isInteger(left3)) {
        return left2(new ParseError({
          message: `Expected a positive integer`,
          input
        }));
      }
      if (left3 < options.min || left3 > options.max) {
        return left2(new ParseError({
          message: `Expected a value between ${options.min} and ${options.max}`,
          input
        }));
      }
      if (right3 === void 0) {
        values15.add(left3);
      } else {
        if (!Number.isInteger(right3)) {
          return left2(new ParseError({
            message: `Expected a positive integer`,
            input
          }));
        }
        if (right3 < options.min || right3 > options.max) {
          return left2(new ParseError({
            message: `Expected a value between ${options.min} and ${options.max}`,
            input
          }));
        }
        if (left3 > right3) {
          return left2(new ParseError({
            message: `Invalid value range`,
            input
          }));
        }
        for (let i = left3; i <= right3; i += step4 ?? 1) {
          values15.add(i);
        }
      }
    }
    if (values15.size >= capacity10) {
      return right2(/* @__PURE__ */ new Set());
    }
  }
  return right2(values15);
};
var splitStep = (input) => {
  const seperator = input.indexOf("/");
  if (seperator !== -1) {
    return [input.slice(0, seperator), Number(input.slice(seperator + 1))];
  }
  return [input, void 0];
};
var splitRange = (input, aliases) => {
  const seperator = input.indexOf("-");
  if (seperator !== -1) {
    return [aliasOrValue(input.slice(0, seperator), aliases), aliasOrValue(input.slice(seperator + 1), aliases)];
  }
  return [aliasOrValue(input, aliases), void 0];
};
function aliasOrValue(field, aliases) {
  return aliases?.[field.toLocaleLowerCase()] ?? Number(field);
}

// ../../node_modules/effect/dist/esm/Random.js
var Random_exports = {};
__export(Random_exports, {
  Random: () => Random2,
  RandomTypeId: () => RandomTypeId2,
  choice: () => choice2,
  fixed: () => fixed2,
  make: () => make59,
  next: () => next3,
  nextBoolean: () => nextBoolean2,
  nextInt: () => nextInt2,
  nextIntBetween: () => nextIntBetween2,
  nextRange: () => nextRange2,
  randomWith: () => randomWith2,
  shuffle: () => shuffle2
});
var RandomTypeId2 = RandomTypeId;
var next3 = next;
var nextInt2 = nextInt;
var nextBoolean2 = nextBoolean;
var nextRange2 = nextRange;
var nextIntBetween2 = nextIntBetween;
var shuffle2 = shuffle;
var choice2 = choice;
var randomWith2 = randomWith;
var Random2 = randomTag;
var make59 = make30;
var fixed2 = fixed;

// ../../node_modules/effect/dist/esm/internal/schedule.js
var ScheduleSymbolKey = "effect/Schedule";
var ScheduleTypeId = Symbol.for(ScheduleSymbolKey);
var isSchedule = (u) => hasProperty(u, ScheduleTypeId);
var ScheduleDriverSymbolKey = "effect/ScheduleDriver";
var ScheduleDriverTypeId = Symbol.for(ScheduleDriverSymbolKey);
var defaultIterationMetadata = {
  start: 0,
  now: 0,
  input: void 0,
  output: void 0,
  elapsed: zero2,
  elapsedSincePrevious: zero2,
  recurrence: 0
};
var CurrentIterationMetadata = Reference2()("effect/Schedule/CurrentIterationMetadata", {
  defaultValue: () => defaultIterationMetadata
});
var scheduleVariance = {
  /* c8 ignore next */
  _Out: (_) => _,
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var scheduleDriverVariance = {
  /* c8 ignore next */
  _Out: (_) => _,
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var ScheduleImpl = class {
  initial;
  step;
  [ScheduleTypeId] = scheduleVariance;
  constructor(initial, step4) {
    this.initial = initial;
    this.step = step4;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var updateInfo = (iterationMetaRef, now3, input, output) => update3(iterationMetaRef, (prev) => prev.recurrence === 0 ? {
  now: now3,
  input,
  output,
  recurrence: prev.recurrence + 1,
  elapsed: zero2,
  elapsedSincePrevious: zero2,
  start: now3
} : {
  now: now3,
  input,
  output,
  recurrence: prev.recurrence + 1,
  elapsed: millis(now3 - prev.start),
  elapsedSincePrevious: millis(now3 - prev.now),
  start: prev.start
});
var ScheduleDriverImpl = class {
  schedule;
  ref;
  [ScheduleDriverTypeId] = scheduleDriverVariance;
  constructor(schedule4, ref) {
    this.schedule = schedule4;
    this.ref = ref;
  }
  get state() {
    return map14(get12(this.ref), (tuple7) => tuple7[1]);
  }
  get last() {
    return flatMap12(get12(this.ref), ([element2, _]) => {
      switch (element2._tag) {
        case "None": {
          return failSync(() => new NoSuchElementException());
        }
        case "Some": {
          return succeed(element2.value);
        }
      }
    });
  }
  iterationMeta = unsafeMake7(defaultIterationMetadata);
  get reset() {
    return set6(this.ref, [none2(), this.schedule.initial]).pipe(zipLeft2(set6(this.iterationMeta, defaultIterationMetadata)));
  }
  next(input) {
    return pipe(map14(get12(this.ref), (tuple7) => tuple7[1]), flatMap12((state) => pipe(currentTimeMillis2, flatMap12((now3) => pipe(suspend(() => this.schedule.step(now3, input, state)), flatMap12(([state2, out, decision]) => {
      const setState = set6(this.ref, [some3(out), state2]);
      if (isDone5(decision)) {
        return setState.pipe(zipRight2(fail2(none2())));
      }
      const millis2 = start2(decision.intervals) - now3;
      if (millis2 <= 0) {
        return setState.pipe(zipRight2(updateInfo(this.iterationMeta, now3, input, out)), as3(out));
      }
      const duration5 = millis(millis2);
      return pipe(setState, zipRight2(updateInfo(this.iterationMeta, now3, input, out)), zipRight2(sleep3(duration5)), as3(out));
    }))))));
  }
};
var makeWithState = (initial, step4) => new ScheduleImpl(initial, step4);
var addDelay = dual(2, (self, f) => addDelayEffect(self, (out) => sync(() => f(out))));
var addDelayEffect = dual(2, (self, f) => modifyDelayEffect(self, (out, duration5) => map14(f(out), (delay4) => sum4(duration5, decode(delay4)))));
var andThen10 = dual(2, (self, that) => map25(andThenEither(self, that), merge));
var andThenEither = dual(2, (self, that) => makeWithState([self.initial, that.initial, true], (now3, input, state) => state[2] ? flatMap12(self.step(now3, input, state[0]), ([lState, out, decision]) => {
  if (isDone5(decision)) {
    return map14(that.step(now3, input, state[1]), ([rState, out2, decision2]) => [[lState, rState, false], right2(out2), decision2]);
  }
  return succeed([[lState, state[1], true], left2(out), decision]);
}) : map14(that.step(now3, input, state[1]), ([rState, out, decision]) => [[state[0], rState, false], right2(out), decision])));
var as7 = dual(2, (self, out) => map25(self, () => out));
var asVoid5 = (self) => map25(self, constVoid);
var bothInOut = dual(2, (self, that) => makeWithState([self.initial, that.initial], (now3, [in1, in2], state) => zipWith6(self.step(now3, in1, state[0]), that.step(now3, in2, state[1]), ([lState, out, lDecision], [rState, out2, rDecision]) => {
  if (isContinue2(lDecision) && isContinue2(rDecision)) {
    const interval = pipe(lDecision.intervals, union12(rDecision.intervals));
    return [[lState, rState], [out, out2], _continue2(interval)];
  }
  return [[lState, rState], [out, out2], done7];
})));
var check2 = dual(2, (self, test3) => checkEffect(self, (input, out) => sync(() => test3(input, out))));
var checkEffect = dual(2, (self, test3) => makeWithState(self.initial, (now3, input, state) => flatMap12(self.step(now3, input, state), ([state2, out, decision]) => {
  if (isDone5(decision)) {
    return succeed([state2, out, done7]);
  }
  return map14(test3(input, out), (cont) => cont ? [state2, out, decision] : [state2, out, done7]);
})));
var collectAllInputs = () => collectAllOutputs(identity3());
var collectAllOutputs = (self) => reduce16(self, empty7(), (outs, out) => pipe(outs, append3(out)));
var collectUntil = (f) => collectAllOutputs(recurUntil(f));
var collectUntilEffect = (f) => collectAllOutputs(recurUntilEffect(f));
var collectWhile = (f) => collectAllOutputs(recurWhile(f));
var collectWhileEffect = (f) => collectAllOutputs(recurWhileEffect(f));
var compose4 = dual(2, (self, that) => makeWithState([self.initial, that.initial], (now3, input, state) => flatMap12(self.step(now3, input, state[0]), ([lState, out, lDecision]) => map14(that.step(now3, out, state[1]), ([rState, out2, rDecision]) => isDone5(lDecision) ? [[lState, rState], out2, done7] : isDone5(rDecision) ? [[lState, rState], out2, done7] : [[lState, rState], out2, _continue2(pipe(lDecision.intervals, max10(rDecision.intervals)))]))));
var mapInput6 = dual(2, (self, f) => mapInputEffect(self, (input2) => sync(() => f(input2))));
var mapInputContext2 = dual(2, (self, f) => makeWithState(self.initial, (now3, input, state) => mapInputContext(self.step(now3, input, state), f)));
var mapInputEffect = dual(2, (self, f) => makeWithState(self.initial, (now3, input2, state) => flatMap12(f(input2), (input) => self.step(now3, input, state))));
var cron = (expression, tz) => {
  const parsed = isCron(expression) ? right2(expression) : parse2(expression, tz);
  return makeWithState([true, [Number.MIN_SAFE_INTEGER, 0, 0]], (now3, _, [initial, previous2]) => {
    if (now3 < previous2[0]) {
      return succeed([[false, previous2], [previous2[1], previous2[2]], continueWith2(make52(previous2[1], previous2[2]))]);
    }
    if (isLeft2(parsed)) {
      return die2(parsed.left);
    }
    const cron3 = parsed.right;
    const date5 = new Date(now3);
    let next6;
    if (initial && match19(cron3, date5)) {
      next6 = now3;
    }
    next6 = next2(cron3, date5).getTime();
    const start5 = beginningOfSecond(next6);
    const end7 = endOfSecond(next6);
    return succeed([[false, [next6, start5, end7]], [start5, end7], continueWith2(make52(start5, end7))]);
  });
};
var dayOfMonth = (day) => {
  return makeWithState([Number.NEGATIVE_INFINITY, 0], (now3, _, state) => {
    if (!Number.isInteger(day) || day < 1 || 31 < day) {
      return dieSync(() => new IllegalArgumentException(`Invalid argument in: dayOfMonth(${day}). Must be in range 1...31`));
    }
    const n = state[1];
    const initial = n === 0;
    const day0 = nextDayOfMonth(now3, day, initial);
    const start5 = beginningOfDay(day0);
    const end7 = endOfDay(day0);
    const interval = make52(start5, end7);
    return succeed([[end7, n + 1], n, continueWith2(interval)]);
  });
};
var dayOfWeek = (day) => {
  return makeWithState([Number.MIN_SAFE_INTEGER, 0], (now3, _, state) => {
    if (!Number.isInteger(day) || day < 1 || 7 < day) {
      return dieSync(() => new IllegalArgumentException(`Invalid argument in: dayOfWeek(${day}). Must be in range 1 (Monday)...7 (Sunday)`));
    }
    const n = state[1];
    const initial = n === 0;
    const day0 = nextDay(now3, day, initial);
    const start5 = beginningOfDay(day0);
    const end7 = endOfDay(day0);
    const interval = make52(start5, end7);
    return succeed([[end7, n + 1], n, continueWith2(interval)]);
  });
};
var delayed = dual(2, (self, f) => delayedEffect(self, (duration5) => sync(() => f(duration5))));
var delayedEffect = dual(2, (self, f) => modifyDelayEffect(self, (_, delay4) => f(delay4)));
var delayedSchedule = (schedule4) => addDelay(schedule4, (x) => x);
var delays = (self) => makeWithState(self.initial, (now3, input, state) => pipe(self.step(now3, input, state), flatMap12(([state2, _, decision]) => {
  if (isDone5(decision)) {
    return succeed([state2, zero2, decision]);
  }
  return succeed([state2, millis(start2(decision.intervals) - now3), decision]);
})));
var mapBoth5 = dual(2, (self, {
  onInput,
  onOutput
}) => map25(mapInput6(self, onInput), onOutput));
var mapBothEffect = dual(2, (self, {
  onInput,
  onOutput
}) => mapEffect4(mapInputEffect(self, onInput), onOutput));
var driver = (self) => pipe(make36([none2(), self.initial]), map14((ref) => new ScheduleDriverImpl(self, ref)));
var duration = (durationInput) => {
  const duration5 = decode(durationInput);
  const durationMillis = toMillis(duration5);
  return makeWithState(true, (now3, _, state) => succeed(state ? [false, duration5, continueWith2(after2(now3 + durationMillis))] : [false, zero2, done7]));
};
var either5 = dual(2, (self, that) => union13(self, that));
var eitherWith = dual(3, (self, that, f) => unionWith2(self, that, f));
var ensuring3 = dual(2, (self, finalizer3) => makeWithState(self.initial, (now3, input, state) => flatMap12(self.step(now3, input, state), ([state2, out, decision]) => isDone5(decision) ? as3(finalizer3, [state2, out, decision]) : succeed([state2, out, decision]))));
var exponential2 = (baseInput, factor = 2) => {
  const base = decode(baseInput);
  return delayedSchedule(map25(forever3, (i) => times(base, Math.pow(factor, i))));
};
var fibonacci = (oneInput) => {
  const one = decode(oneInput);
  return delayedSchedule(pipe(unfold3([one, one], ([a, b]) => [b, sum4(a, b)]), map25((out) => out[0])));
};
var fixed3 = (intervalInput) => {
  const interval = decode(intervalInput);
  const intervalMillis = toMillis(interval);
  return makeWithState([none2(), 0], (now3, _, [option11, n]) => sync(() => {
    switch (option11._tag) {
      case "None": {
        return [[some3([now3, now3 + intervalMillis]), n + 1], n, continueWith2(after2(now3 + intervalMillis))];
      }
      case "Some": {
        const [startMillis, lastRun] = option11.value;
        const runningBehind = now3 > lastRun + intervalMillis;
        const boundary = equals(interval, zero2) ? interval : millis(intervalMillis - (now3 - startMillis) % intervalMillis);
        const sleepTime = equals(boundary, zero2) ? interval : boundary;
        const nextRun = runningBehind ? now3 : now3 + toMillis(sleepTime);
        return [[some3([startMillis, nextRun]), n + 1], n, continueWith2(after2(nextRun))];
      }
    }
  }));
};
var fromDelay = (delay4) => duration(delay4);
var fromDelays = (delay4, ...delays3) => makeWithState([[delay4, ...delays3].map((_) => decode(_)), true], (now3, _, [durations, cont]) => sync(() => {
  if (cont) {
    const x = durations[0];
    const interval = after2(now3 + toMillis(x));
    if (durations.length >= 2) {
      return [[durations.slice(1), true], x, continueWith2(interval)];
    }
    const y = durations.slice(1);
    return [[[x, ...y], false], x, continueWith2(interval)];
  }
  return [[durations, false], zero2, done7];
}));
var fromFunction2 = (f) => map25(identity3(), f);
var hourOfDay = (hour) => makeWithState([Number.NEGATIVE_INFINITY, 0], (now3, _, state) => {
  if (!Number.isInteger(hour) || hour < 0 || 23 < hour) {
    return dieSync(() => new IllegalArgumentException(`Invalid argument in: hourOfDay(${hour}). Must be in range 0...23`));
  }
  const n = state[1];
  const initial = n === 0;
  const hour0 = nextHour(now3, hour, initial);
  const start5 = beginningOfHour(hour0);
  const end7 = endOfHour(hour0);
  const interval = make52(start5, end7);
  return succeed([[end7, n + 1], n, continueWith2(interval)]);
});
var identity3 = () => makeWithState(void 0, (now3, input, state) => succeed([state, input, continueWith2(after2(now3))]));
var intersect5 = dual(2, (self, that) => intersectWith(self, that, intersect4));
var intersectWith = dual(3, (self, that, f) => makeWithState([self.initial, that.initial], (now3, input, state) => pipe(zipWith6(self.step(now3, input, state[0]), that.step(now3, input, state[1]), (a, b) => [a, b]), flatMap12(([[lState, out, lDecision], [rState, out2, rDecision]]) => {
  if (isContinue2(lDecision) && isContinue2(rDecision)) {
    return intersectWithLoop(self, that, input, lState, out, lDecision.intervals, rState, out2, rDecision.intervals, f);
  }
  return succeed([[lState, rState], [out, out2], done7]);
}))));
var intersectWithLoop = (self, that, input, lState, out, lInterval, rState, out2, rInterval, f) => {
  const combined = f(lInterval, rInterval);
  if (isNonEmpty6(combined)) {
    return succeed([[lState, rState], [out, out2], _continue2(combined)]);
  }
  if (pipe(lInterval, lessThan12(rInterval))) {
    return flatMap12(self.step(end2(lInterval), input, lState), ([lState2, out3, decision]) => {
      if (isDone5(decision)) {
        return succeed([[lState2, rState], [out3, out2], done7]);
      }
      return intersectWithLoop(self, that, input, lState2, out3, decision.intervals, rState, out2, rInterval, f);
    });
  }
  return flatMap12(that.step(end2(rInterval), input, rState), ([rState2, out22, decision]) => {
    if (isDone5(decision)) {
      return succeed([[lState, rState2], [out, out22], done7]);
    }
    return intersectWithLoop(self, that, input, lState, out, lInterval, rState2, out22, decision.intervals, f);
  });
};
var jittered = (self) => jitteredWith(self, {
  min: 0.8,
  max: 1.2
});
var jitteredWith = dual(2, (self, options) => {
  const {
    max: max13,
    min: min11
  } = Object.assign({
    min: 0.8,
    max: 1.2
  }, options);
  return delayedEffect(self, (duration5) => map14(next3, (random4) => {
    const d = toMillis(duration5);
    const jittered3 = d * min11 * (1 - random4) + d * max13 * random4;
    return millis(jittered3);
  }));
});
var linear2 = (baseInput) => {
  const base = decode(baseInput);
  return delayedSchedule(map25(forever3, (i) => times(base, i + 1)));
};
var map25 = dual(2, (self, f) => mapEffect4(self, (out) => sync(() => f(out))));
var mapEffect4 = dual(2, (self, f) => makeWithState(self.initial, (now3, input, state) => flatMap12(self.step(now3, input, state), ([state2, out, decision]) => map14(f(out), (out2) => [state2, out2, decision]))));
var minuteOfHour = (minute) => makeWithState([Number.MIN_SAFE_INTEGER, 0], (now3, _, state) => {
  if (!Number.isInteger(minute) || minute < 0 || 59 < minute) {
    return dieSync(() => new IllegalArgumentException(`Invalid argument in: minuteOfHour(${minute}). Must be in range 0...59`));
  }
  const n = state[1];
  const initial = n === 0;
  const minute0 = nextMinute(now3, minute, initial);
  const start5 = beginningOfMinute(minute0);
  const end7 = endOfMinute(minute0);
  const interval = make52(start5, end7);
  return succeed([[end7, n + 1], n, continueWith2(interval)]);
});
var modifyDelay = dual(2, (self, f) => modifyDelayEffect(self, (out, duration5) => sync(() => f(out, duration5))));
var modifyDelayEffect = dual(2, (self, f) => makeWithState(self.initial, (now3, input, state) => flatMap12(self.step(now3, input, state), ([state2, out, decision]) => {
  if (isDone5(decision)) {
    return succeed([state2, out, decision]);
  }
  const intervals = decision.intervals;
  const delay4 = size16(make52(now3, start2(intervals)));
  return map14(f(out, delay4), (durationInput) => {
    const duration5 = decode(durationInput);
    const oldStart = start2(intervals);
    const newStart = now3 + toMillis(duration5);
    const delta = newStart - oldStart;
    const newEnd = Math.max(0, end2(intervals) + delta);
    const newInterval = make52(newStart, newEnd);
    return [state2, out, continueWith2(newInterval)];
  });
})));
var onDecision = dual(2, (self, f) => makeWithState(self.initial, (now3, input, state) => flatMap12(self.step(now3, input, state), ([state2, out, decision]) => as3(f(out, decision), [state2, out, decision]))));
var passthrough2 = (self) => makeWithState(self.initial, (now3, input, state) => pipe(self.step(now3, input, state), map14(([state2, _, decision]) => [state2, input, decision])));
var provideContext3 = dual(2, (self, context15) => makeWithState(self.initial, (now3, input, state) => provideContext(self.step(now3, input, state), context15)));
var provideService4 = dual(3, (self, tag5, service4) => makeWithState(self.initial, (now3, input, state) => contextWithEffect((env) => provideContext(
  // @ts-expect-error
  self.step(now3, input, state),
  add2(env, tag5, service4)
))));
var recurUntil = (f) => untilInput(identity3(), f);
var recurUntilEffect = (f) => untilInputEffect(identity3(), f);
var recurUntilOption = (pf) => untilOutput(map25(identity3(), pf), isSome2);
var recurUpTo = (durationInput) => {
  const duration5 = decode(durationInput);
  return whileOutput(elapsed, (elapsed3) => lessThan5(elapsed3, duration5));
};
var recurWhile = (f) => whileInput(identity3(), f);
var recurWhileEffect = (f) => whileInputEffect(identity3(), f);
var recurs = (n) => whileOutput(forever3, (out) => out < n);
var reduce16 = dual(3, (self, zero3, f) => reduceEffect2(self, zero3, (z, out) => sync(() => f(z, out))));
var reduceEffect2 = dual(3, (self, zero3, f) => makeWithState([self.initial, zero3], (now3, input, [s, z]) => flatMap12(self.step(now3, input, s), ([s2, out, decision]) => isDone5(decision) ? succeed([[s2, z], z, decision]) : map14(f(z, out), (z2) => [[s2, z2], z, decision]))));
var repetitions = (self) => reduce16(self, 0, (n, _) => n + 1);
var resetAfter = dual(2, (self, durationInput) => {
  const duration5 = decode(durationInput);
  return pipe(self, intersect5(elapsed), resetWhen(([, time3]) => greaterThanOrEqualTo5(time3, duration5)), map25((out) => out[0]));
});
var resetWhen = dual(2, (self, f) => makeWithState(self.initial, (now3, input, state) => flatMap12(self.step(now3, input, state), ([state2, out, decision]) => f(out) ? self.step(now3, input, self.initial) : succeed([state2, out, decision]))));
var run = dual(3, (self, now3, input) => pipe(runLoop(self, now3, fromIterable3(input), self.initial, empty7()), map14((list) => reverse3(list))));
var runLoop = (self, now3, inputs, state, acc) => {
  if (!isNonEmpty2(inputs)) {
    return succeed(acc);
  }
  const input = headNonEmpty2(inputs);
  const nextInputs = tailNonEmpty2(inputs);
  return flatMap12(self.step(now3, input, state), ([state2, out, decision]) => {
    if (isDone5(decision)) {
      return sync(() => pipe(acc, prepend3(out)));
    }
    return runLoop(self, start2(decision.intervals), nextInputs, state2, prepend3(acc, out));
  });
};
var secondOfMinute = (second) => makeWithState([Number.NEGATIVE_INFINITY, 0], (now3, _, state) => {
  if (!Number.isInteger(second) || second < 0 || 59 < second) {
    return dieSync(() => new IllegalArgumentException(`Invalid argument in: secondOfMinute(${second}). Must be in range 0...59`));
  }
  const n = state[1];
  const initial = n === 0;
  const second0 = nextSecond(now3, second, initial);
  const start5 = beginningOfSecond(second0);
  const end7 = endOfSecond(second0);
  const interval = make52(start5, end7);
  return succeed([[end7, n + 1], n, continueWith2(interval)]);
});
var spaced = (duration5) => addDelay(forever3, () => duration5);
var succeed11 = (value10) => map25(forever3, () => value10);
var sync7 = (evaluate4) => map25(forever3, evaluate4);
var tapInput = dual(2, (self, f) => makeWithState(self.initial, (now3, input, state) => zipRight2(f(input), self.step(now3, input, state))));
var tapOutput = dual(2, (self, f) => makeWithState(self.initial, (now3, input, state) => tap2(self.step(now3, input, state), ([, out]) => f(out))));
var unfold3 = (initial, f) => makeWithState(initial, (now3, _, state) => sync(() => [f(state), state, continueWith2(after2(now3))]));
var union13 = dual(2, (self, that) => unionWith2(self, that, union12));
var unionWith2 = dual(3, (self, that, f) => makeWithState([self.initial, that.initial], (now3, input, state) => zipWith6(self.step(now3, input, state[0]), that.step(now3, input, state[1]), ([lState, l, lDecision], [rState, r, rDecision]) => {
  if (isDone5(lDecision) && isDone5(rDecision)) {
    return [[lState, rState], [l, r], done7];
  }
  if (isDone5(lDecision) && isContinue2(rDecision)) {
    return [[lState, rState], [l, r], _continue2(rDecision.intervals)];
  }
  if (isContinue2(lDecision) && isDone5(rDecision)) {
    return [[lState, rState], [l, r], _continue2(lDecision.intervals)];
  }
  if (isContinue2(lDecision) && isContinue2(rDecision)) {
    const combined = f(lDecision.intervals, rDecision.intervals);
    return [[lState, rState], [l, r], _continue2(combined)];
  }
  throw new Error("BUG: Schedule.unionWith - please report an issue at https://github.com/Effect-TS/effect/issues");
})));
var untilInput = dual(2, (self, f) => check2(self, (input, _) => !f(input)));
var untilInputEffect = dual(2, (self, f) => checkEffect(self, (input, _) => negate3(f(input))));
var untilOutput = dual(2, (self, f) => check2(self, (_, out) => !f(out)));
var untilOutputEffect = dual(2, (self, f) => checkEffect(self, (_, out) => negate3(f(out))));
var upTo = dual(2, (self, duration5) => zipLeft6(self, recurUpTo(duration5)));
var whileInput = dual(2, (self, f) => check2(self, (input, _) => f(input)));
var whileInputEffect = dual(2, (self, f) => checkEffect(self, (input, _) => f(input)));
var whileOutput = dual(2, (self, f) => check2(self, (_, out) => f(out)));
var whileOutputEffect = dual(2, (self, f) => checkEffect(self, (_, out) => f(out)));
var windowed = (intervalInput) => {
  const interval = decode(intervalInput);
  const millis2 = toMillis(interval);
  return makeWithState([none2(), 0], (now3, _, [option11, n]) => {
    switch (option11._tag) {
      case "None": {
        return succeed([[some3(now3), n + 1], n, continueWith2(after2(now3 + millis2))]);
      }
      case "Some": {
        return succeed([[some3(option11.value), n + 1], n, continueWith2(after2(now3 + (millis2 - (now3 - option11.value) % millis2)))]);
      }
    }
  });
};
var zipLeft6 = dual(2, (self, that) => map25(intersect5(self, that), (out) => out[0]));
var zipRight6 = dual(2, (self, that) => map25(intersect5(self, that), (out) => out[1]));
var zipWith11 = dual(3, (self, that, f) => map25(intersect5(self, that), ([out, out2]) => f(out, out2)));
var beginningOfSecond = (now3) => {
  const date5 = new Date(now3);
  return new Date(date5.getFullYear(), date5.getMonth(), date5.getDate(), date5.getHours(), date5.getMinutes(), date5.getSeconds(), 0).getTime();
};
var endOfSecond = (now3) => {
  const date5 = new Date(beginningOfSecond(now3));
  return date5.setSeconds(date5.getSeconds() + 1);
};
var nextSecond = (now3, second, initial) => {
  const date5 = new Date(now3);
  if (date5.getSeconds() === second && initial) {
    return now3;
  }
  if (date5.getSeconds() < second) {
    return date5.setSeconds(second);
  }
  const newDate = new Date(date5.setSeconds(second));
  return newDate.setTime(newDate.getTime() + 1e3 * 60);
};
var beginningOfMinute = (now3) => {
  const date5 = new Date(now3);
  return new Date(date5.getFullYear(), date5.getMonth(), date5.getDate(), date5.getHours(), date5.getMinutes(), 0, 0).getTime();
};
var endOfMinute = (now3) => {
  const date5 = new Date(beginningOfMinute(now3));
  return date5.setMinutes(date5.getMinutes() + 1);
};
var nextMinute = (now3, minute, initial) => {
  const date5 = new Date(now3);
  if (date5.getMinutes() === minute && initial) {
    return now3;
  }
  if (date5.getMinutes() < minute) {
    return date5.setMinutes(minute);
  }
  const newDate = new Date(date5.setMinutes(minute));
  return newDate.setTime(newDate.getTime() + 1e3 * 60 * 60);
};
var beginningOfHour = (now3) => {
  const date5 = new Date(now3);
  return new Date(date5.getFullYear(), date5.getMonth(), date5.getDate(), date5.getHours(), 0, 0, 0).getTime();
};
var endOfHour = (now3) => {
  const date5 = new Date(beginningOfHour(now3));
  return date5.setHours(date5.getHours() + 1);
};
var nextHour = (now3, hour, initial) => {
  const date5 = new Date(now3);
  if (date5.getHours() === hour && initial) {
    return now3;
  }
  if (date5.getHours() < hour) {
    return date5.setHours(hour);
  }
  const newDate = new Date(date5.setHours(hour));
  return newDate.setTime(newDate.getTime() + 1e3 * 60 * 60 * 24);
};
var beginningOfDay = (now3) => {
  const date5 = new Date(now3);
  return new Date(date5.getFullYear(), date5.getMonth(), date5.getDate(), 0, 0, 0, 0).getTime();
};
var endOfDay = (now3) => {
  const date5 = new Date(beginningOfDay(now3));
  return date5.setDate(date5.getDate() + 1);
};
var nextDay = (now3, dayOfWeek3, initial) => {
  const date5 = new Date(now3);
  if (date5.getDay() === dayOfWeek3 && initial) {
    return now3;
  }
  const nextDayOfWeek = (7 + dayOfWeek3 - date5.getDay()) % 7;
  return date5.setDate(date5.getDate() + (nextDayOfWeek === 0 ? 7 : nextDayOfWeek));
};
var nextDayOfMonth = (now3, day, initial) => {
  const date5 = new Date(now3);
  if (date5.getDate() === day && initial) {
    return now3;
  }
  if (date5.getDate() < day) {
    return date5.setDate(day);
  }
  return findNextMonth(now3, day, 1);
};
var findNextMonth = (now3, day, months) => {
  const d = new Date(now3);
  const tmp1 = new Date(d.setDate(day));
  const tmp2 = new Date(tmp1.setMonth(tmp1.getMonth() + months));
  if (tmp2.getDate() === day) {
    const d2 = new Date(now3);
    const tmp3 = new Date(d2.setDate(day));
    return tmp3.setMonth(tmp3.getMonth() + months);
  }
  return findNextMonth(now3, day, months + 1);
};
var ScheduleDefectTypeId = Symbol.for("effect/Schedule/ScheduleDefect");
var ScheduleDefect = class {
  error;
  [ScheduleDefectTypeId];
  constructor(error4) {
    this.error = error4;
    this[ScheduleDefectTypeId] = ScheduleDefectTypeId;
  }
};
var isScheduleDefect = (u) => hasProperty(u, ScheduleDefectTypeId);
var scheduleDefectWrap = (self) => catchAll(self, (e) => die2(new ScheduleDefect(e)));
var scheduleDefectRefailCause = (cause3) => match2(find(cause3, (_) => isDieType(_) && isScheduleDefect(_.defect) ? some3(_.defect) : none2()), {
  onNone: () => cause3,
  onSome: (error4) => fail(error4.error)
});
var scheduleDefectRefail = (effect4) => catchAllCause(effect4, (cause3) => failCause(scheduleDefectRefailCause(cause3)));
var repeat_Effect = dual(2, (self, schedule4) => repeatOrElse_Effect(self, schedule4, (e, _) => fail2(e)));
var repeat_combined = dual(2, (self, options) => {
  if (isSchedule(options)) {
    return repeat_Effect(self, options);
  }
  const base = options.schedule ?? passthrough2(forever3);
  const withWhile = options.while ? whileInputEffect(base, (a) => {
    const applied = options.while(a);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : base;
  const withUntil = options.until ? untilInputEffect(withWhile, (a) => {
    const applied = options.until(a);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : withWhile;
  const withTimes = options.times ? intersect5(withUntil, recurs(options.times)).pipe(map25((intersectionPair) => intersectionPair[0])) : withUntil;
  return scheduleDefectRefail(repeat_Effect(self, withTimes));
});
var repeatOrElse_Effect = dual(3, (self, schedule4, orElse24) => flatMap12(driver(schedule4), (driver3) => matchEffect(self, {
  onFailure: (error4) => orElse24(error4, none2()),
  onSuccess: (value10) => repeatOrElseEffectLoop(provideServiceEffect(self, CurrentIterationMetadata, get12(driver3.iterationMeta)), driver3, (error4, option11) => provideServiceEffect(orElse24(error4, option11), CurrentIterationMetadata, get12(driver3.iterationMeta)), value10)
})));
var repeatOrElseEffectLoop = (self, driver3, orElse24, value10) => matchEffect(driver3.next(value10), {
  onFailure: () => orDie(driver3.last),
  onSuccess: (b) => matchEffect(self, {
    onFailure: (error4) => orElse24(error4, some3(b)),
    onSuccess: (value11) => repeatOrElseEffectLoop(self, driver3, orElse24, value11)
  })
});
var retry_Effect = dual(2, (self, policy) => retryOrElse_Effect(self, policy, (e, _) => fail2(e)));
var retry_combined = dual(2, (self, options) => {
  if (isSchedule(options)) {
    return retry_Effect(self, options);
  }
  return scheduleDefectRefail(retry_Effect(self, fromRetryOptions(options)));
});
var fromRetryOptions = (options) => {
  const base = options.schedule ?? forever3;
  const withWhile = options.while ? whileInputEffect(base, (e) => {
    const applied = options.while(e);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : base;
  const withUntil = options.until ? untilInputEffect(withWhile, (e) => {
    const applied = options.until(e);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : withWhile;
  return options.times ? intersect5(withUntil, recurs(options.times)) : withUntil;
};
var retryOrElse_Effect = dual(3, (self, policy, orElse24) => flatMap12(driver(policy), (driver3) => retryOrElse_EffectLoop(provideServiceEffect(self, CurrentIterationMetadata, get12(driver3.iterationMeta)), driver3, (e, out) => provideServiceEffect(orElse24(e, out), CurrentIterationMetadata, get12(driver3.iterationMeta)))));
var retryOrElse_EffectLoop = (self, driver3, orElse24) => {
  return catchAll(self, (e) => matchEffect(driver3.next(e), {
    onFailure: () => pipe(driver3.last, orDie, flatMap12((out) => orElse24(e, out))),
    onSuccess: () => retryOrElse_EffectLoop(self, driver3, orElse24)
  }));
};
var schedule_Effect = dual(2, (self, schedule4) => scheduleFrom_Effect(self, void 0, schedule4));
var scheduleFrom_Effect = dual(3, (self, initial, schedule4) => flatMap12(driver(schedule4), (driver3) => scheduleFrom_EffectLoop(provideServiceEffect(self, CurrentIterationMetadata, get12(driver3.iterationMeta)), initial, driver3)));
var scheduleFrom_EffectLoop = (self, initial, driver3) => matchEffect(driver3.next(initial), {
  onFailure: () => orDie(driver3.last),
  onSuccess: () => flatMap12(self, (a) => scheduleFrom_EffectLoop(self, a, driver3))
});
var count2 = unfold3(0, (n) => n + 1);
var elapsed = makeWithState(none2(), (now3, _, state) => {
  switch (state._tag) {
    case "None": {
      return succeed([some3(now3), zero2, continueWith2(after2(now3))]);
    }
    case "Some": {
      return succeed([some3(state.value), millis(now3 - state.value), continueWith2(after2(now3))]);
    }
  }
});
var forever3 = unfold3(0, (n) => n + 1);
var once2 = asVoid5(recurs(1));
var stop = asVoid5(recurs(0));
var scheduleForked = dual(2, (self, schedule4) => forkScoped2(schedule_Effect(self, schedule4)));

// ../../node_modules/effect/dist/esm/internal/executionPlan.js
var TypeId22 = Symbol.for("effect/ExecutionPlan");
var isExecutionPlan = (u) => hasProperty(u, TypeId22);
var withExecutionPlan = dual(2, (effect4, plan) => suspend(() => {
  let i = 0;
  let result;
  return flatMap12(whileLoop({
    while: () => i < plan.steps.length && (result === void 0 || isLeft2(result)),
    body: () => {
      const step4 = plan.steps[i];
      let nextEffect = effect_provide(effect4, step4.provide);
      if (result) {
        let attempted = false;
        const wrapped = nextEffect;
        nextEffect = suspend(() => {
          if (attempted) return wrapped;
          attempted = true;
          return result;
        });
        nextEffect = scheduleDefectRefail(retry_Effect(nextEffect, scheduleFromStep(step4, false)));
      } else {
        const schedule4 = scheduleFromStep(step4, true);
        nextEffect = schedule4 ? scheduleDefectRefail(retry_Effect(nextEffect, schedule4)) : nextEffect;
      }
      return either3(nextEffect);
    },
    step: (either14) => {
      result = either14;
      i++;
    }
  }), () => result);
}));
var scheduleFromStep = (step4, first5) => {
  if (!first5) {
    return fromRetryOptions({
      schedule: step4.schedule ? step4.schedule : step4.attempts ? void 0 : once2,
      times: step4.attempts,
      while: step4.while
    });
  } else if (step4.attempts === 1 || !(step4.schedule || step4.attempts)) {
    return void 0;
  }
  return fromRetryOptions({
    schedule: step4.schedule,
    while: step4.while,
    times: step4.attempts ? step4.attempts - 1 : void 0
  });
};

// ../../node_modules/effect/dist/esm/internal/query.js
var currentCache = globalValue(Symbol.for("effect/FiberRef/currentCache"), () => fiberRefUnsafeMake(unsafeMakeWith(65536, () => map14(deferredMake(), (handle) => ({
  listeners: new Listeners(),
  handle
})), () => seconds(60))));
var currentCacheEnabled = globalValue(Symbol.for("effect/FiberRef/currentCacheEnabled"), () => fiberRefUnsafeMake(false));
var fromRequest = (request2, dataSource) => flatMap12(isEffect(dataSource) ? dataSource : succeed(dataSource), (ds) => fiberIdWith((id3) => {
  const proxy = new Proxy(request2, {});
  return fiberRefGetWith(currentCacheEnabled, (cacheEnabled) => {
    if (cacheEnabled) {
      const cached4 = fiberRefGetWith(currentCache, (cache) => flatMap12(cache.getEither(proxy), (orNew) => {
        switch (orNew._tag) {
          case "Left": {
            if (orNew.left.listeners.interrupted) {
              return flatMap12(cache.invalidateWhen(proxy, (entry) => entry.handle === orNew.left.handle), () => cached4);
            }
            orNew.left.listeners.increment();
            return uninterruptibleMask((restore) => flatMap12(exit(blocked(empty21, restore(deferredAwait(orNew.left.handle)))), (exit4) => {
              orNew.left.listeners.decrement();
              return exit4;
            }));
          }
          case "Right": {
            orNew.right.listeners.increment();
            return uninterruptibleMask((restore) => flatMap12(exit(blocked(single(ds, makeEntry({
              request: proxy,
              result: orNew.right.handle,
              listeners: orNew.right.listeners,
              ownerId: id3,
              state: {
                completed: false
              }
            })), restore(deferredAwait(orNew.right.handle)))), () => {
              orNew.right.listeners.decrement();
              return deferredAwait(orNew.right.handle);
            }));
          }
        }
      }));
      return cached4;
    }
    const listeners = new Listeners();
    listeners.increment();
    return flatMap12(deferredMake(), (ref) => ensuring2(blocked(single(ds, makeEntry({
      request: proxy,
      result: ref,
      listeners,
      ownerId: id3,
      state: {
        completed: false
      }
    })), deferredAwait(ref)), sync(() => listeners.decrement())));
  });
}));
var cacheRequest = (request2, result) => {
  return fiberRefGetWith(currentCacheEnabled, (cacheEnabled) => {
    if (cacheEnabled) {
      return fiberRefGetWith(currentCache, (cache) => flatMap12(cache.getEither(request2), (orNew) => {
        switch (orNew._tag) {
          case "Left": {
            return void_3;
          }
          case "Right": {
            return deferredComplete(orNew.right.handle, result);
          }
        }
      }));
    }
    return void_3;
  });
};
var withRequestCaching = dual(2, (self, strategy) => fiberRefLocally(self, currentCacheEnabled, strategy));
var withRequestCache = dual(
  2,
  // @ts-expect-error
  (self, cache) => fiberRefLocally(self, currentCache, cache)
);

// ../../node_modules/effect/dist/esm/Request.js
var Request_exports = {};
__export(Request_exports, {
  Class: () => Class6,
  EntryTypeId: () => EntryTypeId2,
  RequestTypeId: () => RequestTypeId2,
  TaggedClass: () => TaggedClass3,
  complete: () => complete4,
  completeEffect: () => completeEffect2,
  fail: () => fail11,
  failCause: () => failCause9,
  interruptWhenPossible: () => interruptWhenPossible2,
  isEntry: () => isEntry2,
  isRequest: () => isRequest2,
  makeCache: () => makeCache,
  makeEntry: () => makeEntry2,
  of: () => of6,
  succeed: () => succeed12,
  tagged: () => tagged5
});
var RequestTypeId2 = RequestTypeId;
var isRequest2 = isRequest;
var of6 = of5;
var tagged5 = tagged3;
var Class6 = Class4;
var TaggedClass3 = TaggedClass;
var complete4 = complete2;
var interruptWhenPossible2 = interruptWhenPossible;
var completeEffect2 = completeEffect;
var fail11 = fail7;
var failCause9 = failCause6;
var succeed12 = succeed8;
var makeCache = (options) => make49({
  ...options,
  lookup: () => map14(deferredMake(), (handle) => ({
    listeners: new Listeners(),
    handle
  }))
});
var EntryTypeId2 = Symbol.for("effect/RequestBlock.Entry");
var isEntry2 = isEntry;
var makeEntry2 = makeEntry;

// ../../node_modules/effect/dist/esm/Effect.js
var EffectTypeId4 = EffectTypeId2;
var isEffect2 = isEffect;
var cachedWithTTL = cached2;
var cachedInvalidateWithTTL2 = cachedInvalidateWithTTL;
var cached3 = memoize;
var cachedFunction2 = cachedFunction;
var once3 = once;
var all11 = all9;
var allWith2 = allWith;
var allSuccesses2 = allSuccesses;
var dropUntil2 = dropUntil;
var dropWhile4 = dropWhile3;
var takeUntil2 = takeUntil;
var takeWhile5 = takeWhile4;
var every13 = every11;
var exists4 = exists3;
var filter16 = filter14;
var filterMap11 = filterMap9;
var findFirst11 = findFirst8;
var forEach16 = forEach15;
var head7 = head6;
var mergeAll5 = mergeAll3;
var partition9 = partition8;
var reduce17 = reduce12;
var reduceWhile2 = reduceWhile;
var reduceRight5 = reduceRight4;
var reduceEffect3 = reduceEffect;
var replicate5 = replicate4;
var replicateEffect3 = replicateEffect2;
var validateAll2 = validateAll;
var validateFirst2 = validateFirst;
var async2 = async_;
var asyncEffect2 = asyncEffect;
var custom2 = custom;
var withFiberRuntime2 = withFiberRuntime;
var fail12 = fail2;
var failSync5 = failSync;
var failCause10 = failCause;
var failCauseSync5 = failCauseSync;
var die8 = die2;
var dieMessage2 = dieMessage;
var dieSync4 = dieSync;
var gen6 = gen4;
var never5 = never;
var none9 = none6;
var promise3 = promise;
var succeed13 = succeed;
var succeedNone3 = succeedNone;
var succeedSome3 = succeedSome;
var suspend4 = suspend;
var sync8 = sync;
var _void = void_3;
var yieldNow4 = yieldNow;
var _catch2 = _catch;
var catchAll4 = catchAll;
var catchAllCause4 = catchAllCause;
var catchAllDefect3 = catchAllDefect;
var catchIf3 = catchIf;
var catchSome2 = catchSome;
var catchSomeCause2 = catchSomeCause;
var catchSomeDefect2 = catchSomeDefect;
var catchTag3 = catchTag;
var catchTags2 = catchTags;
var cause2 = cause;
var eventually2 = eventually;
var ignore3 = ignore;
var ignoreLogged3 = ignoreLogged;
var parallelErrors2 = parallelErrors;
var sandbox3 = sandbox;
var retry3 = retry_combined;
var withExecutionPlan2 = withExecutionPlan;
var retryOrElse = retryOrElse_Effect;
var try_4 = try_2;
var tryMap2 = tryMap;
var tryMapPromise2 = tryMapPromise;
var tryPromise3 = tryPromise;
var unsandbox2 = unsandbox;
var allowInterrupt2 = allowInterrupt;
var checkInterruptible2 = checkInterruptible;
var disconnect2 = disconnect;
var interrupt8 = interrupt2;
var interruptWith3 = interruptWith;
var interruptible4 = interruptible2;
var interruptibleMask2 = interruptibleMask;
var onInterrupt3 = onInterrupt;
var uninterruptible3 = uninterruptible;
var uninterruptibleMask3 = uninterruptibleMask;
var liftPredicate5 = liftPredicate4;
var as8 = as3;
var asSome3 = asSome;
var asSomeError2 = asSomeError;
var asVoid6 = asVoid2;
var flip5 = flip3;
var flipWith2 = flipWith;
var map26 = map14;
var mapAccum4 = mapAccum3;
var mapBoth6 = mapBoth3;
var mapError5 = mapError;
var mapErrorCause4 = mapErrorCause2;
var merge7 = merge5;
var negate4 = negate3;
var acquireRelease3 = acquireRelease2;
var acquireReleaseInterruptible2 = acquireReleaseInterruptible;
var acquireUseRelease3 = acquireUseRelease;
var addFinalizer4 = addFinalizer2;
var ensuring4 = ensuring2;
var onError3 = onError;
var onExit3 = onExit;
var parallelFinalizers2 = parallelFinalizers;
var sequentialFinalizers2 = sequentialFinalizers;
var finalizersMask2 = finalizersMask;
var scope4 = scope2;
var scopeWith2 = scopeWith;
var scopedWith2 = scopedWith;
var scoped4 = scopedEffect;
var using2 = using;
var withEarlyRelease2 = withEarlyRelease;
var awaitAllChildren2 = awaitAllChildren;
var daemonChildren2 = daemonChildren;
var descriptor2 = descriptor;
var descriptorWith2 = descriptorWith;
var diffFiberRefs2 = diffFiberRefs;
var ensuringChild2 = ensuringChild;
var ensuringChildren2 = ensuringChildren;
var fiberId2 = fiberId;
var fiberIdWith2 = fiberIdWith;
var fork4 = fork2;
var forkDaemon3 = forkDaemon2;
var forkAll2 = forkAll;
var forkIn3 = forkIn2;
var forkScoped3 = forkScoped2;
var forkWithErrorHandler2 = forkWithErrorHandler;
var fromFiber2 = fromFiber;
var fromFiberEffect2 = fromFiberEffect;
var supervised2 = supervised;
var transplant2 = transplant;
var withConcurrency3 = withConcurrency;
var withScheduler2 = withScheduler;
var withSchedulingPriority2 = withSchedulingPriority;
var withMaxOpsBeforeYield2 = withMaxOpsBeforeYield;
var clock2 = clock;
var clockWith4 = clockWith3;
var withClockScoped2 = withClockScoped;
var withClock2 = withClock;
var console3 = console2;
var consoleWith2 = consoleWith;
var withConsoleScoped2 = withConsoleScoped;
var withConsole2 = withConsole;
var delay3 = delay;
var sleep5 = sleep3;
var timed2 = timed;
var timedWith2 = timedWith;
var timeout3 = timeout2;
var timeoutOption3 = timeoutOption2;
var timeoutFail2 = timeoutFail;
var timeoutFailCause2 = timeoutFailCause;
var timeoutTo2 = timeoutTo;
var configProviderWith2 = configProviderWith;
var withConfigProvider2 = withConfigProvider;
var withConfigProviderScoped2 = withConfigProviderScoped;
var context5 = context2;
var contextWith2 = contextWith;
var contextWithEffect2 = contextWithEffect;
var mapInputContext3 = mapInputContext;
var provide2 = effect_provide;
var provideService5 = provideService;
var provideServiceEffect3 = provideServiceEffect;
var serviceFunction2 = serviceFunction;
var serviceFunctionEffect2 = serviceFunctionEffect;
var serviceFunctions2 = serviceFunctions;
var serviceConstants2 = serviceConstants;
var serviceMembers2 = serviceMembers;
var serviceOption3 = serviceOption;
var serviceOptional2 = serviceOptional;
var updateService3 = updateService;
var Do6 = Do4;
var bind7 = bind5;
var bindAll2 = bindAll;
var bindTo7 = bindTo5;
var let_7 = let_5;
var option4 = option2;
var either6 = either3;
var exit3 = exit;
var intoDeferred2 = intoDeferred;
var if_2 = if_;
var filterOrDie2 = filterOrDie;
var filterOrDieMessage2 = filterOrDieMessage;
var filterOrElse2 = filterOrElse;
var filterOrFail3 = filterOrFail;
var filterEffectOrElse2 = filterEffectOrElse;
var filterEffectOrFail2 = filterEffectOrFail;
var unless2 = unless;
var unlessEffect2 = unlessEffect;
var when3 = when;
var whenEffect2 = whenEffect;
var whenFiberRef2 = whenFiberRef;
var whenRef2 = whenRef;
var flatMap18 = flatMap12;
var andThen11 = andThen6;
var flatten13 = flatten8;
var race3 = race2;
var raceAll3 = raceAll2;
var raceFirst3 = raceFirst2;
var raceWith2 = raceWith;
var summarized2 = summarized;
var tap5 = tap2;
var tapBoth2 = tapBoth;
var tapDefect3 = tapDefect;
var tapError4 = tapError;
var tapErrorTag2 = tapErrorTag;
var tapErrorCause4 = tapErrorCause;
var forever4 = forever;
var iterate2 = iterate;
var loop2 = loop;
var repeat3 = repeat_combined;
var repeatN2 = repeatN;
var repeatOrElse = repeatOrElse_Effect;
var schedule = schedule_Effect;
var scheduleForked2 = scheduleForked;
var scheduleFrom = scheduleFrom_Effect;
var whileLoop3 = whileLoop;
var getFiberRefs = fiberRefs3;
var inheritFiberRefs2 = inheritFiberRefs;
var locally2 = fiberRefLocally;
var locallyWith = fiberRefLocallyWith;
var locallyScoped = fiberRefLocallyScoped;
var locallyScopedWith = fiberRefLocallyScopedWith;
var patchFiberRefs2 = patchFiberRefs;
var setFiberRefs2 = setFiberRefs;
var updateFiberRefs3 = updateFiberRefs;
var isFailure5 = isFailure3;
var isSuccess3 = isSuccess2;
var match20 = match8;
var matchCause4 = matchCause;
var matchCauseEffect3 = matchCauseEffect;
var matchEffect4 = matchEffect;
var log3 = log;
var logWithLevel2 = (level, ...message) => logWithLevel(level)(...message);
var logTrace2 = logTrace;
var logDebug2 = logDebug;
var logInfo2 = logInfo;
var logWarning2 = logWarning;
var logError2 = logError;
var logFatal2 = logFatal;
var withLogSpan2 = withLogSpan;
var annotateLogs3 = annotateLogs;
var annotateLogsScoped2 = annotateLogsScoped;
var logAnnotations2 = logAnnotations;
var withUnhandledErrorLogLevel2 = withUnhandledErrorLogLevel;
var whenLogLevel2 = whenLogLevel;
var orDie4 = orDie;
var orDieWith2 = orDieWith;
var orElse8 = orElse3;
var orElseFail2 = orElseFail;
var orElseSucceed3 = orElseSucceed;
var firstSuccessOf2 = firstSuccessOf;
var random3 = random2;
var randomWith3 = randomWith;
var withRandom2 = withRandom;
var withRandomFixed = dual(2, (effect4, values15) => withRandom2(effect4, fixed2(values15)));
var withRandomScoped2 = withRandomScoped;
var runtime4 = runtime3;
var getRuntimeFlags = runtimeFlags;
var patchRuntimeFlags = updateRuntimeFlags;
var withRuntimeFlagsPatch = withRuntimeFlags;
var withRuntimeFlagsPatchScoped = withRuntimeFlagsScoped;
var tagMetrics2 = tagMetrics;
var labelMetrics2 = labelMetrics;
var tagMetricsScoped2 = tagMetricsScoped;
var labelMetricsScoped2 = labelMetricsScoped;
var metricLabels2 = metricLabels;
var withMetric2 = withMetric;
var unsafeMakeSemaphore2 = unsafeMakeSemaphore;
var makeSemaphore2 = makeSemaphore;
var unsafeMakeLatch2 = unsafeMakeLatch;
var makeLatch2 = makeLatch;
var runFork2 = unsafeForkEffect;
var runCallback = unsafeRunEffect;
var runPromise2 = unsafeRunPromiseEffect;
var runPromiseExit2 = unsafeRunPromiseExitEffect;
var runSync2 = unsafeRunSyncEffect;
var runSyncExit2 = unsafeRunSyncExitEffect;
var validate2 = validate;
var validateWith2 = validateWith;
var zip12 = zipOptions;
var zipLeft7 = zipLeftOptions;
var zipRight7 = zipRightOptions;
var zipWith12 = zipWithOptions;
var ap3 = dual(2, (self, that) => zipWith12(self, that, (f, a) => f(a)));
var blocked2 = blocked;
var runRequestBlock2 = runRequestBlock;
var step3 = step2;
var request = dual((args2) => isRequest2(args2[0]), fromRequest);
var cacheRequestResult = cacheRequest;
var withRequestBatching2 = withRequestBatching;
var withRequestCaching2 = withRequestCaching;
var withRequestCache2 = withRequestCache;
var tracer2 = tracer;
var tracerWith4 = tracerWith;
var withTracer2 = withTracer;
var withTracerScoped2 = withTracerScoped;
var withTracerEnabled2 = withTracerEnabled;
var withTracerTiming2 = withTracerTiming;
var annotateSpans3 = annotateSpans;
var annotateCurrentSpan2 = annotateCurrentSpan;
var currentSpan2 = currentSpan;
var currentParentSpan2 = currentParentSpan;
var spanAnnotations2 = spanAnnotations;
var spanLinks2 = spanLinks;
var linkSpans2 = linkSpans;
var linkSpanCurrent2 = linkSpanCurrent;
var makeSpan2 = makeSpan;
var makeSpanScoped2 = makeSpanScoped;
var useSpan2 = useSpan;
var withSpan3 = withSpan;
var functionWithSpan2 = functionWithSpan;
var withSpanScoped2 = withSpanScoped;
var withParentSpan3 = withParentSpan;
var fromNullable5 = fromNullable4;
var optionFromOptional2 = optionFromOptional;
var transposeOption2 = (self) => {
  return isNone(self) ? succeedNone3 : map26(self.value, some2);
};
var transposeMapOption2 = dual(2, (self, f) => isNone(self) ? succeedNone3 : map26(f(self.value), some2));
var makeTagProxy = (TagClass) => {
  const cache = /* @__PURE__ */ new Map();
  return new Proxy(TagClass, {
    get(target, prop, receiver) {
      if (prop in target) {
        return Reflect.get(target, prop, receiver);
      }
      if (cache.has(prop)) {
        return cache.get(prop);
      }
      const fn2 = (...args2) => andThen6(target, (s) => {
        if (typeof s[prop] === "function") {
          cache.set(prop, (...args3) => andThen6(target, (s2) => s2[prop](...args3)));
          return s[prop](...args2);
        }
        cache.set(prop, andThen6(target, (s2) => s2[prop]));
        return s[prop];
      });
      const cn = andThen6(target, (s) => s[prop]);
      Object.assign(fn2, cn);
      const apply2 = fn2.apply;
      const bind12 = fn2.bind;
      const call = fn2.call;
      const proto16 = Object.setPrototypeOf({}, Object.getPrototypeOf(cn));
      proto16.apply = apply2;
      proto16.bind = bind12;
      proto16.call = call;
      Object.setPrototypeOf(fn2, proto16);
      cache.set(prop, fn2);
      return fn2;
    }
  });
};
var Tag3 = (id3) => () => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit;
  function TagClass() {
  }
  Object.setPrototypeOf(TagClass, TagProto);
  TagClass.key = id3;
  Object.defineProperty(TagClass, "use", {
    get() {
      return (body) => andThen6(this, body);
    }
  });
  Object.defineProperty(TagClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return makeTagProxy(TagClass);
};
var Service = function() {
  return function() {
    const [id3, maker] = arguments;
    const proxy = "accessors" in maker ? maker["accessors"] : false;
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const creationError = new Error();
    Error.stackTraceLimit = limit;
    let patchState = "unchecked";
    const TagClass = function(service4) {
      if (patchState === "unchecked") {
        const proto16 = Object.getPrototypeOf(service4);
        if (proto16 === Object.prototype || proto16 === null) {
          patchState = "plain";
        } else {
          const selfProto = Object.getPrototypeOf(this);
          Object.setPrototypeOf(selfProto, proto16);
          patchState = "patched";
        }
      }
      if (patchState === "plain") {
        Object.assign(this, service4);
      } else if (patchState === "patched") {
        Object.setPrototypeOf(service4, Object.getPrototypeOf(this));
        return service4;
      }
    };
    TagClass.prototype._tag = id3;
    Object.defineProperty(TagClass, "make", {
      get() {
        return (service4) => new this(service4);
      }
    });
    Object.defineProperty(TagClass, "use", {
      get() {
        return (body) => andThen6(this, body);
      }
    });
    TagClass.key = id3;
    Object.assign(TagClass, TagProto);
    Object.defineProperty(TagClass, "stack", {
      get() {
        return creationError.stack;
      }
    });
    const hasDeps = "dependencies" in maker && maker.dependencies.length > 0;
    const layerName = hasDeps ? "DefaultWithoutDependencies" : "Default";
    let layerCache;
    let isFunction3 = false;
    if ("effect" in maker) {
      isFunction3 = typeof maker.effect === "function";
      Object.defineProperty(TagClass, layerName, {
        get() {
          if (isFunction3) {
            return (function() {
              return fromEffect4(TagClass, map26(maker.effect.apply(null, arguments), (_) => new this(_)));
            }).bind(this);
          }
          return layerCache ??= fromEffect4(TagClass, map26(maker.effect, (_) => new this(_)));
        }
      });
    } else if ("scoped" in maker) {
      isFunction3 = typeof maker.scoped === "function";
      Object.defineProperty(TagClass, layerName, {
        get() {
          if (isFunction3) {
            return (function() {
              return scoped3(TagClass, map26(maker.scoped.apply(null, arguments), (_) => new this(_)));
            }).bind(this);
          }
          return layerCache ??= scoped3(TagClass, map26(maker.scoped, (_) => new this(_)));
        }
      });
    } else if ("sync" in maker) {
      Object.defineProperty(TagClass, layerName, {
        get() {
          return layerCache ??= sync6(TagClass, () => new this(maker.sync()));
        }
      });
    } else {
      Object.defineProperty(TagClass, layerName, {
        get() {
          return layerCache ??= succeed10(TagClass, new this(maker.succeed));
        }
      });
    }
    if (hasDeps) {
      let layerWithDepsCache;
      Object.defineProperty(TagClass, "Default", {
        get() {
          if (isFunction3) {
            return function() {
              return provide(this.DefaultWithoutDependencies.apply(null, arguments), maker.dependencies);
            };
          }
          return layerWithDepsCache ??= provide(this.DefaultWithoutDependencies, maker.dependencies);
        }
      });
    }
    return proxy === true ? makeTagProxy(TagClass) : TagClass;
  };
};
var fn = function(nameOrBody, ...pipeables) {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const errorDef = new Error();
  Error.stackTraceLimit = limit;
  if (typeof nameOrBody !== "string") {
    return defineLength(nameOrBody.length, function(...args2) {
      const limit2 = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      const errorCall = new Error();
      Error.stackTraceLimit = limit2;
      return fnApply({
        self: this,
        body: nameOrBody,
        args: args2,
        pipeables,
        spanName: "<anonymous>",
        spanOptions: {
          context: DisablePropagation.context(true)
        },
        errorDef,
        errorCall
      });
    });
  }
  const name = nameOrBody;
  const options = pipeables[0];
  return (body, ...pipeables2) => defineLength(body.length, {
    [name](...args2) {
      const limit2 = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      const errorCall = new Error();
      Error.stackTraceLimit = limit2;
      return fnApply({
        self: this,
        body,
        args: args2,
        pipeables: pipeables2,
        spanName: name,
        spanOptions: options,
        errorDef,
        errorCall
      });
    }
  }[name]);
};
function defineLength(length6, fn2) {
  return Object.defineProperty(fn2, "length", {
    value: length6,
    configurable: true
  });
}
function fnApply(options) {
  let effect4;
  let fnError = void 0;
  if (isGeneratorFunction(options.body)) {
    effect4 = fromIterator(() => options.body.apply(options.self, options.args));
  } else {
    try {
      effect4 = options.body.apply(options.self, options.args);
    } catch (error4) {
      fnError = error4;
      effect4 = die8(error4);
    }
  }
  if (options.pipeables.length > 0) {
    try {
      for (const x of options.pipeables) {
        effect4 = x(effect4, ...options.args);
      }
    } catch (error4) {
      effect4 = fnError ? failCause10(sequential(die(fnError), die(error4))) : die8(error4);
    }
  }
  let cache = false;
  const captureStackTrace = () => {
    if (cache !== false) {
      return cache;
    }
    if (options.errorCall.stack) {
      const stackDef = options.errorDef.stack.trim().split("\n");
      const stackCall = options.errorCall.stack.trim().split("\n");
      let endStackDef = stackDef.slice(2).join("\n").trim();
      if (!endStackDef.includes(`(`)) {
        endStackDef = endStackDef.replace(/at (.*)/, "at ($1)");
      }
      let endStackCall = stackCall.slice(2).join("\n").trim();
      if (!endStackCall.includes(`(`)) {
        endStackCall = endStackCall.replace(/at (.*)/, "at ($1)");
      }
      cache = `${endStackDef}
${endStackCall}`;
      return cache;
    }
  };
  const opts = options.spanOptions && "captureStackTrace" in options.spanOptions ? options.spanOptions : {
    captureStackTrace,
    ...options.spanOptions
  };
  return withSpan3(effect4, options.spanName, opts);
}
var fnUntraced2 = fnUntraced;
var ensureSuccessType = () => (effect4) => effect4;
var ensureErrorType = () => (effect4) => effect4;
var ensureRequirementsType = () => (effect4) => effect4;

// ../../node_modules/effect/dist/esm/FiberRef.js
var FiberRef_exports = {};
__export(FiberRef_exports, {
  FiberRefTypeId: () => FiberRefTypeId2,
  currentConcurrency: () => currentConcurrency2,
  currentContext: () => currentContext2,
  currentLogAnnotations: () => currentLogAnnotations2,
  currentLogLevel: () => currentLogLevel2,
  currentLogSpan: () => currentLogSpan2,
  currentLoggers: () => currentLoggers2,
  currentMaxOpsBeforeYield: () => currentMaxOpsBeforeYield2,
  currentMetricLabels: () => currentMetricLabels2,
  currentMinimumLogLevel: () => currentMinimumLogLevel2,
  currentRequestBatchingEnabled: () => currentRequestBatchingEnabled,
  currentRequestCache: () => currentRequestCache,
  currentRequestCacheEnabled: () => currentRequestCacheEnabled,
  currentRuntimeFlags: () => currentRuntimeFlags2,
  currentScheduler: () => currentScheduler2,
  currentSchedulingPriority: () => currentSchedulingPriority2,
  currentSupervisor: () => currentSupervisor2,
  currentTracerEnabled: () => currentTracerEnabled2,
  currentTracerSpanAnnotations: () => currentTracerSpanAnnotations2,
  currentTracerSpanLinks: () => currentTracerSpanLinks2,
  currentTracerTimingEnabled: () => currentTracerTimingEnabled2,
  delete: () => _delete,
  get: () => get14,
  getAndSet: () => getAndSet4,
  getAndUpdate: () => getAndUpdate4,
  getAndUpdateSome: () => getAndUpdateSome3,
  getWith: () => getWith,
  interruptedCause: () => interruptedCause,
  make: () => make60,
  makeContext: () => makeContext2,
  makeRuntimeFlags: () => makeRuntimeFlags,
  makeWith: () => makeWith3,
  modify: () => modify11,
  modifySome: () => modifySome3,
  reset: () => reset2,
  set: () => set9,
  unhandledErrorLogLevel: () => unhandledErrorLogLevel,
  unsafeMake: () => unsafeMake12,
  unsafeMakeContext: () => unsafeMakeContext,
  unsafeMakeHashSet: () => unsafeMakeHashSet,
  unsafeMakePatch: () => unsafeMakePatch,
  unsafeMakeSupervisor: () => unsafeMakeSupervisor,
  update: () => update7,
  updateAndGet: () => updateAndGet4,
  updateSome: () => updateSome3,
  updateSomeAndGet: () => updateSomeAndGet3,
  versionMismatchErrorLogLevel: () => versionMismatchErrorLogLevel
});
var FiberRefTypeId2 = FiberRefTypeId;
var make60 = fiberRefMake;
var makeWith3 = fiberRefMakeWith;
var makeContext2 = fiberRefMakeContext;
var makeRuntimeFlags = fiberRefMakeRuntimeFlags;
var unsafeMake12 = fiberRefUnsafeMake;
var unsafeMakeHashSet = fiberRefUnsafeMakeHashSet;
var unsafeMakeContext = fiberRefUnsafeMakeContext;
var unsafeMakeSupervisor = fiberRefUnsafeMakeSupervisor;
var unsafeMakePatch = fiberRefUnsafeMakePatch;
var get14 = fiberRefGet;
var getAndSet4 = fiberRefGetAndSet;
var getAndUpdate4 = fiberRefGetAndUpdate;
var getAndUpdateSome3 = fiberRefGetAndUpdateSome;
var getWith = fiberRefGetWith;
var set9 = fiberRefSet;
var _delete = fiberRefDelete;
var reset2 = fiberRefReset;
var modify11 = fiberRefModify;
var modifySome3 = fiberRefModifySome;
var update7 = fiberRefUpdate;
var updateSome3 = fiberRefUpdateSome;
var updateAndGet4 = fiberRefUpdateAndGet;
var updateSomeAndGet3 = fiberRefUpdateSomeAndGet;
var currentConcurrency2 = currentConcurrency;
var currentRequestBatchingEnabled = currentRequestBatching;
var currentRequestCache = currentCache;
var currentRequestCacheEnabled = currentCacheEnabled;
var currentContext2 = currentContext;
var currentSchedulingPriority2 = currentSchedulingPriority;
var currentMaxOpsBeforeYield2 = currentMaxOpsBeforeYield;
var unhandledErrorLogLevel = currentUnhandledErrorLogLevel;
var versionMismatchErrorLogLevel = currentVersionMismatchErrorLogLevel;
var currentLogAnnotations2 = currentLogAnnotations;
var currentLoggers2 = currentLoggers;
var currentLogLevel2 = currentLogLevel;
var currentMinimumLogLevel2 = currentMinimumLogLevel;
var currentLogSpan2 = currentLogSpan;
var currentRuntimeFlags2 = currentRuntimeFlags;
var currentScheduler2 = currentScheduler;
var currentSupervisor2 = currentSupervisor;
var currentMetricLabels2 = currentMetricLabels;
var currentTracerEnabled2 = currentTracerEnabled;
var currentTracerTimingEnabled2 = currentTracerTimingEnabled;
var currentTracerSpanAnnotations2 = currentTracerSpanAnnotations;
var currentTracerSpanLinks2 = currentTracerSpanLinks;
var interruptedCause = currentInterruptedCause;

// ../../node_modules/effect/dist/esm/Layer.js
var Layer_exports = {};
__export(Layer_exports, {
  CurrentMemoMap: () => CurrentMemoMap2,
  LayerTypeId: () => LayerTypeId2,
  MemoMapTypeId: () => MemoMapTypeId2,
  annotateLogs: () => annotateLogs4,
  annotateSpans: () => annotateSpans4,
  build: () => build2,
  buildWithMemoMap: () => buildWithMemoMap2,
  buildWithScope: () => buildWithScope2,
  catchAll: () => catchAll5,
  catchAllCause: () => catchAllCause5,
  context: () => context6,
  die: () => die9,
  dieSync: () => dieSync5,
  discard: () => discard2,
  effect: () => effect,
  effectContext: () => effectContext,
  effectDiscard: () => effectDiscard,
  empty: () => empty42,
  extendScope: () => extendScope2,
  fail: () => fail13,
  failCause: () => failCause11,
  failCauseSync: () => failCauseSync6,
  failSync: () => failSync6,
  fiberRefLocallyScopedWith: () => fiberRefLocallyScopedWith3,
  flatMap: () => flatMap19,
  flatten: () => flatten14,
  fresh: () => fresh2,
  function: () => fromFunction3,
  isFresh: () => isFresh2,
  isLayer: () => isLayer2,
  launch: () => launch2,
  locally: () => locally3,
  locallyEffect: () => locallyEffect2,
  locallyScoped: () => locallyScoped2,
  locallyWith: () => locallyWith2,
  makeMemoMap: () => makeMemoMap2,
  map: () => map27,
  mapError: () => mapError6,
  match: () => match21,
  matchCause: () => matchCause5,
  memoize: () => memoize3,
  merge: () => merge8,
  mergeAll: () => mergeAll6,
  mock: () => mock2,
  orDie: () => orDie5,
  orElse: () => orElse9,
  parentSpan: () => parentSpan2,
  passthrough: () => passthrough3,
  project: () => project2,
  provide: () => provide3,
  provideMerge: () => provideMerge2,
  retry: () => retry4,
  scope: () => scope5,
  scoped: () => scoped5,
  scopedContext: () => scopedContext2,
  scopedDiscard: () => scopedDiscard2,
  service: () => service3,
  setClock: () => setClock,
  setConfigProvider: () => setConfigProvider2,
  setRandom: () => setRandom,
  setRequestBatching: () => setRequestBatching,
  setRequestCache: () => setRequestCache,
  setRequestCaching: () => setRequestCaching,
  setScheduler: () => setScheduler,
  setTracer: () => setTracer2,
  setTracerEnabled: () => setTracerEnabled,
  setTracerTiming: () => setTracerTiming,
  setUnhandledErrorLogLevel: () => setUnhandledErrorLogLevel,
  setVersionMismatchErrorLogLevel: () => setVersionMismatchErrorLogLevel,
  span: () => span3,
  succeed: () => succeed14,
  succeedContext: () => succeedContext2,
  suspend: () => suspend5,
  sync: () => sync9,
  syncContext: () => syncContext2,
  tap: () => tap6,
  tapError: () => tapError5,
  tapErrorCause: () => tapErrorCause5,
  toRuntime: () => toRuntime2,
  toRuntimeWithMemoMap: () => toRuntimeWithMemoMap2,
  unwrapEffect: () => unwrapEffect2,
  unwrapScoped: () => unwrapScoped2,
  updateService: () => updateService4,
  withParentSpan: () => withParentSpan4,
  withSpan: () => withSpan4,
  zipWith: () => zipWith13
});

// ../../node_modules/effect/dist/esm/internal/layer/circular.js
var minimumLogLevel = (level) => scopedDiscard(fiberRefLocallyScoped(currentMinimumLogLevel, level));
var withMinimumLogLevel = dual(2, (self, level) => fiberRefLocally(currentMinimumLogLevel, level)(self));
var addLogger = (logger) => scopedDiscard(fiberRefLocallyScopedWith(currentLoggers, add4(logger)));
var addLoggerEffect = (effect4) => unwrapEffect(map14(effect4, addLogger));
var addLoggerScoped = (effect4) => unwrapScoped(map14(effect4, addLogger));
var removeLogger = (logger) => scopedDiscard(fiberRefLocallyScopedWith(currentLoggers, remove6(logger)));
var replaceLogger = dual(2, (self, that) => flatMap17(removeLogger(self), () => addLogger(that)));
var replaceLoggerEffect = dual(2, (self, that) => flatMap17(removeLogger(self), () => addLoggerEffect(that)));
var replaceLoggerScoped = dual(2, (self, that) => flatMap17(removeLogger(self), () => addLoggerScoped(that)));
var addSupervisor = (supervisor) => scopedDiscard(fiberRefLocallyScopedWith(currentSupervisor, (current2) => new Zip(current2, supervisor)));
var enableCooperativeYielding = scopedDiscard(withRuntimeFlagsScoped(enable(CooperativeYielding)));
var enableInterruption = scopedDiscard(withRuntimeFlagsScoped(enable(Interruption)));
var enableOpSupervision = scopedDiscard(withRuntimeFlagsScoped(enable(OpSupervision)));
var enableRuntimeMetrics = scopedDiscard(withRuntimeFlagsScoped(enable(RuntimeMetrics)));
var enableWindDown = scopedDiscard(withRuntimeFlagsScoped(enable(WindDown)));
var disableCooperativeYielding = scopedDiscard(withRuntimeFlagsScoped(disable(CooperativeYielding)));
var disableInterruption = scopedDiscard(withRuntimeFlagsScoped(disable(Interruption)));
var disableOpSupervision = scopedDiscard(withRuntimeFlagsScoped(disable(OpSupervision)));
var disableRuntimeMetrics = scopedDiscard(withRuntimeFlagsScoped(disable(RuntimeMetrics)));
var disableWindDown = scopedDiscard(withRuntimeFlagsScoped(disable(WindDown)));
var setConfigProvider = (configProvider) => scopedDiscard(withConfigProviderScoped(configProvider));
var parentSpan = (span4) => succeedContext(make8(spanTag, span4));
var span2 = (name, options) => {
  options = addSpanStackTrace(options);
  return scoped3(spanTag, options?.onEnd ? tap2(makeSpanScoped(name, options), (span4) => addFinalizer2((exit4) => options.onEnd(span4, exit4))) : makeSpanScoped(name, options));
};
var setTracer = (tracer3) => scopedDiscard(withTracerScoped(tracer3));

// ../../node_modules/effect/dist/esm/Layer.js
var LayerTypeId2 = LayerTypeId;
var MemoMapTypeId2 = MemoMapTypeId;
var CurrentMemoMap2 = CurrentMemoMap;
var isLayer2 = isLayer;
var isFresh2 = isFresh;
var annotateLogs4 = annotateLogs2;
var annotateSpans4 = annotateSpans2;
var build2 = build;
var buildWithScope2 = buildWithScope;
var catchAll5 = catchAll3;
var catchAllCause5 = catchAllCause3;
var context6 = context4;
var die9 = die7;
var dieSync5 = dieSync3;
var discard2 = discard;
var effect = fromEffect4;
var effectDiscard = fromEffectDiscard;
var effectContext = fromEffectContext;
var empty42 = empty40;
var extendScope2 = extendScope;
var fail13 = fail10;
var failSync6 = failSync4;
var failCause11 = failCause8;
var failCauseSync6 = failCauseSync4;
var flatMap19 = flatMap17;
var flatten14 = flatten12;
var fresh2 = fresh;
var mock2 = mock;
var fromFunction3 = fromFunction;
var launch2 = launch;
var map27 = map24;
var mapError6 = mapError4;
var match21 = match16;
var matchCause5 = matchCause3;
var memoize3 = memoize2;
var merge8 = merge6;
var mergeAll6 = mergeAll4;
var orDie5 = orDie3;
var orElse9 = orElse7;
var passthrough3 = passthrough;
var project2 = project;
var locallyEffect2 = locallyEffect;
var locally3 = fiberRefLocally2;
var locallyWith2 = fiberRefLocallyWith2;
var locallyScoped2 = fiberRefLocallyScoped2;
var fiberRefLocallyScopedWith3 = fiberRefLocallyScopedWith2;
var retry4 = retry2;
var scope5 = scope3;
var scoped5 = scoped3;
var scopedDiscard2 = scopedDiscard;
var scopedContext2 = scopedContext;
var service3 = service2;
var succeed14 = succeed10;
var succeedContext2 = succeedContext;
var suspend5 = suspend3;
var sync9 = sync6;
var syncContext2 = syncContext;
var tap6 = tap4;
var tapError5 = tapError3;
var tapErrorCause5 = tapErrorCause3;
var toRuntime2 = toRuntime;
var toRuntimeWithMemoMap2 = toRuntimeWithMemoMap;
var provide3 = provide;
var provideMerge2 = provideMerge;
var zipWith13 = zipWith10;
var unwrapEffect2 = unwrapEffect;
var unwrapScoped2 = unwrapScoped;
var setClock = (clock3) => scopedDiscard2(fiberRefLocallyScopedWith(currentServices, add2(clockTag, clock3)));
var setConfigProvider2 = setConfigProvider;
var parentSpan2 = parentSpan;
var setRandom = (random4) => scopedDiscard2(fiberRefLocallyScopedWith(currentServices, add2(randomTag, random4)));
var setRequestBatching = (requestBatching) => scopedDiscard2(fiberRefLocallyScoped(currentRequestBatching, requestBatching));
var setRequestCaching = (requestCaching) => scopedDiscard2(fiberRefLocallyScoped(currentCacheEnabled, requestCaching));
var setRequestCache = (cache) => scopedDiscard2(isEffect(cache) ? flatMap12(cache, (x) => fiberRefLocallyScoped(currentCache, x)) : fiberRefLocallyScoped(currentCache, cache));
var setScheduler = (scheduler2) => scopedDiscard2(fiberRefLocallyScoped(currentScheduler, scheduler2));
var span3 = span2;
var setTracer2 = setTracer;
var setTracerEnabled = (enabled2) => scopedDiscard2(fiberRefLocallyScoped(currentTracerEnabled, enabled2));
var setTracerTiming = (enabled2) => scopedDiscard2(fiberRefLocallyScoped(currentTracerTimingEnabled, enabled2));
var setUnhandledErrorLogLevel = (level) => scopedDiscard2(fiberRefLocallyScoped(currentUnhandledErrorLogLevel, level));
var setVersionMismatchErrorLogLevel = (level) => scopedDiscard2(fiberRefLocallyScoped(currentVersionMismatchErrorLogLevel, level));
var withSpan4 = withSpan2;
var withParentSpan4 = withParentSpan2;
var makeMemoMap2 = makeMemoMap;
var buildWithMemoMap2 = buildWithMemoMap;
var updateService4 = dual(3, (layer, tag5, f) => provide3(layer, map27(context6(), (c) => add2(c, tag5, f(unsafeGet3(c, tag5))))));

// ../../node_modules/effect/dist/esm/PubSub.js
var PubSub_exports = {};
__export(PubSub_exports, {
  awaitShutdown: () => awaitShutdown3,
  bounded: () => bounded4,
  capacity: () => capacity4,
  dropping: () => dropping3,
  isEmpty: () => isEmpty17,
  isFull: () => isFull4,
  isShutdown: () => isShutdown3,
  publish: () => publish2,
  publishAll: () => publishAll2,
  shutdown: () => shutdown3,
  size: () => size19,
  sliding: () => sliding3,
  subscribe: () => subscribe2,
  unbounded: () => unbounded4
});

// ../../node_modules/effect/dist/esm/internal/queue.js
var EnqueueSymbolKey = "effect/QueueEnqueue";
var EnqueueTypeId = Symbol.for(EnqueueSymbolKey);
var DequeueSymbolKey = "effect/QueueDequeue";
var DequeueTypeId = Symbol.for(DequeueSymbolKey);
var QueueStrategySymbolKey = "effect/QueueStrategy";
var QueueStrategyTypeId = Symbol.for(QueueStrategySymbolKey);
var BackingQueueSymbolKey = "effect/BackingQueue";
var BackingQueueTypeId = Symbol.for(BackingQueueSymbolKey);
var queueStrategyVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var backingQueueVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var enqueueVariance = {
  /* c8 ignore next */
  _In: (_) => _
};
var dequeueVariance = {
  /* c8 ignore next */
  _Out: (_) => _
};
var QueueImpl = class extends Class3 {
  queue;
  takers;
  shutdownHook;
  shutdownFlag;
  strategy;
  [EnqueueTypeId] = enqueueVariance;
  [DequeueTypeId] = dequeueVariance;
  constructor(queue, takers, shutdownHook, shutdownFlag, strategy) {
    super();
    this.queue = queue;
    this.takers = takers;
    this.shutdownHook = shutdownHook;
    this.shutdownFlag = shutdownFlag;
    this.strategy = strategy;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  commit() {
    return this.take;
  }
  capacity() {
    return this.queue.capacity();
  }
  get size() {
    return suspend(() => catchAll(this.unsafeSize(), () => interrupt2));
  }
  unsafeSize() {
    if (get7(this.shutdownFlag)) {
      return none2();
    }
    return some3(this.queue.length() - length3(this.takers) + this.strategy.surplusSize());
  }
  get isEmpty() {
    return map14(this.size, (size40) => size40 <= 0);
  }
  get isFull() {
    return map14(this.size, (size40) => size40 >= this.capacity());
  }
  get shutdown() {
    return uninterruptible(withFiberRuntime((state) => {
      pipe(this.shutdownFlag, set3(true));
      return pipe(forEachConcurrentDiscard(unsafePollAll(this.takers), (d) => deferredInterruptWith(d, state.id()), false, false), zipRight2(this.strategy.shutdown), whenEffect(deferredSucceed(this.shutdownHook, void 0)), asVoid2);
    }));
  }
  get isShutdown() {
    return sync(() => get7(this.shutdownFlag));
  }
  get awaitShutdown() {
    return deferredAwait(this.shutdownHook);
  }
  isActive() {
    return !get7(this.shutdownFlag);
  }
  unsafeOffer(value10) {
    if (get7(this.shutdownFlag)) {
      return false;
    }
    let noRemaining;
    if (this.queue.length() === 0) {
      const taker = pipe(this.takers, poll2(EmptyMutableQueue));
      if (taker !== EmptyMutableQueue) {
        unsafeCompleteDeferred(taker, value10);
        noRemaining = true;
      } else {
        noRemaining = false;
      }
    } else {
      noRemaining = false;
    }
    if (noRemaining) {
      return true;
    }
    const succeeded = this.queue.offer(value10);
    unsafeCompleteTakers(this.strategy, this.queue, this.takers);
    return succeeded;
  }
  offer(value10) {
    return suspend(() => {
      if (get7(this.shutdownFlag)) {
        return interrupt2;
      }
      let noRemaining;
      if (this.queue.length() === 0) {
        const taker = pipe(this.takers, poll2(EmptyMutableQueue));
        if (taker !== EmptyMutableQueue) {
          unsafeCompleteDeferred(taker, value10);
          noRemaining = true;
        } else {
          noRemaining = false;
        }
      } else {
        noRemaining = false;
      }
      if (noRemaining) {
        return succeed(true);
      }
      const succeeded = this.queue.offer(value10);
      unsafeCompleteTakers(this.strategy, this.queue, this.takers);
      return succeeded ? succeed(true) : this.strategy.handleSurplus([value10], this.queue, this.takers, this.shutdownFlag);
    });
  }
  offerAll(iterable) {
    return suspend(() => {
      if (get7(this.shutdownFlag)) {
        return interrupt2;
      }
      const values15 = fromIterable2(iterable);
      const pTakers = this.queue.length() === 0 ? fromIterable2(unsafePollN(this.takers, values15.length)) : empty4;
      const [forTakers, remaining] = pipe(values15, splitAt(pTakers.length));
      for (let i = 0; i < pTakers.length; i++) {
        const taker = pTakers[i];
        const item = forTakers[i];
        unsafeCompleteDeferred(taker, item);
      }
      if (remaining.length === 0) {
        return succeed(true);
      }
      const surplus = this.queue.offerAll(remaining);
      unsafeCompleteTakers(this.strategy, this.queue, this.takers);
      return isEmpty2(surplus) ? succeed(true) : this.strategy.handleSurplus(surplus, this.queue, this.takers, this.shutdownFlag);
    });
  }
  get take() {
    return withFiberRuntime((state) => {
      if (get7(this.shutdownFlag)) {
        return interrupt2;
      }
      const item = this.queue.poll(EmptyMutableQueue);
      if (item !== EmptyMutableQueue) {
        this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
        return succeed(item);
      } else {
        const deferred = deferredUnsafeMake(state.id());
        return pipe(suspend(() => {
          pipe(this.takers, offer(deferred));
          unsafeCompleteTakers(this.strategy, this.queue, this.takers);
          return get7(this.shutdownFlag) ? interrupt2 : deferredAwait(deferred);
        }), onInterrupt(() => {
          return sync(() => unsafeRemove(this.takers, deferred));
        }));
      }
    });
  }
  get takeAll() {
    return suspend(() => {
      return get7(this.shutdownFlag) ? interrupt2 : sync(() => {
        const values15 = this.queue.pollUpTo(Number.POSITIVE_INFINITY);
        this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
        return fromIterable3(values15);
      });
    });
  }
  takeUpTo(max13) {
    return suspend(() => get7(this.shutdownFlag) ? interrupt2 : sync(() => {
      const values15 = this.queue.pollUpTo(max13);
      this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
      return fromIterable3(values15);
    }));
  }
  takeBetween(min11, max13) {
    return suspend(() => takeRemainderLoop(this, min11, max13, empty7()));
  }
};
var takeRemainderLoop = (self, min11, max13, acc) => {
  if (max13 < min11) {
    return succeed(acc);
  }
  return pipe(takeUpTo(self, max13), flatMap12((bs) => {
    const remaining = min11 - bs.length;
    if (remaining === 1) {
      return pipe(take5(self), map14((b) => pipe(acc, appendAll3(bs), append3(b))));
    }
    if (remaining > 1) {
      return pipe(take5(self), flatMap12((b) => takeRemainderLoop(self, remaining - 1, max13 - bs.length - 1, pipe(acc, appendAll3(bs), append3(b)))));
    }
    return succeed(pipe(acc, appendAll3(bs)));
  }));
};
var isQueue = (u) => isEnqueue(u) && isDequeue(u);
var isEnqueue = (u) => hasProperty(u, EnqueueTypeId);
var isDequeue = (u) => hasProperty(u, DequeueTypeId);
var bounded2 = (requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap12((queue) => make61(backingQueueFromMutableQueue(queue), backPressureStrategy())));
var dropping = (requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap12((queue) => make61(backingQueueFromMutableQueue(queue), droppingStrategy())));
var sliding = (requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap12((queue) => make61(backingQueueFromMutableQueue(queue), slidingStrategy())));
var unbounded2 = () => pipe(sync(() => unbounded()), flatMap12((queue) => make61(backingQueueFromMutableQueue(queue), droppingStrategy())));
var unsafeMake13 = (queue, takers, shutdownHook, shutdownFlag, strategy) => {
  return new QueueImpl(queue, takers, shutdownHook, shutdownFlag, strategy);
};
var make61 = (queue, strategy) => pipe(deferredMake(), map14((deferred) => unsafeMake13(queue, unbounded(), deferred, make15(false), strategy)));
var BackingQueueFromMutableQueue = class {
  mutable;
  [BackingQueueTypeId] = backingQueueVariance;
  constructor(mutable3) {
    this.mutable = mutable3;
  }
  poll(def) {
    return poll2(this.mutable, def);
  }
  pollUpTo(limit) {
    return pollUpTo(this.mutable, limit);
  }
  offerAll(elements) {
    return offerAll(this.mutable, elements);
  }
  offer(element2) {
    return offer(this.mutable, element2);
  }
  capacity() {
    return capacity(this.mutable);
  }
  length() {
    return length3(this.mutable);
  }
};
var backingQueueFromMutableQueue = (mutable3) => new BackingQueueFromMutableQueue(mutable3);
var capacity2 = (self) => self.capacity();
var size17 = (self) => self.size;
var isFull2 = (self) => self.isFull;
var isEmpty15 = (self) => self.isEmpty;
var isShutdown = (self) => self.isShutdown;
var awaitShutdown = (self) => self.awaitShutdown;
var shutdown = (self) => self.shutdown;
var offer2 = dual(2, (self, value10) => self.offer(value10));
var unsafeOffer = dual(2, (self, value10) => self.unsafeOffer(value10));
var offerAll2 = dual(2, (self, iterable) => self.offerAll(iterable));
var poll5 = (self) => map14(self.takeUpTo(1), head3);
var take5 = (self) => self.take;
var takeAll = (self) => self.takeAll;
var takeUpTo = dual(2, (self, max13) => self.takeUpTo(max13));
var takeBetween = dual(3, (self, min11, max13) => self.takeBetween(min11, max13));
var takeN = dual(2, (self, n) => self.takeBetween(n, n));
var backPressureStrategy = () => new BackPressureStrategy();
var droppingStrategy = () => new DroppingStrategy();
var slidingStrategy = () => new SlidingStrategy();
var BackPressureStrategy = class {
  [QueueStrategyTypeId] = queueStrategyVariance;
  putters = unbounded();
  surplusSize() {
    return length3(this.putters);
  }
  onCompleteTakersWithEmptyQueue(takers) {
    while (!isEmpty10(this.putters) && !isEmpty10(takers)) {
      const taker = poll2(takers, void 0);
      const putter = poll2(this.putters, void 0);
      if (putter[2]) {
        unsafeCompleteDeferred(putter[1], true);
      }
      unsafeCompleteDeferred(taker, putter[0]);
    }
  }
  get shutdown() {
    return pipe(fiberId, flatMap12((fiberId5) => pipe(sync(() => unsafePollAll(this.putters)), flatMap12((putters) => forEachConcurrentDiscard(putters, ([_, deferred, isLastItem]) => isLastItem ? pipe(deferredInterruptWith(deferred, fiberId5), asVoid2) : void_3, false, false)))));
  }
  handleSurplus(iterable, queue, takers, isShutdown9) {
    return withFiberRuntime((state) => {
      const deferred = deferredUnsafeMake(state.id());
      return pipe(suspend(() => {
        this.unsafeOffer(iterable, deferred);
        this.unsafeOnQueueEmptySpace(queue, takers);
        unsafeCompleteTakers(this, queue, takers);
        return get7(isShutdown9) ? interrupt2 : deferredAwait(deferred);
      }), onInterrupt(() => sync(() => this.unsafeRemove(deferred))));
    });
  }
  unsafeOnQueueEmptySpace(queue, takers) {
    let keepPolling = true;
    while (keepPolling && (queue.capacity() === Number.POSITIVE_INFINITY || queue.length() < queue.capacity())) {
      const putter = pipe(this.putters, poll2(EmptyMutableQueue));
      if (putter === EmptyMutableQueue) {
        keepPolling = false;
      } else {
        const offered = queue.offer(putter[0]);
        if (offered && putter[2]) {
          unsafeCompleteDeferred(putter[1], true);
        } else if (!offered) {
          unsafeOfferAll(this.putters, pipe(unsafePollAll(this.putters), prepend3(putter)));
        }
        unsafeCompleteTakers(this, queue, takers);
      }
    }
  }
  unsafeOffer(iterable, deferred) {
    const stuff = fromIterable2(iterable);
    for (let i = 0; i < stuff.length; i++) {
      const value10 = stuff[i];
      if (i === stuff.length - 1) {
        pipe(this.putters, offer([value10, deferred, true]));
      } else {
        pipe(this.putters, offer([value10, deferred, false]));
      }
    }
  }
  unsafeRemove(deferred) {
    unsafeOfferAll(this.putters, pipe(unsafePollAll(this.putters), filter5(([, _]) => _ !== deferred)));
  }
};
var DroppingStrategy = class {
  [QueueStrategyTypeId] = queueStrategyVariance;
  surplusSize() {
    return 0;
  }
  get shutdown() {
    return void_3;
  }
  onCompleteTakersWithEmptyQueue() {
  }
  handleSurplus(_iterable, _queue, _takers, _isShutdown) {
    return succeed(false);
  }
  unsafeOnQueueEmptySpace(_queue, _takers) {
  }
};
var SlidingStrategy = class {
  [QueueStrategyTypeId] = queueStrategyVariance;
  surplusSize() {
    return 0;
  }
  get shutdown() {
    return void_3;
  }
  onCompleteTakersWithEmptyQueue() {
  }
  handleSurplus(iterable, queue, takers, _isShutdown) {
    return sync(() => {
      this.unsafeOffer(queue, iterable);
      unsafeCompleteTakers(this, queue, takers);
      return true;
    });
  }
  unsafeOnQueueEmptySpace(_queue, _takers) {
  }
  unsafeOffer(queue, iterable) {
    const iterator = iterable[Symbol.iterator]();
    let next6;
    let offering = true;
    while (!(next6 = iterator.next()).done && offering) {
      if (queue.capacity() === 0) {
        return;
      }
      queue.poll(EmptyMutableQueue);
      offering = queue.offer(next6.value);
    }
  }
};
var unsafeCompleteDeferred = (deferred, a) => {
  return deferredUnsafeDone(deferred, succeed(a));
};
var unsafeOfferAll = (queue, as18) => {
  return pipe(queue, offerAll(as18));
};
var unsafePollAll = (queue) => {
  return pipe(queue, pollUpTo(Number.POSITIVE_INFINITY));
};
var unsafePollN = (queue, max13) => {
  return pipe(queue, pollUpTo(max13));
};
var unsafeRemove = (queue, a) => {
  unsafeOfferAll(queue, pipe(unsafePollAll(queue), filter5((b) => a !== b)));
};
var unsafeCompleteTakers = (strategy, queue, takers) => {
  let keepPolling = true;
  while (keepPolling && queue.length() !== 0) {
    const taker = pipe(takers, poll2(EmptyMutableQueue));
    if (taker !== EmptyMutableQueue) {
      const element2 = queue.poll(EmptyMutableQueue);
      if (element2 !== EmptyMutableQueue) {
        unsafeCompleteDeferred(taker, element2);
        strategy.unsafeOnQueueEmptySpace(queue, takers);
      } else {
        unsafeOfferAll(takers, pipe(unsafePollAll(takers), prepend3(taker)));
      }
      keepPolling = true;
    } else {
      keepPolling = false;
    }
  }
  if (keepPolling && queue.length() === 0 && !isEmpty10(takers)) {
    strategy.onCompleteTakersWithEmptyQueue(takers);
  }
};

// ../../node_modules/effect/dist/esm/internal/pubsub.js
var AbsentValue = Symbol.for("effect/PubSub/AbsentValue");
var addSubscribers = (subscription, pollers) => (subscribers) => {
  if (!subscribers.has(subscription)) {
    subscribers.set(subscription, /* @__PURE__ */ new Set());
  }
  const set26 = subscribers.get(subscription);
  set26.add(pollers);
};
var removeSubscribers = (subscription, pollers) => (subscribers) => {
  if (!subscribers.has(subscription)) {
    return;
  }
  const set26 = subscribers.get(subscription);
  set26.delete(pollers);
  if (set26.size === 0) {
    subscribers.delete(subscription);
  }
};
var bounded3 = (capacity10) => suspend(() => {
  const pubsub = makeBoundedPubSub(capacity10);
  return makePubSub(pubsub, new BackPressureStrategy2());
});
var dropping2 = (capacity10) => suspend(() => {
  const pubsub = makeBoundedPubSub(capacity10);
  return makePubSub(pubsub, new DroppingStrategy2());
});
var sliding2 = (capacity10) => suspend(() => {
  const pubsub = makeBoundedPubSub(capacity10);
  return makePubSub(pubsub, new SlidingStrategy2());
});
var unbounded3 = (options) => suspend(() => {
  const pubsub = makeUnboundedPubSub(options);
  return makePubSub(pubsub, new DroppingStrategy2());
});
var capacity3 = (self) => self.capacity();
var size18 = (self) => self.size;
var isFull3 = (self) => self.isFull;
var isEmpty16 = (self) => self.isEmpty;
var shutdown2 = (self) => self.shutdown;
var isShutdown2 = (self) => self.isShutdown;
var awaitShutdown2 = (self) => self.awaitShutdown;
var publish = dual(2, (self, value10) => self.publish(value10));
var publishAll = dual(2, (self, elements) => self.publishAll(elements));
var subscribe = (self) => self.subscribe;
var makeBoundedPubSub = (capacity10) => {
  const options = typeof capacity10 === "number" ? {
    capacity: capacity10
  } : capacity10;
  ensureCapacity(options.capacity);
  const replayBuffer = options.replay && options.replay > 0 ? new ReplayBuffer(Math.ceil(options.replay)) : void 0;
  if (options.capacity === 1) {
    return new BoundedPubSubSingle(replayBuffer);
  } else if (nextPow2(options.capacity) === options.capacity) {
    return new BoundedPubSubPow2(options.capacity, replayBuffer);
  } else {
    return new BoundedPubSubArb(options.capacity, replayBuffer);
  }
};
var makeUnboundedPubSub = (options) => new UnboundedPubSub(options?.replay ? new ReplayBuffer(options.replay) : void 0);
var makeSubscription = (pubsub, subscribers, strategy) => map14(deferredMake(), (deferred) => unsafeMakeSubscription(pubsub, subscribers, pubsub.subscribe(), unbounded(), deferred, make15(false), strategy));
var unsafeMakeSubscription = (pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy) => new SubscriptionImpl(pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy, pubsub.replayWindow());
var BoundedPubSubArb = class {
  capacity;
  replayBuffer;
  array;
  publisherIndex = 0;
  subscribers;
  subscriberCount = 0;
  subscribersIndex = 0;
  constructor(capacity10, replayBuffer) {
    this.capacity = capacity10;
    this.replayBuffer = replayBuffer;
    this.array = Array.from({
      length: capacity10
    });
    this.subscribers = Array.from({
      length: capacity10
    });
  }
  replayWindow() {
    return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
  }
  isEmpty() {
    return this.publisherIndex === this.subscribersIndex;
  }
  isFull() {
    return this.publisherIndex === this.subscribersIndex + this.capacity;
  }
  size() {
    return this.publisherIndex - this.subscribersIndex;
  }
  publish(value10) {
    if (this.isFull()) {
      return false;
    }
    if (this.subscriberCount !== 0) {
      const index = this.publisherIndex % this.capacity;
      this.array[index] = value10;
      this.subscribers[index] = this.subscriberCount;
      this.publisherIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.offer(value10);
    }
    return true;
  }
  publishAll(elements) {
    if (this.subscriberCount === 0) {
      if (this.replayBuffer) {
        this.replayBuffer.offerAll(elements);
      }
      return empty7();
    }
    const chunk7 = fromIterable3(elements);
    const n = chunk7.length;
    const size40 = this.publisherIndex - this.subscribersIndex;
    const available3 = this.capacity - size40;
    const forPubSub = Math.min(n, available3);
    if (forPubSub === 0) {
      return chunk7;
    }
    let iteratorIndex = 0;
    const publishAllIndex = this.publisherIndex + forPubSub;
    while (this.publisherIndex !== publishAllIndex) {
      const a = unsafeGet4(chunk7, iteratorIndex++);
      const index = this.publisherIndex % this.capacity;
      this.array[index] = a;
      this.subscribers[index] = this.subscriberCount;
      this.publisherIndex += 1;
      if (this.replayBuffer) {
        this.replayBuffer.offer(a);
      }
    }
    return drop3(chunk7, iteratorIndex);
  }
  slide() {
    if (this.subscribersIndex !== this.publisherIndex) {
      const index = this.subscribersIndex % this.capacity;
      this.array[index] = AbsentValue;
      this.subscribers[index] = 0;
      this.subscribersIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.slide();
    }
  }
  subscribe() {
    this.subscriberCount += 1;
    return new BoundedPubSubArbSubscription(this, this.publisherIndex, false);
  }
};
var BoundedPubSubArbSubscription = class {
  self;
  subscriberIndex;
  unsubscribed;
  constructor(self, subscriberIndex, unsubscribed) {
    this.self = self;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    return this.unsubscribed || this.self.publisherIndex === this.subscriberIndex || this.self.publisherIndex === this.self.subscribersIndex;
  }
  size() {
    if (this.unsubscribed) {
      return 0;
    }
    return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
  }
  poll(default_) {
    if (this.unsubscribed) {
      return default_;
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    if (this.subscriberIndex !== this.self.publisherIndex) {
      const index = this.subscriberIndex % this.self.capacity;
      const elem = this.self.array[index];
      this.self.subscribers[index] -= 1;
      if (this.self.subscribers[index] === 0) {
        this.self.array[index] = AbsentValue;
        this.self.subscribersIndex += 1;
      }
      this.subscriberIndex += 1;
      return elem;
    }
    return default_;
  }
  pollUpTo(n) {
    if (this.unsubscribed) {
      return empty7();
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    const size40 = this.self.publisherIndex - this.subscriberIndex;
    const toPoll = Math.min(n, size40);
    if (toPoll <= 0) {
      return empty7();
    }
    const builder = [];
    const pollUpToIndex = this.subscriberIndex + toPoll;
    while (this.subscriberIndex !== pollUpToIndex) {
      const index = this.subscriberIndex % this.self.capacity;
      const a = this.self.array[index];
      this.self.subscribers[index] -= 1;
      if (this.self.subscribers[index] === 0) {
        this.self.array[index] = AbsentValue;
        this.self.subscribersIndex += 1;
      }
      builder.push(a);
      this.subscriberIndex += 1;
    }
    return fromIterable3(builder);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.subscriberCount -= 1;
      this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
      while (this.subscriberIndex !== this.self.publisherIndex) {
        const index = this.subscriberIndex % this.self.capacity;
        this.self.subscribers[index] -= 1;
        if (this.self.subscribers[index] === 0) {
          this.self.array[index] = AbsentValue;
          this.self.subscribersIndex += 1;
        }
        this.subscriberIndex += 1;
      }
    }
  }
};
var BoundedPubSubPow2 = class {
  capacity;
  replayBuffer;
  array;
  mask;
  publisherIndex = 0;
  subscribers;
  subscriberCount = 0;
  subscribersIndex = 0;
  constructor(capacity10, replayBuffer) {
    this.capacity = capacity10;
    this.replayBuffer = replayBuffer;
    this.array = Array.from({
      length: capacity10
    });
    this.mask = capacity10 - 1;
    this.subscribers = Array.from({
      length: capacity10
    });
  }
  replayWindow() {
    return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
  }
  isEmpty() {
    return this.publisherIndex === this.subscribersIndex;
  }
  isFull() {
    return this.publisherIndex === this.subscribersIndex + this.capacity;
  }
  size() {
    return this.publisherIndex - this.subscribersIndex;
  }
  publish(value10) {
    if (this.isFull()) {
      return false;
    }
    if (this.subscriberCount !== 0) {
      const index = this.publisherIndex & this.mask;
      this.array[index] = value10;
      this.subscribers[index] = this.subscriberCount;
      this.publisherIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.offer(value10);
    }
    return true;
  }
  publishAll(elements) {
    if (this.subscriberCount === 0) {
      if (this.replayBuffer) {
        this.replayBuffer.offerAll(elements);
      }
      return empty7();
    }
    const chunk7 = fromIterable3(elements);
    const n = chunk7.length;
    const size40 = this.publisherIndex - this.subscribersIndex;
    const available3 = this.capacity - size40;
    const forPubSub = Math.min(n, available3);
    if (forPubSub === 0) {
      return chunk7;
    }
    let iteratorIndex = 0;
    const publishAllIndex = this.publisherIndex + forPubSub;
    while (this.publisherIndex !== publishAllIndex) {
      const elem = unsafeGet4(chunk7, iteratorIndex++);
      const index = this.publisherIndex & this.mask;
      this.array[index] = elem;
      this.subscribers[index] = this.subscriberCount;
      this.publisherIndex += 1;
      if (this.replayBuffer) {
        this.replayBuffer.offer(elem);
      }
    }
    return drop3(chunk7, iteratorIndex);
  }
  slide() {
    if (this.subscribersIndex !== this.publisherIndex) {
      const index = this.subscribersIndex & this.mask;
      this.array[index] = AbsentValue;
      this.subscribers[index] = 0;
      this.subscribersIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.slide();
    }
  }
  subscribe() {
    this.subscriberCount += 1;
    return new BoundedPubSubPow2Subscription(this, this.publisherIndex, false);
  }
};
var BoundedPubSubPow2Subscription = class {
  self;
  subscriberIndex;
  unsubscribed;
  constructor(self, subscriberIndex, unsubscribed) {
    this.self = self;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    return this.unsubscribed || this.self.publisherIndex === this.subscriberIndex || this.self.publisherIndex === this.self.subscribersIndex;
  }
  size() {
    if (this.unsubscribed) {
      return 0;
    }
    return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
  }
  poll(default_) {
    if (this.unsubscribed) {
      return default_;
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    if (this.subscriberIndex !== this.self.publisherIndex) {
      const index = this.subscriberIndex & this.self.mask;
      const elem = this.self.array[index];
      this.self.subscribers[index] -= 1;
      if (this.self.subscribers[index] === 0) {
        this.self.array[index] = AbsentValue;
        this.self.subscribersIndex += 1;
      }
      this.subscriberIndex += 1;
      return elem;
    }
    return default_;
  }
  pollUpTo(n) {
    if (this.unsubscribed) {
      return empty7();
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    const size40 = this.self.publisherIndex - this.subscriberIndex;
    const toPoll = Math.min(n, size40);
    if (toPoll <= 0) {
      return empty7();
    }
    const builder = [];
    const pollUpToIndex = this.subscriberIndex + toPoll;
    while (this.subscriberIndex !== pollUpToIndex) {
      const index = this.subscriberIndex & this.self.mask;
      const elem = this.self.array[index];
      this.self.subscribers[index] -= 1;
      if (this.self.subscribers[index] === 0) {
        this.self.array[index] = AbsentValue;
        this.self.subscribersIndex += 1;
      }
      builder.push(elem);
      this.subscriberIndex += 1;
    }
    return fromIterable3(builder);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.subscriberCount -= 1;
      this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
      while (this.subscriberIndex !== this.self.publisherIndex) {
        const index = this.subscriberIndex & this.self.mask;
        this.self.subscribers[index] -= 1;
        if (this.self.subscribers[index] === 0) {
          this.self.array[index] = AbsentValue;
          this.self.subscribersIndex += 1;
        }
        this.subscriberIndex += 1;
      }
    }
  }
};
var BoundedPubSubSingle = class {
  replayBuffer;
  publisherIndex = 0;
  subscriberCount = 0;
  subscribers = 0;
  value = AbsentValue;
  capacity = 1;
  constructor(replayBuffer) {
    this.replayBuffer = replayBuffer;
  }
  replayWindow() {
    return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  isEmpty() {
    return this.subscribers === 0;
  }
  isFull() {
    return !this.isEmpty();
  }
  size() {
    return this.isEmpty() ? 0 : 1;
  }
  publish(value10) {
    if (this.isFull()) {
      return false;
    }
    if (this.subscriberCount !== 0) {
      this.value = value10;
      this.subscribers = this.subscriberCount;
      this.publisherIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.offer(value10);
    }
    return true;
  }
  publishAll(elements) {
    if (this.subscriberCount === 0) {
      if (this.replayBuffer) {
        this.replayBuffer.offerAll(elements);
      }
      return empty7();
    }
    const chunk7 = fromIterable3(elements);
    if (isEmpty2(chunk7)) {
      return chunk7;
    }
    if (this.publish(unsafeHead2(chunk7))) {
      return drop3(chunk7, 1);
    } else {
      return chunk7;
    }
  }
  slide() {
    if (this.isFull()) {
      this.subscribers = 0;
      this.value = AbsentValue;
    }
    if (this.replayBuffer) {
      this.replayBuffer.slide();
    }
  }
  subscribe() {
    this.subscriberCount += 1;
    return new BoundedPubSubSingleSubscription(this, this.publisherIndex, false);
  }
};
var BoundedPubSubSingleSubscription = class {
  self;
  subscriberIndex;
  unsubscribed;
  constructor(self, subscriberIndex, unsubscribed) {
    this.self = self;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    return this.unsubscribed || this.self.subscribers === 0 || this.subscriberIndex === this.self.publisherIndex;
  }
  size() {
    return this.isEmpty() ? 0 : 1;
  }
  poll(default_) {
    if (this.isEmpty()) {
      return default_;
    }
    const elem = this.self.value;
    this.self.subscribers -= 1;
    if (this.self.subscribers === 0) {
      this.self.value = AbsentValue;
    }
    this.subscriberIndex += 1;
    return elem;
  }
  pollUpTo(n) {
    if (this.isEmpty() || n < 1) {
      return empty7();
    }
    const a = this.self.value;
    this.self.subscribers -= 1;
    if (this.self.subscribers === 0) {
      this.self.value = AbsentValue;
    }
    this.subscriberIndex += 1;
    return of3(a);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.subscriberCount -= 1;
      if (this.subscriberIndex !== this.self.publisherIndex) {
        this.self.subscribers -= 1;
        if (this.self.subscribers === 0) {
          this.self.value = AbsentValue;
        }
      }
    }
  }
};
var UnboundedPubSub = class {
  replayBuffer;
  publisherHead = {
    value: AbsentValue,
    subscribers: 0,
    next: null
  };
  publisherTail = this.publisherHead;
  publisherIndex = 0;
  subscribersIndex = 0;
  capacity = Number.MAX_SAFE_INTEGER;
  constructor(replayBuffer) {
    this.replayBuffer = replayBuffer;
  }
  replayWindow() {
    return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
  }
  isEmpty() {
    return this.publisherHead === this.publisherTail;
  }
  isFull() {
    return false;
  }
  size() {
    return this.publisherIndex - this.subscribersIndex;
  }
  publish(value10) {
    const subscribers = this.publisherTail.subscribers;
    if (subscribers !== 0) {
      this.publisherTail.next = {
        value: value10,
        subscribers,
        next: null
      };
      this.publisherTail = this.publisherTail.next;
      this.publisherIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.offer(value10);
    }
    return true;
  }
  publishAll(elements) {
    if (this.publisherTail.subscribers !== 0) {
      for (const a of elements) {
        this.publish(a);
      }
    } else if (this.replayBuffer) {
      this.replayBuffer.offerAll(elements);
    }
    return empty7();
  }
  slide() {
    if (this.publisherHead !== this.publisherTail) {
      this.publisherHead = this.publisherHead.next;
      this.publisherHead.value = AbsentValue;
      this.subscribersIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.slide();
    }
  }
  subscribe() {
    this.publisherTail.subscribers += 1;
    return new UnboundedPubSubSubscription(this, this.publisherTail, this.publisherIndex, false);
  }
};
var UnboundedPubSubSubscription = class {
  self;
  subscriberHead;
  subscriberIndex;
  unsubscribed;
  constructor(self, subscriberHead, subscriberIndex, unsubscribed) {
    this.self = self;
    this.subscriberHead = subscriberHead;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    if (this.unsubscribed) {
      return true;
    }
    let empty61 = true;
    let loop5 = true;
    while (loop5) {
      if (this.subscriberHead === this.self.publisherTail) {
        loop5 = false;
      } else {
        if (this.subscriberHead.next.value !== AbsentValue) {
          empty61 = false;
          loop5 = false;
        } else {
          this.subscriberHead = this.subscriberHead.next;
          this.subscriberIndex += 1;
        }
      }
    }
    return empty61;
  }
  size() {
    if (this.unsubscribed) {
      return 0;
    }
    return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
  }
  poll(default_) {
    if (this.unsubscribed) {
      return default_;
    }
    let loop5 = true;
    let polled = default_;
    while (loop5) {
      if (this.subscriberHead === this.self.publisherTail) {
        loop5 = false;
      } else {
        const elem = this.subscriberHead.next.value;
        if (elem !== AbsentValue) {
          polled = elem;
          this.subscriberHead.subscribers -= 1;
          if (this.subscriberHead.subscribers === 0) {
            this.self.publisherHead = this.self.publisherHead.next;
            this.self.publisherHead.value = AbsentValue;
            this.self.subscribersIndex += 1;
          }
          loop5 = false;
        }
        this.subscriberHead = this.subscriberHead.next;
        this.subscriberIndex += 1;
      }
    }
    return polled;
  }
  pollUpTo(n) {
    const builder = [];
    const default_ = AbsentValue;
    let i = 0;
    while (i !== n) {
      const a = this.poll(default_);
      if (a === default_) {
        i = n;
      } else {
        builder.push(a);
        i += 1;
      }
    }
    return fromIterable3(builder);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.publisherTail.subscribers -= 1;
      while (this.subscriberHead !== this.self.publisherTail) {
        if (this.subscriberHead.next.value !== AbsentValue) {
          this.subscriberHead.subscribers -= 1;
          if (this.subscriberHead.subscribers === 0) {
            this.self.publisherHead = this.self.publisherHead.next;
            this.self.publisherHead.value = AbsentValue;
            this.self.subscribersIndex += 1;
          }
        }
        this.subscriberHead = this.subscriberHead.next;
      }
    }
  }
};
var SubscriptionImpl = class extends Class3 {
  pubsub;
  subscribers;
  subscription;
  pollers;
  shutdownHook;
  shutdownFlag;
  strategy;
  replayWindow;
  [DequeueTypeId] = dequeueVariance;
  constructor(pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy, replayWindow) {
    super();
    this.pubsub = pubsub;
    this.subscribers = subscribers;
    this.subscription = subscription;
    this.pollers = pollers;
    this.shutdownHook = shutdownHook;
    this.shutdownFlag = shutdownFlag;
    this.strategy = strategy;
    this.replayWindow = replayWindow;
  }
  commit() {
    return this.take;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  capacity() {
    return this.pubsub.capacity;
  }
  isActive() {
    return !get7(this.shutdownFlag);
  }
  get size() {
    return suspend(() => get7(this.shutdownFlag) ? interrupt2 : succeed(this.subscription.size() + this.replayWindow.remaining));
  }
  unsafeSize() {
    if (get7(this.shutdownFlag)) {
      return none2();
    }
    return some3(this.subscription.size() + this.replayWindow.remaining);
  }
  get isFull() {
    return suspend(() => get7(this.shutdownFlag) ? interrupt2 : succeed(this.subscription.size() === this.capacity()));
  }
  get isEmpty() {
    return map14(this.size, (size40) => size40 === 0);
  }
  get shutdown() {
    return uninterruptible(withFiberRuntime((state) => {
      set3(this.shutdownFlag, true);
      return pipe(forEachParUnbounded(unsafePollAllQueue(this.pollers), (d) => deferredInterruptWith(d, state.id()), false), zipRight2(sync(() => {
        this.subscribers.delete(this.subscription);
        this.subscription.unsubscribe();
        this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
      })), whenEffect(deferredSucceed(this.shutdownHook, void 0)), asVoid2);
    }));
  }
  get isShutdown() {
    return sync(() => get7(this.shutdownFlag));
  }
  get awaitShutdown() {
    return deferredAwait(this.shutdownHook);
  }
  get take() {
    return withFiberRuntime((state) => {
      if (get7(this.shutdownFlag)) {
        return interrupt2;
      }
      if (this.replayWindow.remaining > 0) {
        const message2 = this.replayWindow.take();
        return succeed(message2);
      }
      const message = isEmpty10(this.pollers) ? this.subscription.poll(EmptyMutableQueue) : EmptyMutableQueue;
      if (message === EmptyMutableQueue) {
        const deferred = deferredUnsafeMake(state.id());
        return pipe(suspend(() => {
          pipe(this.pollers, offer(deferred));
          pipe(this.subscribers, addSubscribers(this.subscription, this.pollers));
          this.strategy.unsafeCompletePollers(this.pubsub, this.subscribers, this.subscription, this.pollers);
          return get7(this.shutdownFlag) ? interrupt2 : deferredAwait(deferred);
        }), onInterrupt(() => sync(() => unsafeRemove2(this.pollers, deferred))));
      } else {
        this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
        return succeed(message);
      }
    });
  }
  get takeAll() {
    return suspend(() => {
      if (get7(this.shutdownFlag)) {
        return interrupt2;
      }
      const as18 = isEmpty10(this.pollers) ? unsafePollAllSubscription(this.subscription) : empty7();
      this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
      if (this.replayWindow.remaining > 0) {
        return succeed(appendAll3(this.replayWindow.takeAll(), as18));
      }
      return succeed(as18);
    });
  }
  takeUpTo(max13) {
    return suspend(() => {
      if (get7(this.shutdownFlag)) {
        return interrupt2;
      }
      let replay = void 0;
      if (this.replayWindow.remaining >= max13) {
        const as19 = this.replayWindow.takeN(max13);
        return succeed(as19);
      } else if (this.replayWindow.remaining > 0) {
        replay = this.replayWindow.takeAll();
        max13 = max13 - replay.length;
      }
      const as18 = isEmpty10(this.pollers) ? unsafePollN2(this.subscription, max13) : empty7();
      this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
      return replay ? succeed(appendAll3(replay, as18)) : succeed(as18);
    });
  }
  takeBetween(min11, max13) {
    return suspend(() => takeRemainderLoop2(this, min11, max13, empty7()));
  }
};
var takeRemainderLoop2 = (self, min11, max13, acc) => {
  if (max13 < min11) {
    return succeed(acc);
  }
  return pipe(self.takeUpTo(max13), flatMap12((bs) => {
    const remaining = min11 - bs.length;
    if (remaining === 1) {
      return pipe(self.take, map14((b) => pipe(acc, appendAll3(bs), append3(b))));
    }
    if (remaining > 1) {
      return pipe(self.take, flatMap12((b) => takeRemainderLoop2(self, remaining - 1, max13 - bs.length - 1, pipe(acc, appendAll3(bs), append3(b)))));
    }
    return succeed(pipe(acc, appendAll3(bs)));
  }));
};
var PubSubImpl = class {
  pubsub;
  subscribers;
  scope;
  shutdownHook;
  shutdownFlag;
  strategy;
  [EnqueueTypeId] = enqueueVariance;
  [DequeueTypeId] = dequeueVariance;
  constructor(pubsub, subscribers, scope6, shutdownHook, shutdownFlag, strategy) {
    this.pubsub = pubsub;
    this.subscribers = subscribers;
    this.scope = scope6;
    this.shutdownHook = shutdownHook;
    this.shutdownFlag = shutdownFlag;
    this.strategy = strategy;
  }
  capacity() {
    return this.pubsub.capacity;
  }
  get size() {
    return suspend(() => get7(this.shutdownFlag) ? interrupt2 : sync(() => this.pubsub.size()));
  }
  unsafeSize() {
    if (get7(this.shutdownFlag)) {
      return none2();
    }
    return some3(this.pubsub.size());
  }
  get isFull() {
    return map14(this.size, (size40) => size40 === this.capacity());
  }
  get isEmpty() {
    return map14(this.size, (size40) => size40 === 0);
  }
  get awaitShutdown() {
    return deferredAwait(this.shutdownHook);
  }
  get isShutdown() {
    return sync(() => get7(this.shutdownFlag));
  }
  get shutdown() {
    return uninterruptible(withFiberRuntime((state) => {
      pipe(this.shutdownFlag, set3(true));
      return pipe(this.scope.close(exitInterrupt(state.id())), zipRight2(this.strategy.shutdown), whenEffect(deferredSucceed(this.shutdownHook, void 0)), asVoid2);
    }));
  }
  publish(value10) {
    return suspend(() => {
      if (get7(this.shutdownFlag)) {
        return interrupt2;
      }
      if (this.pubsub.publish(value10)) {
        this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
        return succeed(true);
      }
      return this.strategy.handleSurplus(this.pubsub, this.subscribers, of3(value10), this.shutdownFlag);
    });
  }
  isActive() {
    return !get7(this.shutdownFlag);
  }
  unsafeOffer(value10) {
    if (get7(this.shutdownFlag)) {
      return false;
    }
    if (this.pubsub.publish(value10)) {
      this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
      return true;
    }
    return false;
  }
  publishAll(elements) {
    return suspend(() => {
      if (get7(this.shutdownFlag)) {
        return interrupt2;
      }
      const surplus = unsafePublishAll(this.pubsub, elements);
      this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
      if (isEmpty2(surplus)) {
        return succeed(true);
      }
      return this.strategy.handleSurplus(this.pubsub, this.subscribers, surplus, this.shutdownFlag);
    });
  }
  get subscribe() {
    const acquire4 = tap2(all9([this.scope.fork(sequential2), makeSubscription(this.pubsub, this.subscribers, this.strategy)]), (tuple7) => tuple7[0].addFinalizer(() => tuple7[1].shutdown));
    return map14(acquireRelease2(acquire4, (tuple7, exit4) => tuple7[0].close(exit4)), (tuple7) => tuple7[1]);
  }
  offer(value10) {
    return this.publish(value10);
  }
  offerAll(elements) {
    return this.publishAll(elements);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makePubSub = (pubsub, strategy) => flatMap12(scopeMake2(), (scope6) => map14(deferredMake(), (deferred) => unsafeMakePubSub(pubsub, /* @__PURE__ */ new Map(), scope6, deferred, make15(false), strategy)));
var unsafeMakePubSub = (pubsub, subscribers, scope6, shutdownHook, shutdownFlag, strategy) => new PubSubImpl(pubsub, subscribers, scope6, shutdownHook, shutdownFlag, strategy);
var ensureCapacity = (capacity10) => {
  if (capacity10 <= 0) {
    throw new InvalidPubSubCapacityException(`Cannot construct PubSub with capacity of ${capacity10}`);
  }
};
var unsafeCompleteDeferred2 = (deferred, a) => {
  deferredUnsafeDone(deferred, succeed(a));
};
var unsafeOfferAll2 = (queue, as18) => {
  return pipe(queue, offerAll(as18));
};
var unsafePollAllQueue = (queue) => {
  return pipe(queue, pollUpTo(Number.POSITIVE_INFINITY));
};
var unsafePollAllSubscription = (subscription) => {
  return subscription.pollUpTo(Number.POSITIVE_INFINITY);
};
var unsafePollN2 = (subscription, max13) => {
  return subscription.pollUpTo(max13);
};
var unsafePublishAll = (pubsub, as18) => {
  return pubsub.publishAll(as18);
};
var unsafeRemove2 = (queue, value10) => {
  unsafeOfferAll2(queue, pipe(unsafePollAllQueue(queue), filter5((elem) => elem !== value10)));
};
var BackPressureStrategy2 = class {
  publishers = unbounded();
  get shutdown() {
    return flatMap12(fiberId, (fiberId5) => flatMap12(sync(() => unsafePollAllQueue(this.publishers)), (publishers) => forEachConcurrentDiscard(publishers, ([_, deferred, last8]) => last8 ? pipe(deferredInterruptWith(deferred, fiberId5), asVoid2) : void_3, false, false)));
  }
  handleSurplus(pubsub, subscribers, elements, isShutdown9) {
    return withFiberRuntime((state) => {
      const deferred = deferredUnsafeMake(state.id());
      return pipe(suspend(() => {
        this.unsafeOffer(elements, deferred);
        this.unsafeOnPubSubEmptySpace(pubsub, subscribers);
        this.unsafeCompleteSubscribers(pubsub, subscribers);
        return get7(isShutdown9) ? interrupt2 : deferredAwait(deferred);
      }), onInterrupt(() => sync(() => this.unsafeRemove(deferred))));
    });
  }
  unsafeOnPubSubEmptySpace(pubsub, subscribers) {
    let keepPolling = true;
    while (keepPolling && !pubsub.isFull()) {
      const publisher = pipe(this.publishers, poll2(EmptyMutableQueue));
      if (publisher === EmptyMutableQueue) {
        keepPolling = false;
      } else {
        const published = pubsub.publish(publisher[0]);
        if (published && publisher[2]) {
          unsafeCompleteDeferred2(publisher[1], true);
        } else if (!published) {
          unsafeOfferAll2(this.publishers, pipe(unsafePollAllQueue(this.publishers), prepend3(publisher)));
        }
        this.unsafeCompleteSubscribers(pubsub, subscribers);
      }
    }
  }
  unsafeCompletePollers(pubsub, subscribers, subscription, pollers) {
    return unsafeStrategyCompletePollers(this, pubsub, subscribers, subscription, pollers);
  }
  unsafeCompleteSubscribers(pubsub, subscribers) {
    return unsafeStrategyCompleteSubscribers(this, pubsub, subscribers);
  }
  unsafeOffer(elements, deferred) {
    const iterator = elements[Symbol.iterator]();
    let next6 = iterator.next();
    if (!next6.done) {
      while (1) {
        const value10 = next6.value;
        next6 = iterator.next();
        if (next6.done) {
          pipe(this.publishers, offer([value10, deferred, true]));
          break;
        }
        pipe(this.publishers, offer([value10, deferred, false]));
      }
    }
  }
  unsafeRemove(deferred) {
    unsafeOfferAll2(this.publishers, pipe(unsafePollAllQueue(this.publishers), filter5(([_, a]) => a !== deferred)));
  }
};
var DroppingStrategy2 = class {
  get shutdown() {
    return void_3;
  }
  handleSurplus(_pubsub, _subscribers, _elements, _isShutdown) {
    return succeed(false);
  }
  unsafeOnPubSubEmptySpace(_pubsub, _subscribers) {
  }
  unsafeCompletePollers(pubsub, subscribers, subscription, pollers) {
    return unsafeStrategyCompletePollers(this, pubsub, subscribers, subscription, pollers);
  }
  unsafeCompleteSubscribers(pubsub, subscribers) {
    return unsafeStrategyCompleteSubscribers(this, pubsub, subscribers);
  }
};
var SlidingStrategy2 = class {
  get shutdown() {
    return void_3;
  }
  handleSurplus(pubsub, subscribers, elements, _isShutdown) {
    return sync(() => {
      this.unsafeSlidingPublish(pubsub, elements);
      this.unsafeCompleteSubscribers(pubsub, subscribers);
      return true;
    });
  }
  unsafeOnPubSubEmptySpace(_pubsub, _subscribers) {
  }
  unsafeCompletePollers(pubsub, subscribers, subscription, pollers) {
    return unsafeStrategyCompletePollers(this, pubsub, subscribers, subscription, pollers);
  }
  unsafeCompleteSubscribers(pubsub, subscribers) {
    return unsafeStrategyCompleteSubscribers(this, pubsub, subscribers);
  }
  unsafeSlidingPublish(pubsub, elements) {
    const it = elements[Symbol.iterator]();
    let next6 = it.next();
    if (!next6.done && pubsub.capacity > 0) {
      let a = next6.value;
      let loop5 = true;
      while (loop5) {
        pubsub.slide();
        const pub = pubsub.publish(a);
        if (pub && (next6 = it.next()) && !next6.done) {
          a = next6.value;
        } else if (pub) {
          loop5 = false;
        }
      }
    }
  }
};
var unsafeStrategyCompletePollers = (strategy, pubsub, subscribers, subscription, pollers) => {
  let keepPolling = true;
  while (keepPolling && !subscription.isEmpty()) {
    const poller = pipe(pollers, poll2(EmptyMutableQueue));
    if (poller === EmptyMutableQueue) {
      pipe(subscribers, removeSubscribers(subscription, pollers));
      if (isEmpty10(pollers)) {
        keepPolling = false;
      } else {
        pipe(subscribers, addSubscribers(subscription, pollers));
      }
    } else {
      const pollResult = subscription.poll(EmptyMutableQueue);
      if (pollResult === EmptyMutableQueue) {
        unsafeOfferAll2(pollers, pipe(unsafePollAllQueue(pollers), prepend3(poller)));
      } else {
        unsafeCompleteDeferred2(poller, pollResult);
        strategy.unsafeOnPubSubEmptySpace(pubsub, subscribers);
      }
    }
  }
};
var unsafeStrategyCompleteSubscribers = (strategy, pubsub, subscribers) => {
  for (const [subscription, pollersSet] of subscribers) {
    for (const pollers of pollersSet) {
      strategy.unsafeCompletePollers(pubsub, subscribers, subscription, pollers);
    }
  }
};
var ReplayBuffer = class {
  capacity;
  constructor(capacity10) {
    this.capacity = capacity10;
  }
  head = {
    value: AbsentValue,
    next: null
  };
  tail = this.head;
  size = 0;
  index = 0;
  slide() {
    this.index++;
  }
  offer(a) {
    this.tail.value = a;
    this.tail.next = {
      value: AbsentValue,
      next: null
    };
    this.tail = this.tail.next;
    if (this.size === this.capacity) {
      this.head = this.head.next;
    } else {
      this.size += 1;
    }
  }
  offerAll(as18) {
    for (const a of as18) {
      this.offer(a);
    }
  }
};
var ReplayWindowImpl = class {
  buffer;
  head;
  index;
  remaining;
  constructor(buffer5) {
    this.buffer = buffer5;
    this.index = buffer5.index;
    this.remaining = buffer5.size;
    this.head = buffer5.head;
  }
  fastForward() {
    while (this.index < this.buffer.index) {
      this.head = this.head.next;
      this.index++;
    }
  }
  take() {
    if (this.remaining === 0) {
      return void 0;
    } else if (this.index < this.buffer.index) {
      this.fastForward();
    }
    this.remaining--;
    const value10 = this.head.value;
    this.head = this.head.next;
    return value10;
  }
  takeN(n) {
    if (this.remaining === 0) {
      return empty7();
    } else if (this.index < this.buffer.index) {
      this.fastForward();
    }
    const len = Math.min(n, this.remaining);
    const items = new Array(len);
    for (let i = 0; i < len; i++) {
      const value10 = this.head.value;
      this.head = this.head.next;
      items[i] = value10;
    }
    this.remaining -= len;
    return unsafeFromArray(items);
  }
  takeAll() {
    return this.takeN(this.remaining);
  }
};
var emptyReplayWindow = {
  remaining: 0,
  take: () => void 0,
  takeN: () => empty7(),
  takeAll: () => empty7()
};

// ../../node_modules/effect/dist/esm/PubSub.js
var bounded4 = bounded3;
var dropping3 = dropping2;
var sliding3 = sliding2;
var unbounded4 = unbounded3;
var capacity4 = capacity3;
var size19 = size18;
var isFull4 = isFull3;
var isEmpty17 = isEmpty16;
var shutdown3 = shutdown2;
var isShutdown3 = isShutdown2;
var awaitShutdown3 = awaitShutdown2;
var publish2 = publish;
var publishAll2 = publishAll;
var subscribe2 = subscribe;

// ../../node_modules/effect/dist/esm/Queue.js
var Queue_exports = {};
__export(Queue_exports, {
  BackingQueueTypeId: () => BackingQueueTypeId2,
  DequeueTypeId: () => DequeueTypeId2,
  EnqueueTypeId: () => EnqueueTypeId2,
  QueueStrategyTypeId: () => QueueStrategyTypeId2,
  awaitShutdown: () => awaitShutdown4,
  backPressureStrategy: () => backPressureStrategy2,
  bounded: () => bounded5,
  capacity: () => capacity5,
  dropping: () => dropping4,
  droppingStrategy: () => droppingStrategy2,
  isDequeue: () => isDequeue2,
  isEmpty: () => isEmpty18,
  isEnqueue: () => isEnqueue2,
  isFull: () => isFull5,
  isQueue: () => isQueue2,
  isShutdown: () => isShutdown4,
  make: () => make62,
  offer: () => offer3,
  offerAll: () => offerAll3,
  poll: () => poll6,
  shutdown: () => shutdown4,
  size: () => size20,
  sliding: () => sliding4,
  slidingStrategy: () => slidingStrategy2,
  take: () => take6,
  takeAll: () => takeAll2,
  takeBetween: () => takeBetween2,
  takeN: () => takeN2,
  takeUpTo: () => takeUpTo2,
  unbounded: () => unbounded5,
  unsafeOffer: () => unsafeOffer2
});
var EnqueueTypeId2 = EnqueueTypeId;
var DequeueTypeId2 = DequeueTypeId;
var QueueStrategyTypeId2 = QueueStrategyTypeId;
var BackingQueueTypeId2 = BackingQueueTypeId;
var isQueue2 = isQueue;
var isDequeue2 = isDequeue;
var isEnqueue2 = isEnqueue;
var backPressureStrategy2 = backPressureStrategy;
var droppingStrategy2 = droppingStrategy;
var slidingStrategy2 = slidingStrategy;
var make62 = make61;
var bounded5 = bounded2;
var dropping4 = dropping;
var sliding4 = sliding;
var unbounded5 = unbounded2;
var capacity5 = capacity2;
var size20 = size17;
var isEmpty18 = isEmpty15;
var isFull5 = isFull2;
var isShutdown4 = isShutdown;
var awaitShutdown4 = awaitShutdown;
var shutdown4 = shutdown;
var offer3 = offer2;
var unsafeOffer2 = unsafeOffer;
var offerAll3 = offerAll2;
var poll6 = poll5;
var take6 = take5;
var takeAll2 = takeAll;
var takeUpTo2 = takeUpTo;
var takeBetween2 = takeBetween;
var takeN2 = takeN;

// ../../node_modules/effect/dist/esm/internal/opCodes/channelChildExecutorDecision.js
var OP_CONTINUE2 = "Continue";
var OP_CLOSE = "Close";
var OP_YIELD2 = "Yield";

// ../../node_modules/effect/dist/esm/internal/channel/childExecutorDecision.js
var ChildExecutorDecisionSymbolKey = "effect/ChannelChildExecutorDecision";
var ChildExecutorDecisionTypeId = Symbol.for(ChildExecutorDecisionSymbolKey);
var proto4 = {
  [ChildExecutorDecisionTypeId]: ChildExecutorDecisionTypeId
};
var Continue = (_) => {
  const op = Object.create(proto4);
  op._tag = OP_CONTINUE2;
  return op;
};
var Close = (value10) => {
  const op = Object.create(proto4);
  op._tag = OP_CLOSE;
  op.value = value10;
  return op;
};
var Yield2 = (_) => {
  const op = Object.create(proto4);
  op._tag = OP_YIELD2;
  return op;
};
var isChildExecutorDecision = (u) => hasProperty(u, ChildExecutorDecisionTypeId);
var isContinue3 = (self) => self._tag === OP_CONTINUE2;
var isClose = (self) => self._tag === OP_CLOSE;
var isYield = (self) => self._tag === OP_YIELD2;
var match22 = dual(2, (self, {
  onClose,
  onContinue,
  onYield
}) => {
  switch (self._tag) {
    case OP_CONTINUE2: {
      return onContinue();
    }
    case OP_CLOSE: {
      return onClose(self.value);
    }
    case OP_YIELD2: {
      return onYield();
    }
  }
});

// ../../node_modules/effect/dist/esm/internal/opCodes/continuation.js
var OP_CONTINUATION_K = "ContinuationK";
var OP_CONTINUATION_FINALIZER = "ContinuationFinalizer";

// ../../node_modules/effect/dist/esm/internal/channel/continuation.js
var ContinuationTypeId = Symbol.for("effect/ChannelContinuation");
var continuationVariance = {
  /* c8 ignore next */
  _Env: (_) => _,
  /* c8 ignore next */
  _InErr: (_) => _,
  /* c8 ignore next */
  _InElem: (_) => _,
  /* c8 ignore next */
  _InDone: (_) => _,
  /* c8 ignore next */
  _OutErr: (_) => _,
  /* c8 ignore next */
  _OutDone: (_) => _,
  /* c8 ignore next */
  _OutErr2: (_) => _,
  /* c8 ignore next */
  _OutElem: (_) => _,
  /* c8 ignore next */
  _OutDone2: (_) => _
};
var ContinuationKImpl = class {
  onSuccess;
  onHalt;
  _tag = OP_CONTINUATION_K;
  [ContinuationTypeId] = continuationVariance;
  constructor(onSuccess, onHalt) {
    this.onSuccess = onSuccess;
    this.onHalt = onHalt;
  }
  onExit(exit4) {
    return isFailure2(exit4) ? this.onHalt(exit4.cause) : this.onSuccess(exit4.value);
  }
};
var ContinuationFinalizerImpl = class {
  finalizer;
  _tag = OP_CONTINUATION_FINALIZER;
  [ContinuationTypeId] = continuationVariance;
  constructor(finalizer3) {
    this.finalizer = finalizer3;
  }
};

// ../../node_modules/effect/dist/esm/internal/opCodes/channelUpstreamPullStrategy.js
var OP_PULL_AFTER_NEXT = "PullAfterNext";
var OP_PULL_AFTER_ALL_ENQUEUED = "PullAfterAllEnqueued";

// ../../node_modules/effect/dist/esm/internal/channel/upstreamPullStrategy.js
var UpstreamPullStrategySymbolKey = "effect/ChannelUpstreamPullStrategy";
var UpstreamPullStrategyTypeId = Symbol.for(UpstreamPullStrategySymbolKey);
var upstreamPullStrategyVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var proto5 = {
  [UpstreamPullStrategyTypeId]: upstreamPullStrategyVariance
};
var PullAfterNext = (emitSeparator) => {
  const op = Object.create(proto5);
  op._tag = OP_PULL_AFTER_NEXT;
  op.emitSeparator = emitSeparator;
  return op;
};
var PullAfterAllEnqueued = (emitSeparator) => {
  const op = Object.create(proto5);
  op._tag = OP_PULL_AFTER_ALL_ENQUEUED;
  op.emitSeparator = emitSeparator;
  return op;
};
var isUpstreamPullStrategy = (u) => hasProperty(u, UpstreamPullStrategyTypeId);
var isPullAfterNext = (self) => self._tag === OP_PULL_AFTER_NEXT;
var isPullAfterAllEnqueued = (self) => self._tag === OP_PULL_AFTER_ALL_ENQUEUED;
var match23 = dual(2, (self, {
  onAllEnqueued,
  onNext
}) => {
  switch (self._tag) {
    case OP_PULL_AFTER_NEXT: {
      return onNext(self.emitSeparator);
    }
    case OP_PULL_AFTER_ALL_ENQUEUED: {
      return onAllEnqueued(self.emitSeparator);
    }
  }
});

// ../../node_modules/effect/dist/esm/internal/opCodes/channel.js
var OP_BRACKET_OUT = "BracketOut";
var OP_BRIDGE = "Bridge";
var OP_CONCAT_ALL = "ConcatAll";
var OP_EMIT = "Emit";
var OP_ENSURING = "Ensuring";
var OP_FAIL3 = "Fail";
var OP_FOLD2 = "Fold";
var OP_FROM_EFFECT2 = "FromEffect";
var OP_PIPE_TO = "PipeTo";
var OP_PROVIDE2 = "Provide";
var OP_READ = "Read";
var OP_SUCCEED = "Succeed";
var OP_SUCCEED_NOW = "SucceedNow";
var OP_SUSPEND2 = "Suspend";

// ../../node_modules/effect/dist/esm/internal/core-stream.js
var ChannelSymbolKey = "effect/Channel";
var ChannelTypeId3 = Symbol.for(ChannelSymbolKey);
var channelVariance2 = {
  /* c8 ignore next */
  _Env: (_) => _,
  /* c8 ignore next */
  _InErr: (_) => _,
  /* c8 ignore next */
  _InElem: (_) => _,
  /* c8 ignore next */
  _InDone: (_) => _,
  /* c8 ignore next */
  _OutErr: (_) => _,
  /* c8 ignore next */
  _OutElem: (_) => _,
  /* c8 ignore next */
  _OutDone: (_) => _
};
var proto6 = {
  [ChannelTypeId3]: channelVariance2,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isChannel = (u) => hasProperty(u, ChannelTypeId3) || isEffect2(u);
var acquireReleaseOut = dual(2, (self, release4) => {
  const op = Object.create(proto6);
  op._tag = OP_BRACKET_OUT;
  op.acquire = () => self;
  op.finalizer = release4;
  return op;
});
var catchAllCause6 = dual(2, (self, f) => {
  const op = Object.create(proto6);
  op._tag = OP_FOLD2;
  op.channel = self;
  op.k = new ContinuationKImpl(succeed15, f);
  return op;
});
var collectElements = (self) => {
  return suspend6(() => {
    const builder = [];
    return flatMap20(pipeTo(self, collectElementsReader(builder)), (value10) => sync10(() => [fromIterable3(builder), value10]));
  });
};
var collectElementsReader = (builder) => readWith({
  onInput: (outElem) => flatMap20(sync10(() => {
    builder.push(outElem);
  }), () => collectElementsReader(builder)),
  onFailure: fail14,
  onDone: succeedNow
});
var concatAll = (channels) => concatAllWith(channels, constVoid, constVoid);
var concatAllWith = (channels, f, g) => {
  const op = Object.create(proto6);
  op._tag = OP_CONCAT_ALL;
  op.combineInners = f;
  op.combineAll = g;
  op.onPull = () => PullAfterNext(none2());
  op.onEmit = () => Continue;
  op.value = () => channels;
  op.k = identity;
  return op;
};
var concatMapWith = dual(4, (self, f, g, h2) => {
  const op = Object.create(proto6);
  op._tag = OP_CONCAT_ALL;
  op.combineInners = g;
  op.combineAll = h2;
  op.onPull = () => PullAfterNext(none2());
  op.onEmit = () => Continue;
  op.value = () => self;
  op.k = f;
  return op;
});
var concatMapWithCustom = dual(6, (self, f, g, h2, onPull, onEmit) => {
  const op = Object.create(proto6);
  op._tag = OP_CONCAT_ALL;
  op.combineInners = g;
  op.combineAll = h2;
  op.onPull = onPull;
  op.onEmit = onEmit;
  op.value = () => self;
  op.k = f;
  return op;
});
var embedInput = dual(2, (self, input) => {
  const op = Object.create(proto6);
  op._tag = OP_BRIDGE;
  op.input = input;
  op.channel = self;
  return op;
});
var ensuringWith = dual(2, (self, finalizer3) => {
  const op = Object.create(proto6);
  op._tag = OP_ENSURING;
  op.channel = self;
  op.finalizer = finalizer3;
  return op;
});
var fail14 = (error4) => failCause12(fail8(error4));
var failSync7 = (evaluate4) => failCauseSync7(() => fail8(evaluate4()));
var failCause12 = (cause3) => failCauseSync7(() => cause3);
var failCauseSync7 = (evaluate4) => {
  const op = Object.create(proto6);
  op._tag = OP_FAIL3;
  op.error = evaluate4;
  return op;
};
var flatMap20 = dual(2, (self, f) => {
  const op = Object.create(proto6);
  op._tag = OP_FOLD2;
  op.channel = self;
  op.k = new ContinuationKImpl(f, failCause12);
  return op;
});
var foldCauseChannel = dual(2, (self, options) => {
  const op = Object.create(proto6);
  op._tag = OP_FOLD2;
  op.channel = self;
  op.k = new ContinuationKImpl(options.onSuccess, options.onFailure);
  return op;
});
var fromEffect5 = (effect4) => {
  const op = Object.create(proto6);
  op._tag = OP_FROM_EFFECT2;
  op.effect = () => effect4;
  return op;
};
var pipeTo = dual(2, (self, that) => {
  const op = Object.create(proto6);
  op._tag = OP_PIPE_TO;
  op.left = () => self;
  op.right = () => that;
  return op;
});
var provideContext4 = dual(2, (self, env) => {
  const op = Object.create(proto6);
  op._tag = OP_PROVIDE2;
  op.context = () => env;
  op.inner = self;
  return op;
});
var readOrFail = (error4) => {
  const op = Object.create(proto6);
  op._tag = OP_READ;
  op.more = succeed15;
  op.done = new ContinuationKImpl(() => fail14(error4), () => fail14(error4));
  return op;
};
var readWith = (options) => readWithCause({
  onInput: options.onInput,
  onFailure: (cause3) => match(failureOrCause2(cause3), {
    onLeft: options.onFailure,
    onRight: failCause12
  }),
  onDone: options.onDone
});
var readWithCause = (options) => {
  const op = Object.create(proto6);
  op._tag = OP_READ;
  op.more = options.onInput;
  op.done = new ContinuationKImpl(options.onDone, options.onFailure);
  return op;
};
var succeed15 = (value10) => sync10(() => value10);
var succeedNow = (result) => {
  const op = Object.create(proto6);
  op._tag = OP_SUCCEED_NOW;
  op.terminal = result;
  return op;
};
var suspend6 = (evaluate4) => {
  const op = Object.create(proto6);
  op._tag = OP_SUSPEND2;
  op.channel = evaluate4;
  return op;
};
var sync10 = (evaluate4) => {
  const op = Object.create(proto6);
  op._tag = OP_SUCCEED;
  op.evaluate = evaluate4;
  return op;
};
var void_8 = succeedNow(void 0);
var write = (out) => {
  const op = Object.create(proto6);
  op._tag = OP_EMIT;
  op.out = out;
  return op;
};

// ../../node_modules/effect/dist/esm/internal/opCodes/channelState.js
var OP_DONE3 = "Done";
var OP_EMIT2 = "Emit";
var OP_FROM_EFFECT3 = "FromEffect";
var OP_READ2 = "Read";

// ../../node_modules/effect/dist/esm/internal/channel/channelState.js
var ChannelStateTypeId = Symbol.for("effect/ChannelState");
var channelStateVariance = {
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var proto7 = {
  [ChannelStateTypeId]: channelStateVariance
};
var Done2 = () => {
  const op = Object.create(proto7);
  op._tag = OP_DONE3;
  return op;
};
var Emit = () => {
  const op = Object.create(proto7);
  op._tag = OP_EMIT2;
  return op;
};
var fromEffect6 = (effect4) => {
  const op = Object.create(proto7);
  op._tag = OP_FROM_EFFECT3;
  op.effect = effect4;
  return op;
};
var Read = (upstream, onEffect, onEmit, onDone3) => {
  const op = Object.create(proto7);
  op._tag = OP_READ2;
  op.upstream = upstream;
  op.onEffect = onEffect;
  op.onEmit = onEmit;
  op.onDone = onDone3;
  return op;
};
var isFromEffect = (self) => self._tag === OP_FROM_EFFECT3;
var effect2 = (self) => isFromEffect(self) ? self.effect : _void;
var effectOrUndefinedIgnored = (self) => isFromEffect(self) ? ignore3(self.effect) : void 0;

// ../../node_modules/effect/dist/esm/internal/channel/subexecutor.js
var OP_PULL_FROM_CHILD = "PullFromChild";
var OP_PULL_FROM_UPSTREAM = "PullFromUpstream";
var OP_DRAIN_CHILD_EXECUTORS = "DrainChildExecutors";
var OP_EMIT3 = "Emit";
var PullFromChild = class {
  childExecutor;
  parentSubexecutor;
  onEmit;
  _tag = OP_PULL_FROM_CHILD;
  constructor(childExecutor, parentSubexecutor, onEmit) {
    this.childExecutor = childExecutor;
    this.parentSubexecutor = parentSubexecutor;
    this.onEmit = onEmit;
  }
  close(exit4) {
    const fin1 = this.childExecutor.close(exit4);
    const fin2 = this.parentSubexecutor.close(exit4);
    if (fin1 !== void 0 && fin2 !== void 0) {
      return zipWith12(exit3(fin1), exit3(fin2), (exit1, exit22) => pipe(exit1, zipRight3(exit22)));
    } else if (fin1 !== void 0) {
      return fin1;
    } else if (fin2 !== void 0) {
      return fin2;
    } else {
      return void 0;
    }
  }
  enqueuePullFromChild(_child) {
    return this;
  }
};
var PullFromUpstream = class _PullFromUpstream {
  upstreamExecutor;
  createChild;
  lastDone;
  activeChildExecutors;
  combineChildResults;
  combineWithChildResult;
  onPull;
  onEmit;
  _tag = OP_PULL_FROM_UPSTREAM;
  constructor(upstreamExecutor, createChild, lastDone, activeChildExecutors, combineChildResults, combineWithChildResult, onPull, onEmit) {
    this.upstreamExecutor = upstreamExecutor;
    this.createChild = createChild;
    this.lastDone = lastDone;
    this.activeChildExecutors = activeChildExecutors;
    this.combineChildResults = combineChildResults;
    this.combineWithChildResult = combineWithChildResult;
    this.onPull = onPull;
    this.onEmit = onEmit;
  }
  close(exit4) {
    const fin1 = this.upstreamExecutor.close(exit4);
    const fins = [...this.activeChildExecutors.map((child) => child !== void 0 ? child.childExecutor.close(exit4) : void 0), fin1];
    const result = fins.reduce((acc, next6) => {
      if (acc !== void 0 && next6 !== void 0) {
        return zipWith12(acc, exit3(next6), (exit1, exit22) => zipRight3(exit1, exit22));
      } else if (acc !== void 0) {
        return acc;
      } else if (next6 !== void 0) {
        return exit3(next6);
      } else {
        return void 0;
      }
    }, void 0);
    return result === void 0 ? result : result;
  }
  enqueuePullFromChild(child) {
    return new _PullFromUpstream(this.upstreamExecutor, this.createChild, this.lastDone, [...this.activeChildExecutors, child], this.combineChildResults, this.combineWithChildResult, this.onPull, this.onEmit);
  }
};
var DrainChildExecutors = class _DrainChildExecutors {
  upstreamExecutor;
  lastDone;
  activeChildExecutors;
  upstreamDone;
  combineChildResults;
  combineWithChildResult;
  onPull;
  _tag = OP_DRAIN_CHILD_EXECUTORS;
  constructor(upstreamExecutor, lastDone, activeChildExecutors, upstreamDone, combineChildResults, combineWithChildResult, onPull) {
    this.upstreamExecutor = upstreamExecutor;
    this.lastDone = lastDone;
    this.activeChildExecutors = activeChildExecutors;
    this.upstreamDone = upstreamDone;
    this.combineChildResults = combineChildResults;
    this.combineWithChildResult = combineWithChildResult;
    this.onPull = onPull;
  }
  close(exit4) {
    const fin1 = this.upstreamExecutor.close(exit4);
    const fins = [...this.activeChildExecutors.map((child) => child !== void 0 ? child.childExecutor.close(exit4) : void 0), fin1];
    const result = fins.reduce((acc, next6) => {
      if (acc !== void 0 && next6 !== void 0) {
        return zipWith12(acc, exit3(next6), (exit1, exit22) => zipRight3(exit1, exit22));
      } else if (acc !== void 0) {
        return acc;
      } else if (next6 !== void 0) {
        return exit3(next6);
      } else {
        return void 0;
      }
    }, void 0);
    return result === void 0 ? result : result;
  }
  enqueuePullFromChild(child) {
    return new _DrainChildExecutors(this.upstreamExecutor, this.lastDone, [...this.activeChildExecutors, child], this.upstreamDone, this.combineChildResults, this.combineWithChildResult, this.onPull);
  }
};
var Emit2 = class {
  value;
  next;
  _tag = OP_EMIT3;
  constructor(value10, next6) {
    this.value = value10;
    this.next = next6;
  }
  close(exit4) {
    const result = this.next.close(exit4);
    return result === void 0 ? result : result;
  }
  enqueuePullFromChild(_child) {
    return this;
  }
};

// ../../node_modules/effect/dist/esm/internal/opCodes/channelUpstreamPullRequest.js
var OP_PULLED = "Pulled";
var OP_NO_UPSTREAM = "NoUpstream";

// ../../node_modules/effect/dist/esm/internal/channel/upstreamPullRequest.js
var UpstreamPullRequestSymbolKey = "effect/ChannelUpstreamPullRequest";
var UpstreamPullRequestTypeId = Symbol.for(UpstreamPullRequestSymbolKey);
var upstreamPullRequestVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var proto8 = {
  [UpstreamPullRequestTypeId]: upstreamPullRequestVariance
};
var Pulled = (value10) => {
  const op = Object.create(proto8);
  op._tag = OP_PULLED;
  op.value = value10;
  return op;
};
var NoUpstream = (activeDownstreamCount) => {
  const op = Object.create(proto8);
  op._tag = OP_NO_UPSTREAM;
  op.activeDownstreamCount = activeDownstreamCount;
  return op;
};
var isUpstreamPullRequest = (u) => hasProperty(u, UpstreamPullRequestTypeId);
var isPulled = (self) => self._tag === OP_PULLED;
var isNoUpstream = (self) => self._tag === OP_NO_UPSTREAM;
var match24 = dual(2, (self, {
  onNoUpstream,
  onPulled
}) => {
  switch (self._tag) {
    case OP_PULLED: {
      return onPulled(self.value);
    }
    case OP_NO_UPSTREAM: {
      return onNoUpstream(self.activeDownstreamCount);
    }
  }
});

// ../../node_modules/effect/dist/esm/internal/channel/channelExecutor.js
var ChannelExecutor = class _ChannelExecutor {
  _activeSubexecutor = void 0;
  _cancelled = void 0;
  _closeLastSubstream = void 0;
  _currentChannel;
  _done = void 0;
  _doneStack = [];
  _emitted = void 0;
  _executeCloseLastSubstream;
  _input = void 0;
  _inProgressFinalizer = void 0;
  _providedEnv;
  constructor(initialChannel, providedEnv, executeCloseLastSubstream) {
    this._currentChannel = initialChannel;
    this._executeCloseLastSubstream = executeCloseLastSubstream;
    this._providedEnv = providedEnv;
  }
  run() {
    let result = void 0;
    while (result === void 0) {
      if (this._cancelled !== void 0) {
        result = this.processCancellation();
      } else if (this._activeSubexecutor !== void 0) {
        result = this.runSubexecutor();
      } else {
        try {
          if (this._currentChannel === void 0) {
            result = Done2();
          } else {
            if (isEffect2(this._currentChannel)) {
              this._currentChannel = fromEffect5(this._currentChannel);
            }
            switch (this._currentChannel._tag) {
              case OP_BRACKET_OUT: {
                result = this.runBracketOut(this._currentChannel);
                break;
              }
              case OP_BRIDGE: {
                const bridgeInput = this._currentChannel.input;
                this._currentChannel = this._currentChannel.channel;
                if (this._input !== void 0) {
                  const inputExecutor = this._input;
                  this._input = void 0;
                  const drainer = () => flatMap18(bridgeInput.awaitRead(), () => suspend4(() => {
                    const state = inputExecutor.run();
                    switch (state._tag) {
                      case OP_DONE3: {
                        return match7(inputExecutor.getDone(), {
                          onFailure: (cause3) => bridgeInput.error(cause3),
                          onSuccess: (value10) => bridgeInput.done(value10)
                        });
                      }
                      case OP_EMIT2: {
                        return flatMap18(bridgeInput.emit(inputExecutor.getEmit()), () => drainer());
                      }
                      case OP_FROM_EFFECT3: {
                        return matchCauseEffect3(state.effect, {
                          onFailure: (cause3) => bridgeInput.error(cause3),
                          onSuccess: () => drainer()
                        });
                      }
                      case OP_READ2: {
                        return readUpstream(state, () => drainer(), (cause3) => bridgeInput.error(cause3));
                      }
                    }
                  }));
                  result = fromEffect6(flatMap18(forkDaemon3(interruptible4(drainer())), (fiber) => sync8(() => this.addFinalizer((exit4) => flatMap18(interrupt7(fiber), () => suspend4(() => {
                    const effect4 = this.restorePipe(exit4, inputExecutor);
                    return effect4 !== void 0 ? effect4 : _void;
                  }))))));
                }
                break;
              }
              case OP_CONCAT_ALL: {
                const executor = new _ChannelExecutor(this._currentChannel.value(), this._providedEnv, (effect4) => sync8(() => {
                  const prevLastClose = this._closeLastSubstream === void 0 ? _void : this._closeLastSubstream;
                  this._closeLastSubstream = pipe(prevLastClose, zipRight7(effect4));
                }));
                executor._input = this._input;
                const channel = this._currentChannel;
                this._activeSubexecutor = new PullFromUpstream(executor, (value10) => channel.k(value10), void 0, [], (x, y) => channel.combineInners(x, y), (x, y) => channel.combineAll(x, y), (request2) => channel.onPull(request2), (value10) => channel.onEmit(value10));
                this._closeLastSubstream = void 0;
                this._currentChannel = void 0;
                break;
              }
              case OP_EMIT: {
                this._emitted = this._currentChannel.out;
                this._currentChannel = this._activeSubexecutor !== void 0 ? void 0 : void_8;
                result = Emit();
                break;
              }
              case OP_ENSURING: {
                this.runEnsuring(this._currentChannel);
                break;
              }
              case OP_FAIL3: {
                result = this.doneHalt(this._currentChannel.error());
                break;
              }
              case OP_FOLD2: {
                this._doneStack.push(this._currentChannel.k);
                this._currentChannel = this._currentChannel.channel;
                break;
              }
              case OP_FROM_EFFECT2: {
                const effect4 = this._providedEnv === void 0 ? this._currentChannel.effect() : pipe(this._currentChannel.effect(), provide2(this._providedEnv));
                result = fromEffect6(matchCauseEffect3(effect4, {
                  onFailure: (cause3) => {
                    const state = this.doneHalt(cause3);
                    return state !== void 0 && isFromEffect(state) ? state.effect : _void;
                  },
                  onSuccess: (value10) => {
                    const state = this.doneSucceed(value10);
                    return state !== void 0 && isFromEffect(state) ? state.effect : _void;
                  }
                }));
                break;
              }
              case OP_PIPE_TO: {
                const previousInput = this._input;
                const leftExec = new _ChannelExecutor(this._currentChannel.left(), this._providedEnv, (effect4) => this._executeCloseLastSubstream(effect4));
                leftExec._input = previousInput;
                this._input = leftExec;
                this.addFinalizer((exit4) => {
                  const effect4 = this.restorePipe(exit4, previousInput);
                  return effect4 !== void 0 ? effect4 : _void;
                });
                this._currentChannel = this._currentChannel.right();
                break;
              }
              case OP_PROVIDE2: {
                const previousEnv = this._providedEnv;
                this._providedEnv = this._currentChannel.context();
                this._currentChannel = this._currentChannel.inner;
                this.addFinalizer(() => sync8(() => {
                  this._providedEnv = previousEnv;
                }));
                break;
              }
              case OP_READ: {
                const read3 = this._currentChannel;
                result = Read(this._input, identity, (emitted) => {
                  try {
                    this._currentChannel = read3.more(emitted);
                  } catch (error4) {
                    this._currentChannel = read3.done.onExit(die4(error4));
                  }
                  return void 0;
                }, (exit4) => {
                  const onExit4 = (exit5) => {
                    return read3.done.onExit(exit5);
                  };
                  this._currentChannel = onExit4(exit4);
                  return void 0;
                });
                break;
              }
              case OP_SUCCEED: {
                result = this.doneSucceed(this._currentChannel.evaluate());
                break;
              }
              case OP_SUCCEED_NOW: {
                result = this.doneSucceed(this._currentChannel.terminal);
                break;
              }
              case OP_SUSPEND2: {
                this._currentChannel = this._currentChannel.channel();
                break;
              }
            }
          }
        } catch (error4) {
          this._currentChannel = failCause12(die6(error4));
        }
      }
    }
    return result;
  }
  getDone() {
    return this._done;
  }
  getEmit() {
    return this._emitted;
  }
  cancelWith(exit4) {
    this._cancelled = exit4;
  }
  clearInProgressFinalizer() {
    this._inProgressFinalizer = void 0;
  }
  storeInProgressFinalizer(finalizer3) {
    this._inProgressFinalizer = finalizer3;
  }
  popAllFinalizers(exit4) {
    const finalizers = [];
    let next6 = this._doneStack.pop();
    while (next6) {
      if (next6._tag === "ContinuationFinalizer") {
        finalizers.push(next6.finalizer);
      }
      next6 = this._doneStack.pop();
    }
    const effect4 = finalizers.length === 0 ? _void : runFinalizers(finalizers, exit4);
    this.storeInProgressFinalizer(effect4);
    return effect4;
  }
  popNextFinalizers() {
    const builder = [];
    while (this._doneStack.length !== 0) {
      const cont = this._doneStack[this._doneStack.length - 1];
      if (cont._tag === OP_CONTINUATION_K) {
        return builder;
      }
      builder.push(cont);
      this._doneStack.pop();
    }
    return builder;
  }
  restorePipe(exit4, prev) {
    const currInput = this._input;
    this._input = prev;
    if (currInput !== void 0) {
      const effect4 = currInput.close(exit4);
      return effect4;
    }
    return _void;
  }
  close(exit4) {
    let runInProgressFinalizers = void 0;
    const finalizer3 = this._inProgressFinalizer;
    if (finalizer3 !== void 0) {
      runInProgressFinalizers = pipe(finalizer3, ensuring4(sync8(() => this.clearInProgressFinalizer())));
    }
    let closeSelf = void 0;
    const selfFinalizers = this.popAllFinalizers(exit4);
    if (selfFinalizers !== void 0) {
      closeSelf = pipe(selfFinalizers, ensuring4(sync8(() => this.clearInProgressFinalizer())));
    }
    const closeSubexecutors = this._activeSubexecutor === void 0 ? void 0 : this._activeSubexecutor.close(exit4);
    if (closeSubexecutors === void 0 && runInProgressFinalizers === void 0 && closeSelf === void 0) {
      return void 0;
    }
    return pipe(
      exit3(ifNotNull(closeSubexecutors)),
      zip12(exit3(ifNotNull(runInProgressFinalizers))),
      zip12(exit3(ifNotNull(closeSelf))),
      map26(([[exit1, exit22], exit32]) => pipe(exit1, zipRight3(exit22), zipRight3(exit32))),
      uninterruptible3,
      // TODO: remove
      flatMap18((exit5) => suspend4(() => exit5))
    );
  }
  doneSucceed(value10) {
    if (this._doneStack.length === 0) {
      this._done = succeed3(value10);
      this._currentChannel = void 0;
      return Done2();
    }
    const head13 = this._doneStack[this._doneStack.length - 1];
    if (head13._tag === OP_CONTINUATION_K) {
      this._doneStack.pop();
      this._currentChannel = head13.onSuccess(value10);
      return void 0;
    }
    const finalizers = this.popNextFinalizers();
    if (this._doneStack.length === 0) {
      this._doneStack = finalizers.reverse();
      this._done = succeed3(value10);
      this._currentChannel = void 0;
      return Done2();
    }
    const finalizerEffect = runFinalizers(finalizers.map((f) => f.finalizer), succeed3(value10));
    this.storeInProgressFinalizer(finalizerEffect);
    const effect4 = pipe(finalizerEffect, ensuring4(sync8(() => this.clearInProgressFinalizer())), uninterruptible3, flatMap18(() => sync8(() => this.doneSucceed(value10))));
    return fromEffect6(effect4);
  }
  doneHalt(cause3) {
    if (this._doneStack.length === 0) {
      this._done = failCause3(cause3);
      this._currentChannel = void 0;
      return Done2();
    }
    const head13 = this._doneStack[this._doneStack.length - 1];
    if (head13._tag === OP_CONTINUATION_K) {
      this._doneStack.pop();
      try {
        this._currentChannel = head13.onHalt(cause3);
      } catch (error4) {
        this._currentChannel = failCause12(die6(error4));
      }
      return void 0;
    }
    const finalizers = this.popNextFinalizers();
    if (this._doneStack.length === 0) {
      this._doneStack = finalizers.reverse();
      this._done = failCause3(cause3);
      this._currentChannel = void 0;
      return Done2();
    }
    const finalizerEffect = runFinalizers(finalizers.map((f) => f.finalizer), failCause3(cause3));
    this.storeInProgressFinalizer(finalizerEffect);
    const effect4 = pipe(finalizerEffect, ensuring4(sync8(() => this.clearInProgressFinalizer())), uninterruptible3, flatMap18(() => sync8(() => this.doneHalt(cause3))));
    return fromEffect6(effect4);
  }
  processCancellation() {
    this._currentChannel = void 0;
    this._done = this._cancelled;
    this._cancelled = void 0;
    return Done2();
  }
  runBracketOut(bracketOut) {
    const effect4 = uninterruptible3(matchCauseEffect3(this.provide(bracketOut.acquire()), {
      onFailure: (cause3) => sync8(() => {
        this._currentChannel = failCause12(cause3);
      }),
      onSuccess: (out) => sync8(() => {
        this.addFinalizer((exit4) => this.provide(bracketOut.finalizer(out, exit4)));
        this._currentChannel = write(out);
      })
    }));
    return fromEffect6(effect4);
  }
  provide(effect4) {
    if (this._providedEnv === void 0) {
      return effect4;
    }
    return pipe(effect4, provide2(this._providedEnv));
  }
  runEnsuring(ensuring14) {
    this.addFinalizer(ensuring14.finalizer);
    this._currentChannel = ensuring14.channel;
  }
  addFinalizer(f) {
    this._doneStack.push(new ContinuationFinalizerImpl(f));
  }
  runSubexecutor() {
    const subexecutor = this._activeSubexecutor;
    switch (subexecutor._tag) {
      case OP_PULL_FROM_CHILD: {
        return this.pullFromChild(subexecutor.childExecutor, subexecutor.parentSubexecutor, subexecutor.onEmit, subexecutor);
      }
      case OP_PULL_FROM_UPSTREAM: {
        return this.pullFromUpstream(subexecutor);
      }
      case OP_DRAIN_CHILD_EXECUTORS: {
        return this.drainChildExecutors(subexecutor);
      }
      case OP_EMIT3: {
        this._emitted = subexecutor.value;
        this._activeSubexecutor = subexecutor.next;
        return Emit();
      }
    }
  }
  replaceSubexecutor(nextSubExec) {
    this._currentChannel = void 0;
    this._activeSubexecutor = nextSubExec;
  }
  finishWithExit(exit4) {
    const state = match7(exit4, {
      onFailure: (cause3) => this.doneHalt(cause3),
      onSuccess: (value10) => this.doneSucceed(value10)
    });
    this._activeSubexecutor = void 0;
    return state === void 0 ? _void : effect2(state);
  }
  finishSubexecutorWithCloseEffect(subexecutorDone, ...closeFuncs) {
    this.addFinalizer(() => pipe(closeFuncs, forEach16((closeFunc) => pipe(sync8(() => closeFunc(subexecutorDone)), flatMap18((closeEffect) => closeEffect !== void 0 ? closeEffect : _void)), {
      discard: true
    })));
    const state = pipe(subexecutorDone, match7({
      onFailure: (cause3) => this.doneHalt(cause3),
      onSuccess: (value10) => this.doneSucceed(value10)
    }));
    this._activeSubexecutor = void 0;
    return state;
  }
  applyUpstreamPullStrategy(upstreamFinished, queue, strategy) {
    switch (strategy._tag) {
      case OP_PULL_AFTER_NEXT: {
        const shouldPrepend = !upstreamFinished || queue.some((subexecutor) => subexecutor !== void 0);
        return [strategy.emitSeparator, shouldPrepend ? [void 0, ...queue] : queue];
      }
      case OP_PULL_AFTER_ALL_ENQUEUED: {
        const shouldEnqueue = !upstreamFinished || queue.some((subexecutor) => subexecutor !== void 0);
        return [strategy.emitSeparator, shouldEnqueue ? [...queue, void 0] : queue];
      }
    }
  }
  pullFromChild(childExecutor, parentSubexecutor, onEmitted, subexecutor) {
    return Read(childExecutor, identity, (emitted) => {
      const childExecutorDecision = onEmitted(emitted);
      switch (childExecutorDecision._tag) {
        case OP_CONTINUE2: {
          break;
        }
        case OP_CLOSE: {
          this.finishWithDoneValue(childExecutor, parentSubexecutor, childExecutorDecision.value);
          break;
        }
        case OP_YIELD2: {
          const modifiedParent = parentSubexecutor.enqueuePullFromChild(subexecutor);
          this.replaceSubexecutor(modifiedParent);
          break;
        }
      }
      this._activeSubexecutor = new Emit2(emitted, this._activeSubexecutor);
      return void 0;
    }, match7({
      onFailure: (cause3) => {
        const state = this.handleSubexecutorFailure(childExecutor, parentSubexecutor, cause3);
        return state === void 0 ? void 0 : effectOrUndefinedIgnored(state);
      },
      onSuccess: (doneValue) => {
        this.finishWithDoneValue(childExecutor, parentSubexecutor, doneValue);
        return void 0;
      }
    }));
  }
  finishWithDoneValue(childExecutor, parentSubexecutor, doneValue) {
    const subexecutor = parentSubexecutor;
    switch (subexecutor._tag) {
      case OP_PULL_FROM_UPSTREAM: {
        const modifiedParent = new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone !== void 0 ? subexecutor.combineChildResults(subexecutor.lastDone, doneValue) : doneValue, subexecutor.activeChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit);
        this._closeLastSubstream = childExecutor.close(succeed3(doneValue));
        this.replaceSubexecutor(modifiedParent);
        break;
      }
      case OP_DRAIN_CHILD_EXECUTORS: {
        const modifiedParent = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone !== void 0 ? subexecutor.combineChildResults(subexecutor.lastDone, doneValue) : doneValue, subexecutor.activeChildExecutors, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
        this._closeLastSubstream = childExecutor.close(succeed3(doneValue));
        this.replaceSubexecutor(modifiedParent);
        break;
      }
      default: {
        break;
      }
    }
  }
  handleSubexecutorFailure(childExecutor, parentSubexecutor, cause3) {
    return this.finishSubexecutorWithCloseEffect(failCause3(cause3), (exit4) => parentSubexecutor.close(exit4), (exit4) => childExecutor.close(exit4));
  }
  pullFromUpstream(subexecutor) {
    if (subexecutor.activeChildExecutors.length === 0) {
      return this.performPullFromUpstream(subexecutor);
    }
    const activeChild = subexecutor.activeChildExecutors[0];
    const parentSubexecutor = new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, subexecutor.activeChildExecutors.slice(1), subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit);
    if (activeChild === void 0) {
      return this.performPullFromUpstream(parentSubexecutor);
    }
    this.replaceSubexecutor(new PullFromChild(activeChild.childExecutor, parentSubexecutor, activeChild.onEmit));
    return void 0;
  }
  performPullFromUpstream(subexecutor) {
    return Read(subexecutor.upstreamExecutor, (effect4) => {
      const closeLastSubstream = this._closeLastSubstream === void 0 ? _void : this._closeLastSubstream;
      this._closeLastSubstream = void 0;
      return pipe(this._executeCloseLastSubstream(closeLastSubstream), zipRight7(effect4));
    }, (emitted) => {
      if (this._closeLastSubstream !== void 0) {
        const closeLastSubstream = this._closeLastSubstream;
        this._closeLastSubstream = void 0;
        return pipe(this._executeCloseLastSubstream(closeLastSubstream), map26(() => {
          const childExecutor2 = new _ChannelExecutor(subexecutor.createChild(emitted), this._providedEnv, this._executeCloseLastSubstream);
          childExecutor2._input = this._input;
          const [emitSeparator2, updatedChildExecutors2] = this.applyUpstreamPullStrategy(false, subexecutor.activeChildExecutors, subexecutor.onPull(Pulled(emitted)));
          this._activeSubexecutor = new PullFromChild(childExecutor2, new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, updatedChildExecutors2, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit), subexecutor.onEmit);
          if (isSome2(emitSeparator2)) {
            this._activeSubexecutor = new Emit2(emitSeparator2.value, this._activeSubexecutor);
          }
          return void 0;
        }));
      }
      const childExecutor = new _ChannelExecutor(subexecutor.createChild(emitted), this._providedEnv, this._executeCloseLastSubstream);
      childExecutor._input = this._input;
      const [emitSeparator, updatedChildExecutors] = this.applyUpstreamPullStrategy(false, subexecutor.activeChildExecutors, subexecutor.onPull(Pulled(emitted)));
      this._activeSubexecutor = new PullFromChild(childExecutor, new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, updatedChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit), subexecutor.onEmit);
      if (isSome2(emitSeparator)) {
        this._activeSubexecutor = new Emit2(emitSeparator.value, this._activeSubexecutor);
      }
      return void 0;
    }, (exit4) => {
      if (subexecutor.activeChildExecutors.some((subexecutor2) => subexecutor2 !== void 0)) {
        const drain7 = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, [void 0, ...subexecutor.activeChildExecutors], subexecutor.upstreamExecutor.getDone(), subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
        if (this._closeLastSubstream !== void 0) {
          const closeLastSubstream2 = this._closeLastSubstream;
          this._closeLastSubstream = void 0;
          return pipe(this._executeCloseLastSubstream(closeLastSubstream2), map26(() => this.replaceSubexecutor(drain7)));
        }
        this.replaceSubexecutor(drain7);
        return void 0;
      }
      const closeLastSubstream = this._closeLastSubstream;
      const state = this.finishSubexecutorWithCloseEffect(pipe(exit4, map15((a) => subexecutor.combineWithChildResult(subexecutor.lastDone, a))), () => closeLastSubstream, (exit5) => subexecutor.upstreamExecutor.close(exit5));
      return state === void 0 ? void 0 : (
        // NOTE: assuming finalizers cannot fail
        effectOrUndefinedIgnored(state)
      );
    });
  }
  drainChildExecutors(subexecutor) {
    if (subexecutor.activeChildExecutors.length === 0) {
      const lastClose = this._closeLastSubstream;
      if (lastClose !== void 0) {
        this.addFinalizer(() => succeed13(lastClose));
      }
      return this.finishSubexecutorWithCloseEffect(subexecutor.upstreamDone, () => lastClose, (exit4) => subexecutor.upstreamExecutor.close(exit4));
    }
    const activeChild = subexecutor.activeChildExecutors[0];
    const rest = subexecutor.activeChildExecutors.slice(1);
    if (activeChild === void 0) {
      const [emitSeparator, remainingExecutors] = this.applyUpstreamPullStrategy(true, rest, subexecutor.onPull(NoUpstream(rest.reduce((n, curr) => curr !== void 0 ? n + 1 : n, 0))));
      this.replaceSubexecutor(new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, remainingExecutors, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull));
      if (isSome2(emitSeparator)) {
        this._emitted = emitSeparator.value;
        return Emit();
      }
      return void 0;
    }
    const parentSubexecutor = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, rest, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
    this.replaceSubexecutor(new PullFromChild(activeChild.childExecutor, parentSubexecutor, activeChild.onEmit));
    return void 0;
  }
};
var ifNotNull = (effect4) => effect4 !== void 0 ? effect4 : _void;
var runFinalizers = (finalizers, exit4) => {
  return pipe(forEach16(finalizers, (fin) => exit3(fin(exit4))), map26((exits) => pipe(all7(exits), getOrElse2(() => void_4))), flatMap18((exit5) => suspend4(() => exit5)));
};
var readUpstream = (r, onSuccess, onFailure) => {
  const readStack = [r];
  const read3 = () => {
    const current2 = readStack.pop();
    if (current2 === void 0 || current2.upstream === void 0) {
      return dieMessage2("Unexpected end of input for channel execution");
    }
    const state = current2.upstream.run();
    switch (state._tag) {
      case OP_EMIT2: {
        const emitEffect = current2.onEmit(current2.upstream.getEmit());
        if (readStack.length === 0) {
          if (emitEffect === void 0) {
            return suspend4(onSuccess);
          }
          return pipe(emitEffect, matchCauseEffect3({
            onFailure,
            onSuccess
          }));
        }
        if (emitEffect === void 0) {
          return suspend4(() => read3());
        }
        return pipe(emitEffect, matchCauseEffect3({
          onFailure,
          onSuccess: () => read3()
        }));
      }
      case OP_DONE3: {
        const doneEffect = current2.onDone(current2.upstream.getDone());
        if (readStack.length === 0) {
          if (doneEffect === void 0) {
            return suspend4(onSuccess);
          }
          return pipe(doneEffect, matchCauseEffect3({
            onFailure,
            onSuccess
          }));
        }
        if (doneEffect === void 0) {
          return suspend4(() => read3());
        }
        return pipe(doneEffect, matchCauseEffect3({
          onFailure,
          onSuccess: () => read3()
        }));
      }
      case OP_FROM_EFFECT3: {
        readStack.push(current2);
        return pipe(current2.onEffect(state.effect), catchAllCause4((cause3) => suspend4(() => {
          const doneEffect = current2.onDone(failCause3(cause3));
          return doneEffect === void 0 ? _void : doneEffect;
        })), matchCauseEffect3({
          onFailure,
          onSuccess: () => read3()
        }));
      }
      case OP_READ2: {
        readStack.push(current2);
        readStack.push(state);
        return suspend4(() => read3());
      }
    }
  };
  return read3();
};
var runIn = dual(2, (self, scope6) => {
  const run10 = (channelDeferred, scopeDeferred, scope7) => acquireUseRelease3(sync8(() => new ChannelExecutor(self, void 0, identity)), (exec) => suspend4(() => runScopedInterpret(exec.run(), exec).pipe(intoDeferred2(channelDeferred), zipRight7(_await(channelDeferred)), zipLeft7(_await(scopeDeferred)))), (exec, exit4) => {
    const finalize = exec.close(exit4);
    if (finalize === void 0) {
      return _void;
    }
    return tapErrorCause4(finalize, (cause3) => addFinalizer3(scope7, failCause10(cause3)));
  });
  return uninterruptibleMask3((restore) => all11([fork3(scope6, sequential3), make24(), make24()]).pipe(flatMap18(([child, channelDeferred, scopeDeferred]) => restore(run10(channelDeferred, scopeDeferred, child)).pipe(forkIn3(scope6), flatMap18((fiber) => scope6.addFinalizer((exit4) => {
    const interruptors3 = isFailure2(exit4) ? interruptors2(exit4.cause) : void 0;
    return isDone(channelDeferred).pipe(flatMap18((isDone9) => isDone9 ? succeed2(scopeDeferred, void 0).pipe(zipRight7(_await3(fiber)), zipRight7(inheritAll2(fiber))) : succeed2(scopeDeferred, void 0).pipe(zipRight7(interruptors3 && size6(interruptors3) > 0 ? interruptAs(fiber, combineAll4(interruptors3)) : interrupt7(fiber)), zipRight7(inheritAll2(fiber)))));
  }).pipe(zipRight7(restore(_await(channelDeferred)))))))));
});
var runScopedInterpret = (channelState, exec) => {
  const op = channelState;
  switch (op._tag) {
    case OP_FROM_EFFECT3: {
      return pipe(op.effect, flatMap18(() => runScopedInterpret(exec.run(), exec)));
    }
    case OP_EMIT2: {
      return runScopedInterpret(exec.run(), exec);
    }
    case OP_DONE3: {
      return suspend4(() => exec.getDone());
    }
    case OP_READ2: {
      return readUpstream(op, () => runScopedInterpret(exec.run(), exec), failCause10);
    }
  }
};

// ../../node_modules/effect/dist/esm/internal/opCodes/channelMergeDecision.js
var OP_DONE4 = "Done";
var OP_AWAIT = "Await";

// ../../node_modules/effect/dist/esm/internal/channel/mergeDecision.js
var MergeDecisionSymbolKey = "effect/ChannelMergeDecision";
var MergeDecisionTypeId = Symbol.for(MergeDecisionSymbolKey);
var proto9 = {
  [MergeDecisionTypeId]: {
    _R: (_) => _,
    _E0: (_) => _,
    _Z0: (_) => _,
    _E: (_) => _,
    _Z: (_) => _
  }
};
var Done3 = (effect4) => {
  const op = Object.create(proto9);
  op._tag = OP_DONE4;
  op.effect = effect4;
  return op;
};
var Await = (f) => {
  const op = Object.create(proto9);
  op._tag = OP_AWAIT;
  op.f = f;
  return op;
};
var AwaitConst = (effect4) => Await(() => effect4);
var isMergeDecision = (u) => hasProperty(u, MergeDecisionTypeId);
var match25 = dual(2, (self, {
  onAwait,
  onDone: onDone3
}) => {
  const op = self;
  switch (op._tag) {
    case OP_DONE4:
      return onDone3(op.effect);
    case OP_AWAIT:
      return onAwait(op.f);
  }
});

// ../../node_modules/effect/dist/esm/internal/opCodes/channelMergeState.js
var OP_BOTH_RUNNING = "BothRunning";
var OP_LEFT_DONE = "LeftDone";
var OP_RIGHT_DONE = "RightDone";

// ../../node_modules/effect/dist/esm/internal/channel/mergeState.js
var MergeStateSymbolKey = "effect/ChannelMergeState";
var MergeStateTypeId = Symbol.for(MergeStateSymbolKey);
var proto10 = {
  [MergeStateTypeId]: MergeStateTypeId
};
var BothRunning = (left3, right3) => {
  const op = Object.create(proto10);
  op._tag = OP_BOTH_RUNNING;
  op.left = left3;
  op.right = right3;
  return op;
};
var LeftDone = (f) => {
  const op = Object.create(proto10);
  op._tag = OP_LEFT_DONE;
  op.f = f;
  return op;
};
var RightDone = (f) => {
  const op = Object.create(proto10);
  op._tag = OP_RIGHT_DONE;
  op.f = f;
  return op;
};
var isMergeState = (u) => hasProperty(u, MergeStateTypeId);
var isBothRunning = (self) => {
  return self._tag === OP_BOTH_RUNNING;
};
var isLeftDone = (self) => {
  return self._tag === OP_LEFT_DONE;
};
var isRightDone = (self) => {
  return self._tag === OP_RIGHT_DONE;
};
var match26 = dual(2, (self, {
  onBothRunning,
  onLeftDone,
  onRightDone
}) => {
  switch (self._tag) {
    case OP_BOTH_RUNNING: {
      return onBothRunning(self.left, self.right);
    }
    case OP_LEFT_DONE: {
      return onLeftDone(self.f);
    }
    case OP_RIGHT_DONE: {
      return onRightDone(self.f);
    }
  }
});

// ../../node_modules/effect/dist/esm/internal/opCodes/channelMergeStrategy.js
var OP_BACK_PRESSURE = "BackPressure";
var OP_BUFFER_SLIDING = "BufferSliding";

// ../../node_modules/effect/dist/esm/internal/channel/mergeStrategy.js
var MergeStrategySymbolKey = "effect/ChannelMergeStrategy";
var MergeStrategyTypeId = Symbol.for(MergeStrategySymbolKey);
var proto11 = {
  [MergeStrategyTypeId]: MergeStrategyTypeId
};
var BackPressure = (_) => {
  const op = Object.create(proto11);
  op._tag = OP_BACK_PRESSURE;
  return op;
};
var BufferSliding = (_) => {
  const op = Object.create(proto11);
  op._tag = OP_BUFFER_SLIDING;
  return op;
};
var isMergeStrategy = (u) => hasProperty(u, MergeStrategyTypeId);
var isBackPressure = (self) => self._tag === OP_BACK_PRESSURE;
var isBufferSliding = (self) => self._tag === OP_BUFFER_SLIDING;
var match27 = dual(2, (self, {
  onBackPressure,
  onBufferSliding
}) => {
  switch (self._tag) {
    case OP_BACK_PRESSURE: {
      return onBackPressure();
    }
    case OP_BUFFER_SLIDING: {
      return onBufferSliding();
    }
  }
});

// ../../node_modules/effect/dist/esm/internal/channel/singleProducerAsyncInput.js
var OP_STATE_EMPTY = "Empty";
var OP_STATE_EMIT = "Emit";
var OP_STATE_ERROR = "Error";
var OP_STATE_DONE2 = "Done";
var stateEmpty = (notifyProducer) => ({
  _tag: OP_STATE_EMPTY,
  notifyProducer
});
var stateEmit = (notifyConsumers) => ({
  _tag: OP_STATE_EMIT,
  notifyConsumers
});
var stateError = (cause3) => ({
  _tag: OP_STATE_ERROR,
  cause: cause3
});
var stateDone = (done17) => ({
  _tag: OP_STATE_DONE2,
  done: done17
});
var SingleProducerAsyncInputImpl = class {
  ref;
  constructor(ref) {
    this.ref = ref;
  }
  awaitRead() {
    return flatten13(modify8(this.ref, (state) => state._tag === OP_STATE_EMPTY ? [_await(state.notifyProducer), state] : [_void, state]));
  }
  get close() {
    return fiberIdWith2((fiberId5) => this.error(interrupt6(fiberId5)));
  }
  done(value10) {
    return flatten13(modify8(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [_await(state.notifyProducer), state];
        }
        case OP_STATE_EMIT: {
          return [forEach16(state.notifyConsumers, (deferred) => succeed2(deferred, left2(value10)), {
            discard: true
          }), stateDone(value10)];
        }
        case OP_STATE_ERROR: {
          return [interrupt8, state];
        }
        case OP_STATE_DONE2: {
          return [interrupt8, state];
        }
      }
    }));
  }
  emit(element2) {
    return flatMap18(make24(), (deferred) => flatten13(modify8(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [_await(state.notifyProducer), state];
        }
        case OP_STATE_EMIT: {
          const notifyConsumer = state.notifyConsumers[0];
          const notifyConsumers = state.notifyConsumers.slice(1);
          if (notifyConsumer !== void 0) {
            return [succeed2(notifyConsumer, right2(element2)), notifyConsumers.length === 0 ? stateEmpty(deferred) : stateEmit(notifyConsumers)];
          }
          throw new Error("Bug: Channel.SingleProducerAsyncInput.emit - Queue was empty! please report an issue at https://github.com/Effect-TS/effect/issues");
        }
        case OP_STATE_ERROR: {
          return [interrupt8, state];
        }
        case OP_STATE_DONE2: {
          return [interrupt8, state];
        }
      }
    })));
  }
  error(cause3) {
    return flatten13(modify8(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [_await(state.notifyProducer), state];
        }
        case OP_STATE_EMIT: {
          return [forEach16(state.notifyConsumers, (deferred) => failCause2(deferred, cause3), {
            discard: true
          }), stateError(cause3)];
        }
        case OP_STATE_ERROR: {
          return [interrupt8, state];
        }
        case OP_STATE_DONE2: {
          return [interrupt8, state];
        }
      }
    }));
  }
  get take() {
    return this.takeWith((cause3) => failCause3(map22(cause3, left2)), (elem) => succeed3(elem), (done17) => fail4(right2(done17)));
  }
  takeWith(onError6, onElement, onDone3) {
    return flatMap18(make24(), (deferred) => flatten13(modify8(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [zipRight7(succeed2(state.notifyProducer, void 0), matchCause4(_await(deferred), {
            onFailure: onError6,
            onSuccess: match({
              onLeft: onDone3,
              onRight: onElement
            })
          })), stateEmit([deferred])];
        }
        case OP_STATE_EMIT: {
          return [matchCause4(_await(deferred), {
            onFailure: onError6,
            onSuccess: match({
              onLeft: onDone3,
              onRight: onElement
            })
          }), stateEmit([...state.notifyConsumers, deferred])];
        }
        case OP_STATE_ERROR: {
          return [succeed13(onError6(state.cause)), state];
        }
        case OP_STATE_DONE2: {
          return [succeed13(onDone3(state.done)), state];
        }
      }
    })));
  }
};
var make63 = () => pipe(make24(), flatMap18((deferred) => make37(stateEmpty(deferred))), map26((ref) => new SingleProducerAsyncInputImpl(ref)));

// ../../node_modules/effect/dist/esm/internal/channel.js
var acquireUseRelease4 = (acquire4, use2, release4) => flatMap20(fromEffect5(make37(() => _void)), (ref) => pipe(fromEffect5(uninterruptible3(tap5(acquire4, (a) => set7(ref, (exit4) => release4(a, exit4))))), flatMap20(use2), ensuringWith((exit4) => flatMap18(get13(ref), (f) => f(exit4)))));
var as9 = dual(2, (self, value10) => map28(self, () => value10));
var asVoid7 = (self) => map28(self, constVoid);
var buffer = (options) => suspend6(() => {
  const doBuffer = (empty61, isEmpty32, ref) => unwrap2(modify8(ref, (inElem) => isEmpty32(inElem) ? [readWith({
    onInput: (input) => flatMap20(write(input), () => doBuffer(empty61, isEmpty32, ref)),
    onFailure: (error4) => fail14(error4),
    onDone: (done17) => succeedNow(done17)
  }), inElem] : [flatMap20(write(inElem), () => doBuffer(empty61, isEmpty32, ref)), empty61]));
  return doBuffer(options.empty, options.isEmpty, options.ref);
});
var bufferChunk = (ref) => buffer({
  empty: empty7(),
  isEmpty: isEmpty2,
  ref
});
var catchAll6 = dual(2, (self, f) => catchAllCause6(self, (cause3) => match(failureOrCause2(cause3), {
  onLeft: f,
  onRight: failCause12
})));
var concatMap = dual(2, (self, f) => concatMapWith(self, f, () => void 0, () => void 0));
var collect2 = dual(2, (self, pf) => {
  const collector = readWith({
    onInput: (out) => match2(pf(out), {
      onNone: () => collector,
      onSome: (out2) => flatMap20(write(out2), () => collector)
    }),
    onFailure: fail14,
    onDone: succeedNow
  });
  return pipeTo(self, collector);
});
var concatOut = (self) => concatAll(self);
var mapInput7 = dual(2, (self, f) => {
  const reader = readWith({
    onInput: (inElem) => flatMap20(write(inElem), () => reader),
    onFailure: fail14,
    onDone: (done17) => succeedNow(f(done17))
  });
  return pipeTo(reader, self);
});
var mapInputEffect2 = dual(2, (self, f) => {
  const reader = readWith({
    onInput: (inElem) => flatMap20(write(inElem), () => reader),
    onFailure: fail14,
    onDone: (done17) => fromEffect5(f(done17))
  });
  return pipeTo(reader, self);
});
var mapInputError = dual(2, (self, f) => {
  const reader = readWith({
    onInput: (inElem) => flatMap20(write(inElem), () => reader),
    onFailure: (error4) => fail14(f(error4)),
    onDone: succeedNow
  });
  return pipeTo(reader, self);
});
var mapInputErrorEffect = dual(2, (self, f) => {
  const reader = readWith({
    onInput: (inElem) => flatMap20(write(inElem), () => reader),
    onFailure: (error4) => fromEffect5(f(error4)),
    onDone: succeedNow
  });
  return pipeTo(reader, self);
});
var mapInputIn = dual(2, (self, f) => {
  const reader = readWith({
    onInput: (inElem) => flatMap20(write(f(inElem)), () => reader),
    onFailure: fail14,
    onDone: succeedNow
  });
  return pipeTo(reader, self);
});
var mapInputInEffect = dual(2, (self, f) => {
  const reader = readWith({
    onInput: (inElem) => flatMap20(flatMap20(fromEffect5(f(inElem)), write), () => reader),
    onFailure: fail14,
    onDone: succeedNow
  });
  return pipeTo(reader, self);
});
var doneCollect = (self) => suspend6(() => {
  const builder = [];
  return pipe(pipeTo(self, doneCollectReader(builder)), flatMap20((outDone) => succeed15([unsafeFromArray(builder), outDone])));
});
var doneCollectReader = (builder) => {
  return readWith({
    onInput: (outElem) => flatMap20(sync10(() => {
      builder.push(outElem);
    }), () => doneCollectReader(builder)),
    onFailure: fail14,
    onDone: succeed15
  });
};
var drain = (self) => {
  const drainer = readWithCause({
    onInput: () => drainer,
    onFailure: failCause12,
    onDone: succeed15
  });
  return pipeTo(self, drainer);
};
var emitCollect = (self) => flatMap20(doneCollect(self), write);
var ensuring5 = dual(2, (self, finalizer3) => ensuringWith(self, () => finalizer3));
var context7 = () => fromEffect5(context5());
var contextWith3 = (f) => map28(context7(), f);
var contextWithChannel = (f) => flatMap20(context7(), f);
var contextWithEffect3 = (f) => mapEffect5(context7(), f);
var flatten15 = (self) => flatMap20(self, identity);
var foldChannel = dual(2, (self, options) => foldCauseChannel(self, {
  onFailure: (cause3) => {
    const either14 = failureOrCause2(cause3);
    switch (either14._tag) {
      case "Left": {
        return options.onFailure(either14.left);
      }
      case "Right": {
        return failCause12(either14.right);
      }
    }
  },
  onSuccess: options.onSuccess
}));
var fromEither3 = (either14) => suspend6(() => match(either14, {
  onLeft: fail14,
  onRight: succeed15
}));
var fromInput = (input) => unwrap2(input.takeWith(failCause12, (elem) => flatMap20(write(elem), () => fromInput(input)), succeed15));
var fromPubSub = (pubsub) => unwrapScoped3(map26(subscribe2(pubsub), fromQueue));
var fromPubSubScoped = (pubsub) => map26(subscribe2(pubsub), fromQueue);
var fromOption6 = (option11) => suspend6(() => match2(option11, {
  onNone: () => fail14(none2()),
  onSome: succeed15
}));
var fromQueue = (queue) => suspend6(() => fromQueueInternal(queue));
var fromQueueInternal = (queue) => pipe(fromEffect5(take6(queue)), flatMap20(match({
  onLeft: match7({
    onFailure: failCause12,
    onSuccess: succeedNow
  }),
  onRight: (elem) => flatMap20(write(elem), () => fromQueueInternal(queue))
})));
var identityChannel = () => readWith({
  onInput: (input) => flatMap20(write(input), () => identityChannel()),
  onFailure: fail14,
  onDone: succeedNow
});
var interruptWhen = dual(2, (self, effect4) => mergeWith2(self, {
  other: fromEffect5(effect4),
  onSelfDone: (selfDone) => Done3(suspend4(() => selfDone)),
  onOtherDone: (effectDone) => Done3(suspend4(() => effectDone))
}));
var interruptWhenDeferred = dual(2, (self, deferred) => interruptWhen(self, _await(deferred)));
var map28 = dual(2, (self, f) => flatMap20(self, (a) => sync10(() => f(a))));
var mapEffect5 = dual(2, (self, f) => flatMap20(self, (z) => fromEffect5(f(z))));
var mapError7 = dual(2, (self, f) => mapErrorCause5(self, map22(f)));
var mapErrorCause5 = dual(2, (self, f) => catchAllCause6(self, (cause3) => failCause12(f(cause3))));
var mapOut = dual(2, (self, f) => {
  const reader = readWith({
    onInput: (outElem) => flatMap20(write(f(outElem)), () => reader),
    onFailure: fail14,
    onDone: succeedNow
  });
  return pipeTo(self, reader);
});
var mapOutEffect = dual(2, (self, f) => {
  const reader = readWithCause({
    onInput: (outElem) => pipe(fromEffect5(f(outElem)), flatMap20(write), flatMap20(() => reader)),
    onFailure: failCause12,
    onDone: succeedNow
  });
  return pipeTo(self, reader);
});
var mapOutEffectPar = dual(3, (self, f, n) => unwrapScopedWith((scope6) => gen6(function* () {
  const input = yield* make63();
  const queueReader = fromInput(input);
  const queue = yield* bounded5(n);
  yield* addFinalizer3(scope6, shutdown4(queue));
  const errorSignal = yield* make24();
  const withPermits3 = n === Number.POSITIVE_INFINITY ? (_) => identity : (yield* makeSemaphore2(n)).withPermits;
  const pull = yield* queueReader.pipe(pipeTo(self), toPullIn(scope6));
  yield* pull.pipe(matchCauseEffect3({
    onFailure: (cause3) => offer3(queue, failCause10(cause3)),
    onSuccess: match({
      onLeft: (outDone) => zipRight7(interruptible4(withPermits3(n)(_void)), asVoid6(offer3(queue, succeed13(left2(outDone))))),
      onRight: (outElem) => gen6(function* () {
        const deferred = yield* make24();
        const latch = yield* make24();
        yield* offer3(queue, map26(_await(deferred), right2));
        yield* succeed2(latch, void 0).pipe(zipRight7(uninterruptibleMask3((restore) => exit3(restore(_await(errorSignal))).pipe(raceFirst3(exit3(restore(f(outElem)))), flatMap18(identity))).pipe(tapErrorCause4((cause3) => failCause2(errorSignal, cause3)), intoDeferred2(deferred))), withPermits3(1), forkIn3(scope6));
        yield* _await(latch);
      })
    })
  }), forever4, interruptible4, forkIn3(scope6));
  const consumer = unwrap2(matchCause4(flatten13(take6(queue)), {
    onFailure: failCause12,
    onSuccess: match({
      onLeft: succeedNow,
      onRight: (outElem) => flatMap20(write(outElem), () => consumer)
    })
  }));
  return embedInput(consumer, input);
})));
var mergeAll7 = (options) => {
  return (channels) => mergeAllWith(options)(channels, constVoid);
};
var mergeAllUnbounded = (channels) => mergeAllWith({
  concurrency: "unbounded"
})(channels, constVoid);
var mergeAllUnboundedWith = (channels, f) => mergeAllWith({
  concurrency: "unbounded"
})(channels, f);
var mergeAllWith = ({
  bufferSize = 16,
  concurrency,
  mergeStrategy = BackPressure()
}) => (channels, f) => unwrapScopedWith((scope6) => gen6(function* () {
  const concurrencyN = concurrency === "unbounded" ? Number.MAX_SAFE_INTEGER : concurrency;
  const input = yield* make63();
  const queueReader = fromInput(input);
  const queue = yield* bounded5(bufferSize);
  yield* addFinalizer3(scope6, shutdown4(queue));
  const cancelers = yield* unbounded5();
  yield* addFinalizer3(scope6, shutdown4(cancelers));
  const lastDone = yield* make37(none2());
  const errorSignal = yield* make24();
  const withPermits3 = (yield* makeSemaphore2(concurrencyN)).withPermits;
  const pull = yield* toPullIn(pipeTo(queueReader, channels), scope6);
  function evaluatePull(pull2) {
    return pull2.pipe(flatMap18(match({
      onLeft: (done17) => succeed13(some3(done17)),
      onRight: (outElem) => as8(offer3(queue, succeed13(right2(outElem))), none2())
    })), repeat3({
      until: (_) => isSome2(_)
    }), flatMap18((outDone) => update4(lastDone, match2({
      onNone: () => some3(outDone.value),
      onSome: (lastDone2) => some3(f(lastDone2, outDone.value))
    }))), catchAllCause4((cause3) => isInterrupted3(cause3) ? failCause10(cause3) : offer3(queue, failCause10(cause3)).pipe(zipRight7(succeed2(errorSignal, void 0)), asVoid6)));
  }
  yield* pull.pipe(matchCauseEffect3({
    onFailure: (cause3) => offer3(queue, failCause10(cause3)).pipe(zipRight7(succeed13(false))),
    onSuccess: match({
      onLeft: (outDone) => raceWith2(interruptible4(_await(errorSignal)), interruptible4(withPermits3(concurrencyN)(_void)), {
        onSelfDone: (_, permitAcquisition) => as8(interrupt7(permitAcquisition), false),
        onOtherDone: (_, failureAwait) => zipRight7(interrupt7(failureAwait), get13(lastDone).pipe(flatMap18(match2({
          onNone: () => offer3(queue, succeed13(left2(outDone))),
          onSome: (lastDone2) => offer3(queue, succeed13(left2(f(lastDone2, outDone))))
        })), as8(false)))
      }),
      onRight: (channel) => match27(mergeStrategy, {
        onBackPressure: () => gen6(function* () {
          const latch = yield* make24();
          const raceEffects = scopedWith2((scope7) => toPullIn(pipeTo(queueReader, channel), scope7).pipe(flatMap18((pull2) => race3(exit3(evaluatePull(pull2)), exit3(interruptible4(_await(errorSignal))))), flatMap18(identity)));
          yield* succeed2(latch, void 0).pipe(zipRight7(raceEffects), withPermits3(1), forkIn3(scope6));
          yield* _await(latch);
          const errored = yield* isDone(errorSignal);
          return !errored;
        }),
        onBufferSliding: () => gen6(function* () {
          const canceler = yield* make24();
          const latch = yield* make24();
          const size40 = yield* size20(cancelers);
          yield* take6(cancelers).pipe(flatMap18((canceler2) => succeed2(canceler2, void 0)), when3(() => size40 >= concurrencyN));
          yield* offer3(cancelers, canceler);
          const raceEffects = scopedWith2((scope7) => toPullIn(pipeTo(queueReader, channel), scope7).pipe(flatMap18((pull2) => exit3(evaluatePull(pull2)).pipe(race3(exit3(interruptible4(_await(errorSignal)))), race3(exit3(interruptible4(_await(canceler)))))), flatMap18(identity)));
          yield* succeed2(latch, void 0).pipe(zipRight7(raceEffects), withPermits3(1), forkIn3(scope6));
          yield* _await(latch);
          const errored = yield* isDone(errorSignal);
          return !errored;
        })
      })
    })
  }), repeat3({
    while: (_) => _
  }), forkIn3(scope6));
  const consumer = pipe(take6(queue), flatten13, matchCause4({
    onFailure: failCause12,
    onSuccess: match({
      onLeft: succeedNow,
      onRight: (outElem) => flatMap20(write(outElem), () => consumer)
    })
  }), unwrap2);
  return embedInput(consumer, input);
}));
var mergeMap = dual(3, (self, f, options) => mergeAll7(options)(mapOut(self, f)));
var mergeOut = dual(2, (self, n) => mergeAll7({
  concurrency: n
})(mapOut(self, identity)));
var mergeOutWith = dual(3, (self, n, f) => mergeAllWith({
  concurrency: n
})(mapOut(self, identity), f));
var mergeWith2 = dual(2, (self, options) => {
  function merge16(scope6) {
    return gen6(function* () {
      const input = yield* make63();
      const queueReader = fromInput(input);
      const pullL = yield* toPullIn(pipeTo(queueReader, self), scope6);
      const pullR = yield* toPullIn(pipeTo(queueReader, options.other), scope6);
      function handleSide(exit4, fiber, pull) {
        return (done17, both3, single3) => {
          function onDecision3(decision) {
            const op = decision;
            if (op._tag === OP_DONE4) {
              return succeed13(fromEffect5(zipRight7(interrupt7(fiber), op.effect)));
            }
            return map26(_await3(fiber), match7({
              onFailure: (cause3) => fromEffect5(op.f(failCause3(cause3))),
              onSuccess: match({
                onLeft: (done18) => fromEffect5(op.f(succeed3(done18))),
                onRight: (elem) => zipRight8(write(elem), go5(single3(op.f)))
              })
            }));
          }
          return match7(exit4, {
            onFailure: (cause3) => onDecision3(done17(failCause3(cause3))),
            onSuccess: match({
              onLeft: (z) => onDecision3(done17(succeed3(z))),
              onRight: (elem) => succeed13(flatMap20(write(elem), () => flatMap20(fromEffect5(forkIn3(interruptible4(pull), scope6)), (leftFiber) => go5(both3(leftFiber, fiber)))))
            })
          });
        };
      }
      function go5(state) {
        switch (state._tag) {
          case OP_BOTH_RUNNING: {
            const leftJoin = interruptible4(join4(state.left));
            const rightJoin = interruptible4(join4(state.right));
            return unwrap2(raceWith2(leftJoin, rightJoin, {
              onSelfDone: (leftExit, rf) => zipRight7(interrupt7(rf), handleSide(leftExit, state.right, pullL)(options.onSelfDone, BothRunning, (f) => LeftDone(f))),
              onOtherDone: (rightExit, lf) => zipRight7(interrupt7(lf), handleSide(rightExit, state.left, pullR)(options.onOtherDone, (left3, right3) => BothRunning(right3, left3), (f) => RightDone(f)))
            }));
          }
          case OP_LEFT_DONE: {
            return unwrap2(map26(exit3(pullR), match7({
              onFailure: (cause3) => fromEffect5(state.f(failCause3(cause3))),
              onSuccess: match({
                onLeft: (done17) => fromEffect5(state.f(succeed3(done17))),
                onRight: (elem) => flatMap20(write(elem), () => go5(LeftDone(state.f)))
              })
            })));
          }
          case OP_RIGHT_DONE: {
            return unwrap2(map26(exit3(pullL), match7({
              onFailure: (cause3) => fromEffect5(state.f(failCause3(cause3))),
              onSuccess: match({
                onLeft: (done17) => fromEffect5(state.f(succeed3(done17))),
                onRight: (elem) => flatMap20(write(elem), () => go5(RightDone(state.f)))
              })
            })));
          }
        }
      }
      return fromEffect5(withFiberRuntime2((parent) => {
        const inherit = withFiberRuntime2((state) => {
          ;
          state.transferChildren(parent.scope());
          return _void;
        });
        const leftFiber = interruptible4(pullL).pipe(ensuring4(inherit), forkIn3(scope6));
        const rightFiber = interruptible4(pullR).pipe(ensuring4(inherit), forkIn3(scope6));
        return zipWith12(leftFiber, rightFiber, (left3, right3) => BothRunning(left3, right3));
      })).pipe(flatMap20(go5), embedInput(input));
    });
  }
  return unwrapScopedWith(merge16);
});
var never6 = fromEffect5(never5);
var orDie6 = dual(2, (self, error4) => orDieWith3(self, error4));
var orDieWith3 = dual(2, (self, f) => catchAll6(self, (e) => failCauseSync7(() => die6(f(e)))));
var orElse10 = dual(2, (self, that) => catchAll6(self, that));
var pipeToOrFail = dual(2, (self, that) => suspend6(() => {
  let channelException = void 0;
  const reader = readWith({
    onInput: (outElem) => flatMap20(write(outElem), () => reader),
    onFailure: (outErr) => {
      channelException = ChannelException(outErr);
      return failCause12(die6(channelException));
    },
    onDone: succeedNow
  });
  const writer = readWithCause({
    onInput: (outElem) => pipe(write(outElem), flatMap20(() => writer)),
    onFailure: (cause3) => isDieType2(cause3) && isChannelException(cause3.defect) && equals(cause3.defect, channelException) ? fail14(cause3.defect.error) : failCause12(cause3),
    onDone: succeedNow
  });
  return pipeTo(pipeTo(pipeTo(self, reader), that), writer);
}));
var provideService6 = dual(3, (self, tag5, service4) => {
  return flatMap20(context7(), (context15) => provideContext4(self, add2(context15, tag5, service4)));
});
var provideLayer = dual(2, (self, layer) => unwrapScopedWith((scope6) => map26(buildWithScope2(layer, scope6), (context15) => provideContext4(self, context15))));
var mapInputContext4 = dual(2, (self, f) => contextWithChannel((context15) => provideContext4(self, f(context15))));
var provideSomeLayer2 = dual(2, (self, layer) => (
  // @ts-expect-error
  provideLayer(self, merge8(context6(), layer))
));
var read = () => readOrFail(none2());
var repeated = (self) => flatMap20(self, () => repeated(self));
var run2 = (self) => scopedWith2((scope6) => runIn(self, scope6));
var runCollect = (self) => run2(collectElements(self));
var runDrain = (self) => run2(drain(self));
var runScoped = (self) => scopeWith2((scope6) => runIn(self, scope6));
var scoped6 = (effect4) => unwrap2(uninterruptibleMask3((restore) => map26(make55(), (scope6) => acquireReleaseOut(tapErrorCause4(restore(extend3(effect4, scope6)), (cause3) => close(scope6, failCause3(cause3))), (_, exit4) => close(scope6, exit4)))));
var scopedWith3 = (f) => unwrapScoped3(map26(scope4, (scope6) => flatMap20(fromEffect5(f(scope6)), write)));
var splitLines = () => suspend6(() => {
  let stringBuilder = "";
  let midCRLF = false;
  const splitLinesChunk = (chunk7) => {
    const chunkBuilder = [];
    map7(chunk7, (str) => {
      if (str.length !== 0) {
        let from = 0;
        let indexOfCR = str.indexOf("\r");
        let indexOfLF = str.indexOf("\n");
        if (midCRLF) {
          if (indexOfLF === 0) {
            chunkBuilder.push(stringBuilder);
            stringBuilder = "";
            from = 1;
            indexOfLF = str.indexOf("\n", from);
          } else {
            stringBuilder = stringBuilder + "\r";
          }
          midCRLF = false;
        }
        while (indexOfCR !== -1 || indexOfLF !== -1) {
          if (indexOfCR === -1 || indexOfLF !== -1 && indexOfLF < indexOfCR) {
            if (stringBuilder.length === 0) {
              chunkBuilder.push(str.substring(from, indexOfLF));
            } else {
              chunkBuilder.push(stringBuilder + str.substring(from, indexOfLF));
              stringBuilder = "";
            }
            from = indexOfLF + 1;
            indexOfLF = str.indexOf("\n", from);
          } else {
            if (str.length === indexOfCR + 1) {
              midCRLF = true;
              indexOfCR = -1;
            } else {
              if (indexOfLF === indexOfCR + 1) {
                if (stringBuilder.length === 0) {
                  chunkBuilder.push(str.substring(from, indexOfCR));
                } else {
                  stringBuilder = stringBuilder + str.substring(from, indexOfCR);
                  chunkBuilder.push(stringBuilder);
                  stringBuilder = "";
                }
                from = indexOfCR + 2;
                indexOfCR = str.indexOf("\r", from);
                indexOfLF = str.indexOf("\n", from);
              } else {
                indexOfCR = str.indexOf("\r", indexOfCR + 1);
              }
            }
          }
        }
        if (midCRLF) {
          stringBuilder = stringBuilder + str.substring(from, str.length - 1);
        } else {
          stringBuilder = stringBuilder + str.substring(from, str.length);
        }
      }
    });
    return unsafeFromArray(chunkBuilder);
  };
  const loop5 = readWithCause({
    onInput: (input) => {
      const out = splitLinesChunk(input);
      return isEmpty2(out) ? loop5 : flatMap20(write(out), () => loop5);
    },
    onFailure: (cause3) => stringBuilder.length === 0 ? failCause12(cause3) : flatMap20(write(of3(stringBuilder)), () => failCause12(cause3)),
    onDone: (done17) => stringBuilder.length === 0 ? succeed15(done17) : flatMap20(write(of3(stringBuilder)), () => succeed15(done17))
  });
  return loop5;
});
var toPubSub = (pubsub) => toQueue(pubsub);
var toPull = (self) => flatMap18(scope4, (scope6) => toPullIn(self, scope6));
var toPullIn = dual(2, (self, scope6) => zip12(sync8(() => new ChannelExecutor(self, void 0, identity)), runtime4()).pipe(tap5(([executor, runtime8]) => addFinalizerExit(scope6, (exit4) => {
  const finalizer3 = executor.close(exit4);
  return finalizer3 !== void 0 ? provide2(finalizer3, runtime8) : _void;
})), uninterruptible3, map26(([executor]) => suspend4(() => interpretToPull(executor.run(), executor)))));
var interpretToPull = (channelState, exec) => {
  const state = channelState;
  switch (state._tag) {
    case OP_DONE3: {
      return match7(exec.getDone(), {
        onFailure: failCause10,
        onSuccess: (done17) => succeed13(left2(done17))
      });
    }
    case OP_EMIT2: {
      return succeed13(right2(exec.getEmit()));
    }
    case OP_FROM_EFFECT3: {
      return pipe(state.effect, flatMap18(() => interpretToPull(exec.run(), exec)));
    }
    case OP_READ2: {
      return readUpstream(state, () => interpretToPull(exec.run(), exec), (cause3) => failCause10(cause3));
    }
  }
};
var toQueue = (queue) => suspend6(() => toQueueInternal(queue));
var toQueueInternal = (queue) => {
  return readWithCause({
    onInput: (elem) => flatMap20(fromEffect5(offer3(queue, right2(elem))), () => toQueueInternal(queue)),
    onFailure: (cause3) => fromEffect5(offer3(queue, left2(failCause3(cause3)))),
    onDone: (done17) => fromEffect5(offer3(queue, left2(succeed3(done17))))
  });
};
var unwrap2 = (channel) => flatten15(fromEffect5(channel));
var unwrapScoped3 = (self) => concatAllWith(scoped6(self), (d, _) => d, (d, _) => d);
var unwrapScopedWith = (f) => concatAllWith(scopedWith3(f), (d, _) => d, (d, _) => d);
var updateService5 = dual(3, (self, tag5, f) => mapInputContext4(self, (context15) => merge3(context15, make8(tag5, f(unsafeGet3(context15, tag5))))));
var withSpan5 = function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  const acquire4 = all11([makeSpan2(name, options), context5(), clock2, get14(currentTracerTimingEnabled2)]);
  if (dataFirst) {
    const self = arguments[0];
    return acquireUseRelease4(acquire4, ([span4, context15]) => provideContext4(self, add2(context15, spanTag, span4)), ([span4, , clock3, timingEnabled], exit4) => endSpan(span4, exit4, clock3, timingEnabled));
  }
  return (self) => acquireUseRelease4(acquire4, ([span4, context15]) => provideContext4(self, add2(context15, spanTag, span4)), ([span4, , clock3, timingEnabled], exit4) => endSpan(span4, exit4, clock3, timingEnabled));
};
var writeAll = (...outs) => writeChunk(fromIterable3(outs));
var writeChunk = (outs) => writeChunkWriter(0, outs.length, outs);
var writeChunkWriter = (idx, len, chunk7) => {
  return idx === len ? void_8 : pipe(write(pipe(chunk7, unsafeGet4(idx))), flatMap20(() => writeChunkWriter(idx + 1, len, chunk7)));
};
var zip13 = dual((args2) => isChannel(args2[1]), (self, that, options) => options?.concurrent ? mergeWith2(self, {
  other: that,
  onSelfDone: (exit1) => Await((exit22) => suspend4(() => zip6(exit1, exit22))),
  onOtherDone: (exit22) => Await((exit1) => suspend4(() => zip6(exit1, exit22)))
}) : flatMap20(self, (a) => map28(that, (b) => [a, b])));
var zipLeft8 = dual((args2) => isChannel(args2[1]), (self, that, options) => options?.concurrent ? map28(zip13(self, that, {
  concurrent: true
}), (tuple7) => tuple7[0]) : flatMap20(self, (z) => as9(that, z)));
var zipRight8 = dual((args2) => isChannel(args2[1]), (self, that, options) => options?.concurrent ? map28(zip13(self, that, {
  concurrent: true
}), (tuple7) => tuple7[1]) : flatMap20(self, () => that));
var ChannelExceptionTypeId = Symbol.for("effect/Channel/ChannelException");
var ChannelException = (error4) => ({
  _tag: "ChannelException",
  [ChannelExceptionTypeId]: ChannelExceptionTypeId,
  error: error4
});
var isChannelException = (u) => hasProperty(u, ChannelExceptionTypeId);

// ../../node_modules/effect/dist/esm/internal/sink.js
var SinkTypeId3 = Symbol.for("effect/Sink");
var sinkVariance2 = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _L: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var SinkImpl = class {
  channel;
  [SinkTypeId3] = sinkVariance2;
  constructor(channel) {
    this.channel = channel;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isSink = (u) => hasProperty(u, SinkTypeId3);
var suspend7 = (evaluate4) => new SinkImpl(suspend6(() => toChannel(evaluate4())));
var as10 = dual(2, (self, a) => pipe(self, map29(() => a)));
var collectAll = () => new SinkImpl(collectAllLoop(empty7()));
var collectAllLoop = (acc) => readWithCause({
  onInput: (chunk7) => collectAllLoop(pipe(acc, appendAll3(chunk7))),
  onFailure: failCause12,
  onDone: () => succeed15(acc)
});
var collectAllN = (n) => suspend7(() => fromChannel(collectAllNLoop(n, empty7())));
var collectAllNLoop = (n, acc) => readWithCause({
  onInput: (chunk7) => {
    const [collected, leftovers] = splitAt2(chunk7, n);
    if (collected.length < n) {
      return collectAllNLoop(n - collected.length, appendAll3(acc, collected));
    }
    if (isEmpty2(leftovers)) {
      return succeed15(appendAll3(acc, collected));
    }
    return flatMap20(write(leftovers), () => succeed15(appendAll3(acc, collected)));
  },
  onFailure: failCause12,
  onDone: () => succeed15(acc)
});
var collectAllFrom = (self) => collectAllWhileWith(self, {
  initial: empty7(),
  while: constTrue,
  body: (chunk7, a) => pipe(chunk7, append3(a))
});
var collectAllToMap = (key, merge16) => {
  return foldLeftChunks(empty11(), (map49, chunk7) => pipe(chunk7, reduce4(map49, (map50, input) => {
    const k = key(input);
    const v = pipe(map50, has5(k)) ? merge16(pipe(map50, unsafeGet6(k)), input) : input;
    return pipe(map50, set4(k, v));
  })));
};
var collectAllToMapN = (n, key, merge16) => {
  return foldWeighted({
    initial: empty11(),
    maxCost: n,
    cost: (acc, input) => pipe(acc, has5(key(input))) ? 0 : 1,
    body: (acc, input) => {
      const k = key(input);
      const v = pipe(acc, has5(k)) ? merge16(pipe(acc, unsafeGet6(k)), input) : input;
      return pipe(acc, set4(k, v));
    }
  });
};
var collectAllToSet = () => foldLeftChunks(empty10(), (acc, chunk7) => pipe(chunk7, reduce4(acc, (acc2, input) => pipe(acc2, add4(input)))));
var collectAllToSetN = (n) => foldWeighted({
  initial: empty10(),
  maxCost: n,
  cost: (acc, input) => has4(acc, input) ? 0 : 1,
  body: (acc, input) => add4(acc, input)
});
var collectAllUntil = (p) => {
  return pipe(fold([empty7(), true], (tuple7) => tuple7[1], ([chunk7, _], input) => [pipe(chunk7, append3(input)), !p(input)]), map29((tuple7) => tuple7[0]));
};
var collectAllUntilEffect = (p) => {
  return pipe(foldEffect([empty7(), true], (tuple7) => tuple7[1], ([chunk7, _], input) => pipe(p(input), map26((bool) => [pipe(chunk7, append3(input)), !bool]))), map29((tuple7) => tuple7[0]));
};
var collectAllWhile = (predicate) => fromChannel(collectAllWhileReader(predicate, empty7()));
var collectAllWhileReader = (predicate, done17) => readWith({
  onInput: (input) => {
    const [collected, leftovers] = pipe(toReadonlyArray(input), span(predicate));
    if (leftovers.length === 0) {
      return collectAllWhileReader(predicate, pipe(done17, appendAll3(unsafeFromArray(collected))));
    }
    return pipe(write(unsafeFromArray(leftovers)), zipRight8(succeed15(pipe(done17, appendAll3(unsafeFromArray(collected))))));
  },
  onFailure: fail14,
  onDone: () => succeed15(done17)
});
var collectAllWhileEffect = (predicate) => fromChannel(collectAllWhileEffectReader(predicate, empty7()));
var collectAllWhileEffectReader = (predicate, done17) => readWith({
  onInput: (input) => pipe(fromEffect5(pipe(input, takeWhile5(predicate), map26(unsafeFromArray))), flatMap20((collected) => {
    const leftovers = pipe(input, drop3(collected.length));
    if (isEmpty2(leftovers)) {
      return collectAllWhileEffectReader(predicate, pipe(done17, appendAll3(collected)));
    }
    return pipe(write(leftovers), zipRight8(succeed15(pipe(done17, appendAll3(collected)))));
  })),
  onFailure: fail14,
  onDone: () => succeed15(done17)
});
var collectAllWhileWith = dual(2, (self, options) => {
  const refs = pipe(make37(empty7()), zip12(make37(false)));
  const newChannel = pipe(fromEffect5(refs), flatMap20(([leftoversRef, upstreamDoneRef]) => {
    const upstreamMarker = readWith({
      onInput: (input) => pipe(write(input), flatMap20(() => upstreamMarker)),
      onFailure: fail14,
      onDone: (done17) => pipe(fromEffect5(set7(upstreamDoneRef, true)), as9(done17))
    });
    return pipe(upstreamMarker, pipeTo(bufferChunk(leftoversRef)), pipeTo(collectAllWhileWithLoop(self, leftoversRef, upstreamDoneRef, options.initial, options.while, options.body)));
  }));
  return new SinkImpl(newChannel);
});
var collectAllWhileWithLoop = (self, leftoversRef, upstreamDoneRef, currentResult, p, f) => {
  return pipe(toChannel(self), doneCollect, foldChannel({
    onFailure: fail14,
    onSuccess: ([leftovers, doneValue]) => p(doneValue) ? pipe(fromEffect5(set7(leftoversRef, flatten5(leftovers))), flatMap20(() => pipe(fromEffect5(get13(upstreamDoneRef)), flatMap20((upstreamDone) => {
      const accumulatedResult = f(currentResult, doneValue);
      return upstreamDone ? pipe(write(flatten5(leftovers)), as9(accumulatedResult)) : collectAllWhileWithLoop(self, leftoversRef, upstreamDoneRef, accumulatedResult, p, f);
    })))) : pipe(write(flatten5(leftovers)), as9(currentResult))
  }));
};
var collectLeftover = (self) => new SinkImpl(pipe(collectElements(toChannel(self)), map28(([chunks3, z]) => [z, flatten5(chunks3)])));
var mapInput8 = dual(2, (self, f) => pipe(self, mapInputChunks(map7(f))));
var mapInputEffect3 = dual(2, (self, f) => mapInputChunksEffect(self, (chunk7) => map26(forEach16(chunk7, (v) => f(v)), unsafeFromArray)));
var mapInputChunks = dual(2, (self, f) => {
  const loop5 = readWith({
    onInput: (chunk7) => pipe(write(f(chunk7)), flatMap20(() => loop5)),
    onFailure: fail14,
    onDone: succeed15
  });
  return new SinkImpl(pipe(loop5, pipeTo(toChannel(self))));
});
var mapInputChunksEffect = dual(2, (self, f) => {
  const loop5 = readWith({
    onInput: (chunk7) => pipe(fromEffect5(f(chunk7)), flatMap20(write), flatMap20(() => loop5)),
    onFailure: fail14,
    onDone: succeed15
  });
  return new SinkImpl(pipe(loop5, pipeToOrFail(toChannel(self))));
});
var die10 = (defect) => failCause13(die6(defect));
var dieMessage3 = (message) => failCause13(die6(new RuntimeException2(message)));
var dieSync6 = (evaluate4) => failCauseSync8(() => die6(evaluate4()));
var dimap = dual(2, (self, options) => map29(mapInput8(self, options.onInput), options.onDone));
var dimapEffect = dual(2, (self, options) => mapEffect6(mapInputEffect3(self, options.onInput), options.onDone));
var dimapChunks = dual(2, (self, options) => map29(mapInputChunks(self, options.onInput), options.onDone));
var dimapChunksEffect = dual(2, (self, options) => mapEffect6(mapInputChunksEffect(self, options.onInput), options.onDone));
var drain2 = new SinkImpl(drain(identityChannel()));
var drop5 = (n) => suspend7(() => new SinkImpl(dropLoop(n)));
var dropLoop = (n) => readWith({
  onInput: (input) => {
    const dropped = pipe(input, drop3(n));
    const leftover3 = Math.max(n - input.length, 0);
    const more = isEmpty2(input) || leftover3 > 0;
    if (more) {
      return dropLoop(leftover3);
    }
    return pipe(write(dropped), zipRight8(identityChannel()));
  },
  onFailure: fail14,
  onDone: () => void_8
});
var dropUntil3 = (predicate) => new SinkImpl(pipe(toChannel(dropWhile5((input) => !predicate(input))), pipeToOrFail(toChannel(drop5(1)))));
var dropUntilEffect = (predicate) => suspend7(() => new SinkImpl(dropUntilEffectReader(predicate)));
var dropUntilEffectReader = (predicate) => readWith({
  onInput: (input) => pipe(input, dropUntil2(predicate), map26((leftover3) => {
    const more = leftover3.length === 0;
    return more ? dropUntilEffectReader(predicate) : pipe(write(unsafeFromArray(leftover3)), zipRight8(identityChannel()));
  }), unwrap2),
  onFailure: fail14,
  onDone: () => void_8
});
var dropWhile5 = (predicate) => new SinkImpl(dropWhileReader(predicate));
var dropWhileReader = (predicate) => readWith({
  onInput: (input) => {
    const out = pipe(input, dropWhile2(predicate));
    if (isEmpty2(out)) {
      return dropWhileReader(predicate);
    }
    return pipe(write(out), zipRight8(identityChannel()));
  },
  onFailure: fail14,
  onDone: succeedNow
});
var dropWhileEffect = (predicate) => suspend7(() => new SinkImpl(dropWhileEffectReader(predicate)));
var dropWhileEffectReader = (predicate) => readWith({
  onInput: (input) => pipe(input, dropWhile4(predicate), map26((leftover3) => {
    const more = leftover3.length === 0;
    return more ? dropWhileEffectReader(predicate) : pipe(write(unsafeFromArray(leftover3)), zipRight8(identityChannel()));
  }), unwrap2),
  onFailure: fail14,
  onDone: () => void_8
});
var ensuring6 = dual(2, (self, finalizer3) => new SinkImpl(pipe(self, toChannel, ensuring5(finalizer3))));
var ensuringWith2 = dual(2, (self, finalizer3) => new SinkImpl(pipe(self, toChannel, ensuringWith(finalizer3))));
var context8 = () => fromEffect7(context5());
var contextWith4 = (f) => pipe(context8(), map29(f));
var contextWithEffect4 = (f) => pipe(context8(), mapEffect6(f));
var contextWithSink = (f) => new SinkImpl(unwrap2(contextWith2((context15) => toChannel(f(context15)))));
var every14 = (predicate) => fold(true, identity, (acc, input) => acc && predicate(input));
var fail15 = (e) => new SinkImpl(fail14(e));
var failSync8 = (evaluate4) => new SinkImpl(failSync7(evaluate4));
var failCause13 = (cause3) => new SinkImpl(failCause12(cause3));
var failCauseSync8 = (evaluate4) => new SinkImpl(failCauseSync7(evaluate4));
var filterInput = (f) => {
  return (self) => pipe(self, mapInputChunks(filter5(f)));
};
var filterInputEffect = dual(2, (self, f) => mapInputChunksEffect(self, (chunk7) => map26(filter16(chunk7, f), unsafeFromArray)));
var findEffect = dual(2, (self, f) => {
  const newChannel = pipe(fromEffect5(pipe(make37(empty7()), zip12(make37(false)))), flatMap20(([leftoversRef, upstreamDoneRef]) => {
    const upstreamMarker = readWith({
      onInput: (input) => pipe(write(input), flatMap20(() => upstreamMarker)),
      onFailure: fail14,
      onDone: (done17) => pipe(fromEffect5(set7(upstreamDoneRef, true)), as9(done17))
    });
    const loop5 = foldChannel(collectElements(toChannel(self)), {
      onFailure: fail14,
      onSuccess: ([leftovers, doneValue]) => pipe(fromEffect5(f(doneValue)), flatMap20((satisfied) => pipe(fromEffect5(set7(leftoversRef, flatten5(leftovers))), zipRight8(pipe(fromEffect5(get13(upstreamDoneRef)), flatMap20((upstreamDone) => {
        if (satisfied) {
          return pipe(write(flatten5(leftovers)), as9(some3(doneValue)));
        }
        if (upstreamDone) {
          return pipe(write(flatten5(leftovers)), as9(none2()));
        }
        return loop5;
      }))))))
    });
    return pipe(upstreamMarker, pipeTo(bufferChunk(leftoversRef)), pipeTo(loop5));
  }));
  return new SinkImpl(newChannel);
});
var fold = (s, contFn, f) => suspend7(() => new SinkImpl(foldReader(s, contFn, f)));
var foldReader = (s, contFn, f) => {
  if (!contFn(s)) {
    return succeedNow(s);
  }
  return readWith({
    onInput: (input) => {
      const [nextS, leftovers] = foldChunkSplit(s, input, contFn, f, 0, input.length);
      if (isNonEmpty2(leftovers)) {
        return pipe(write(leftovers), as9(nextS));
      }
      return foldReader(nextS, contFn, f);
    },
    onFailure: fail14,
    onDone: () => succeedNow(s)
  });
};
var foldChunkSplit = (s, chunk7, contFn, f, index, length6) => {
  if (index === length6) {
    return [s, empty7()];
  }
  const s1 = f(s, pipe(chunk7, unsafeGet4(index)));
  if (contFn(s1)) {
    return foldChunkSplit(s1, chunk7, contFn, f, index + 1, length6);
  }
  return [s1, pipe(chunk7, drop3(index + 1))];
};
var foldSink = dual(2, (self, options) => {
  const newChannel = pipe(toChannel(self), collectElements, foldChannel({
    onFailure: (error4) => toChannel(options.onFailure(error4)),
    onSuccess: ([leftovers, z]) => suspend6(() => {
      const leftoversRef = {
        ref: pipe(leftovers, filter5(isNonEmpty2))
      };
      const refReader = pipe(
        sync10(() => {
          const ref = leftoversRef.ref;
          leftoversRef.ref = empty7();
          return ref;
        }),
        // This cast is safe because of the L1 >: L <: In1 bound. It follows that
        // L <: In1 and therefore Chunk[L] can be safely cast to Chunk[In1].
        flatMap20((chunk7) => writeChunk(chunk7))
      );
      const passthrough5 = identityChannel();
      const continuationSink = pipe(refReader, zipRight8(passthrough5), pipeTo(toChannel(options.onSuccess(z))));
      return flatMap20(collectElements(continuationSink), ([newLeftovers, z1]) => pipe(succeed15(leftoversRef.ref), flatMap20(writeChunk), zipRight8(writeChunk(newLeftovers)), as9(z1)));
    })
  }));
  return new SinkImpl(newChannel);
});
var foldChunks = (s, contFn, f) => suspend7(() => new SinkImpl(foldChunksReader(s, contFn, f)));
var foldChunksReader = (s, contFn, f) => {
  if (!contFn(s)) {
    return succeedNow(s);
  }
  return readWith({
    onInput: (input) => foldChunksReader(f(s, input), contFn, f),
    onFailure: fail14,
    onDone: () => succeedNow(s)
  });
};
var foldChunksEffect = (s, contFn, f) => suspend7(() => new SinkImpl(foldChunksEffectReader(s, contFn, f)));
var foldChunksEffectReader = (s, contFn, f) => {
  if (!contFn(s)) {
    return succeedNow(s);
  }
  return readWith({
    onInput: (input) => pipe(fromEffect5(f(s, input)), flatMap20((s2) => foldChunksEffectReader(s2, contFn, f))),
    onFailure: fail14,
    onDone: () => succeedNow(s)
  });
};
var foldEffect = (s, contFn, f) => suspend7(() => new SinkImpl(foldEffectReader(s, contFn, f)));
var foldEffectReader = (s, contFn, f) => {
  if (!contFn(s)) {
    return succeedNow(s);
  }
  return readWith({
    onInput: (input) => pipe(fromEffect5(foldChunkSplitEffect(s, input, contFn, f)), flatMap20(([nextS, leftovers]) => pipe(leftovers, match2({
      onNone: () => foldEffectReader(nextS, contFn, f),
      onSome: (leftover3) => pipe(write(leftover3), as9(nextS))
    })))),
    onFailure: fail14,
    onDone: () => succeedNow(s)
  });
};
var foldChunkSplitEffect = (s, chunk7, contFn, f) => foldChunkSplitEffectInternal(s, chunk7, 0, chunk7.length, contFn, f);
var foldChunkSplitEffectInternal = (s, chunk7, index, length6, contFn, f) => {
  if (index === length6) {
    return succeed13([s, none2()]);
  }
  return pipe(f(s, pipe(chunk7, unsafeGet4(index))), flatMap18((s1) => contFn(s1) ? foldChunkSplitEffectInternal(s1, chunk7, index + 1, length6, contFn, f) : succeed13([s1, some3(pipe(chunk7, drop3(index + 1)))])));
};
var foldLeft = (s, f) => ignoreLeftover(fold(s, constTrue, f));
var foldLeftChunks = (s, f) => foldChunks(s, constTrue, f);
var foldLeftChunksEffect = (s, f) => ignoreLeftover(foldChunksEffect(s, constTrue, f));
var foldLeftEffect = (s, f) => foldEffect(s, constTrue, f);
var foldUntil = (s, max13, f) => pipe(fold([s, 0], (tuple7) => tuple7[1] < max13, ([output, count9], input) => [f(output, input), count9 + 1]), map29((tuple7) => tuple7[0]));
var foldUntilEffect = (s, max13, f) => pipe(foldEffect([s, 0], (tuple7) => tuple7[1] < max13, ([output, count9], input) => pipe(f(output, input), map26((s2) => [s2, count9 + 1]))), map29((tuple7) => tuple7[0]));
var foldWeighted = (options) => foldWeightedDecompose({
  ...options,
  decompose: of3
});
var foldWeightedDecompose = (options) => suspend7(() => new SinkImpl(foldWeightedDecomposeLoop(options.initial, 0, false, options.maxCost, options.cost, options.decompose, options.body)));
var foldWeightedDecomposeLoop = (s, cost, dirty, max13, costFn, decompose, f) => readWith({
  onInput: (input) => {
    const [nextS, nextCost, nextDirty, leftovers] = foldWeightedDecomposeFold(input, 0, s, cost, dirty, max13, costFn, decompose, f);
    if (isNonEmpty2(leftovers)) {
      return pipe(write(leftovers), zipRight8(succeedNow(nextS)));
    }
    if (cost > max13) {
      return succeedNow(nextS);
    }
    return foldWeightedDecomposeLoop(nextS, nextCost, nextDirty, max13, costFn, decompose, f);
  },
  onFailure: fail14,
  onDone: () => succeedNow(s)
});
var foldWeightedDecomposeFold = (input, index, s, cost, dirty, max13, costFn, decompose, f) => {
  if (index === input.length) {
    return [s, cost, dirty, empty7()];
  }
  const elem = pipe(input, unsafeGet4(index));
  const total = cost + costFn(s, elem);
  if (total <= max13) {
    return foldWeightedDecomposeFold(input, index + 1, f(s, elem), total, true, max13, costFn, decompose, f);
  }
  const decomposed = decompose(elem);
  if (decomposed.length <= 1 && !dirty) {
    return [f(s, elem), total, true, pipe(input, drop3(index + 1))];
  }
  if (decomposed.length <= 1 && dirty) {
    return [s, cost, dirty, pipe(input, drop3(index))];
  }
  const next6 = pipe(decomposed, appendAll3(pipe(input, drop3(index + 1))));
  return foldWeightedDecomposeFold(next6, 0, s, cost, dirty, max13, costFn, decompose, f);
};
var foldWeightedDecomposeEffect = (options) => suspend7(() => new SinkImpl(foldWeightedDecomposeEffectLoop(options.initial, options.maxCost, options.cost, options.decompose, options.body, 0, false)));
var foldWeightedEffect = (options) => foldWeightedDecomposeEffect({
  ...options,
  decompose: (input) => succeed13(of3(input))
});
var foldWeightedDecomposeEffectLoop = (s, max13, costFn, decompose, f, cost, dirty) => readWith({
  onInput: (input) => pipe(fromEffect5(foldWeightedDecomposeEffectFold(s, max13, costFn, decompose, f, input, dirty, cost, 0)), flatMap20(([nextS, nextCost, nextDirty, leftovers]) => {
    if (isNonEmpty2(leftovers)) {
      return pipe(write(leftovers), zipRight8(succeedNow(nextS)));
    }
    if (cost > max13) {
      return succeedNow(nextS);
    }
    return foldWeightedDecomposeEffectLoop(nextS, max13, costFn, decompose, f, nextCost, nextDirty);
  })),
  onFailure: fail14,
  onDone: () => succeedNow(s)
});
var foldWeightedDecomposeEffectFold = (s, max13, costFn, decompose, f, input, dirty, cost, index) => {
  if (index === input.length) {
    return succeed13([s, cost, dirty, empty7()]);
  }
  const elem = pipe(input, unsafeGet4(index));
  return pipe(costFn(s, elem), map26((newCost) => cost + newCost), flatMap18((total) => {
    if (total <= max13) {
      return pipe(f(s, elem), flatMap18((s2) => foldWeightedDecomposeEffectFold(s2, max13, costFn, decompose, f, input, true, total, index + 1)));
    }
    return pipe(decompose(elem), flatMap18((decomposed) => {
      if (decomposed.length <= 1 && !dirty) {
        return pipe(f(s, elem), map26((s2) => [s2, total, true, pipe(input, drop3(index + 1))]));
      }
      if (decomposed.length <= 1 && dirty) {
        return succeed13([s, cost, dirty, pipe(input, drop3(index))]);
      }
      const next6 = pipe(decomposed, appendAll3(pipe(input, drop3(index + 1))));
      return foldWeightedDecomposeEffectFold(s, max13, costFn, decompose, f, next6, dirty, cost, 0);
    }));
  }));
};
var flatMap21 = dual(2, (self, f) => foldSink(self, {
  onFailure: fail15,
  onSuccess: f
}));
var forEach17 = (f) => {
  const process2 = readWithCause({
    onInput: (input) => pipe(fromEffect5(forEach16(input, (v) => f(v), {
      discard: true
    })), flatMap20(() => process2)),
    onFailure: failCause12,
    onDone: () => void_8
  });
  return new SinkImpl(process2);
};
var forEachChunk = (f) => {
  const process2 = readWithCause({
    onInput: (input) => pipe(fromEffect5(f(input)), flatMap20(() => process2)),
    onFailure: failCause12,
    onDone: () => void_8
  });
  return new SinkImpl(process2);
};
var forEachWhile = (f) => {
  const process2 = readWithCause({
    onInput: (input) => forEachWhileReader(f, input, 0, input.length, process2),
    onFailure: failCause12,
    onDone: () => void_8
  });
  return new SinkImpl(process2);
};
var forEachWhileReader = (f, input, index, length6, cont) => {
  if (index === length6) {
    return cont;
  }
  return pipe(fromEffect5(f(pipe(input, unsafeGet4(index)))), flatMap20((bool) => bool ? forEachWhileReader(f, input, index + 1, length6, cont) : write(pipe(input, drop3(index)))), catchAll6((error4) => pipe(write(pipe(input, drop3(index))), zipRight8(fail14(error4)))));
};
var forEachChunkWhile = (f) => {
  const reader = readWith({
    onInput: (input) => pipe(fromEffect5(f(input)), flatMap20((cont) => cont ? reader : void_8)),
    onFailure: fail14,
    onDone: () => void_8
  });
  return new SinkImpl(reader);
};
var fromChannel = (channel) => new SinkImpl(channel);
var fromEffect7 = (effect4) => new SinkImpl(fromEffect5(effect4));
var fromPubSub2 = (pubsub, options) => fromQueue2(pubsub, options);
var fromPush = (push) => new SinkImpl(unwrapScoped3(pipe(push, map26(fromPushPull))));
var fromPushPull = (push) => readWith({
  onInput: (input) => foldChannel(fromEffect5(push(some3(input))), {
    onFailure: ([either14, leftovers]) => match(either14, {
      onLeft: (error4) => pipe(write(leftovers), zipRight8(fail14(error4))),
      onRight: (z) => pipe(write(leftovers), zipRight8(succeedNow(z)))
    }),
    onSuccess: () => fromPushPull(push)
  }),
  onFailure: fail14,
  onDone: () => foldChannel(fromEffect5(push(none2())), {
    onFailure: ([either14, leftovers]) => match(either14, {
      onLeft: (error4) => pipe(write(leftovers), zipRight8(fail14(error4))),
      onRight: (z) => pipe(write(leftovers), zipRight8(succeedNow(z)))
    }),
    onSuccess: () => fromEffect5(dieMessage2("BUG: Sink.fromPush - please report an issue at https://github.com/Effect-TS/effect/issues"))
  })
});
var fromQueue2 = (queue, options) => options?.shutdown ? unwrapScoped4(map26(acquireRelease3(succeed13(queue), shutdown4), fromQueue2)) : forEachChunk((input) => offerAll3(queue, input));
var head8 = () => fold(none2(), isNone2, (option11, input) => match2(option11, {
  onNone: () => some3(input),
  onSome: () => option11
}));
var ignoreLeftover = (self) => new SinkImpl(drain(toChannel(self)));
var last6 = () => foldLeftChunks(none2(), (s, input) => orElse2(last2(input), () => s));
var leftover = (chunk7) => new SinkImpl(suspend6(() => write(chunk7)));
var map29 = dual(2, (self, f) => {
  return new SinkImpl(pipe(toChannel(self), map28(f)));
});
var mapEffect6 = dual(2, (self, f) => new SinkImpl(pipe(toChannel(self), mapEffect5(f))));
var mapError8 = dual(2, (self, f) => new SinkImpl(pipe(toChannel(self), mapError7(f))));
var mapLeftover = dual(2, (self, f) => new SinkImpl(pipe(toChannel(self), mapOut(map7(f)))));
var never7 = fromEffect7(never5);
var orElse11 = dual(2, (self, that) => new SinkImpl(pipe(toChannel(self), orElse10(() => toChannel(that())))));
var provideContext5 = dual(2, (self, context15) => new SinkImpl(pipe(toChannel(self), provideContext4(context15))));
var race4 = dual(2, (self, that) => pipe(self, raceBoth(that), map29(merge)));
var raceBoth = dual((args2) => isSink(args2[1]), (self, that, options) => raceWith3(self, {
  other: that,
  onSelfDone: (selfDone) => Done3(map26(selfDone, left2)),
  onOtherDone: (thatDone) => Done3(map26(thatDone, right2)),
  capacity: options?.capacity ?? 16
}));
var raceWith3 = dual(2, (self, options) => {
  function race10(scope6) {
    return gen6(function* () {
      const pubsub = yield* bounded4(options?.capacity ?? 16);
      const subscription1 = yield* extend3(subscribe2(pubsub), scope6);
      const subscription2 = yield* extend3(subscribe2(pubsub), scope6);
      const reader = toPubSub(pubsub);
      const writer = fromQueue(subscription1).pipe(pipeTo(toChannel(self)), zipLeft8(fromEffect5(shutdown4(subscription1))), mergeWith2({
        other: fromQueue(subscription2).pipe(pipeTo(toChannel(options.other)), zipLeft8(fromEffect5(shutdown4(subscription2)))),
        onSelfDone: options.onSelfDone,
        onOtherDone: options.onOtherDone
      }));
      const racedChannel = mergeWith2(reader, {
        other: writer,
        onSelfDone: () => Await(identity),
        onOtherDone: (exit4) => Done3(exit4)
      });
      return new SinkImpl(racedChannel);
    });
  }
  return unwrapScopedWith2(race10);
});
var refineOrDie = dual(2, (self, pf) => pipe(self, refineOrDieWith(pf, identity)));
var refineOrDieWith = dual(3, (self, pf, f) => {
  const newChannel = pipe(self, toChannel, catchAll6((error4) => match2(pf(error4), {
    onNone: () => failCauseSync7(() => die6(f(error4))),
    onSome: fail14
  })));
  return new SinkImpl(newChannel);
});
var some15 = (predicate) => fold(false, (bool) => !bool, (acc, input) => acc || predicate(input));
var splitWhere3 = dual(2, (self, f) => {
  const newChannel = pipe(fromEffect5(make37(empty7())), flatMap20((ref) => pipe(splitWhereSplitter(false, ref, f), pipeToOrFail(toChannel(self)), collectElements, flatMap20(([leftovers, z]) => pipe(fromEffect5(get13(ref)), flatMap20((leftover3) => pipe(write(pipe(leftover3, appendAll3(flatten5(leftovers)))), zipRight8(succeed15(z)))))))));
  return new SinkImpl(newChannel);
});
var splitWhereSplitter = (written, leftovers, f) => readWithCause({
  onInput: (input) => {
    if (isEmpty2(input)) {
      return splitWhereSplitter(written, leftovers, f);
    }
    if (written) {
      const index2 = indexWhere(input, f);
      if (index2 === -1) {
        return zipRight8(write(input), splitWhereSplitter(true, leftovers, f));
      }
      const [left4, right4] = splitAt2(input, index2);
      return zipRight8(write(left4), fromEffect5(set7(leftovers, right4)));
    }
    const index = indexWhere(input, f, 1);
    if (index === -1) {
      return zipRight8(write(input), splitWhereSplitter(true, leftovers, f));
    }
    const [left3, right3] = pipe(input, splitAt2(Math.max(index, 1)));
    return zipRight8(write(left3), fromEffect5(set7(leftovers, right3)));
  },
  onFailure: failCause12,
  onDone: succeed15
});
var indexWhere = (self, predicate, from = 0) => {
  const iterator = self[Symbol.iterator]();
  let index = 0;
  let result = -1;
  let next6;
  while (result < 0 && (next6 = iterator.next()) && !next6.done) {
    const a = next6.value;
    if (index >= from && predicate(a)) {
      result = index;
    }
    index = index + 1;
  }
  return result;
};
var succeed16 = (a) => new SinkImpl(succeed15(a));
var sum5 = foldLeftChunks(0, (acc, chunk7) => acc + reduce4(chunk7, 0, (s, a) => s + a));
var summarized3 = dual(3, (self, summary11, f) => {
  const newChannel = pipe(fromEffect5(summary11), flatMap20((start5) => pipe(self, toChannel, flatMap20((done17) => pipe(fromEffect5(summary11), map28((end7) => [done17, f(start5, end7)]))))));
  return new SinkImpl(newChannel);
});
var sync11 = (evaluate4) => new SinkImpl(sync10(evaluate4));
var take7 = (n) => pipe(foldChunks(empty7(), (chunk7) => chunk7.length < n, (acc, chunk7) => pipe(acc, appendAll3(chunk7))), flatMap21((acc) => {
  const [taken, leftover3] = pipe(acc, splitAt2(n));
  return new SinkImpl(pipe(write(leftover3), zipRight8(succeedNow(taken))));
}));
var toChannel = (self) => isEffect2(self) ? toChannel(fromEffect7(self)) : self.channel;
var unwrap3 = (effect4) => new SinkImpl(unwrap2(pipe(effect4, map26((sink) => toChannel(sink)))));
var unwrapScoped4 = (effect4) => new SinkImpl(unwrapScoped3(effect4.pipe(map26((sink) => toChannel(sink)))));
var unwrapScopedWith2 = (f) => new SinkImpl(unwrapScopedWith((scope6) => f(scope6).pipe(map26((sink) => toChannel(sink)))));
var withDuration = (self) => pipe(self, summarized3(currentTimeMillis2, (start5, end7) => millis(end7 - start5)));
var zip14 = dual((args2) => isSink(args2[1]), (self, that, options) => zipWith14(self, that, (z, z2) => [z, z2], options));
var zipLeft9 = dual((args2) => isSink(args2[1]), (self, that, options) => zipWith14(self, that, (z, _) => z, options));
var zipRight9 = dual((args2) => isSink(args2[1]), (self, that, options) => zipWith14(self, that, (_, z2) => z2, options));
var zipWith14 = dual((args2) => isSink(args2[1]), (self, that, f, options) => options?.concurrent ? raceWith3(self, {
  other: that,
  onSelfDone: match7({
    onFailure: (cause3) => Done3(failCause10(cause3)),
    onSuccess: (leftZ) => Await(match7({
      onFailure: failCause10,
      onSuccess: (rightZ) => succeed13(f(leftZ, rightZ))
    }))
  }),
  onOtherDone: match7({
    onFailure: (cause3) => Done3(failCause10(cause3)),
    onSuccess: (rightZ) => Await(match7({
      onFailure: failCause10,
      onSuccess: (leftZ) => succeed13(f(leftZ, rightZ))
    }))
  })
}) : flatMap21(self, (z) => map29(that, (z2) => f(z, z2))));
var channelToSink = (self) => new SinkImpl(self);
var count3 = foldLeftChunks(0, (acc, chunk7) => acc + chunk7.length);
var mkString = suspend7(() => {
  const strings = [];
  return pipe(foldLeftChunks(void 0, (_, elems) => map7(elems, (elem) => {
    strings.push(String(elem));
  })), map29(() => strings.join("")));
});
var timed3 = pipe(withDuration(drain2), map29((tuple7) => tuple7[1]));

// ../../node_modules/effect/dist/esm/MergeDecision.js
var MergeDecision_exports = {};
__export(MergeDecision_exports, {
  Await: () => Await2,
  AwaitConst: () => AwaitConst2,
  Done: () => Done4,
  MergeDecisionTypeId: () => MergeDecisionTypeId2,
  isMergeDecision: () => isMergeDecision2,
  match: () => match28
});
var MergeDecisionTypeId2 = MergeDecisionTypeId;
var Done4 = Done3;
var Await2 = Await;
var AwaitConst2 = AwaitConst;
var isMergeDecision2 = isMergeDecision;
var match28 = match25;

// ../../node_modules/effect/dist/esm/RcRef.js
var RcRef_exports = {};
__export(RcRef_exports, {
  TypeId: () => TypeId24,
  get: () => get16,
  make: () => make65
});

// ../../node_modules/effect/dist/esm/internal/rcRef.js
var TypeId23 = Symbol.for("effect/RcRef");
var stateEmpty2 = {
  _tag: "Empty"
};
var stateClosed = {
  _tag: "Closed"
};
var variance8 = {
  _A: identity,
  _E: identity
};
var RcRefImpl = class extends Class3 {
  acquire;
  context;
  scope;
  idleTimeToLive;
  [TypeId23] = variance8;
  [TypeId15] = TypeId15;
  state = stateEmpty2;
  semaphore = unsafeMakeSemaphore(1);
  constructor(acquire4, context15, scope6, idleTimeToLive) {
    super();
    this.acquire = acquire4;
    this.context = context15;
    this.scope = scope6;
    this.idleTimeToLive = idleTimeToLive;
    this.get = get15(this);
  }
  get;
  commit() {
    return this.get;
  }
};
var make64 = (options) => withFiberRuntime((fiber) => {
  const context15 = fiber.getFiberRef(currentContext);
  const scope6 = get4(context15, scopeTag);
  const ref = new RcRefImpl(options.acquire, context15, scope6, options.idleTimeToLive ? decode(options.idleTimeToLive) : void 0);
  return as3(scope6.addFinalizer(() => ref.semaphore.withPermits(1)(suspend(() => {
    const close3 = ref.state._tag === "Acquired" ? scopeClose(ref.state.scope, exitVoid) : void_3;
    ref.state = stateClosed;
    return close3;
  }))), ref);
});
var get15 = (self_) => {
  const self = self_;
  return uninterruptibleMask((restore) => suspend(() => {
    switch (self.state._tag) {
      case "Closed": {
        return interrupt2;
      }
      case "Acquired": {
        self.state.refCount++;
        return self.state.fiber ? as3(interruptFiber(self.state.fiber), self.state) : succeed(self.state);
      }
      case "Empty": {
        return scopeMake2().pipe(bindTo5("scope"), bind5("value", ({
          scope: scope6
        }) => restore(fiberRefLocally(self.acquire, currentContext, add2(self.context, scopeTag, scope6)))), map14(({
          scope: scope6,
          value: value10
        }) => {
          const state = {
            _tag: "Acquired",
            value: value10,
            scope: scope6,
            fiber: void 0,
            refCount: 1
          };
          self.state = state;
          return state;
        }));
      }
    }
  })).pipe(self.semaphore.withPermits(1), bindTo5("state"), bind5("scope", () => scopeTag), tap2(({
    scope: scope6,
    state
  }) => scope6.addFinalizer(() => suspend(() => {
    state.refCount--;
    if (state.refCount > 0) {
      return void_3;
    }
    if (self.idleTimeToLive === void 0) {
      self.state = stateEmpty2;
      return scopeClose(state.scope, exitVoid);
    }
    return sleep3(self.idleTimeToLive).pipe(interruptible2, zipRight2(suspend(() => {
      if (self.state._tag === "Acquired" && self.state.refCount === 0) {
        self.state = stateEmpty2;
        return scopeClose(state.scope, exitVoid);
      }
      return void_3;
    })), ensuring2(sync(() => {
      state.fiber = void 0;
    })), forkIn2(self.scope), tap2((fiber) => {
      state.fiber = fiber;
    }), self.semaphore.withPermits(1));
  }))), map14(({
    state
  }) => state.value));
};

// ../../node_modules/effect/dist/esm/RcRef.js
var TypeId24 = TypeId23;
var make65 = make64;
var get16 = get15;

// ../../node_modules/effect/dist/esm/Runtime.js
var Runtime_exports = {};
__export(Runtime_exports, {
  FiberFailureCauseId: () => FiberFailureCauseId2,
  FiberFailureId: () => FiberFailureId2,
  defaultRuntime: () => defaultRuntime2,
  defaultRuntimeFlags: () => defaultRuntimeFlags2,
  deleteFiberRef: () => deleteFiberRef2,
  disableRuntimeFlag: () => disableRuntimeFlag2,
  enableRuntimeFlag: () => enableRuntimeFlag2,
  isAsyncFiberException: () => isAsyncFiberException2,
  isFiberFailure: () => isFiberFailure2,
  make: () => make66,
  makeFiberFailure: () => makeFiberFailure,
  provideService: () => provideService7,
  runCallback: () => runCallback2,
  runFork: () => runFork3,
  runPromise: () => runPromise3,
  runPromiseExit: () => runPromiseExit3,
  runSync: () => runSync3,
  runSyncExit: () => runSyncExit3,
  setFiberRef: () => setFiberRef2,
  updateContext: () => updateContext3,
  updateFiberRefs: () => updateFiberRefs4,
  updateRuntimeFlags: () => updateRuntimeFlags3
});
var runFork3 = unsafeFork3;
var runSyncExit3 = unsafeRunSyncExit;
var runSync3 = unsafeRunSync;
var runCallback2 = unsafeRunCallback;
var runPromise3 = unsafeRunPromise;
var runPromiseExit3 = unsafeRunPromiseExit;
var defaultRuntime2 = defaultRuntime;
var defaultRuntimeFlags2 = defaultRuntimeFlags;
var make66 = make56;
var FiberFailureId2 = Symbol.for("effect/Runtime/FiberFailure");
var FiberFailureCauseId2 = FiberFailureCauseId;
var isAsyncFiberException2 = isAsyncFiberException;
var isFiberFailure2 = isFiberFailure;
var makeFiberFailure = fiberFailure;
var updateRuntimeFlags3 = updateRuntimeFlags2;
var enableRuntimeFlag2 = enableRuntimeFlag;
var disableRuntimeFlag2 = disableRuntimeFlag;
var updateContext3 = updateContext2;
var provideService7 = provideService3;
var updateFiberRefs4 = updateFiberRefs2;
var setFiberRef2 = setFiberRef;
var deleteFiberRef2 = deleteFiberRef;

// ../../node_modules/effect/dist/esm/Schedule.js
var Schedule_exports = {};
__export(Schedule_exports, {
  CurrentIterationMetadata: () => CurrentIterationMetadata2,
  ScheduleDriverTypeId: () => ScheduleDriverTypeId2,
  ScheduleTypeId: () => ScheduleTypeId2,
  addDelay: () => addDelay2,
  addDelayEffect: () => addDelayEffect2,
  andThen: () => andThen12,
  andThenEither: () => andThenEither2,
  as: () => as11,
  asVoid: () => asVoid8,
  bothInOut: () => bothInOut2,
  check: () => check3,
  checkEffect: () => checkEffect2,
  collectAllInputs: () => collectAllInputs2,
  collectAllOutputs: () => collectAllOutputs2,
  collectUntil: () => collectUntil2,
  collectUntilEffect: () => collectUntilEffect2,
  collectWhile: () => collectWhile2,
  collectWhileEffect: () => collectWhileEffect2,
  compose: () => compose5,
  count: () => count4,
  cron: () => cron2,
  dayOfMonth: () => dayOfMonth2,
  dayOfWeek: () => dayOfWeek2,
  delayed: () => delayed2,
  delayedEffect: () => delayedEffect2,
  delayedSchedule: () => delayedSchedule2,
  delays: () => delays2,
  driver: () => driver2,
  duration: () => duration2,
  either: () => either7,
  eitherWith: () => eitherWith2,
  elapsed: () => elapsed2,
  ensuring: () => ensuring7,
  exponential: () => exponential3,
  fibonacci: () => fibonacci2,
  fixed: () => fixed4,
  forever: () => forever5,
  fromDelay: () => fromDelay2,
  fromDelays: () => fromDelays2,
  fromFunction: () => fromFunction4,
  hourOfDay: () => hourOfDay2,
  identity: () => identity4,
  intersect: () => intersect6,
  intersectWith: () => intersectWith2,
  isSchedule: () => isSchedule2,
  jittered: () => jittered2,
  jitteredWith: () => jitteredWith2,
  linear: () => linear3,
  makeWithState: () => makeWithState2,
  map: () => map30,
  mapBoth: () => mapBoth7,
  mapBothEffect: () => mapBothEffect2,
  mapEffect: () => mapEffect7,
  mapInput: () => mapInput9,
  mapInputContext: () => mapInputContext5,
  mapInputEffect: () => mapInputEffect4,
  minuteOfHour: () => minuteOfHour2,
  modifyDelay: () => modifyDelay2,
  modifyDelayEffect: () => modifyDelayEffect2,
  onDecision: () => onDecision2,
  once: () => once4,
  passthrough: () => passthrough4,
  provideContext: () => provideContext6,
  provideService: () => provideService8,
  recurUntil: () => recurUntil2,
  recurUntilEffect: () => recurUntilEffect2,
  recurUntilOption: () => recurUntilOption2,
  recurUpTo: () => recurUpTo2,
  recurWhile: () => recurWhile2,
  recurWhileEffect: () => recurWhileEffect2,
  recurs: () => recurs2,
  reduce: () => reduce18,
  reduceEffect: () => reduceEffect4,
  repeatForever: () => repeatForever,
  repetitions: () => repetitions2,
  resetAfter: () => resetAfter2,
  resetWhen: () => resetWhen2,
  run: () => run3,
  secondOfMinute: () => secondOfMinute2,
  spaced: () => spaced2,
  stop: () => stop2,
  succeed: () => succeed17,
  sync: () => sync12,
  tapInput: () => tapInput2,
  tapOutput: () => tapOutput2,
  unfold: () => unfold4,
  union: () => union14,
  unionWith: () => unionWith3,
  untilInput: () => untilInput2,
  untilInputEffect: () => untilInputEffect2,
  untilOutput: () => untilOutput2,
  untilOutputEffect: () => untilOutputEffect2,
  upTo: () => upTo2,
  whileInput: () => whileInput2,
  whileInputEffect: () => whileInputEffect2,
  whileOutput: () => whileOutput2,
  whileOutputEffect: () => whileOutputEffect2,
  windowed: () => windowed2,
  zipLeft: () => zipLeft10,
  zipRight: () => zipRight10,
  zipWith: () => zipWith15
});
var ScheduleTypeId2 = ScheduleTypeId;
var ScheduleDriverTypeId2 = ScheduleDriverTypeId;
var makeWithState2 = makeWithState;
var isSchedule2 = isSchedule;
var addDelay2 = addDelay;
var addDelayEffect2 = addDelayEffect;
var andThen12 = andThen10;
var andThenEither2 = andThenEither;
var as11 = as7;
var asVoid8 = asVoid5;
var bothInOut2 = bothInOut;
var check3 = check2;
var checkEffect2 = checkEffect;
var collectAllInputs2 = collectAllInputs;
var collectAllOutputs2 = collectAllOutputs;
var collectUntil2 = collectUntil;
var collectUntilEffect2 = collectUntilEffect;
var collectWhile2 = collectWhile;
var collectWhileEffect2 = collectWhileEffect;
var compose5 = compose4;
var mapInput9 = mapInput6;
var mapInputEffect4 = mapInputEffect;
var mapInputContext5 = mapInputContext2;
var count4 = count2;
var cron2 = cron;
var secondOfMinute2 = secondOfMinute;
var minuteOfHour2 = minuteOfHour;
var hourOfDay2 = hourOfDay;
var dayOfMonth2 = dayOfMonth;
var dayOfWeek2 = dayOfWeek;
var delayed2 = delayed;
var delayedEffect2 = delayedEffect;
var delayedSchedule2 = delayedSchedule;
var delays2 = delays;
var mapBoth7 = mapBoth5;
var mapBothEffect2 = mapBothEffect;
var driver2 = driver;
var duration2 = duration;
var either7 = either5;
var eitherWith2 = eitherWith;
var elapsed2 = elapsed;
var ensuring7 = ensuring3;
var exponential3 = exponential2;
var fibonacci2 = fibonacci;
var fixed4 = fixed3;
var forever5 = forever3;
var fromDelay2 = fromDelay;
var fromDelays2 = fromDelays;
var fromFunction4 = fromFunction2;
var identity4 = identity3;
var passthrough4 = passthrough2;
var intersect6 = intersect5;
var intersectWith2 = intersectWith;
var jittered2 = jittered;
var jitteredWith2 = jitteredWith;
var linear3 = linear2;
var map30 = map25;
var mapEffect7 = mapEffect4;
var modifyDelay2 = modifyDelay;
var modifyDelayEffect2 = modifyDelayEffect;
var onDecision2 = onDecision;
var once4 = once2;
var provideContext6 = provideContext3;
var provideService8 = provideService4;
var recurUntil2 = recurUntil;
var recurUntilEffect2 = recurUntilEffect;
var recurUntilOption2 = recurUntilOption;
var recurUpTo2 = recurUpTo;
var recurWhile2 = recurWhile;
var recurWhileEffect2 = recurWhileEffect;
var recurs2 = recurs;
var reduce18 = reduce16;
var reduceEffect4 = reduceEffect2;
var repeatForever = forever3;
var repetitions2 = repetitions;
var resetAfter2 = resetAfter;
var resetWhen2 = resetWhen;
var run3 = run;
var spaced2 = spaced;
var stop2 = stop;
var succeed17 = succeed11;
var sync12 = sync7;
var tapInput2 = tapInput;
var tapOutput2 = tapOutput;
var unfold4 = unfold3;
var union14 = union13;
var unionWith3 = unionWith2;
var untilInput2 = untilInput;
var untilInputEffect2 = untilInputEffect;
var untilOutput2 = untilOutput;
var untilOutputEffect2 = untilOutputEffect;
var upTo2 = upTo;
var whileInput2 = whileInput;
var whileInputEffect2 = whileInputEffect;
var whileOutput2 = whileOutput;
var whileOutputEffect2 = whileOutputEffect;
var windowed2 = windowed;
var zipLeft10 = zipLeft6;
var zipRight10 = zipRight6;
var zipWith15 = zipWith11;
var CurrentIterationMetadata2 = CurrentIterationMetadata;

// ../../node_modules/effect/dist/esm/StreamHaltStrategy.js
var StreamHaltStrategy_exports = {};
__export(StreamHaltStrategy_exports, {
  Both: () => Both2,
  Either: () => Either2,
  Left: () => Left2,
  Right: () => Right2,
  fromInput: () => fromInput3,
  isBoth: () => isBoth2,
  isEither: () => isEither4,
  isLeft: () => isLeft4,
  isRight: () => isRight4,
  match: () => match30
});

// ../../node_modules/effect/dist/esm/internal/opCodes/streamHaltStrategy.js
var OP_LEFT = "Left";
var OP_RIGHT = "Right";
var OP_BOTH = "Both";
var OP_EITHER = "Either";

// ../../node_modules/effect/dist/esm/internal/stream/haltStrategy.js
var Left = {
  _tag: OP_LEFT
};
var Right = {
  _tag: OP_RIGHT
};
var Both = {
  _tag: OP_BOTH
};
var Either = {
  _tag: OP_EITHER
};
var fromInput2 = (input) => {
  switch (input) {
    case "left":
      return Left;
    case "right":
      return Right;
    case "both":
      return Both;
    case "either":
      return Either;
    default:
      return input;
  }
};
var isLeft3 = (self) => self._tag === OP_LEFT;
var isRight3 = (self) => self._tag === OP_RIGHT;
var isBoth = (self) => self._tag === OP_BOTH;
var isEither3 = (self) => self._tag === OP_EITHER;
var match29 = dual(2, (self, options) => {
  switch (self._tag) {
    case OP_LEFT: {
      return options.onLeft();
    }
    case OP_RIGHT: {
      return options.onRight();
    }
    case OP_BOTH: {
      return options.onBoth();
    }
    case OP_EITHER: {
      return options.onEither();
    }
  }
});

// ../../node_modules/effect/dist/esm/StreamHaltStrategy.js
var Left2 = Left;
var Right2 = Right;
var Both2 = Both;
var Either2 = Either;
var fromInput3 = fromInput2;
var isLeft4 = isLeft3;
var isRight4 = isRight3;
var isBoth2 = isBoth;
var isEither4 = isEither3;
var match30 = match29;

// ../../node_modules/effect/dist/esm/TPubSub.js
var TPubSub_exports = {};
__export(TPubSub_exports, {
  TPubSubTypeId: () => TPubSubTypeId2,
  awaitShutdown: () => awaitShutdown7,
  bounded: () => bounded8,
  capacity: () => capacity8,
  dropping: () => dropping7,
  isEmpty: () => isEmpty21,
  isFull: () => isFull8,
  isShutdown: () => isShutdown7,
  publish: () => publish4,
  publishAll: () => publishAll4,
  shutdown: () => shutdown7,
  size: () => size23,
  sliding: () => sliding7,
  subscribe: () => subscribe4,
  subscribeScoped: () => subscribeScoped2,
  unbounded: () => unbounded8
});

// ../../node_modules/effect/dist/esm/internal/stm/versioned.js
var Versioned = class {
  value;
  constructor(value10) {
    this.value = value10;
  }
};

// ../../node_modules/effect/dist/esm/internal/stm/entry.js
var make67 = (ref, isNew) => ({
  ref,
  isNew,
  isChanged: false,
  expected: ref.versioned,
  newValue: ref.versioned.value
});
var unsafeGet8 = (self) => {
  return self.newValue;
};
var unsafeSet = (self, value10) => {
  self.isChanged = true;
  self.newValue = value10;
};
var commit = (self) => {
  self.ref.versioned = new Versioned(self.newValue);
};
var copy3 = (self) => ({
  ref: self.ref,
  isNew: self.isNew,
  isChanged: self.isChanged,
  expected: self.expected,
  newValue: self.newValue
});
var isInvalid = (self) => {
  return self.ref.versioned !== self.expected;
};
var isChanged = (self) => {
  return self.isChanged;
};

// ../../node_modules/effect/dist/esm/internal/stm/journal.js
var JournalAnalysisInvalid = "Invalid";
var JournalAnalysisReadWrite = "ReadWrite";
var JournalAnalysisReadOnly = "ReadOnly";
var commitJournal = (journal) => {
  for (const entry of journal) {
    commit(entry[1]);
  }
};
var analyzeJournal = (journal) => {
  let val = JournalAnalysisReadOnly;
  for (const [, entry] of journal) {
    val = isInvalid(entry) ? JournalAnalysisInvalid : isChanged(entry) ? JournalAnalysisReadWrite : val;
    if (val === JournalAnalysisInvalid) {
      return val;
    }
  }
  return val;
};
var prepareResetJournal = (journal) => {
  const saved = /* @__PURE__ */ new Map();
  for (const entry of journal) {
    saved.set(entry[0], copy3(entry[1]));
  }
  return () => {
    journal.clear();
    for (const entry of saved) {
      journal.set(entry[0], entry[1]);
    }
  };
};
var collectTodos = (journal) => {
  const allTodos = /* @__PURE__ */ new Map();
  for (const [, entry] of journal) {
    for (const todo of entry.ref.todos) {
      allTodos.set(todo[0], todo[1]);
    }
    entry.ref.todos = /* @__PURE__ */ new Map();
  }
  return allTodos;
};
var execTodos = (todos) => {
  const todosSorted = Array.from(todos.entries()).sort((x, y) => x[0] - y[0]);
  for (const [_, todo] of todosSorted) {
    todo();
  }
};
var addTodo = (txnId, journal, todoEffect) => {
  let added = false;
  for (const [, entry] of journal) {
    if (!entry.ref.todos.has(txnId)) {
      entry.ref.todos.set(txnId, todoEffect);
      added = true;
    }
  }
  return added;
};

// ../../node_modules/effect/dist/esm/internal/stm/opCodes/stm.js
var OP_WITH_STM_RUNTIME = "WithSTMRuntime";
var OP_ON_FAILURE2 = "OnFailure";
var OP_ON_RETRY = "OnRetry";
var OP_ON_SUCCESS2 = "OnSuccess";
var OP_PROVIDE3 = "Provide";
var OP_SYNC2 = "Sync";
var OP_SUCCEED2 = "Succeed";
var OP_RETRY = "Retry";
var OP_FAIL4 = "Fail";
var OP_DIE2 = "Die";
var OP_INTERRUPT2 = "Interrupt";

// ../../node_modules/effect/dist/esm/internal/stm/opCodes/tExit.js
var OP_FAIL5 = "Fail";
var OP_DIE3 = "Die";
var OP_INTERRUPT3 = "Interrupt";
var OP_SUCCEED3 = "Succeed";
var OP_RETRY2 = "Retry";

// ../../node_modules/effect/dist/esm/internal/stm/opCodes/tryCommit.js
var OP_DONE5 = "Done";
var OP_SUSPEND3 = "Suspend";

// ../../node_modules/effect/dist/esm/internal/stm/opCodes/stmState.js
var OP_DONE6 = "Done";
var OP_INTERRUPTED = "Interrupted";
var OP_RUNNING2 = "Running";

// ../../node_modules/effect/dist/esm/internal/stm/stmState.js
var STMStateSymbolKey = "effect/STM/State";
var STMStateTypeId = Symbol.for(STMStateSymbolKey);
var isSTMState = (u) => hasProperty(u, STMStateTypeId);
var isRunning3 = (self) => {
  return self._tag === OP_RUNNING2;
};
var isDone6 = (self) => {
  return self._tag === OP_DONE6;
};
var done9 = (exit4) => {
  return {
    [STMStateTypeId]: STMStateTypeId,
    _tag: OP_DONE6,
    exit: exit4,
    [symbol2]() {
      return pipe(hash(STMStateSymbolKey), combine2(hash(OP_DONE6)), combine2(hash(exit4)), cached(this));
    },
    [symbol3](that) {
      return isSTMState(that) && that._tag === OP_DONE6 && equals(exit4, that.exit);
    }
  };
};
var interruptedHash = pipe(hash(STMStateSymbolKey), combine2(hash(OP_INTERRUPTED)), combine2(hash("interrupted")));
var interrupted3 = {
  [STMStateTypeId]: STMStateTypeId,
  _tag: OP_INTERRUPTED,
  [symbol2]() {
    return interruptedHash;
  },
  [symbol3](that) {
    return isSTMState(that) && that._tag === OP_INTERRUPTED;
  }
};
var runningHash = pipe(hash(STMStateSymbolKey), combine2(hash(OP_RUNNING2)), combine2(hash("running")));
var running3 = {
  [STMStateTypeId]: STMStateTypeId,
  _tag: OP_RUNNING2,
  [symbol2]() {
    return runningHash;
  },
  [symbol3](that) {
    return isSTMState(that) && that._tag === OP_RUNNING2;
  }
};
var fromTExit = (tExit) => {
  switch (tExit._tag) {
    case OP_FAIL5: {
      return done9(fail4(tExit.error));
    }
    case OP_DIE3: {
      return done9(die4(tExit.defect));
    }
    case OP_INTERRUPT3: {
      return done9(interrupt4(tExit.fiberId));
    }
    case OP_SUCCEED3: {
      return done9(succeed3(tExit.value));
    }
    case OP_RETRY2: {
      throw new Error("BUG: STM.STMState.fromTExit - please report an issue at https://github.com/Effect-TS/effect/issues");
    }
  }
};

// ../../node_modules/effect/dist/esm/internal/stm/tExit.js
var TExitSymbolKey = "effect/TExit";
var TExitTypeId = Symbol.for(TExitSymbolKey);
var variance9 = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _E: (_) => _
};
var isExit2 = (u) => hasProperty(u, TExitTypeId);
var isSuccess4 = (self) => {
  return self._tag === OP_SUCCEED3;
};
var isRetry = (self) => {
  return self._tag === OP_RETRY2;
};
var fail16 = (error4) => ({
  [TExitTypeId]: variance9,
  _tag: OP_FAIL5,
  error: error4,
  [symbol2]() {
    return pipe(hash(TExitSymbolKey), combine2(hash(OP_FAIL5)), combine2(hash(error4)), cached(this));
  },
  [symbol3](that) {
    return isExit2(that) && that._tag === OP_FAIL5 && equals(error4, that.error);
  }
});
var die11 = (defect) => ({
  [TExitTypeId]: variance9,
  _tag: OP_DIE3,
  defect,
  [symbol2]() {
    return pipe(hash(TExitSymbolKey), combine2(hash(OP_DIE3)), combine2(hash(defect)), cached(this));
  },
  [symbol3](that) {
    return isExit2(that) && that._tag === OP_DIE3 && equals(defect, that.defect);
  }
});
var interrupt9 = (fiberId5) => ({
  [TExitTypeId]: variance9,
  _tag: OP_INTERRUPT3,
  fiberId: fiberId5,
  [symbol2]() {
    return pipe(hash(TExitSymbolKey), combine2(hash(OP_INTERRUPT3)), combine2(hash(fiberId5)), cached(this));
  },
  [symbol3](that) {
    return isExit2(that) && that._tag === OP_INTERRUPT3 && equals(fiberId5, that.fiberId);
  }
});
var succeed18 = (value10) => ({
  [TExitTypeId]: variance9,
  _tag: OP_SUCCEED3,
  value: value10,
  [symbol2]() {
    return pipe(hash(TExitSymbolKey), combine2(hash(OP_SUCCEED3)), combine2(hash(value10)), cached(this));
  },
  [symbol3](that) {
    return isExit2(that) && that._tag === OP_SUCCEED3 && equals(value10, that.value);
  }
});
var retryHash = pipe(hash(TExitSymbolKey), combine2(hash(OP_RETRY2)), combine2(hash("retry")));
var retry5 = {
  [TExitTypeId]: variance9,
  _tag: OP_RETRY2,
  [symbol2]() {
    return retryHash;
  },
  [symbol3](that) {
    return isExit2(that) && isRetry(that);
  }
};
var void_9 = succeed18(void 0);

// ../../node_modules/effect/dist/esm/internal/stm/tryCommit.js
var done10 = (exit4) => {
  return {
    _tag: OP_DONE5,
    exit: exit4
  };
};
var suspend8 = (journal) => {
  return {
    _tag: OP_SUSPEND3,
    journal
  };
};

// ../../node_modules/effect/dist/esm/internal/stm/txnId.js
var txnCounter = {
  ref: 0
};
var make68 = () => {
  const newId = txnCounter.ref + 1;
  txnCounter.ref = newId;
  return newId;
};

// ../../node_modules/effect/dist/esm/internal/stm/core.js
var STMSymbolKey2 = "effect/STM";
var STMTypeId2 = Symbol.for(STMSymbolKey2);
var stmVariance = {
  /* c8 ignore next */
  _R: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var STMPrimitive = class {
  effect_instruction_i0;
  _op = OP_COMMIT;
  effect_instruction_i1 = void 0;
  effect_instruction_i2 = void 0;
  [EffectTypeId4];
  [StreamTypeId];
  [SinkTypeId3];
  [ChannelTypeId3];
  get [STMTypeId2]() {
    return stmVariance;
  }
  constructor(effect_instruction_i0) {
    this.effect_instruction_i0 = effect_instruction_i0;
    this[EffectTypeId4] = effectVariance;
    this[StreamTypeId] = stmVariance;
    this[SinkTypeId3] = stmVariance;
    this[ChannelTypeId3] = stmVariance;
  }
  [symbol3](that) {
    return this === that;
  }
  [symbol2]() {
    return cached(this, random(this));
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
  commit() {
    return unsafeAtomically(this, constVoid, constVoid);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isSTM = (u) => hasProperty(u, STMTypeId2);
var commit2 = (self) => unsafeAtomically(self, constVoid, constVoid);
var unsafeAtomically = (self, onDone3, onInterrupt4) => withFiberRuntime((state) => {
  const fiberId5 = state.id();
  const env = state.getFiberRef(currentContext2);
  const scheduler2 = state.getFiberRef(currentScheduler2);
  const priority = state.getFiberRef(currentSchedulingPriority2);
  const commitResult = tryCommitSync(fiberId5, self, env, scheduler2, priority);
  switch (commitResult._tag) {
    case OP_DONE5: {
      onDone3(commitResult.exit);
      return commitResult.exit;
    }
    case OP_SUSPEND3: {
      const txnId = make68();
      const state2 = {
        value: running3
      };
      const effect4 = async2((k) => tryCommitAsync(fiberId5, self, txnId, state2, env, scheduler2, priority, k));
      return uninterruptibleMask3((restore) => pipe(restore(effect4), catchAllCause4((cause3) => {
        let currentState = state2.value;
        if (isRunning3(currentState)) {
          state2.value = interrupted3;
        }
        currentState = state2.value;
        if (isDone6(currentState)) {
          onDone3(currentState.exit);
          return currentState.exit;
        }
        onInterrupt4();
        return failCause10(cause3);
      })));
    }
  }
});
var tryCommit = (fiberId5, stm, state, env, scheduler2, priority) => {
  const journal = /* @__PURE__ */ new Map();
  const tExit = new STMDriver(stm, journal, fiberId5, env).run();
  const analysis = analyzeJournal(journal);
  if (analysis === JournalAnalysisReadWrite) {
    commitJournal(journal);
  } else if (analysis === JournalAnalysisInvalid) {
    throw new Error("BUG: STM.TryCommit.tryCommit - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  switch (tExit._tag) {
    case OP_SUCCEED3: {
      state.value = fromTExit(tExit);
      return completeTodos(succeed3(tExit.value), journal, scheduler2, priority);
    }
    case OP_FAIL5: {
      state.value = fromTExit(tExit);
      const cause3 = fail8(tExit.error);
      return completeTodos(failCause3(cause3), journal, scheduler2, priority);
    }
    case OP_DIE3: {
      state.value = fromTExit(tExit);
      const cause3 = die6(tExit.defect);
      return completeTodos(failCause3(cause3), journal, scheduler2, priority);
    }
    case OP_INTERRUPT3: {
      state.value = fromTExit(tExit);
      const cause3 = interrupt6(fiberId5);
      return completeTodos(failCause3(cause3), journal, scheduler2, priority);
    }
    case OP_RETRY2: {
      return suspend8(journal);
    }
  }
};
var tryCommitSync = (fiberId5, stm, env, scheduler2, priority) => {
  const journal = /* @__PURE__ */ new Map();
  const tExit = new STMDriver(stm, journal, fiberId5, env).run();
  const analysis = analyzeJournal(journal);
  if (analysis === JournalAnalysisReadWrite && isSuccess4(tExit)) {
    commitJournal(journal);
  } else if (analysis === JournalAnalysisInvalid) {
    throw new Error("BUG: STM.TryCommit.tryCommitSync - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  switch (tExit._tag) {
    case OP_SUCCEED3: {
      return completeTodos(succeed3(tExit.value), journal, scheduler2, priority);
    }
    case OP_FAIL5: {
      const cause3 = fail8(tExit.error);
      return completeTodos(failCause3(cause3), journal, scheduler2, priority);
    }
    case OP_DIE3: {
      const cause3 = die6(tExit.defect);
      return completeTodos(failCause3(cause3), journal, scheduler2, priority);
    }
    case OP_INTERRUPT3: {
      const cause3 = interrupt6(fiberId5);
      return completeTodos(failCause3(cause3), journal, scheduler2, priority);
    }
    case OP_RETRY2: {
      return suspend8(journal);
    }
  }
};
var tryCommitAsync = (fiberId5, self, txnId, state, context15, scheduler2, priority, k) => {
  if (isRunning3(state.value)) {
    const result = tryCommit(fiberId5, self, state, context15, scheduler2, priority);
    switch (result._tag) {
      case OP_DONE5: {
        completeTryCommit(result.exit, k);
        break;
      }
      case OP_SUSPEND3: {
        addTodo(txnId, result.journal, () => tryCommitAsync(fiberId5, self, txnId, state, context15, scheduler2, priority, k));
        break;
      }
    }
  }
};
var completeTodos = (exit4, journal, scheduler2, priority) => {
  const todos = collectTodos(journal);
  if (todos.size > 0) {
    scheduler2.scheduleTask(() => execTodos(todos), priority);
  }
  return done10(exit4);
};
var completeTryCommit = (exit4, k) => {
  k(exit4);
};
var context9 = () => effect3((_, __, env) => env);
var contextWith5 = (f) => map31(context9(), f);
var contextWithSTM = (f) => flatMap22(context9(), f);
var STMDriver = class {
  self;
  journal;
  fiberId;
  contStack = [];
  env;
  constructor(self, journal, fiberId5, r0) {
    this.self = self;
    this.journal = journal;
    this.fiberId = fiberId5;
    this.env = r0;
  }
  getEnv() {
    return this.env;
  }
  pushStack(cont) {
    this.contStack.push(cont);
  }
  popStack() {
    return this.contStack.pop();
  }
  nextSuccess() {
    let current2 = this.popStack();
    while (current2 !== void 0 && current2.effect_instruction_i0 !== OP_ON_SUCCESS2) {
      current2 = this.popStack();
    }
    return current2;
  }
  nextFailure() {
    let current2 = this.popStack();
    while (current2 !== void 0 && current2.effect_instruction_i0 !== OP_ON_FAILURE2) {
      current2 = this.popStack();
    }
    return current2;
  }
  nextRetry() {
    let current2 = this.popStack();
    while (current2 !== void 0 && current2.effect_instruction_i0 !== OP_ON_RETRY) {
      current2 = this.popStack();
    }
    return current2;
  }
  run() {
    let curr = this.self;
    let exit4 = void 0;
    while (exit4 === void 0 && curr !== void 0) {
      try {
        const current2 = curr;
        if (current2) {
          switch (current2._op) {
            case "Tag": {
              curr = effect3((_, __, env) => unsafeGet3(env, current2));
              break;
            }
            case "Left": {
              curr = fail17(current2.left);
              break;
            }
            case "None": {
              curr = fail17(new NoSuchElementException3());
              break;
            }
            case "Right": {
              curr = succeed19(current2.right);
              break;
            }
            case "Some": {
              curr = succeed19(current2.value);
              break;
            }
            case "Commit": {
              switch (current2.effect_instruction_i0) {
                case OP_DIE2: {
                  exit4 = die11(internalCall(() => current2.effect_instruction_i1()));
                  break;
                }
                case OP_FAIL4: {
                  const cont = this.nextFailure();
                  if (cont === void 0) {
                    exit4 = fail16(internalCall(() => current2.effect_instruction_i1()));
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2(internalCall(() => current2.effect_instruction_i1())));
                  }
                  break;
                }
                case OP_RETRY: {
                  const cont = this.nextRetry();
                  if (cont === void 0) {
                    exit4 = retry5;
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2());
                  }
                  break;
                }
                case OP_INTERRUPT2: {
                  exit4 = interrupt9(this.fiberId);
                  break;
                }
                case OP_WITH_STM_RUNTIME: {
                  curr = internalCall(() => current2.effect_instruction_i1(this));
                  break;
                }
                case OP_ON_SUCCESS2:
                case OP_ON_FAILURE2:
                case OP_ON_RETRY: {
                  this.pushStack(current2);
                  curr = current2.effect_instruction_i1;
                  break;
                }
                case OP_PROVIDE3: {
                  const env = this.env;
                  this.env = internalCall(() => current2.effect_instruction_i2(env));
                  curr = pipe(current2.effect_instruction_i1, ensuring8(sync13(() => this.env = env)));
                  break;
                }
                case OP_SUCCEED2: {
                  const value10 = current2.effect_instruction_i1;
                  const cont = this.nextSuccess();
                  if (cont === void 0) {
                    exit4 = succeed18(value10);
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2(value10));
                  }
                  break;
                }
                case OP_SYNC2: {
                  const value10 = internalCall(() => current2.effect_instruction_i1());
                  const cont = this.nextSuccess();
                  if (cont === void 0) {
                    exit4 = succeed18(value10);
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2(value10));
                  }
                  break;
                }
              }
              break;
            }
          }
        }
      } catch (e) {
        curr = die12(e);
      }
    }
    return exit4;
  }
};
var catchAll7 = dual(2, (self, f) => {
  const stm = new STMPrimitive(OP_ON_FAILURE2);
  stm.effect_instruction_i1 = self;
  stm.effect_instruction_i2 = f;
  return stm;
});
var mapInputContext6 = dual(2, (self, f) => {
  const stm = new STMPrimitive(OP_PROVIDE3);
  stm.effect_instruction_i1 = self;
  stm.effect_instruction_i2 = f;
  return stm;
});
var die12 = (defect) => dieSync7(() => defect);
var dieMessage4 = (message) => dieSync7(() => new RuntimeException2(message));
var dieSync7 = (evaluate4) => {
  const stm = new STMPrimitive(OP_DIE2);
  stm.effect_instruction_i1 = evaluate4;
  return stm;
};
var effect3 = (f) => withSTMRuntime((_) => succeed19(f(_.journal, _.fiberId, _.getEnv())));
var ensuring8 = dual(2, (self, finalizer3) => matchSTM(self, {
  onFailure: (e) => zipRight11(finalizer3, fail17(e)),
  onSuccess: (a) => zipRight11(finalizer3, succeed19(a))
}));
var fail17 = (error4) => failSync9(() => error4);
var failSync9 = (evaluate4) => {
  const stm = new STMPrimitive(OP_FAIL4);
  stm.effect_instruction_i1 = evaluate4;
  return stm;
};
var flatMap22 = dual(2, (self, f) => {
  const stm = new STMPrimitive(OP_ON_SUCCESS2);
  stm.effect_instruction_i1 = self;
  stm.effect_instruction_i2 = f;
  return stm;
});
var matchSTM = dual(2, (self, {
  onFailure,
  onSuccess
}) => pipe(self, map31(right2), catchAll7((e) => pipe(onFailure(e), map31(left2))), flatMap22((either14) => {
  switch (either14._tag) {
    case "Left": {
      return succeed19(either14.left);
    }
    case "Right": {
      return onSuccess(either14.right);
    }
  }
})));
var withSTMRuntime = (f) => {
  const stm = new STMPrimitive(OP_WITH_STM_RUNTIME);
  stm.effect_instruction_i1 = f;
  return stm;
};
var interrupt10 = withSTMRuntime((_) => {
  const stm = new STMPrimitive(OP_INTERRUPT2);
  stm.effect_instruction_i1 = _.fiberId;
  return stm;
});
var interruptAs2 = (fiberId5) => {
  const stm = new STMPrimitive(OP_INTERRUPT2);
  stm.effect_instruction_i1 = fiberId5;
  return stm;
};
var map31 = dual(2, (self, f) => pipe(self, flatMap22((a) => sync13(() => f(a)))));
var orTry = dual(2, (self, that) => {
  const stm = new STMPrimitive(OP_ON_RETRY);
  stm.effect_instruction_i1 = self;
  stm.effect_instruction_i2 = that;
  return stm;
});
var retry6 = new STMPrimitive(OP_RETRY);
var succeed19 = (value10) => {
  const stm = new STMPrimitive(OP_SUCCEED2);
  stm.effect_instruction_i1 = value10;
  return stm;
};
var sync13 = (evaluate4) => {
  const stm = new STMPrimitive(OP_SYNC2);
  stm.effect_instruction_i1 = evaluate4;
  return stm;
};
var zip15 = dual(2, (self, that) => pipe(self, zipWith16(that, (a, a1) => [a, a1])));
var zipLeft11 = dual(2, (self, that) => pipe(self, flatMap22((a) => pipe(that, map31(() => a)))));
var zipRight11 = dual(2, (self, that) => pipe(self, flatMap22(() => that)));
var zipWith16 = dual(3, (self, that, f) => pipe(self, flatMap22((a) => pipe(that, map31((b) => f(a, b))))));

// ../../node_modules/effect/dist/esm/internal/stm/opCodes/strategy.js
var OP_BACKPRESSURE_STRATEGY = "BackPressure";
var OP_DROPPING_STRATEGY = "Dropping";
var OP_SLIDING_STRATEGY = "Sliding";

// ../../node_modules/effect/dist/esm/internal/stm/stm.js
var acquireUseRelease5 = dual(3, (acquire4, use2, release4) => uninterruptibleMask3((restore) => {
  let state = running3;
  return pipe(restore(unsafeAtomically(acquire4, (exit4) => {
    state = done9(exit4);
  }, () => {
    state = interrupted3;
  })), matchCauseEffect3({
    onFailure: (cause3) => {
      if (isDone6(state) && isSuccess(state.exit)) {
        return pipe(release4(state.exit.value), matchCauseEffect3({
          onFailure: (cause22) => failCause10(parallel4(cause3, cause22)),
          onSuccess: () => failCause10(cause3)
        }));
      }
      return failCause10(cause3);
    },
    onSuccess: (a) => pipe(restore(use2(a)), matchCauseEffect3({
      onFailure: (cause3) => pipe(release4(a), matchCauseEffect3({
        onFailure: (cause22) => failCause10(parallel4(cause3, cause22)),
        onSuccess: () => failCause10(cause3)
      })),
      onSuccess: (a2) => pipe(release4(a), as8(a2))
    }))
  }));
}));
var as12 = dual(2, (self, value10) => pipe(self, map31(() => value10)));
var asSome4 = (self) => pipe(self, map31(some3));
var asSomeError3 = (self) => pipe(self, mapError9(some3));
var asVoid9 = (self) => pipe(self, map31(constVoid));
var attempt = (evaluate4) => suspend9(() => {
  try {
    return succeed19(evaluate4());
  } catch (defect) {
    return fail17(defect);
  }
});
var bind8 = dual(3, (self, tag5, f) => flatMap22(self, (k) => map31(f(k), (a) => ({
  ...k,
  [tag5]: a
}))));
var bindTo8 = dual(2, (self, tag5) => map31(self, (a) => ({
  [tag5]: a
})));
var let_8 = dual(3, (self, tag5, f) => map31(self, (k) => ({
  ...k,
  [tag5]: f(k)
})));
var catchSome3 = dual(2, (self, pf) => catchAll7(self, (e) => getOrElse2(pf(e), () => fail17(e))));
var catchTag4 = dual(3, (self, k, f) => catchAll7(self, (e) => {
  if ("_tag" in e && e["_tag"] === k) {
    return f(e);
  }
  return fail17(e);
}));
var catchTags3 = dual(2, (self, cases) => catchAll7(self, (e) => {
  const keys15 = Object.keys(cases);
  if ("_tag" in e && keys15.includes(e["_tag"])) {
    return cases[e["_tag"]](e);
  }
  return fail17(e);
}));
var check4 = (predicate) => suspend9(() => predicate() ? void_10 : retry6);
var collect3 = dual(2, (self, pf) => collectSTM(self, (a) => map2(pf(a), succeed19)));
var collectSTM = dual(2, (self, pf) => matchSTM(self, {
  onFailure: fail17,
  onSuccess: (a) => {
    const option11 = pf(a);
    return isSome2(option11) ? option11.value : retry6;
  }
}));
var commitEither = (self) => flatten13(commit2(either8(self)));
var cond = (predicate, error4, result) => {
  return suspend9(() => predicate() ? sync13(result) : failSync9(error4));
};
var either8 = (self) => match31(self, {
  onFailure: left2,
  onSuccess: right2
});
var eventually3 = (self) => matchSTM(self, {
  onFailure: () => eventually3(self),
  onSuccess: succeed19
});
var every15 = dual(2, (iterable, predicate) => flatMap22(sync13(() => iterable[Symbol.iterator]()), (iterator) => {
  const loop5 = suspend9(() => {
    const next6 = iterator.next();
    if (next6.done) {
      return succeed19(true);
    }
    return pipe(predicate(next6.value), flatMap22((bool) => bool ? loop5 : succeed19(bool)));
  });
  return loop5;
}));
var exists5 = dual(2, (iterable, predicate) => flatMap22(sync13(() => iterable[Symbol.iterator]()), (iterator) => {
  const loop5 = suspend9(() => {
    const next6 = iterator.next();
    if (next6.done) {
      return succeed19(false);
    }
    return flatMap22(predicate(next6.value), (bool) => bool ? succeed19(bool) : loop5);
  });
  return loop5;
}));
var fiberId3 = effect3((_, fiberId5) => fiberId5);
var filter17 = dual(2, (iterable, predicate) => Array.from(iterable).reduce((acc, curr) => pipe(acc, zipWith16(predicate(curr), (as18, p) => {
  if (p) {
    as18.push(curr);
    return as18;
  }
  return as18;
})), succeed19([])));
var filterNot = dual(2, (iterable, predicate) => filter17(iterable, (a) => negate5(predicate(a))));
var filterOrDie3 = dual(3, (self, predicate, defect) => filterOrElse3(self, predicate, () => dieSync7(defect)));
var filterOrDieMessage3 = dual(3, (self, predicate, message) => filterOrElse3(self, predicate, () => dieMessage4(message)));
var filterOrElse3 = dual(3, (self, predicate, orElse24) => flatMap22(self, (a) => predicate(a) ? succeed19(a) : orElse24(a)));
var filterOrFail4 = dual(3, (self, predicate, orFailWith) => filterOrElse3(self, predicate, (a) => failSync9(() => orFailWith(a))));
var flatten16 = (self) => flatMap22(self, identity);
var flip6 = (self) => matchSTM(self, {
  onFailure: succeed19,
  onSuccess: fail17
});
var flipWith3 = dual(2, (self, f) => flip6(f(flip6(self))));
var match31 = dual(2, (self, {
  onFailure,
  onSuccess
}) => matchSTM(self, {
  onFailure: (e) => succeed19(onFailure(e)),
  onSuccess: (a) => succeed19(onSuccess(a))
}));
var forEach18 = dual((args2) => isIterable(args2[0]), (iterable, f, options) => {
  if (options?.discard) {
    return pipe(sync13(() => iterable[Symbol.iterator]()), flatMap22((iterator) => {
      const loop5 = suspend9(() => {
        const next6 = iterator.next();
        if (next6.done) {
          return void_10;
        }
        return pipe(f(next6.value), flatMap22(() => loop5));
      });
      return loop5;
    }));
  }
  return suspend9(() => fromIterable2(iterable).reduce((acc, curr) => zipWith16(acc, f(curr), (array8, elem) => {
    array8.push(elem);
    return array8;
  }), succeed19([])));
});
var fromEither4 = (either14) => {
  switch (either14._tag) {
    case "Left": {
      return fail17(either14.left);
    }
    case "Right": {
      return succeed19(either14.right);
    }
  }
};
var fromOption7 = (option11) => match2(option11, {
  onNone: () => fail17(none2()),
  onSome: succeed19
});
var gen7 = (...args2) => suspend9(() => {
  const f = args2.length === 1 ? args2[0] : args2[1].bind(args2[0]);
  const iterator = f(pipe);
  const state = iterator.next();
  const run10 = (state2) => state2.done ? succeed19(state2.value) : flatMap22(yieldWrapGet(state2.value), (val) => run10(iterator.next(val)));
  return run10(state);
});
var head9 = (self) => pipe(self, matchSTM({
  onFailure: (e) => fail17(some3(e)),
  onSuccess: (a) => {
    const i = a[Symbol.iterator]();
    const res = i.next();
    if (res.done) {
      return fail17(none2());
    } else {
      return succeed19(res.value);
    }
  }
}));
var if_3 = dual((args2) => typeof args2[0] === "boolean" || isSTM(args2[0]), (self, {
  onFalse,
  onTrue
}) => {
  if (typeof self === "boolean") {
    return self ? onTrue : onFalse;
  }
  return flatMap22(self, (bool) => bool ? onTrue : onFalse);
});
var ignore4 = (self) => match31(self, {
  onFailure: () => void_10,
  onSuccess: () => void_10
});
var isFailure6 = (self) => match31(self, {
  onFailure: constTrue,
  onSuccess: constFalse
});
var isSuccess5 = (self) => match31(self, {
  onFailure: constFalse,
  onSuccess: constTrue
});
var iterate3 = (initial, options) => iterateLoop(initial, options.while, options.body);
var iterateLoop = (initial, cont, body) => {
  if (cont(initial)) {
    return pipe(body(initial), flatMap22((z) => iterateLoop(z, cont, body)));
  }
  return succeed19(initial);
};
var loop3 = (initial, options) => options.discard ? loopDiscardLoop(initial, options.while, options.step, options.body) : map31(loopLoop(initial, options.while, options.step, options.body), (a) => Array.from(a));
var loopLoop = (initial, cont, inc, body) => {
  if (cont(initial)) {
    return pipe(body(initial), flatMap22((a) => pipe(loopLoop(inc(initial), cont, inc, body), map31(append3(a)))));
  }
  return succeed19(empty7());
};
var loopDiscardLoop = (initial, cont, inc, body) => {
  if (cont(initial)) {
    return pipe(body(initial), flatMap22(() => loopDiscardLoop(inc(initial), cont, inc, body)));
  }
  return void_10;
};
var mapAttempt = dual(2, (self, f) => matchSTM(self, {
  onFailure: (e) => fail17(e),
  onSuccess: (a) => attempt(() => f(a))
}));
var mapBoth8 = dual(2, (self, {
  onFailure,
  onSuccess
}) => matchSTM(self, {
  onFailure: (e) => fail17(onFailure(e)),
  onSuccess: (a) => succeed19(onSuccess(a))
}));
var mapError9 = dual(2, (self, f) => matchSTM(self, {
  onFailure: (e) => fail17(f(e)),
  onSuccess: succeed19
}));
var merge9 = (self) => matchSTM(self, {
  onFailure: (e) => succeed19(e),
  onSuccess: succeed19
});
var mergeAll8 = dual(3, (iterable, zero3, f) => suspend9(() => Array.from(iterable).reduce((acc, curr) => pipe(acc, zipWith16(curr, f)), succeed19(zero3))));
var negate5 = (self) => pipe(self, map31((b) => !b));
var none10 = (self) => matchSTM(self, {
  onFailure: (e) => fail17(some3(e)),
  onSuccess: match2({
    onNone: () => void_10,
    onSome: () => fail17(none2())
  })
});
var option5 = (self) => match31(self, {
  onFailure: () => none2(),
  onSuccess: some3
});
var orDie7 = (self) => pipe(self, orDieWith4(identity));
var orDieWith4 = dual(2, (self, f) => pipe(self, mapError9(f), catchAll7(die12)));
var orElse12 = dual(2, (self, that) => flatMap22(effect3((journal) => prepareResetJournal(journal)), (reset3) => pipe(orTry(self, () => flatMap22(sync13(reset3), that)), catchAll7(() => flatMap22(sync13(reset3), that)))));
var orElseEither6 = dual(2, (self, that) => orElse12(map31(self, left2), () => map31(that(), right2)));
var orElseFail3 = dual(2, (self, error4) => orElse12(self, () => failSync9(error4)));
var orElseOptional = dual(2, (self, that) => catchAll7(self, match2({
  onNone: that,
  onSome: (e) => fail17(some3(e))
})));
var orElseSucceed4 = dual(2, (self, value10) => orElse12(self, () => sync13(value10)));
var provideContext7 = dual(2, (self, env) => mapInputContext6(self, (_) => env));
var provideSomeContext2 = dual(2, (self, context15) => mapInputContext6(self, (parent) => merge3(parent, context15)));
var provideService9 = dual(3, (self, tag5, resource) => provideServiceSTM(self, tag5, succeed19(resource)));
var provideServiceSTM = dual(3, (self, tag5, stm) => contextWithSTM((env) => flatMap22(stm, (service4) => provideContext7(self, add2(env, tag5, service4)))));
var reduce19 = dual(3, (iterable, zero3, f) => suspend9(() => Array.from(iterable).reduce((acc, curr) => pipe(acc, flatMap22((s) => f(s, curr))), succeed19(zero3))));
var reduceAll = dual(3, (iterable, initial, f) => suspend9(() => Array.from(iterable).reduce((acc, curr) => pipe(acc, zipWith16(curr, f)), initial)));
var reduceRight6 = dual(3, (iterable, zero3, f) => suspend9(() => Array.from(iterable).reduceRight((acc, curr) => pipe(acc, flatMap22((s) => f(s, curr))), succeed19(zero3))));
var refineOrDie2 = dual(2, (self, pf) => refineOrDieWith2(self, pf, identity));
var refineOrDieWith2 = dual(3, (self, pf, f) => catchAll7(self, (e) => match2(pf(e), {
  onNone: () => die12(f(e)),
  onSome: fail17
})));
var reject = dual(2, (self, pf) => rejectSTM(self, (a) => map2(pf(a), fail17)));
var rejectSTM = dual(2, (self, pf) => flatMap22(self, (a) => match2(pf(a), {
  onNone: () => succeed19(a),
  onSome: flatMap22(fail17)
})));
var repeatUntil = dual(2, (self, predicate) => repeatUntilLoop(self, predicate));
var repeatUntilLoop = (self, predicate) => flatMap22(self, (a) => predicate(a) ? succeed19(a) : repeatUntilLoop(self, predicate));
var repeatWhile = dual(2, (self, predicate) => repeatWhileLoop(self, predicate));
var repeatWhileLoop = (self, predicate) => flatMap22(self, (a) => predicate(a) ? repeatWhileLoop(self, predicate) : succeed19(a));
var replicate6 = dual(2, (self, n) => Array.from({
  length: n
}, () => self));
var replicateSTM = dual(2, (self, n) => all12(replicate6(self, n)));
var replicateSTMDiscard = dual(2, (self, n) => all12(replicate6(self, n), {
  discard: true
}));
var retryUntil = dual(2, (self, predicate) => matchSTM(self, {
  onFailure: fail17,
  onSuccess: (a) => predicate(a) ? succeed19(a) : retry6
}));
var retryWhile = dual(2, (self, predicate) => matchSTM(self, {
  onFailure: fail17,
  onSuccess: (a) => !predicate(a) ? succeed19(a) : retry6
}));
var partition10 = dual(2, (elements, f) => pipe(forEach18(elements, (a) => either8(f(a))), map31((as18) => partitionMap6(as18, identity))));
var some16 = (self) => matchSTM(self, {
  onFailure: (e) => fail17(some3(e)),
  onSuccess: match2({
    onNone: () => fail17(none2()),
    onSome: succeed19
  })
});
var all12 = (input, options) => {
  if (Symbol.iterator in input) {
    return forEach18(input, identity, options);
  } else if (options?.discard) {
    return forEach18(Object.values(input), identity, options);
  }
  return map31(forEach18(Object.entries(input), ([_, e]) => map31(e, (a) => [_, a])), (values15) => {
    const res = {};
    for (const [k, v] of values15) {
      ;
      res[k] = v;
    }
    return res;
  });
};
var succeedNone4 = succeed19(none2());
var succeedSome4 = (value10) => succeed19(some3(value10));
var summarized4 = dual(3, (self, summary11, f) => flatMap22(summary11, (start5) => flatMap22(self, (value10) => map31(summary11, (end7) => [f(start5, end7), value10]))));
var suspend9 = (evaluate4) => flatten16(sync13(evaluate4));
var tap7 = dual(2, (self, f) => flatMap22(self, (a) => as12(f(a), a)));
var tapBoth3 = dual(2, (self, {
  onFailure,
  onSuccess
}) => matchSTM(self, {
  onFailure: (e) => pipe(onFailure(e), zipRight11(fail17(e))),
  onSuccess: (a) => pipe(onSuccess(a), as12(a))
}));
var tapError6 = dual(2, (self, f) => matchSTM(self, {
  onFailure: (e) => zipRight11(f(e), fail17(e)),
  onSuccess: succeed19
}));
var try_5 = (arg) => {
  const evaluate4 = typeof arg === "function" ? arg : arg.try;
  return suspend9(() => {
    try {
      return succeed19(evaluate4());
    } catch (error4) {
      return fail17("catch" in arg ? arg.catch(error4) : error4);
    }
  });
};
var void_10 = succeed19(void 0);
var unless3 = dual(2, (self, predicate) => suspend9(() => predicate() ? succeedNone4 : asSome4(self)));
var unlessSTM = dual(2, (self, predicate) => flatMap22(predicate, (bool) => bool ? succeedNone4 : asSome4(self)));
var unsome = (self) => matchSTM(self, {
  onFailure: match2({
    onNone: () => succeed19(none2()),
    onSome: fail17
  }),
  onSuccess: (a) => succeed19(some3(a))
});
var validateAll3 = dual(2, (elements, f) => flatMap22(partition10(elements, f), ([errors2, values15]) => isNonEmptyArray2(errors2) ? fail17(errors2) : succeed19(values15)));
var validateFirst3 = dual(2, (elements, f) => flip6(forEach18(elements, (a) => flip6(f(a)))));
var when4 = dual(2, (self, predicate) => suspend9(() => predicate() ? asSome4(self) : succeedNone4));
var whenSTM = dual(2, (self, predicate) => flatMap22(predicate, (bool) => bool ? asSome4(self) : succeedNone4));

// ../../node_modules/effect/dist/esm/internal/stm/tRef.js
var TRefSymbolKey = "effect/TRef";
var TRefTypeId = Symbol.for(TRefSymbolKey);
var tRefVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var TRefImpl = class {
  [TRefTypeId] = tRefVariance;
  /** @internal */
  todos;
  /** @internal */
  versioned;
  constructor(value10) {
    this.versioned = new Versioned(value10);
    this.todos = /* @__PURE__ */ new Map();
  }
  modify(f) {
    return effect3((journal) => {
      const entry = getOrMakeEntry(this, journal);
      const [retValue, newValue] = f(unsafeGet8(entry));
      unsafeSet(entry, newValue);
      return retValue;
    });
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make69 = (value10) => effect3((journal) => {
  const ref = new TRefImpl(value10);
  journal.set(ref, make67(ref, true));
  return ref;
});
var get17 = (self) => self.modify((a) => [a, a]);
var set10 = dual(2, (self, value10) => self.modify(() => [void 0, value10]));
var getAndSet5 = dual(2, (self, value10) => self.modify((a) => [a, value10]));
var getAndUpdate5 = dual(2, (self, f) => self.modify((a) => [a, f(a)]));
var getAndUpdateSome4 = dual(2, (self, f) => self.modify((a) => match2(f(a), {
  onNone: () => [a, a],
  onSome: (b) => [a, b]
})));
var setAndGet4 = dual(2, (self, value10) => self.modify(() => [value10, value10]));
var modify12 = dual(2, (self, f) => self.modify(f));
var modifySome4 = dual(3, (self, fallback, f) => self.modify((a) => match2(f(a), {
  onNone: () => [fallback, a],
  onSome: (b) => b
})));
var update8 = dual(2, (self, f) => self.modify((a) => [void 0, f(a)]));
var updateAndGet5 = dual(2, (self, f) => self.modify((a) => {
  const b = f(a);
  return [b, b];
}));
var updateSome4 = dual(2, (self, f) => self.modify((a) => [void 0, match2(f(a), {
  onNone: () => a,
  onSome: (b) => b
})]));
var updateSomeAndGet4 = dual(2, (self, f) => self.modify((a) => match2(f(a), {
  onNone: () => [a, a],
  onSome: (b) => [b, b]
})));
var getOrMakeEntry = (self, journal) => {
  if (journal.has(self)) {
    return journal.get(self);
  }
  const entry = make67(self, false);
  journal.set(self, entry);
  return entry;
};
var unsafeGet9 = dual(2, (self, journal) => unsafeGet8(getOrMakeEntry(self, journal)));
var unsafeSet2 = dual(3, (self, value10, journal) => {
  const entry = getOrMakeEntry(self, journal);
  unsafeSet(entry, value10);
  return void 0;
});

// ../../node_modules/effect/dist/esm/internal/stm/tQueue.js
var TEnqueueSymbolKey = "effect/TQueue/TEnqueue";
var TEnqueueTypeId = Symbol.for(TEnqueueSymbolKey);
var TDequeueSymbolKey = "effect/TQueue/TDequeue";
var TDequeueTypeId = Symbol.for(TDequeueSymbolKey);
var BackPressure2 = {
  _tag: OP_BACKPRESSURE_STRATEGY
};
var Dropping = {
  _tag: OP_DROPPING_STRATEGY
};
var Sliding = {
  _tag: OP_SLIDING_STRATEGY
};
var tDequeueVariance = {
  /* c8 ignore next */
  _Out: (_) => _
};
var tEnqueueVariance = {
  /* c8 ignore next */
  _In: (_) => _
};
var TQueueImpl = class {
  ref;
  requestedCapacity;
  strategy;
  [TDequeueTypeId] = tDequeueVariance;
  [TEnqueueTypeId] = tEnqueueVariance;
  constructor(ref, requestedCapacity, strategy) {
    this.ref = ref;
    this.requestedCapacity = requestedCapacity;
    this.strategy = strategy;
  }
  capacity() {
    return this.requestedCapacity;
  }
  size = withSTMRuntime((runtime8) => {
    const queue = unsafeGet9(this.ref, runtime8.journal);
    if (queue === void 0) {
      return interruptAs2(runtime8.fiberId);
    }
    return succeed19(queue.length);
  });
  isFull = map31(this.size, (size40) => size40 === this.requestedCapacity);
  isEmpty = map31(this.size, (size40) => size40 === 0);
  shutdown = withSTMRuntime((runtime8) => {
    unsafeSet2(this.ref, void 0, runtime8.journal);
    return void_10;
  });
  isShutdown = effect3((journal) => {
    const queue = unsafeGet9(this.ref, journal);
    return queue === void 0;
  });
  awaitShutdown = flatMap22(this.isShutdown, (isShutdown9) => isShutdown9 ? void_10 : retry6);
  offer(value10) {
    return withSTMRuntime((runtime8) => {
      const queue = pipe(this.ref, unsafeGet9(runtime8.journal));
      if (queue === void 0) {
        return interruptAs2(runtime8.fiberId);
      }
      if (queue.length < this.requestedCapacity) {
        queue.push(value10);
        unsafeSet2(this.ref, queue, runtime8.journal);
        return succeed19(true);
      }
      switch (this.strategy._tag) {
        case OP_BACKPRESSURE_STRATEGY: {
          return retry6;
        }
        case OP_DROPPING_STRATEGY: {
          return succeed19(false);
        }
        case OP_SLIDING_STRATEGY: {
          if (queue.length === 0) {
            return succeed19(true);
          }
          queue.shift();
          queue.push(value10);
          unsafeSet2(this.ref, queue, runtime8.journal);
          return succeed19(true);
        }
      }
    });
  }
  offerAll(iterable) {
    return withSTMRuntime((runtime8) => {
      const as18 = Array.from(iterable);
      const queue = unsafeGet9(this.ref, runtime8.journal);
      if (queue === void 0) {
        return interruptAs2(runtime8.fiberId);
      }
      if (queue.length + as18.length <= this.requestedCapacity) {
        unsafeSet2(this.ref, [...queue, ...as18], runtime8.journal);
        return succeed19(true);
      }
      switch (this.strategy._tag) {
        case OP_BACKPRESSURE_STRATEGY: {
          return retry6;
        }
        case OP_DROPPING_STRATEGY: {
          const forQueue = as18.slice(0, this.requestedCapacity - queue.length);
          unsafeSet2(this.ref, [...queue, ...forQueue], runtime8.journal);
          return succeed19(false);
        }
        case OP_SLIDING_STRATEGY: {
          const forQueue = as18.slice(0, this.requestedCapacity - queue.length);
          const toDrop = queue.length + forQueue.length - this.requestedCapacity;
          const newQueue = queue.slice(toDrop);
          unsafeSet2(this.ref, [...newQueue, ...forQueue], runtime8.journal);
          return succeed19(true);
        }
      }
    });
  }
  peek = withSTMRuntime((runtime8) => {
    const queue = unsafeGet9(this.ref, runtime8.journal);
    if (queue === void 0) {
      return interruptAs2(runtime8.fiberId);
    }
    if (queue.length === 0) {
      return retry6;
    }
    return succeed19(queue[0]);
  });
  peekOption = withSTMRuntime((runtime8) => {
    const queue = unsafeGet9(this.ref, runtime8.journal);
    if (queue === void 0) {
      return interruptAs2(runtime8.fiberId);
    }
    return succeed19(fromNullable2(queue[0]));
  });
  take = withSTMRuntime((runtime8) => {
    const queue = unsafeGet9(this.ref, runtime8.journal);
    if (queue === void 0) {
      return interruptAs2(runtime8.fiberId);
    }
    if (queue.length === 0) {
      return retry6;
    }
    const dequeued = queue.shift();
    unsafeSet2(this.ref, queue, runtime8.journal);
    return succeed19(dequeued);
  });
  takeAll = withSTMRuntime((runtime8) => {
    const queue = unsafeGet9(this.ref, runtime8.journal);
    if (queue === void 0) {
      return interruptAs2(runtime8.fiberId);
    }
    unsafeSet2(this.ref, [], runtime8.journal);
    return succeed19(queue);
  });
  takeUpTo(max13) {
    return withSTMRuntime((runtime8) => {
      const queue = unsafeGet9(this.ref, runtime8.journal);
      if (queue === void 0) {
        return interruptAs2(runtime8.fiberId);
      }
      const [toTake, remaining] = splitAt2(unsafeFromArray(queue), max13);
      unsafeSet2(this.ref, Array.from(remaining), runtime8.journal);
      return succeed19(Array.from(toTake));
    });
  }
};
var isTQueue = (u) => {
  return isTEnqueue(u) && isTDequeue(u);
};
var isTEnqueue = (u) => hasProperty(u, TEnqueueTypeId);
var isTDequeue = (u) => hasProperty(u, TDequeueTypeId);
var awaitShutdown5 = (self) => self.awaitShutdown;
var bounded6 = (requestedCapacity) => makeQueue(requestedCapacity, BackPressure2);
var capacity6 = (self) => {
  return self.capacity();
};
var dropping5 = (requestedCapacity) => makeQueue(requestedCapacity, Dropping);
var isEmpty19 = (self) => self.isEmpty;
var isFull6 = (self) => self.isFull;
var isShutdown5 = (self) => self.isShutdown;
var offer4 = dual(2, (self, value10) => self.offer(value10));
var offerAll4 = dual(2, (self, iterable) => self.offerAll(iterable));
var peek = (self) => self.peek;
var peekOption = (self) => self.peekOption;
var poll7 = (self) => pipe(self.takeUpTo(1), map31(head2));
var seek = dual(2, (self, predicate) => seekLoop(self, predicate));
var seekLoop = (self, predicate) => flatMap22(self.take, (a) => predicate(a) ? succeed19(a) : seekLoop(self, predicate));
var shutdown5 = (self) => self.shutdown;
var size21 = (self) => self.size;
var sliding5 = (requestedCapacity) => makeQueue(requestedCapacity, Sliding);
var take8 = (self) => self.take;
var takeAll3 = (self) => self.takeAll;
var takeBetween3 = dual(3, (self, min11, max13) => suspend9(() => {
  const takeRemainder = (min12, max14, acc) => {
    if (max14 < min12) {
      return succeed19(acc);
    }
    return pipe(self.takeUpTo(max14), flatMap22((taken) => {
      const remaining = min12 - taken.length;
      if (remaining === 1) {
        return pipe(self.take, map31((a) => pipe(acc, appendAll3(unsafeFromArray(taken)), append3(a))));
      }
      if (remaining > 1) {
        return pipe(self.take, flatMap22((a) => takeRemainder(remaining - 1, max14 - taken.length - 1, pipe(acc, appendAll3(unsafeFromArray(taken)), append3(a)))));
      }
      return succeed19(pipe(acc, appendAll3(unsafeFromArray(taken))));
    }));
  };
  return map31(takeRemainder(min11, max13, empty7()), (c) => Array.from(c));
}));
var takeN3 = dual(2, (self, n) => pipe(self, takeBetween3(n, n)));
var takeUpTo3 = dual(2, (self, max13) => self.takeUpTo(max13));
var unbounded6 = () => makeQueue(Number.MAX_SAFE_INTEGER, Dropping);
var makeQueue = (requestedCapacity, strategy) => map31(make69([]), (ref) => new TQueueImpl(ref, requestedCapacity, strategy));

// ../../node_modules/effect/dist/esm/internal/stm/tPubSub.js
var TPubSubSymbolKey = "effect/TPubSub";
var TPubSubTypeId = Symbol.for(TPubSubSymbolKey);
var AbsentValue2 = Symbol.for("effect/TPubSub/AbsentValue");
var makeNode2 = (head13, subscribers, tail5) => ({
  head: head13,
  subscribers,
  tail: tail5
});
var TPubSubImpl = class {
  pubsubSize;
  publisherHead;
  publisherTail;
  requestedCapacity;
  strategy;
  subscriberCount;
  subscribers;
  [TPubSubTypeId] = {
    _A: (_) => _
  };
  [TEnqueueTypeId] = tEnqueueVariance;
  constructor(pubsubSize, publisherHead, publisherTail, requestedCapacity, strategy, subscriberCount, subscribers) {
    this.pubsubSize = pubsubSize;
    this.publisherHead = publisherHead;
    this.publisherTail = publisherTail;
    this.requestedCapacity = requestedCapacity;
    this.strategy = strategy;
    this.subscriberCount = subscriberCount;
    this.subscribers = subscribers;
  }
  isShutdown = effect3((journal) => {
    const currentPublisherTail = unsafeGet9(this.publisherTail, journal);
    return currentPublisherTail === void 0;
  });
  awaitShutdown = flatMap22(this.isShutdown, (isShutdown9) => isShutdown9 ? void_10 : retry6);
  capacity() {
    return this.requestedCapacity;
  }
  size = withSTMRuntime((runtime8) => {
    const currentPublisherTail = unsafeGet9(this.publisherTail, runtime8.journal);
    if (currentPublisherTail === void 0) {
      return interruptAs2(runtime8.fiberId);
    }
    return succeed19(unsafeGet9(this.pubsubSize, runtime8.journal));
  });
  isEmpty = map31(this.size, (size40) => size40 === 0);
  isFull = map31(this.size, (size40) => size40 === this.capacity());
  offer(value10) {
    return withSTMRuntime((runtime8) => {
      const currentPublisherTail = unsafeGet9(this.publisherTail, runtime8.journal);
      if (currentPublisherTail === void 0) {
        return interruptAs2(runtime8.fiberId);
      }
      const currentSubscriberCount = unsafeGet9(this.subscriberCount, runtime8.journal);
      if (currentSubscriberCount === 0) {
        return succeed19(true);
      }
      const currentPubSubSize = unsafeGet9(this.pubsubSize, runtime8.journal);
      if (currentPubSubSize < this.requestedCapacity) {
        const updatedPublisherTail = new TRefImpl(void 0);
        const updatedNode = makeNode2(value10, currentSubscriberCount, updatedPublisherTail);
        unsafeSet2(currentPublisherTail, updatedNode, runtime8.journal);
        unsafeSet2(this.publisherTail, updatedPublisherTail, runtime8.journal);
        unsafeSet2(this.pubsubSize, currentPubSubSize + 1, runtime8.journal);
        return succeed19(true);
      }
      switch (this.strategy._tag) {
        case OP_BACKPRESSURE_STRATEGY: {
          return retry6;
        }
        case OP_DROPPING_STRATEGY: {
          return succeed19(false);
        }
        case OP_SLIDING_STRATEGY: {
          if (this.requestedCapacity > 0) {
            let currentPublisherHead = unsafeGet9(this.publisherHead, runtime8.journal);
            let loop5 = true;
            while (loop5) {
              const node = unsafeGet9(currentPublisherHead, runtime8.journal);
              if (node === void 0) {
                return retry6;
              }
              const head13 = node.head;
              const tail5 = node.tail;
              if (head13 !== AbsentValue2) {
                const updatedNode2 = makeNode2(AbsentValue2, node.subscribers, node.tail);
                unsafeSet2(currentPublisherHead, updatedNode2, runtime8.journal);
                unsafeSet2(this.publisherHead, tail5, runtime8.journal);
                loop5 = false;
              } else {
                currentPublisherHead = tail5;
              }
            }
          }
          const updatedPublisherTail = new TRefImpl(void 0);
          const updatedNode = makeNode2(value10, currentSubscriberCount, updatedPublisherTail);
          unsafeSet2(currentPublisherTail, updatedNode, runtime8.journal);
          unsafeSet2(this.publisherTail, updatedPublisherTail, runtime8.journal);
          return succeed19(true);
        }
      }
    });
  }
  offerAll(iterable) {
    return map31(forEach18(iterable, (a) => this.offer(a)), every3(identity));
  }
  shutdown = effect3((journal) => {
    const currentPublisherTail = unsafeGet9(this.publisherTail, journal);
    if (currentPublisherTail !== void 0) {
      unsafeSet2(this.publisherTail, void 0, journal);
      const currentSubscribers = unsafeGet9(this.subscribers, journal);
      forEach6(currentSubscribers, (subscriber) => {
        unsafeSet2(subscriber, void 0, journal);
      });
      unsafeSet2(this.subscribers, empty10(), journal);
    }
  });
};
var TPubSubSubscriptionImpl = class {
  pubsubSize;
  publisherHead;
  requestedCapacity;
  subscriberHead;
  subscriberCount;
  subscribers;
  [TPubSubTypeId] = TPubSubTypeId;
  [TDequeueTypeId] = tDequeueVariance;
  constructor(pubsubSize, publisherHead, requestedCapacity, subscriberHead, subscriberCount, subscribers) {
    this.pubsubSize = pubsubSize;
    this.publisherHead = publisherHead;
    this.requestedCapacity = requestedCapacity;
    this.subscriberHead = subscriberHead;
    this.subscriberCount = subscriberCount;
    this.subscribers = subscribers;
  }
  isShutdown = effect3((journal) => {
    const currentSubscriberHead = unsafeGet9(this.subscriberHead, journal);
    return currentSubscriberHead === void 0;
  });
  awaitShutdown = flatMap22(this.isShutdown, (isShutdown9) => isShutdown9 ? void_10 : retry6);
  capacity() {
    return this.requestedCapacity;
  }
  size = withSTMRuntime((runtime8) => {
    let currentSubscriberHead = unsafeGet9(this.subscriberHead, runtime8.journal);
    if (currentSubscriberHead === void 0) {
      return interruptAs2(runtime8.fiberId);
    }
    let loop5 = true;
    let size40 = 0;
    while (loop5) {
      const node = unsafeGet9(currentSubscriberHead, runtime8.journal);
      if (node === void 0) {
        loop5 = false;
      } else {
        const head13 = node.head;
        const tail5 = node.tail;
        if (head13 !== AbsentValue2) {
          size40 = size40 + 1;
          if (size40 >= Number.MAX_SAFE_INTEGER) {
            loop5 = false;
          }
        }
        currentSubscriberHead = tail5;
      }
    }
    return succeed19(size40);
  });
  isEmpty = map31(this.size, (size40) => size40 === 0);
  isFull = map31(this.size, (size40) => size40 === this.capacity());
  peek = withSTMRuntime((runtime8) => {
    let currentSubscriberHead = unsafeGet9(this.subscriberHead, runtime8.journal);
    if (currentSubscriberHead === void 0) {
      return interruptAs2(runtime8.fiberId);
    }
    let value10 = AbsentValue2;
    let loop5 = true;
    while (loop5) {
      const node = unsafeGet9(currentSubscriberHead, runtime8.journal);
      if (node === void 0) {
        return retry6;
      }
      const head13 = node.head;
      const tail5 = node.tail;
      if (head13 !== AbsentValue2) {
        value10 = head13;
        loop5 = false;
      } else {
        currentSubscriberHead = tail5;
      }
    }
    return succeed19(value10);
  });
  peekOption = withSTMRuntime((runtime8) => {
    let currentSubscriberHead = unsafeGet9(this.subscriberHead, runtime8.journal);
    if (currentSubscriberHead === void 0) {
      return interruptAs2(runtime8.fiberId);
    }
    let value10 = none2();
    let loop5 = true;
    while (loop5) {
      const node = unsafeGet9(currentSubscriberHead, runtime8.journal);
      if (node === void 0) {
        value10 = none2();
        loop5 = false;
      } else {
        const head13 = node.head;
        const tail5 = node.tail;
        if (head13 !== AbsentValue2) {
          value10 = some3(head13);
          loop5 = false;
        } else {
          currentSubscriberHead = tail5;
        }
      }
    }
    return succeed19(value10);
  });
  shutdown = effect3((journal) => {
    let currentSubscriberHead = unsafeGet9(this.subscriberHead, journal);
    if (currentSubscriberHead !== void 0) {
      unsafeSet2(this.subscriberHead, void 0, journal);
      let loop5 = true;
      while (loop5) {
        const node = unsafeGet9(currentSubscriberHead, journal);
        if (node === void 0) {
          loop5 = false;
        } else {
          const head13 = node.head;
          const tail5 = node.tail;
          if (head13 !== AbsentValue2) {
            const subscribers = node.subscribers;
            if (subscribers === 1) {
              const size40 = unsafeGet9(this.pubsubSize, journal);
              const updatedNode = makeNode2(AbsentValue2, 0, tail5);
              unsafeSet2(currentSubscriberHead, updatedNode, journal);
              unsafeSet2(this.publisherHead, tail5, journal);
              unsafeSet2(this.pubsubSize, size40 - 1, journal);
            } else {
              const updatedNode = makeNode2(head13, subscribers - 1, tail5);
              unsafeSet2(currentSubscriberHead, updatedNode, journal);
            }
          }
          currentSubscriberHead = tail5;
        }
      }
      const currentSubscriberCount = unsafeGet9(this.subscriberCount, journal);
      unsafeSet2(this.subscriberCount, currentSubscriberCount - 1, journal);
      unsafeSet2(this.subscribers, remove6(unsafeGet9(this.subscribers, journal), this.subscriberHead), journal);
    }
  });
  take = withSTMRuntime((runtime8) => {
    let currentSubscriberHead = unsafeGet9(this.subscriberHead, runtime8.journal);
    if (currentSubscriberHead === void 0) {
      return interruptAs2(runtime8.fiberId);
    }
    let value10 = AbsentValue2;
    let loop5 = true;
    while (loop5) {
      const node = unsafeGet9(currentSubscriberHead, runtime8.journal);
      if (node === void 0) {
        return retry6;
      }
      const head13 = node.head;
      const tail5 = node.tail;
      if (head13 !== AbsentValue2) {
        const subscribers = node.subscribers;
        if (subscribers === 1) {
          const size40 = unsafeGet9(this.pubsubSize, runtime8.journal);
          const updatedNode = makeNode2(AbsentValue2, 0, tail5);
          unsafeSet2(currentSubscriberHead, updatedNode, runtime8.journal);
          unsafeSet2(this.publisherHead, tail5, runtime8.journal);
          unsafeSet2(this.pubsubSize, size40 - 1, runtime8.journal);
        } else {
          const updatedNode = makeNode2(head13, subscribers - 1, tail5);
          unsafeSet2(currentSubscriberHead, updatedNode, runtime8.journal);
        }
        unsafeSet2(this.subscriberHead, tail5, runtime8.journal);
        value10 = head13;
        loop5 = false;
      } else {
        currentSubscriberHead = tail5;
      }
    }
    return succeed19(value10);
  });
  takeAll = this.takeUpTo(Number.POSITIVE_INFINITY);
  takeUpTo(max13) {
    return withSTMRuntime((runtime8) => {
      let currentSubscriberHead = unsafeGet9(this.subscriberHead, runtime8.journal);
      if (currentSubscriberHead === void 0) {
        return interruptAs2(runtime8.fiberId);
      }
      const builder = [];
      let n = 0;
      while (n !== max13) {
        const node = unsafeGet9(currentSubscriberHead, runtime8.journal);
        if (node === void 0) {
          n = max13;
        } else {
          const head13 = node.head;
          const tail5 = node.tail;
          if (head13 !== AbsentValue2) {
            const subscribers = node.subscribers;
            if (subscribers === 1) {
              const size40 = unsafeGet9(this.pubsubSize, runtime8.journal);
              const updatedNode = makeNode2(AbsentValue2, 0, tail5);
              unsafeSet2(currentSubscriberHead, updatedNode, runtime8.journal);
              unsafeSet2(this.publisherHead, tail5, runtime8.journal);
              unsafeSet2(this.pubsubSize, size40 - 1, runtime8.journal);
            } else {
              const updatedNode = makeNode2(head13, subscribers - 1, tail5);
              unsafeSet2(currentSubscriberHead, updatedNode, runtime8.journal);
            }
            builder.push(head13);
            n = n + 1;
          }
          currentSubscriberHead = tail5;
        }
      }
      unsafeSet2(this.subscriberHead, currentSubscriberHead, runtime8.journal);
      return succeed19(builder);
    });
  }
};
var makeTPubSub = (requestedCapacity, strategy) => pipe(all12([make69(void 0), make69(0)]), flatMap22(([empty61, pubsubSize]) => pipe(all12([make69(empty61), make69(empty61), make69(0), make69(empty10())]), map31(([publisherHead, publisherTail, subscriberCount, subscribers]) => new TPubSubImpl(pubsubSize, publisherHead, publisherTail, requestedCapacity, strategy, subscriberCount, subscribers)))));
var makeSubscription2 = (pubsubSize, publisherHead, publisherTail, requestedCapacity, subscriberCount, subscribers) => pipe(get17(publisherTail), flatMap22((currentPublisherTail) => pipe(all12([make69(currentPublisherTail), get17(subscriberCount), get17(subscribers)]), tap7(([_, currentSubscriberCount]) => pipe(subscriberCount, set10(currentSubscriberCount + 1))), tap7(([subscriberHead, _, currentSubscribers]) => pipe(subscribers, set10(pipe(currentSubscribers, add4(subscriberHead))))), map31(([subscriberHead]) => new TPubSubSubscriptionImpl(pubsubSize, publisherHead, requestedCapacity, subscriberHead, subscriberCount, subscribers)))));
var awaitShutdown6 = (self) => self.awaitShutdown;
var bounded7 = (requestedCapacity) => makeTPubSub(requestedCapacity, BackPressure2);
var capacity7 = (self) => self.capacity();
var dropping6 = (requestedCapacity) => makeTPubSub(requestedCapacity, Dropping);
var isEmpty20 = (self) => self.isEmpty;
var isFull7 = (self) => self.isFull;
var isShutdown6 = (self) => self.isShutdown;
var publish3 = dual(2, (self, value10) => self.offer(value10));
var publishAll3 = dual(2, (self, iterable) => self.offerAll(iterable));
var size22 = (self) => self.size;
var shutdown6 = (self) => self.shutdown;
var sliding6 = (requestedCapacity) => makeTPubSub(requestedCapacity, Sliding);
var subscribe3 = (self) => makeSubscription2(self.pubsubSize, self.publisherHead, self.publisherTail, self.requestedCapacity, self.subscriberCount, self.subscribers);
var subscribeScoped = (self) => acquireRelease3(subscribe3(self), (dequeue) => shutdown5(dequeue));
var unbounded7 = () => makeTPubSub(Number.MAX_SAFE_INTEGER, Dropping);

// ../../node_modules/effect/dist/esm/TPubSub.js
var TPubSubTypeId2 = TPubSubTypeId;
var awaitShutdown7 = awaitShutdown6;
var bounded8 = bounded7;
var capacity8 = capacity7;
var dropping7 = dropping6;
var isEmpty21 = isEmpty20;
var isFull8 = isFull7;
var shutdown7 = shutdown6;
var isShutdown7 = isShutdown6;
var publish4 = publish3;
var publishAll4 = publishAll3;
var size23 = size22;
var sliding7 = sliding6;
var subscribe4 = subscribe3;
var subscribeScoped2 = subscribeScoped;
var unbounded8 = unbounded7;

// ../../node_modules/effect/dist/esm/TQueue.js
var TQueue_exports = {};
__export(TQueue_exports, {
  TDequeueTypeId: () => TDequeueTypeId2,
  TEnqueueTypeId: () => TEnqueueTypeId2,
  awaitShutdown: () => awaitShutdown8,
  bounded: () => bounded9,
  capacity: () => capacity9,
  dropping: () => dropping8,
  isEmpty: () => isEmpty22,
  isFull: () => isFull9,
  isShutdown: () => isShutdown8,
  isTDequeue: () => isTDequeue2,
  isTEnqueue: () => isTEnqueue2,
  isTQueue: () => isTQueue2,
  offer: () => offer5,
  offerAll: () => offerAll5,
  peek: () => peek2,
  peekOption: () => peekOption2,
  poll: () => poll8,
  seek: () => seek2,
  shutdown: () => shutdown8,
  size: () => size24,
  sliding: () => sliding8,
  take: () => take9,
  takeAll: () => takeAll4,
  takeBetween: () => takeBetween4,
  takeN: () => takeN4,
  takeUpTo: () => takeUpTo4,
  unbounded: () => unbounded9
});
var TDequeueTypeId2 = TDequeueTypeId;
var TEnqueueTypeId2 = TEnqueueTypeId;
var isTQueue2 = isTQueue;
var isTDequeue2 = isTDequeue;
var isTEnqueue2 = isTEnqueue;
var awaitShutdown8 = awaitShutdown5;
var bounded9 = bounded6;
var capacity9 = capacity6;
var dropping8 = dropping5;
var isEmpty22 = isEmpty19;
var isFull9 = isFull6;
var isShutdown8 = isShutdown5;
var offer5 = offer4;
var offerAll5 = offerAll4;
var peek2 = peek;
var peekOption2 = peekOption;
var poll8 = poll7;
var seek2 = seek;
var shutdown8 = shutdown5;
var size24 = size21;
var sliding8 = sliding5;
var take9 = take8;
var takeAll4 = takeAll3;
var takeBetween4 = takeBetween3;
var takeN4 = takeN3;
var takeUpTo4 = takeUpTo3;
var unbounded9 = unbounded6;

// ../../node_modules/effect/dist/esm/internal/ringBuffer.js
var RingBuffer = class {
  capacity;
  array;
  size = 0;
  current = 0;
  constructor(capacity10) {
    this.capacity = capacity10;
    this.array = Array.from({
      length: capacity10
    }, constUndefined);
  }
  head() {
    return fromNullable2(this.array[this.current]);
  }
  lastOrNull() {
    if (this.size === 0) {
      return void 0;
    }
    const index = this.current === 0 ? this.array.length - 1 : this.current - 1;
    return this.array[index] ?? void 0;
  }
  put(value10) {
    this.array[this.current] = value10;
    this.increment();
  }
  dropLast() {
    if (this.size > 0) {
      this.decrement();
      this.array[this.current] = void 0;
    }
  }
  toChunk() {
    const begin = this.current - this.size;
    const newArray = begin < 0 ? [...this.array.slice(this.capacity + begin, this.capacity), ...this.array.slice(0, this.current)] : this.array.slice(begin, this.current);
    return fromIterable3(newArray);
  }
  increment() {
    if (this.size < this.capacity) {
      this.size += 1;
    }
    this.current = (this.current + 1) % this.capacity;
  }
  decrement() {
    this.size -= 1;
    if (this.current > 0) {
      this.current -= 1;
    } else {
      this.current = this.capacity - 1;
    }
  }
};

// ../../node_modules/effect/dist/esm/internal/stream/debounceState.js
var OP_NOT_STARTED = "NotStarted";
var OP_PREVIOUS = "Previous";
var OP_CURRENT = "Current";
var notStarted = {
  _tag: OP_NOT_STARTED
};
var previous = (fiber) => ({
  _tag: OP_PREVIOUS,
  fiber
});
var current = (fiber) => ({
  _tag: OP_CURRENT,
  fiber
});

// ../../node_modules/effect/dist/esm/internal/stream/emit.js
var make70 = (emit2) => {
  const ops = {
    chunk(as18) {
      return this(succeed13(as18));
    },
    die(defect) {
      return this(die8(defect));
    },
    dieMessage(message) {
      return this(dieMessage2(message));
    },
    done(exit4) {
      return this(suspend4(() => mapBoth4(exit4, {
        onFailure: some3,
        onSuccess: of3
      })));
    },
    end() {
      return this(fail12(none2()));
    },
    fail(e) {
      return this(fail12(some3(e)));
    },
    fromEffect(effect4) {
      return this(mapBoth6(effect4, {
        onFailure: some3,
        onSuccess: of3
      }));
    },
    fromEffectChunk(effect4) {
      return this(pipe(effect4, mapError5(some3)));
    },
    halt(cause3) {
      return this(failCause10(pipe(cause3, map22(some3))));
    },
    single(value10) {
      return this(succeed13(of3(value10)));
    }
  };
  return Object.assign(emit2, ops);
};
var makePush = (queue, scheduler2) => {
  let finished = false;
  let buffer5 = [];
  let running4 = false;
  function array8(items) {
    if (finished) return false;
    if (items.length <= 5e4) {
      buffer5.push.apply(buffer5, items);
    } else {
      for (let i = 0; i < items.length; i++) {
        buffer5.push(items[0]);
      }
    }
    if (!running4) {
      running4 = true;
      scheduler2.scheduleTask(flush, 0);
    }
    return true;
  }
  function flush() {
    running4 = false;
    if (buffer5.length > 0) {
      queue.unsafeOffer(buffer5);
      buffer5 = [];
    }
  }
  function done17(exit4) {
    if (finished) return;
    finished = true;
    if (exit4._tag === "Success") {
      buffer5.push(exit4.value);
    }
    flush();
    queue.unsafeOffer(exit4._tag === "Success" ? void_4 : exit4);
  }
  return {
    single(value10) {
      if (finished) return false;
      buffer5.push(value10);
      if (!running4) {
        running4 = true;
        scheduler2.scheduleTask(flush, 0);
      }
      return true;
    },
    array: array8,
    chunk(chunk7) {
      return array8(toReadonlyArray(chunk7));
    },
    done: done17,
    end() {
      if (finished) return;
      finished = true;
      flush();
      queue.unsafeOffer(void_4);
    },
    halt(cause3) {
      return done17(failCause3(cause3));
    },
    fail(error4) {
      return done17(fail4(error4));
    },
    die(defect) {
      return done17(die4(defect));
    },
    dieMessage(message) {
      return done17(die4(new Error(message)));
    }
  };
};

// ../../node_modules/effect/dist/esm/internal/stream/handoff.js
var HandoffTypeId = Symbol.for("effect/Stream/Handoff");
var OP_HANDOFF_STATE_EMPTY = "Empty";
var OP_HANDOFF_STATE_FULL = "Full";
var handoffStateEmpty = (notifyConsumer) => ({
  _tag: OP_HANDOFF_STATE_EMPTY,
  notifyConsumer
});
var handoffStateFull = (value10, notifyProducer) => ({
  _tag: OP_HANDOFF_STATE_FULL,
  value: value10,
  notifyProducer
});
var handoffStateMatch = (onEmpty, onFull) => {
  return (self) => {
    switch (self._tag) {
      case OP_HANDOFF_STATE_EMPTY: {
        return onEmpty(self.notifyConsumer);
      }
      case OP_HANDOFF_STATE_FULL: {
        return onFull(self.value, self.notifyProducer);
      }
    }
  };
};
var handoffVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var make71 = () => pipe(make24(), flatMap18((deferred) => make37(handoffStateEmpty(deferred))), map26((ref) => ({
  [HandoffTypeId]: handoffVariance,
  ref
})));
var offer6 = dual(2, (self, value10) => {
  return flatMap18(make24(), (deferred) => flatten13(modify8(self.ref, (state) => pipe(state, handoffStateMatch((notifyConsumer) => [zipRight7(succeed2(notifyConsumer, void 0), _await(deferred)), handoffStateFull(value10, deferred)], (_, notifyProducer) => [flatMap18(_await(notifyProducer), () => pipe(self, offer6(value10))), state])))));
});
var take10 = (self) => flatMap18(make24(), (deferred) => flatten13(modify8(self.ref, (state) => pipe(state, handoffStateMatch((notifyConsumer) => [flatMap18(_await(notifyConsumer), () => take10(self)), state], (value10, notifyProducer) => [as8(succeed2(notifyProducer, void 0), value10), handoffStateEmpty(deferred)])))));

// ../../node_modules/effect/dist/esm/internal/stream/handoffSignal.js
var OP_EMIT4 = "Emit";
var OP_HALT = "Halt";
var OP_END = "End";
var emit = (elements) => ({
  _tag: OP_EMIT4,
  elements
});
var halt = (cause3) => ({
  _tag: OP_HALT,
  cause: cause3
});
var end3 = (reason) => ({
  _tag: OP_END,
  reason
});

// ../../node_modules/effect/dist/esm/internal/take.js
var TakeSymbolKey = "effect/Take";
var TakeTypeId = Symbol.for(TakeSymbolKey);
var takeVariance = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _E: (_) => _
};
var TakeImpl = class {
  exit;
  [TakeTypeId] = takeVariance;
  constructor(exit4) {
    this.exit = exit4;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var chunk3 = (chunk7) => new TakeImpl(succeed3(chunk7));
var die13 = (defect) => new TakeImpl(die4(defect));
var dieMessage5 = (message) => new TakeImpl(die4(new RuntimeException2(message)));
var done11 = (self) => suspend4(() => self.exit);
var end4 = new TakeImpl(fail4(none2()));
var fail18 = (error4) => new TakeImpl(fail4(some3(error4)));
var failCause14 = (cause3) => new TakeImpl(failCause3(pipe(cause3, map22(some3))));
var fromEffect8 = (effect4) => matchCause4(effect4, {
  onFailure: failCause14,
  onSuccess: of7
});
var fromExit = (exit4) => new TakeImpl(pipe(exit4, mapBoth4({
  onFailure: some3,
  onSuccess: of3
})));
var fromPull = (pull) => matchCause4(pull, {
  onFailure: (cause3) => match2(flipCauseOption2(cause3), {
    onNone: () => end4,
    onSome: failCause14
  }),
  onSuccess: chunk3
});
var isDone7 = (self) => match7(self.exit, {
  onFailure: (cause3) => isNone2(flipCauseOption2(cause3)),
  onSuccess: constFalse
});
var isFailure7 = (self) => match7(self.exit, {
  onFailure: (cause3) => isSome2(flipCauseOption2(cause3)),
  onSuccess: constFalse
});
var isSuccess6 = (self) => match7(self.exit, {
  onFailure: constFalse,
  onSuccess: constTrue
});
var make72 = (exit4) => new TakeImpl(exit4);
var match32 = dual(2, (self, {
  onEnd: onEnd3,
  onFailure,
  onSuccess
}) => match7(self.exit, {
  onFailure: (cause3) => match2(flipCauseOption2(cause3), {
    onNone: onEnd3,
    onSome: onFailure
  }),
  onSuccess
}));
var matchEffect5 = dual(2, (self, {
  onEnd: onEnd3,
  onFailure,
  onSuccess
}) => matchEffect2(self.exit, {
  onFailure: (cause3) => match2(flipCauseOption2(cause3), {
    onNone: () => onEnd3,
    onSome: onFailure
  }),
  onSuccess
}));
var map32 = dual(2, (self, f) => new TakeImpl(pipe(self.exit, map15(map7(f)))));
var of7 = (value10) => new TakeImpl(succeed3(of3(value10)));
var tap8 = dual(2, (self, f) => pipe(self.exit, forEachEffect(f), asVoid6));

// ../../node_modules/effect/dist/esm/internal/stream/pull.js
var end5 = () => fail12(none2());
var failCause15 = (cause3) => mapError5(failCause10(cause3), some3);

// ../../node_modules/effect/dist/esm/internal/stream/sinkEndReason.js
var OP_SCHEDULE_END = "ScheduleEnd";
var OP_UPSTREAM_END = "UpstreamEnd";
var ScheduleEnd = {
  _tag: OP_SCHEDULE_END
};
var UpstreamEnd = {
  _tag: OP_UPSTREAM_END
};

// ../../node_modules/effect/dist/esm/internal/stream/zipAllState.js
var OP_DRAIN_LEFT = "DrainLeft";
var OP_DRAIN_RIGHT = "DrainRight";
var OP_PULL_BOTH = "PullBoth";
var OP_PULL_LEFT = "PullLeft";
var OP_PULL_RIGHT = "PullRight";
var DrainLeft = {
  _tag: OP_DRAIN_LEFT
};
var DrainRight = {
  _tag: OP_DRAIN_RIGHT
};
var PullBoth = {
  _tag: OP_PULL_BOTH
};
var PullLeft = (rightChunk) => ({
  _tag: OP_PULL_LEFT,
  rightChunk
});
var PullRight = (leftChunk) => ({
  _tag: OP_PULL_RIGHT,
  leftChunk
});

// ../../node_modules/effect/dist/esm/internal/stream/zipChunksState.js
var OP_PULL_BOTH2 = "PullBoth";
var OP_PULL_LEFT2 = "PullLet";
var OP_PULL_RIGHT2 = "PullRight";
var PullBoth2 = {
  _tag: OP_PULL_BOTH2
};
var PullLeft2 = (rightChunk) => ({
  _tag: OP_PULL_LEFT2,
  rightChunk
});
var PullRight2 = (leftChunk) => ({
  _tag: OP_PULL_RIGHT2,
  leftChunk
});

// ../../node_modules/effect/dist/esm/internal/stream.js
var StreamSymbolKey = "effect/Stream";
var StreamTypeId3 = Symbol.for(StreamSymbolKey);
var streamVariance = {
  _R: (_) => _,
  _E: (_) => _,
  _A: (_) => _
};
var StreamImpl = class {
  channel;
  [StreamTypeId3] = streamVariance;
  constructor(channel) {
    this.channel = channel;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isStream = (u) => hasProperty(u, StreamTypeId3) || isEffect2(u);
var DefaultChunkSize = 4096;
var accumulate = (self) => chunks(accumulateChunks(self));
var accumulateChunks = (self) => {
  const accumulator = (s) => readWith({
    onInput: (input) => {
      const next6 = appendAll3(s, input);
      return flatMap20(write(next6), () => accumulator(next6));
    },
    onFailure: fail14,
    onDone: () => void_8
  });
  return new StreamImpl(pipeTo(toChannel2(self), accumulator(empty7())));
};
var acquireRelease4 = (acquire4, release4) => scoped7(acquireRelease3(acquire4, release4));
var aggregate = dual(2, (self, sink) => aggregateWithin(self, sink, forever5));
var aggregateWithin = dual(3, (self, sink, schedule4) => filterMap12(aggregateWithinEither(self, sink, schedule4), (_) => match(_, {
  onLeft: none2,
  onRight: some3
})));
var aggregateWithinEither = dual(3, (self, sink, schedule4) => {
  const layer = all11([make71(), make37(ScheduleEnd), make37(empty7()), driver2(schedule4), make37(false), make37(false)]);
  return fromEffect9(layer).pipe(flatMap23(([handoff, sinkEndReason, sinkLeftovers, scheduleDriver, consumed, endAfterEmit]) => {
    const handoffProducer = readWithCause({
      onInput: (input) => flatMap20(fromEffect5(pipe(handoff, offer6(emit(input)), when3(() => isNonEmpty2(input)))), () => handoffProducer),
      onFailure: (cause3) => fromEffect5(offer6(handoff, halt(cause3))),
      onDone: () => fromEffect5(offer6(handoff, end3(UpstreamEnd)))
    });
    const handoffConsumer = pipe(getAndSet3(sinkLeftovers, empty7()), flatMap18((leftovers) => {
      if (isNonEmpty2(leftovers)) {
        return pipe(set7(consumed, true), zipRight7(succeed13(pipe(write(leftovers), flatMap20(() => handoffConsumer)))));
      }
      return pipe(take10(handoff), map26((signal) => {
        switch (signal._tag) {
          case OP_EMIT4: {
            return pipe(fromEffect5(set7(consumed, true)), zipRight8(write(signal.elements)), zipRight8(fromEffect5(get13(endAfterEmit))), flatMap20((bool) => bool ? void_8 : handoffConsumer));
          }
          case OP_HALT: {
            return failCause12(signal.cause);
          }
          case OP_END: {
            if (signal.reason._tag === OP_SCHEDULE_END) {
              return pipe(get13(consumed), map26((bool) => bool ? fromEffect5(pipe(set7(sinkEndReason, ScheduleEnd), zipRight7(set7(endAfterEmit, true)))) : pipe(fromEffect5(pipe(set7(sinkEndReason, ScheduleEnd), zipRight7(set7(endAfterEmit, true)))), flatMap20(() => handoffConsumer))), unwrap2);
            }
            return pipe(set7(sinkEndReason, signal.reason), zipRight7(set7(endAfterEmit, true)), fromEffect5);
          }
        }
      }));
    }), unwrap2);
    const timeout6 = (lastB) => scheduleDriver.next(lastB);
    const scheduledAggregator = (sinkFiber, scheduleFiber, scope6) => {
      const forkSink = pipe(set7(consumed, false), zipRight7(set7(endAfterEmit, false)), zipRight7(pipe(handoffConsumer, pipeToOrFail(toChannel(sink)), collectElements, run2, forkIn3(scope6))));
      const handleSide = (leftovers, b, c) => pipe(set7(sinkLeftovers, flatten5(leftovers)), zipRight7(map26(get13(sinkEndReason), (reason) => {
        switch (reason._tag) {
          case OP_SCHEDULE_END: {
            return pipe(all11([get13(consumed), forkSink, pipe(timeout6(some3(b)), forkIn3(scope6))]), map26(([wasConsumed, sinkFiber2, scheduleFiber2]) => {
              const toWrite = pipe(c, match2({
                onNone: () => of3(right2(b)),
                onSome: (c2) => make9(right2(b), left2(c2))
              }));
              if (wasConsumed) {
                return pipe(write(toWrite), flatMap20(() => scheduledAggregator(sinkFiber2, scheduleFiber2, scope6)));
              }
              return scheduledAggregator(sinkFiber2, scheduleFiber2, scope6);
            }), unwrap2);
          }
          case OP_UPSTREAM_END: {
            return pipe(get13(consumed), map26((wasConsumed) => wasConsumed ? write(of3(right2(b))) : void_8), unwrap2);
          }
        }
      })), unwrap2);
      return unwrap2(raceWith2(join4(sinkFiber), join4(scheduleFiber), {
        onSelfDone: (sinkExit, _) => pipe(interrupt7(scheduleFiber), zipRight7(pipe(suspend4(() => sinkExit), map26(([leftovers, b]) => handleSide(leftovers, b, none2()))))),
        onOtherDone: (scheduleExit, _) => matchCauseEffect3(suspend4(() => scheduleExit), {
          onFailure: (cause3) => match(failureOrCause2(cause3), {
            onLeft: () => pipe(handoff, offer6(end3(ScheduleEnd)), forkDaemon3, zipRight7(pipe(join4(sinkFiber), map26(([leftovers, b]) => handleSide(leftovers, b, none2()))))),
            onRight: (cause4) => pipe(handoff, offer6(halt(cause4)), forkDaemon3, zipRight7(pipe(join4(sinkFiber), map26(([leftovers, b]) => handleSide(leftovers, b, none2())))))
          }),
          onSuccess: (c) => pipe(handoff, offer6(end3(ScheduleEnd)), forkDaemon3, zipRight7(pipe(join4(sinkFiber), map26(([leftovers, b]) => handleSide(leftovers, b, some3(c))))))
        })
      }));
    };
    return unwrapScopedWith3((scope6) => pipeTo(toChannel2(self), handoffProducer).pipe(run2, forkIn3(scope6), zipRight7(pipeToOrFail(handoffConsumer, toChannel(sink)).pipe(collectElements, run2, forkIn3(scope6), flatMap18((sinkFiber) => timeout6(none2()).pipe(forkIn3(scope6), map26((scheduleFiber) => new StreamImpl(scheduledAggregator(sinkFiber, scheduleFiber, scope6)))))))));
  }));
});
var as13 = dual(2, (self, value10) => map33(self, () => value10));
var queueFromBufferOptions = (bufferSize) => {
  if (bufferSize === "unbounded") {
    return unbounded5();
  } else if (typeof bufferSize === "number" || bufferSize === void 0) {
    return bounded5(bufferSize ?? 16);
  }
  switch (bufferSize.strategy) {
    case "dropping":
      return dropping4(bufferSize.bufferSize ?? 16);
    case "sliding":
      return sliding4(bufferSize.bufferSize ?? 16);
    default:
      return bounded5(bufferSize.bufferSize ?? 16);
  }
};
var _async = (register, bufferSize) => acquireRelease3(queueFromBufferOptions(bufferSize), (queue) => shutdown4(queue)).pipe(flatMap18((output) => runtime4().pipe(flatMap18((runtime8) => sync8(() => {
  const runPromiseExit4 = runPromiseExit3(runtime8);
  const canceler = register(make70((resume2) => fromPull(resume2).pipe(flatMap18((take16) => offer3(output, take16)), asVoid6, runPromiseExit4).then((exit4) => {
    if (isFailure2(exit4)) {
      if (!isInterrupted3(exit4.cause)) {
        throw squash(exit4.cause);
      }
    }
  })));
  return canceler;
})), map26((value10) => {
  const loop5 = take6(output).pipe(flatMap18((take16) => done11(take16)), match20({
    onFailure: (maybeError) => fromEffect5(shutdown4(output)).pipe(zipRight8(match2(maybeError, {
      onNone: () => void_8,
      onSome: (error4) => fail14(error4)
    }))),
    onSuccess: (chunk7) => write(chunk7).pipe(flatMap20(() => loop5))
  }), unwrap2);
  return fromChannel2(loop5).pipe(ensuring9(value10 ?? _void));
}))), unwrapScoped5);
var asyncEffect3 = (register, bufferSize) => pipe(acquireRelease3(queueFromBufferOptions(bufferSize), (queue) => shutdown4(queue)), flatMap18((output) => pipe(runtime4(), flatMap18((runtime8) => pipe(register(make70((k) => pipe(fromPull(k), flatMap18((take16) => offer3(output, take16)), asVoid6, runPromiseExit3(runtime8)).then((exit4) => {
  if (isFailure2(exit4)) {
    if (!isInterrupted3(exit4.cause)) {
      throw squash(exit4.cause);
    }
  }
}))), map26(() => {
  const loop5 = pipe(take6(output), flatMap18(done11), match20({
    onFailure: (maybeError) => pipe(fromEffect5(shutdown4(output)), zipRight8(match2(maybeError, {
      onNone: () => void_8,
      onSome: fail14
    }))),
    onSuccess: (chunk7) => pipe(write(chunk7), flatMap20(() => loop5))
  }), unwrap2);
  return loop5;
}))))), unwrapScoped3, fromChannel2);
var queueFromBufferOptionsPush = (options) => {
  if (options?.bufferSize === "unbounded" || options?.bufferSize === void 0 && options?.strategy === void 0) {
    return unbounded5();
  }
  switch (options?.strategy) {
    case "sliding":
      return sliding4(options.bufferSize ?? 16);
    default:
      return dropping4(options?.bufferSize ?? 16);
  }
};
var asyncPush = (register, options) => acquireRelease3(queueFromBufferOptionsPush(options), shutdown4).pipe(tap5((queue) => getWith(currentScheduler2, (scheduler2) => register(makePush(queue, scheduler2)))), map26((queue) => {
  const loop5 = flatMap20(take6(queue), (item) => isExit(item) ? isSuccess(item) ? void_8 : failCause12(item.cause) : zipRight8(write(unsafeFromArray(item)), loop5));
  return loop5;
}), unwrapScoped3, fromChannel2);
var asyncScoped = (register, bufferSize) => pipe(acquireRelease3(queueFromBufferOptions(bufferSize), (queue) => shutdown4(queue)), flatMap18((output) => pipe(runtime4(), flatMap18((runtime8) => pipe(register(make70((k) => pipe(fromPull(k), flatMap18((take16) => offer3(output, take16)), asVoid6, runPromiseExit3(runtime8)).then((exit4) => {
  if (isFailure2(exit4)) {
    if (!isInterrupted3(exit4.cause)) {
      throw squash(exit4.cause);
    }
  }
}))), zipRight7(make37(false)), flatMap18((ref) => pipe(get13(ref), map26((isDone9) => isDone9 ? end5() : pipe(take6(output), flatMap18(done11), onError3(() => pipe(set7(ref, true), zipRight7(shutdown4(output)))))))))))), scoped7, flatMap23(repeatEffectChunkOption));
var branchAfter = dual(3, (self, n, f) => suspend10(() => {
  const buffering = (acc) => readWith({
    onInput: (input) => {
      const nextSize = acc.length + input.length;
      if (nextSize >= n) {
        const [b1, b2] = pipe(input, splitAt2(n - acc.length));
        return running4(pipe(acc, appendAll3(b1)), b2);
      }
      return buffering(pipe(acc, appendAll3(input)));
    },
    onFailure: fail14,
    onDone: () => running4(acc, empty7())
  });
  const running4 = (prefix, leftover3) => pipeTo(zipRight8(write(leftover3), identityChannel()), toChannel2(f(prefix)));
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(buffering(empty7()))));
}));
var broadcast = dual(3, (self, n, maximumLag) => pipe(self, broadcastedQueues(n, maximumLag), map26((tuple7) => tuple7.map((queue) => flattenTake(fromQueue3(queue, {
  shutdown: true
}))))));
var broadcastDynamic = dual(2, (self, maximumLag) => map26(toPubSub2(self, maximumLag), (pubsub) => flattenTake(fromPubSub3(pubsub))));
var share = dual(2, (self, options) => map26(make65({
  acquire: broadcastDynamic(self, options),
  idleTimeToLive: options.idleTimeToLive
}), (rcRef) => unwrapScoped5(get16(rcRef))));
var broadcastedQueues = dual(3, (self, n, maximumLag) => flatMap18(pubsubFromOptions(maximumLag), (pubsub) => pipe(all11(Array.from({
  length: n
}, () => subscribe2(pubsub))), tap5(() => forkScoped3(runIntoPubSubScoped(self, pubsub))))));
var broadcastedQueuesDynamic = dual(2, (self, maximumLag) => map26(toPubSub2(self, maximumLag), subscribe2));
var buffer2 = dual(2, (self, options) => {
  if (options.capacity === "unbounded") {
    return bufferUnbounded(self);
  } else if (options.strategy === "dropping") {
    return bufferDropping(self, options.capacity);
  } else if (options.strategy === "sliding") {
    return bufferSliding(self, options.capacity);
  }
  const queue = toQueueOfElements(self, options);
  return new StreamImpl(unwrapScoped3(map26(queue, (queue2) => {
    const process2 = pipe(fromEffect5(take6(queue2)), flatMap20(match7({
      onFailure: (cause3) => pipe(flipCauseOption2(cause3), match2({
        onNone: () => void_8,
        onSome: failCause12
      })),
      onSuccess: (value10) => flatMap20(write(of3(value10)), () => process2)
    })));
    return process2;
  })));
});
var bufferChunks = dual(2, (self, options) => {
  if (options.strategy === "dropping") {
    return bufferChunksDropping(self, options.capacity);
  } else if (options.strategy === "sliding") {
    return bufferChunksSliding(self, options.capacity);
  }
  const queue = toQueue2(self, options);
  return new StreamImpl(unwrapScoped3(map26(queue, (queue2) => {
    const process2 = pipe(fromEffect5(take6(queue2)), flatMap20(match32({
      onEnd: () => void_8,
      onFailure: failCause12,
      onSuccess: (value10) => pipe(write(value10), flatMap20(() => process2))
    })));
    return process2;
  })));
});
var bufferChunksDropping = dual(2, (self, capacity10) => {
  const queue = acquireRelease3(dropping4(capacity10), (queue2) => shutdown4(queue2));
  return new StreamImpl(bufferSignal(queue, toChannel2(self)));
});
var bufferChunksSliding = dual(2, (self, capacity10) => {
  const queue = acquireRelease3(sliding4(capacity10), (queue2) => shutdown4(queue2));
  return new StreamImpl(bufferSignal(queue, toChannel2(self)));
});
var bufferDropping = dual(2, (self, capacity10) => {
  const queue = acquireRelease3(dropping4(capacity10), (queue2) => shutdown4(queue2));
  return new StreamImpl(bufferSignal(queue, toChannel2(rechunk(1)(self))));
});
var bufferSliding = dual(2, (self, capacity10) => {
  const queue = acquireRelease3(sliding4(capacity10), (queue2) => shutdown4(queue2));
  return new StreamImpl(bufferSignal(queue, toChannel2(pipe(self, rechunk(1)))));
});
var bufferUnbounded = (self) => {
  const queue = toQueue2(self, {
    strategy: "unbounded"
  });
  return new StreamImpl(unwrapScoped3(map26(queue, (queue2) => {
    const process2 = pipe(fromEffect5(take6(queue2)), flatMap20(match32({
      onEnd: () => void_8,
      onFailure: failCause12,
      onSuccess: (value10) => flatMap20(write(value10), () => process2)
    })));
    return process2;
  })));
};
var bufferSignal = (scoped10, bufferChannel) => {
  const producer = (queue, ref) => {
    const terminate = (take16) => pipe(get13(ref), tap5(_await), zipRight7(make24()), flatMap18((deferred) => pipe(offer3(queue, [take16, deferred]), zipRight7(set7(ref, deferred)), zipRight7(_await(deferred)))), asVoid6, fromEffect5);
    return readWithCause({
      onInput: (input) => pipe(make24(), flatMap18((deferred) => pipe(offer3(queue, [chunk3(input), deferred]), flatMap18((added) => pipe(set7(ref, deferred), when3(() => added))))), asVoid6, fromEffect5, flatMap20(() => producer(queue, ref))),
      onFailure: (error4) => terminate(failCause14(error4)),
      onDone: () => terminate(end4)
    });
  };
  const consumer = (queue) => {
    const process2 = pipe(fromEffect5(take6(queue)), flatMap20(([take16, deferred]) => zipRight8(fromEffect5(succeed2(deferred, void 0)), match32(take16, {
      onEnd: () => void_8,
      onFailure: failCause12,
      onSuccess: (value10) => pipe(write(value10), flatMap20(() => process2))
    }))));
    return process2;
  };
  return unwrapScoped3(pipe(scoped10, flatMap18((queue) => pipe(make24(), tap5((start5) => succeed2(start5, void 0)), flatMap18((start5) => pipe(make37(start5), flatMap18((ref) => pipe(bufferChannel, pipeTo(producer(queue, ref)), runScoped, forkScoped3)), as8(consumer(queue))))))));
};
var catchAll8 = dual(2, (self, f) => catchAllCause7(self, (cause3) => match(failureOrCause2(cause3), {
  onLeft: f,
  onRight: failCause16
})));
var catchAllCause7 = dual(2, (self, f) => new StreamImpl(pipe(toChannel2(self), catchAllCause6((cause3) => toChannel2(f(cause3))))));
var catchSome4 = dual(2, (self, pf) => pipe(self, catchAll8((error4) => pipe(pf(error4), getOrElse2(() => fail19(error4))))));
var catchSomeCause3 = dual(2, (self, pf) => pipe(self, catchAllCause7((cause3) => pipe(pf(cause3), getOrElse2(() => failCause16(cause3))))));
var catchTag5 = dual(3, (self, k, f) => catchAll8(self, (e) => {
  if ("_tag" in e && e["_tag"] === k) {
    return f(e);
  }
  return fail19(e);
}));
var catchTags4 = dual(2, (self, cases) => catchAll8(self, (e) => {
  const keys15 = Object.keys(cases);
  if ("_tag" in e && keys15.includes(e["_tag"])) {
    return cases[e["_tag"]](e);
  }
  return fail19(e);
}));
var changes = (self) => pipe(self, changesWith((x, y) => equals(y)(x)));
var changesWith = dual(2, (self, f) => {
  const writer = (last8) => readWithCause({
    onInput: (input) => {
      const [newLast, newChunk] = reduce4(input, [last8, empty7()], ([option11, outputs], output) => {
        if (isSome2(option11) && f(option11.value, output)) {
          return [some3(output), outputs];
        }
        return [some3(output), pipe(outputs, append3(output))];
      });
      return flatMap20(write(newChunk), () => writer(newLast));
    },
    onFailure: failCause12,
    onDone: () => void_8
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(writer(none2()))));
});
var changesWithEffect = dual(2, (self, f) => {
  const writer = (last8) => readWithCause({
    onInput: (input) => pipe(input, reduce17([last8, empty7()], ([option11, outputs], output) => {
      if (isSome2(option11)) {
        return pipe(f(option11.value, output), map26((bool) => bool ? [some3(output), outputs] : [some3(output), pipe(outputs, append3(output))]));
      }
      return succeed13([some3(output), pipe(outputs, append3(output))]);
    }), fromEffect5, flatMap20(([newLast, newChunk]) => pipe(write(newChunk), flatMap20(() => writer(newLast))))),
    onFailure: failCause12,
    onDone: () => void_8
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(writer(none2()))));
});
var chunks = (self) => pipe(self, mapChunks(of3));
var chunksWith = dual(2, (self, f) => flattenChunks(f(chunks(self))));
var unsome2 = (effect4) => catchAll4(asSome3(effect4), (o) => o._tag === "None" ? succeedNone3 : fail12(o.value));
var combine16 = dual(4, (self, that, s, f) => {
  function producer(handoff, latch) {
    return fromEffect5(take10(latch)).pipe(zipRight8(readWithCause({
      onInput: (input) => flatMap20(fromEffect5(offer6(handoff, succeed3(input))), () => producer(handoff, latch)),
      onFailure: (cause3) => fromEffect5(offer6(handoff, failCause3(pipe(cause3, map22(some3))))),
      onDone: () => flatMap20(fromEffect5(offer6(handoff, fail4(none2()))), () => producer(handoff, latch))
    })));
  }
  return new StreamImpl(unwrapScopedWith((scope6) => all11([make71(), make71(), make71(), make71()]).pipe(tap5(([left3, _, latchL]) => toChannel2(self).pipe(concatMap(writeChunk), pipeTo(producer(left3, latchL)), runIn(scope6), forkIn3(scope6))), tap5(([, right3, _, rightL]) => toChannel2(that).pipe(concatMap(writeChunk), pipeTo(producer(right3, rightL)), runIn(scope6), forkIn3(scope6))), map26(([left3, right3, latchL, latchR]) => {
    const pullLeft = offer6(latchL, void 0).pipe(zipRight7(take10(left3).pipe(flatMap18(identity))));
    const pullRight = offer6(latchR, void 0).pipe(zipRight7(take10(right3).pipe(flatMap18(identity))));
    return toChannel2(unfoldEffect(s, (s2) => flatMap18(f(s2, pullLeft, pullRight), unsome2)));
  }))));
});
var combineChunks = dual(4, (self, that, s, f) => {
  const producer = (handoff, latch) => zipRight8(fromEffect5(take10(latch)), readWithCause({
    onInput: (input) => flatMap20(fromEffect5(pipe(handoff, offer6(chunk3(input)))), () => producer(handoff, latch)),
    onFailure: (cause3) => fromEffect5(offer6(handoff, failCause14(cause3))),
    onDone: () => fromEffect5(offer6(handoff, end4))
  }));
  return new StreamImpl(unwrapScopedWith((scope6) => all11([make71(), make71(), make71(), make71()]).pipe(tap5(([left3, _, latchL]) => pipeTo(toChannel2(self), producer(left3, latchL)).pipe(runIn(scope6), forkIn3(scope6))), tap5(([_, right3, __, latchR]) => pipeTo(toChannel2(that), producer(right3, latchR)).pipe(runIn(scope6), forkIn3(scope6))), map26(([left3, right3, latchL, latchR]) => {
    const pullLeft = offer6(latchL, void 0).pipe(zipRight7(take10(left3).pipe(flatMap18(done11))));
    const pullRight = offer6(latchR, void 0).pipe(zipRight7(take10(right3).pipe(flatMap18(done11))));
    return toChannel2(unfoldChunkEffect(s, (s2) => flatMap18(f(s2, pullLeft, pullRight), unsome2)));
  }))));
});
var concat3 = dual(2, (self, that) => new StreamImpl(pipe(toChannel2(self), zipRight8(toChannel2(that)))));
var concatAll2 = (streams) => suspend10(() => pipe(streams, reduce4(empty43, (x, y) => concat3(y)(x))));
var cross = dual(2, (left3, right3) => pipe(left3, crossWith(right3, (a, a2) => [a, a2])));
var crossLeft = dual(2, (left3, right3) => pipe(left3, crossWith(right3, (a, _) => a)));
var crossRight = dual(2, (left3, right3) => flatMap23(left3, () => right3));
var crossWith = dual(3, (left3, right3, f) => pipe(left3, flatMap23((a) => pipe(right3, map33((b) => f(a, b))))));
var debounce = dual(2, (self, duration5) => unwrapScopedWith3((scope6) => gen6(function* () {
  const handoff = yield* make71();
  function enqueue(last8) {
    return sleep2(duration5).pipe(as8(last8), forkIn3(scope6), map26((fiber) => consumer(previous(fiber))));
  }
  const producer = readWithCause({
    onInput: (input) => match2(last2(input), {
      onNone: () => producer,
      onSome: (elem) => fromEffect5(offer6(handoff, emit(of3(elem)))).pipe(flatMap20(() => producer))
    }),
    onFailure: (cause3) => fromEffect5(offer6(handoff, halt(cause3))),
    onDone: () => fromEffect5(offer6(handoff, end3(UpstreamEnd)))
  });
  function consumer(state) {
    switch (state._tag) {
      case OP_NOT_STARTED: {
        return unwrap2(take10(handoff).pipe(map26((signal) => {
          switch (signal._tag) {
            case OP_EMIT4: {
              return unwrap2(enqueue(signal.elements));
            }
            case OP_HALT: {
              return failCause12(signal.cause);
            }
            case OP_END: {
              return void_8;
            }
          }
        })));
      }
      case OP_PREVIOUS: {
        return unwrap2(take10(handoff).pipe(forkIn3(scope6), flatMap18((handoffFiber) => raceWith2(join4(state.fiber), join4(handoffFiber), {
          onSelfDone: (leftExit, current2) => match7(leftExit, {
            onFailure: (cause3) => interrupt7(current2).pipe(as8(failCause12(cause3))),
            onSuccess: (chunk7) => interrupt7(current2).pipe(zipRight7(succeed13(write(chunk7).pipe(flatMap20(() => consumer(current(handoffFiber)))))))
          }),
          onOtherDone: (rightExit, previous2) => match7(rightExit, {
            onFailure: (cause3) => interrupt7(previous2).pipe(as8(failCause12(cause3))),
            onSuccess: (signal) => {
              switch (signal._tag) {
                case OP_EMIT4: {
                  return interrupt7(previous2).pipe(zipRight7(enqueue(signal.elements)));
                }
                case OP_HALT: {
                  return interrupt7(previous2).pipe(as8(failCause12(signal.cause)));
                }
                case OP_END: {
                  return join4(previous2).pipe(map26((chunk7) => write(chunk7).pipe(zipRight8(void_8))));
                }
              }
            }
          })
        }))));
      }
      case OP_CURRENT: {
        return unwrap2(join4(state.fiber).pipe(map26((signal) => {
          switch (signal._tag) {
            case OP_EMIT4: {
              return unwrap2(enqueue(signal.elements));
            }
            case OP_HALT: {
              return failCause12(signal.cause);
            }
            case OP_END: {
              return void_8;
            }
          }
        })));
      }
    }
  }
  return scopedWith4((scope7) => pipeTo(toChannel2(self), producer).pipe(runIn(scope7), forkIn3(scope7))).pipe(crossRight(new StreamImpl(consumer(notStarted))));
})));
var die14 = (defect) => fromEffect9(die8(defect));
var dieSync8 = (evaluate4) => fromEffect9(dieSync4(evaluate4));
var dieMessage6 = (message) => fromEffect9(dieMessage2(message));
var distributedWith = dual(2, (self, options) => pipe(make24(), flatMap18((deferred) => pipe(self, distributedWithDynamic({
  maximumLag: options.maximumLag,
  decide: (a) => flatMap18(_await(deferred), (f) => f(a))
}), flatMap18((next6) => pipe(all11(map7(range3(0, options.size - 1), (id3) => map26(next6, ([key, queue]) => [[key, id3], queue]))), map26(unsafeFromArray), flatMap18((entries7) => {
  const [mappings, queues] = reduceRight2(entries7, [/* @__PURE__ */ new Map(), empty7()], ([mappings2, queues2], [mapping, queue]) => [mappings2.set(mapping[0], mapping[1]), pipe(queues2, prepend3(queue))]);
  return pipe(succeed2(deferred, (a) => map26(options.decide(a), (f) => (key) => f(mappings.get(key)))), as8(Array.from(queues)));
})))))));
var distributedWithDynamicId = {
  ref: 0
};
var newDistributedWithDynamicId = () => {
  const current2 = distributedWithDynamicId.ref;
  distributedWithDynamicId.ref = current2 + 1;
  return current2;
};
var distributedWithDynamic = dual(2, (self, options) => distributedWithDynamicCallback(self, options.maximumLag, options.decide, () => _void));
var distributedWithDynamicCallback = dual(4, (self, maximumLag, decide, done17) => pipe(acquireRelease3(make37(/* @__PURE__ */ new Map()), (ref, _) => pipe(get13(ref), flatMap18((queues) => pipe(queues.values(), forEach16(shutdown4))))), flatMap18((queuesRef) => gen6(function* () {
  const offer9 = (a) => pipe(decide(a), flatMap18((shouldProcess) => pipe(get13(queuesRef), flatMap18((queues) => pipe(queues.entries(), reduce17(empty7(), (acc, [id3, queue]) => {
    if (shouldProcess(id3)) {
      return pipe(offer3(queue, succeed3(a)), matchCauseEffect3({
        onFailure: (cause3) => (
          // Ignore all downstream queues that were shut
          // down and remove them later
          isInterrupted3(cause3) ? succeed13(pipe(acc, prepend3(id3))) : failCause10(cause3)
        ),
        onSuccess: () => succeed13(acc)
      }));
    }
    return succeed13(acc);
  }), flatMap18((ids3) => {
    if (isNonEmpty2(ids3)) {
      return update4(queuesRef, (map49) => {
        for (const id3 of ids3) {
          map49.delete(id3);
        }
        return map49;
      });
    }
    return _void;
  }))))), asVoid6);
  const queuesLock = yield* makeSemaphore2(1);
  const newQueue = yield* make37(pipe(bounded5(maximumLag), flatMap18((queue) => {
    const id3 = newDistributedWithDynamicId();
    return pipe(update4(queuesRef, (map49) => map49.set(id3, queue)), as8([id3, queue]));
  })));
  const finalize = (endTake) => (
    // Make sure that no queues are currently being added
    queuesLock.withPermits(1)(pipe(set7(newQueue, pipe(
      // All newly created queues should end immediately
      bounded5(1),
      tap5((queue) => offer3(queue, endTake)),
      flatMap18((queue) => {
        const id3 = newDistributedWithDynamicId();
        return pipe(update4(queuesRef, (map49) => map49.set(id3, queue)), as8(make3(id3, queue)));
      })
    )), zipRight7(pipe(get13(queuesRef), flatMap18((map49) => pipe(fromIterable3(map49.values()), forEach16((queue) => pipe(offer3(queue, endTake), catchSomeCause2((cause3) => isInterrupted3(cause3) ? some3(_void) : none2()))))))), zipRight7(done17(endTake)), asVoid6))
  );
  yield* pipe(self, runForEachScoped(offer9), matchCauseEffect3({
    onFailure: (cause3) => finalize(failCause3(pipe(cause3, map22(some3)))),
    onSuccess: () => finalize(fail4(none2()))
  }), forkScoped3);
  return queuesLock.withPermits(1)(flatten13(get13(newQueue)));
}))));
var drain3 = (self) => new StreamImpl(drain(toChannel2(self)));
var drainFork = dual(2, (self, that) => fromEffect9(make24()).pipe(flatMap23((backgroundDied) => scopedWith4((scope6) => toChannel2(that).pipe(drain, runIn(scope6), catchAllCause4((cause3) => failCause2(backgroundDied, cause3)), forkIn3(scope6))).pipe(crossRight(interruptWhenDeferred2(self, backgroundDied))))));
var drop6 = dual(2, (self, n) => {
  const loop5 = (r) => readWith({
    onInput: (input) => {
      const dropped = pipe(input, drop3(r));
      const leftover3 = Math.max(0, r - input.length);
      const more = isEmpty2(input) || leftover3 > 0;
      if (more) {
        return loop5(leftover3);
      }
      return pipe(write(dropped), zipRight8(identityChannel()));
    },
    onFailure: fail14,
    onDone: () => void_8
  });
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(loop5(n))));
});
var dropRight3 = dual(2, (self, n) => {
  if (n <= 0) {
    return identityStream();
  }
  return suspend10(() => {
    const queue = new RingBuffer(n);
    const reader = readWith({
      onInput: (input) => {
        const outputs = pipe(input, filterMap5((elem) => {
          const head13 = queue.head();
          queue.put(elem);
          return head13;
        }));
        return pipe(write(outputs), flatMap20(() => reader));
      },
      onFailure: fail14,
      onDone: () => void_8
    });
    return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(reader)));
  });
});
var dropUntil4 = dual(2, (self, predicate) => drop6(dropWhile6(self, (a) => !predicate(a)), 1));
var dropUntilEffect2 = dual(2, (self, predicate) => {
  const loop5 = readWith({
    onInput: (input) => pipe(dropUntil2(input, predicate), map26(unsafeFromArray), map26((leftover3) => {
      const more = isEmpty2(leftover3);
      if (more) {
        return suspend6(() => loop5);
      }
      return pipe(write(leftover3), zipRight8(identityChannel()));
    }), unwrap2),
    onFailure: fail14,
    onDone: () => void_8
  });
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(loop5)));
});
var dropWhile6 = dual(2, (self, predicate) => {
  const loop5 = readWith({
    onInput: (input) => {
      const output = dropWhile2(input, predicate);
      if (isEmpty2(output)) {
        return suspend6(() => loop5);
      }
      return zipRight8(write(output), identityChannel());
    },
    onFailure: fail14,
    onDone: succeedNow
  });
  return new StreamImpl(pipeToOrFail(toChannel2(self), loop5));
});
var dropWhileEffect2 = dual(2, (self, predicate) => {
  const loop5 = readWith({
    onInput: (input) => pipe(dropWhile4(input, predicate), map26(unsafeFromArray), map26((leftover3) => {
      const more = isEmpty2(leftover3);
      if (more) {
        return suspend6(() => loop5);
      }
      return zipRight8(write(leftover3), identityChannel());
    }), unwrap2),
    onFailure: fail14,
    onDone: () => void_8
  });
  return new StreamImpl(pipeToOrFail(toChannel2(self), loop5));
});
var either9 = (self) => pipe(self, map33(right2), catchAll8((error4) => make73(left2(error4))));
var empty43 = new StreamImpl(void_8);
var ensuring9 = dual(2, (self, finalizer3) => new StreamImpl(pipe(toChannel2(self), ensuring5(finalizer3))));
var ensuringWith3 = dual(2, (self, finalizer3) => new StreamImpl(ensuringWith(toChannel2(self), finalizer3)));
var context10 = () => fromEffect9(context5());
var contextWith6 = (f) => pipe(context10(), map33(f));
var contextWithEffect5 = (f) => pipe(context10(), mapEffectSequential(f));
var contextWithStream = (f) => pipe(context10(), flatMap23(f));
var execute = (effect4) => drain3(fromEffect9(effect4));
var fail19 = (error4) => fromEffectOption(fail12(some3(error4)));
var failSync10 = (evaluate4) => fromEffectOption(failSync5(() => some3(evaluate4())));
var failCause16 = (cause3) => fromEffect9(failCause10(cause3));
var failCauseSync9 = (evaluate4) => fromEffect9(failCauseSync5(evaluate4));
var filter18 = dual(2, (self, predicate) => mapChunks(self, filter5(predicate)));
var filterEffect = dual(2, (self, f) => {
  const loop5 = (iterator) => {
    const next6 = iterator.next();
    if (next6.done) {
      return readWithCause({
        onInput: (input) => loop5(input[Symbol.iterator]()),
        onFailure: failCause12,
        onDone: succeed15
      });
    } else {
      return pipe(f(next6.value), map26((bool) => bool ? pipe(write(of3(next6.value)), flatMap20(() => loop5(iterator))) : loop5(iterator)), unwrap2);
    }
  };
  return new StreamImpl(suspend6(() => pipe(toChannel2(self), pipeTo(loop5(empty7()[Symbol.iterator]())))));
});
var filterMap12 = dual(2, (self, pf) => mapChunks(self, filterMap5(pf)));
var filterMapEffect = dual(2, (self, pf) => suspend10(() => {
  const loop5 = (iterator) => {
    const next6 = iterator.next();
    if (next6.done) {
      return readWithCause({
        onInput: (input) => loop5(input[Symbol.iterator]()),
        onFailure: failCause12,
        onDone: succeed15
      });
    } else {
      return pipe(pf(next6.value), match2({
        onNone: () => sync8(() => loop5(iterator)),
        onSome: map26((a2) => flatMap20(write(of3(a2)), () => loop5(iterator)))
      }), unwrap2);
    }
  };
  return new StreamImpl(pipe(toChannel2(self), pipeTo(loop5(empty7()[Symbol.iterator]()))));
}));
var filterMapWhile4 = dual(2, (self, pf) => {
  const loop5 = readWith({
    onInput: (input) => {
      const mapped = filterMapWhile3(input, pf);
      if (mapped.length === input.length) {
        return pipe(write(mapped), flatMap20(() => loop5));
      }
      return write(mapped);
    },
    onFailure: fail14,
    onDone: succeed15
  });
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(loop5)));
});
var filterMapWhileEffect = dual(2, (self, pf) => suspend10(() => {
  const loop5 = (iterator) => {
    const next6 = iterator.next();
    if (next6.done) {
      return readWithCause({
        onInput: (input) => loop5(input[Symbol.iterator]()),
        onFailure: failCause12,
        onDone: succeed15
      });
    } else {
      return unwrap2(match2(pf(next6.value), {
        onNone: () => succeed13(void_8),
        onSome: map26((a2) => flatMap20(write(of3(a2)), () => loop5(iterator)))
      }));
    }
  };
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(loop5(empty7()[Symbol.iterator]()))));
}));
var finalizer = (finalizer3) => acquireRelease4(_void, () => finalizer3);
var find3 = dual(2, (self, predicate) => {
  const loop5 = readWith({
    onInput: (input) => match2(findFirst4(input, predicate), {
      onNone: () => loop5,
      onSome: (n) => write(of3(n))
    }),
    onFailure: fail14,
    onDone: () => void_8
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(loop5)));
});
var findEffect2 = dual(2, (self, predicate) => {
  const loop5 = readWith({
    onInput: (input) => pipe(findFirst11(input, predicate), map26(match2({
      onNone: () => loop5,
      onSome: (n) => write(of3(n))
    })), unwrap2),
    onFailure: fail14,
    onDone: () => void_8
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(loop5)));
});
var flatMap23 = dual((args2) => isStream(args2[0]), (self, f, options) => {
  const bufferSize = options?.bufferSize ?? 16;
  if (options?.switch) {
    return matchConcurrency(options?.concurrency, () => flatMapParSwitchBuffer(self, 1, bufferSize, f), (n) => flatMapParSwitchBuffer(self, n, bufferSize, f));
  }
  return matchConcurrency(options?.concurrency, () => new StreamImpl(concatMap(toChannel2(self), (as18) => pipe(as18, map7((a) => toChannel2(f(a))), reduce4(void_8, (left3, right3) => pipe(left3, zipRight8(right3)))))), (_) => new StreamImpl(pipe(toChannel2(self), concatMap(writeChunk), mergeMap((out) => toChannel2(f(out)), options))));
});
var matchConcurrency = (concurrency, sequential6, bounded10) => {
  switch (concurrency) {
    case void 0:
      return sequential6();
    case "unbounded":
      return bounded10(Number.MAX_SAFE_INTEGER);
    default:
      return concurrency > 1 ? bounded10(concurrency) : sequential6();
  }
};
var flatMapParSwitchBuffer = dual(4, (self, n, bufferSize, f) => new StreamImpl(pipe(toChannel2(self), concatMap(writeChunk), mergeMap((out) => toChannel2(f(out)), {
  concurrency: n,
  mergeStrategy: BufferSliding(),
  bufferSize
}))));
var flatten17 = dual((args2) => isStream(args2[0]), (self, options) => flatMap23(self, identity, options));
var flattenChunks = (self) => {
  const flatten21 = readWithCause({
    onInput: (chunks3) => flatMap20(writeChunk(chunks3), () => flatten21),
    onFailure: failCause12,
    onDone: () => void_8
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(flatten21)));
};
var flattenEffect = dual((args2) => isStream(args2[0]), (self, options) => options?.unordered ? flatMap23(self, (a) => fromEffect9(a), {
  concurrency: options.concurrency
}) : matchConcurrency(options?.concurrency, () => mapEffectSequential(self, identity), (n) => new StreamImpl(pipe(toChannel2(self), concatMap(writeChunk), mapOutEffectPar(identity, n), mapOut(of3)))));
var flattenExitOption = (self) => {
  const processChunk = (chunk7, cont) => {
    const [toEmit, rest] = pipe(chunk7, splitWhere2((exit4) => !isSuccess(exit4)));
    const next6 = pipe(head3(rest), match2({
      onNone: () => cont,
      onSome: match7({
        onFailure: (cause3) => match2(flipCauseOption2(cause3), {
          onNone: () => void_8,
          onSome: failCause12
        }),
        onSuccess: () => void_8
      })
    }));
    return pipe(write(pipe(toEmit, filterMap5((exit4) => isSuccess(exit4) ? some3(exit4.value) : none2()))), flatMap20(() => next6));
  };
  const process2 = readWithCause({
    onInput: (chunk7) => processChunk(chunk7, process2),
    onFailure: (cause3) => failCause12(cause3),
    onDone: () => void_8
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(process2)));
};
var flattenIterables = (self) => pipe(self, map33(fromIterable3), flattenChunks);
var flattenTake = (self) => flattenChunks(flattenExitOption(pipe(self, map33((take16) => take16.exit))));
var forever6 = (self) => new StreamImpl(repeated(toChannel2(self)));
var fromAsyncIterable = (iterable, onError6) => pipe(acquireRelease3(sync8(() => iterable[Symbol.asyncIterator]()), (iterator) => iterator.return ? promise3(async () => iterator.return()) : _void), map26((iterator) => repeatEffectOption(pipe(tryPromise3({
  try: async () => iterator.next(),
  catch: (reason) => some3(onError6(reason))
}), flatMap18((result) => result.done ? fail12(none2()) : succeed13(result.value))))), unwrapScoped5);
var fromChannel2 = (channel) => new StreamImpl(channel);
var toChannel2 = (stream2) => {
  if ("channel" in stream2) {
    return stream2.channel;
  } else if (isEffect2(stream2)) {
    return toChannel2(fromEffect9(stream2));
  } else {
    throw new TypeError(`Expected a Stream.`);
  }
};
var fromChunk = (chunk7) => new StreamImpl(isEmpty2(chunk7) ? void_8 : write(chunk7));
var fromChunkPubSub = (pubsub, options) => {
  if (options?.scoped) {
    const effect4 = map26(subscribe2(pubsub), fromChunkQueue);
    return options.shutdown ? map26(effect4, ensuring9(shutdown3(pubsub))) : effect4;
  }
  const stream2 = flatMap23(scoped7(subscribe2(pubsub)), fromChunkQueue);
  return options?.shutdown ? ensuring9(stream2, shutdown3(pubsub)) : stream2;
};
var fromChunkQueue = (queue, options) => pipe(take6(queue), catchAllCause4((cause3) => pipe(isShutdown4(queue), flatMap18((isShutdown9) => isShutdown9 && isInterrupted3(cause3) ? end5() : failCause15(cause3)))), repeatEffectChunkOption, options?.shutdown ? ensuring9(shutdown4(queue)) : identity);
var fromChunks = (...chunks3) => pipe(fromIterable17(chunks3), flatMap23(fromChunk));
var fromEffect9 = (effect4) => pipe(effect4, mapError5(some3), fromEffectOption);
var fromEffectOption = (effect4) => new StreamImpl(unwrap2(match20(effect4, {
  onFailure: match2({
    onNone: () => void_8,
    onSome: fail14
  }),
  onSuccess: (a) => write(of3(a))
})));
var fromPubSub3 = (pubsub, options) => {
  const maxChunkSize = options?.maxChunkSize ?? DefaultChunkSize;
  if (options?.scoped) {
    const effect4 = map26(subscribe2(pubsub), (queue) => fromQueue3(queue, {
      maxChunkSize,
      shutdown: true
    }));
    return options.shutdown ? map26(effect4, ensuring9(shutdown3(pubsub))) : effect4;
  }
  const stream2 = flatMap23(scoped7(subscribe2(pubsub)), (queue) => fromQueue3(queue, {
    maxChunkSize
  }));
  return options?.shutdown ? ensuring9(stream2, shutdown3(pubsub)) : stream2;
};
var fromTPubSub = (pubsub) => {
  return unwrapScoped5(map26(subscribeScoped2(pubsub), (queue) => fromTQueue(queue)));
};
var fromIterable17 = (iterable) => suspend10(() => isChunk(iterable) ? fromChunk(iterable) : fromIteratorSucceed(iterable[Symbol.iterator]()));
var fromIterableEffect = (effect4) => pipe(effect4, map26(fromIterable17), unwrap4);
var fromIteratorSucceed = (iterator, maxChunkSize = DefaultChunkSize) => {
  return pipe(sync8(() => {
    let builder = [];
    const loop5 = (iterator2) => pipe(sync8(() => {
      let next6 = iterator2.next();
      if (maxChunkSize === 1) {
        if (next6.done) {
          return void_8;
        }
        return pipe(write(of3(next6.value)), flatMap20(() => loop5(iterator2)));
      }
      builder = [];
      let count9 = 0;
      while (next6.done === false) {
        builder.push(next6.value);
        count9 = count9 + 1;
        if (count9 >= maxChunkSize) {
          break;
        }
        next6 = iterator2.next();
      }
      if (count9 > 0) {
        return pipe(write(unsafeFromArray(builder)), flatMap20(() => loop5(iterator2)));
      }
      return void_8;
    }), unwrap2);
    return new StreamImpl(loop5(iterator));
  }), unwrap4);
};
var fromPull2 = (effect4) => pipe(effect4, map26(repeatEffectChunkOption), unwrapScoped5);
var fromQueue3 = (queue, options) => pipe(takeBetween2(queue, 1, options?.maxChunkSize ?? DefaultChunkSize), catchAllCause4((cause3) => pipe(isShutdown4(queue), flatMap18((isShutdown9) => isShutdown9 && isInterrupted3(cause3) ? end5() : failCause15(cause3)))), repeatEffectChunkOption, options?.shutdown ? ensuring9(shutdown4(queue)) : identity);
var fromTQueue = (queue) => pipe(take9(queue), map26(of3), catchAllCause4((cause3) => pipe(isShutdown8(queue), flatMap18((isShutdown9) => isShutdown9 && isInterrupted3(cause3) ? end5() : failCause15(cause3)))), repeatEffectChunkOption);
var fromSchedule = (schedule4) => pipe(driver2(schedule4), map26((driver3) => repeatEffectOption(driver3.next(void 0))), unwrap4);
var fromReadableStream = (...args2) => {
  const evaluate4 = args2.length === 1 ? args2[0].evaluate : args2[0];
  const onError6 = args2.length === 1 ? args2[0].onError : args2[1];
  const releaseLockOnEnd = args2.length === 1 ? args2[0].releaseLockOnEnd === true : false;
  return unwrapScoped5(map26(acquireRelease3(sync8(() => evaluate4().getReader()), (reader) => releaseLockOnEnd ? sync8(() => reader.releaseLock()) : promise3(() => reader.cancel())), (reader) => repeatEffectOption(flatMap18(tryPromise3({
    try: () => reader.read(),
    catch: (reason) => some3(onError6(reason))
  }), ({
    done: done17,
    value: value10
  }) => done17 ? fail12(none2()) : succeed13(value10)))));
};
var fromReadableStreamByob = (...args2) => {
  const evaluate4 = args2.length === 1 ? args2[0].evaluate : args2[0];
  const onError6 = args2.length === 1 ? args2[0].onError : args2[1];
  const allocSize = (args2.length === 1 ? args2[0].bufferSize : args2[2]) ?? 4096;
  const releaseLockOnEnd = args2.length === 1 ? args2[0].releaseLockOnEnd === true : false;
  return unwrapScoped5(map26(acquireRelease3(sync8(() => evaluate4().getReader({
    mode: "byob"
  })), (reader) => releaseLockOnEnd ? sync8(() => reader.releaseLock()) : promise3(() => reader.cancel())), (reader) => catchAll8(forever6(readChunkStreamByobReader(reader, onError6, allocSize)), (error4) => error4 === EOF ? empty43 : fail19(error4))));
};
var EOF = Symbol.for("effect/Stream/EOF");
var readChunkStreamByobReader = (reader, onError6, size40) => {
  const buffer5 = new ArrayBuffer(size40);
  return paginateEffect(0, (offset) => flatMap18(tryPromise3({
    try: () => reader.read(new Uint8Array(buffer5, offset, buffer5.byteLength - offset)),
    catch: (reason) => onError6(reason)
  }), ({
    done: done17,
    value: value10
  }) => {
    if (done17) {
      return fail12(EOF);
    }
    const newOffset = offset + value10.byteLength;
    return succeed13([value10, newOffset >= buffer5.byteLength ? none2() : some3(newOffset)]);
  }));
};
var groupAdjacentBy = dual(2, (self, f) => {
  const groupAdjacentByChunk = (state, chunk7) => {
    if (isEmpty2(chunk7)) {
      return [state, empty7()];
    }
    const builder = [];
    let from = 0;
    let until = 0;
    let key = void 0;
    let previousChunk = empty7();
    switch (state._tag) {
      case "Some": {
        const tuple7 = state.value;
        key = tuple7[0];
        let loop5 = true;
        while (loop5 && until < chunk7.length) {
          const input = unsafeGet4(chunk7, until);
          const updatedKey = f(input);
          if (!equals(key, updatedKey)) {
            const previousChunk2 = tuple7[1];
            const additionalChunk = unsafeFromArray(Array.from(chunk7).slice(from, until));
            const group5 = appendAll3(previousChunk2, additionalChunk);
            builder.push([key, group5]);
            key = updatedKey;
            from = until;
            loop5 = false;
          }
          until = until + 1;
        }
        if (loop5) {
          previousChunk = tuple7[1];
        }
        break;
      }
      case "None": {
        key = f(unsafeGet4(chunk7, until));
        until = until + 1;
        break;
      }
    }
    while (until < chunk7.length) {
      const input = unsafeGet4(chunk7, until);
      const updatedKey = f(input);
      if (!equals(key, updatedKey)) {
        builder.push([key, unsafeFromArray(Array.from(chunk7).slice(from, until))]);
        key = updatedKey;
        from = until;
      }
      until = until + 1;
    }
    const nonEmptyChunk = appendAll3(previousChunk, unsafeFromArray(Array.from(chunk7).slice(from, until)));
    const output = unsafeFromArray(builder);
    return [some3([key, nonEmptyChunk]), output];
  };
  const groupAdjacent = (state) => readWithCause({
    onInput: (input) => {
      const [updatedState, output] = groupAdjacentByChunk(state, input);
      return isEmpty2(output) ? groupAdjacent(updatedState) : flatMap20(write(output), () => groupAdjacent(updatedState));
    },
    onFailure: (cause3) => match2(state, {
      onNone: () => failCause12(cause3),
      onSome: (output) => flatMap20(write(of3(output)), () => failCause12(cause3))
    }),
    onDone: (done17) => match2(state, {
      onNone: () => succeedNow(done17),
      onSome: (output) => flatMap20(write(of3(output)), () => succeedNow(done17))
    })
  });
  return new StreamImpl(pipeToOrFail(toChannel2(self), groupAdjacent(none2())));
});
var grouped = dual(2, (self, chunkSize) => pipe(self, rechunk(chunkSize), chunks));
var groupedWithin = dual(3, (self, chunkSize, duration5) => aggregateWithin(self, collectAllN(chunkSize), spaced2(duration5)));
var haltWhen = dual(2, (self, effect4) => {
  const writer = (fiber) => pipe(poll4(fiber), map26(match2({
    onNone: () => readWith({
      onInput: (input) => flatMap20(write(input), () => writer(fiber)),
      onFailure: fail14,
      onDone: () => void_8
    }),
    onSome: match7({
      onFailure: failCause12,
      onSuccess: () => void_8
    })
  })), unwrap2);
  return new StreamImpl(unwrapScopedWith((scope6) => effect4.pipe(forkIn3(scope6), map26((fiber) => toChannel2(self).pipe(pipeTo(writer(fiber)))))));
});
var haltAfter = dual(2, (self, duration5) => pipe(self, haltWhen(sleep2(duration5))));
var haltWhenDeferred = dual(2, (self, deferred) => {
  const writer = pipe(poll(deferred), map26(match2({
    onNone: () => readWith({
      onInput: (input) => pipe(write(input), flatMap20(() => writer)),
      onFailure: fail14,
      onDone: () => void_8
    }),
    onSome: (effect4) => unwrap2(match20(effect4, {
      onFailure: fail14,
      onSuccess: () => void_8
    }))
  })), unwrap2);
  return new StreamImpl(pipe(toChannel2(self), pipeTo(writer)));
});
var identityStream = () => new StreamImpl(identityChannel());
var interleave = dual(2, (self, that) => pipe(self, interleaveWith(that, forever6(make73(true, false)))));
var interleaveWith = dual(3, (self, that, decider) => {
  const producer = (handoff) => readWithCause({
    onInput: (value10) => flatMap20(fromEffect5(offer6(handoff, of7(value10))), () => producer(handoff)),
    onFailure: (cause3) => fromEffect5(offer6(handoff, failCause14(cause3))),
    onDone: () => fromEffect5(offer6(handoff, end4))
  });
  return new StreamImpl(unwrapScopedWith((scope6) => pipe(make71(), zip12(make71()), tap5(([left3]) => toChannel2(self).pipe(concatMap(writeChunk), pipeTo(producer(left3)), runIn(scope6), forkIn3(scope6))), tap5(([_, right3]) => toChannel2(that).pipe(concatMap(writeChunk), pipeTo(producer(right3)), runIn(scope6), forkIn3(scope6))), map26(([left3, right3]) => {
    const process2 = (leftDone, rightDone) => readWithCause({
      onInput: (bool) => {
        if (bool && !leftDone) {
          return pipe(fromEffect5(take10(left3)), flatMap20(match32({
            onEnd: () => rightDone ? void_8 : process2(true, rightDone),
            onFailure: failCause12,
            onSuccess: (chunk7) => pipe(write(chunk7), flatMap20(() => process2(leftDone, rightDone)))
          })));
        }
        if (!bool && !rightDone) {
          return pipe(fromEffect5(take10(right3)), flatMap20(match32({
            onEnd: () => leftDone ? void_8 : process2(leftDone, true),
            onFailure: failCause12,
            onSuccess: (chunk7) => pipe(write(chunk7), flatMap20(() => process2(leftDone, rightDone)))
          })));
        }
        return process2(leftDone, rightDone);
      },
      onFailure: failCause12,
      onDone: () => void_8
    });
    return pipe(toChannel2(decider), concatMap(writeChunk), pipeTo(process2(false, false)));
  }))));
});
var intersperse3 = dual(2, (self, element2) => new StreamImpl(pipe(toChannel2(self), pipeToOrFail(suspend6(() => {
  const writer = (isFirst) => readWithCause({
    onInput: (chunk7) => {
      const builder = [];
      let flagResult = isFirst;
      for (const output of chunk7) {
        if (flagResult) {
          flagResult = false;
          builder.push(output);
        } else {
          builder.push(element2);
          builder.push(output);
        }
      }
      return pipe(write(unsafeFromArray(builder)), flatMap20(() => writer(flagResult)));
    },
    onFailure: failCause12,
    onDone: () => void_8
  });
  return writer(true);
})))));
var intersperseAffixes = dual(2, (self, {
  end: end7,
  middle,
  start: start5
}) => pipe(make73(start5), concat3(pipe(self, intersperse3(middle))), concat3(make73(end7))));
var interruptAfter2 = dual(2, (self, duration5) => pipe(self, interruptWhen2(sleep2(duration5))));
var interruptWhen2 = dual(2, (self, effect4) => new StreamImpl(pipe(toChannel2(self), interruptWhen(effect4))));
var interruptWhenDeferred2 = dual(2, (self, deferred) => new StreamImpl(pipe(toChannel2(self), interruptWhenDeferred(deferred))));
var iterate4 = (value10, next6) => unfold5(value10, (a) => some3([a, next6(a)]));
var make73 = (...as18) => fromIterable17(as18);
var map33 = dual(2, (self, f) => new StreamImpl(pipe(toChannel2(self), mapOut(map7(f)))));
var mapAccum5 = dual(3, (self, s, f) => {
  const accumulator = (s2) => readWith({
    onInput: (input) => {
      const [nextS, chunk7] = mapAccum2(input, s2, f);
      return flatMap20(write(chunk7), () => accumulator(nextS));
    },
    onFailure: fail14,
    onDone: () => void_8
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(accumulator(s))));
});
var mapAccumEffect = dual(3, (self, s, f) => suspend10(() => {
  const accumulator = (s2) => readWith({
    onInput: (input) => pipe(suspend4(() => {
      const outputs = [];
      const emit2 = (output) => sync8(() => {
        outputs.push(output);
      });
      return pipe(input, reduce17(s2, (s3, a) => pipe(f(s3, a), flatMap18(([s4, a2]) => pipe(emit2(a2), as8(s4))))), match20({
        onFailure: (error4) => {
          if (outputs.length !== 0) {
            return zipRight8(write(unsafeFromArray(outputs)), fail14(error4));
          }
          return fail14(error4);
        },
        onSuccess: (s3) => flatMap20(write(unsafeFromArray(outputs)), () => accumulator(s3))
      }));
    }), unwrap2),
    onFailure: fail14,
    onDone: () => void_8
  });
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(accumulator(s))));
}));
var mapBoth9 = dual(2, (self, options) => pipe(self, mapError10(options.onFailure), map33(options.onSuccess)));
var mapChunks = dual(2, (self, f) => new StreamImpl(pipe(toChannel2(self), mapOut(f))));
var mapChunksEffect = dual(2, (self, f) => new StreamImpl(pipe(toChannel2(self), mapOutEffect(f))));
var mapConcat = dual(2, (self, f) => pipe(self, mapConcatChunk((a) => fromIterable3(f(a)))));
var mapConcatChunk = dual(2, (self, f) => pipe(self, mapChunks(flatMap5(f))));
var mapConcatChunkEffect = dual(2, (self, f) => pipe(self, mapEffectSequential(f), mapConcatChunk(identity)));
var mapConcatEffect = dual(2, (self, f) => pipe(self, mapEffectSequential((a) => pipe(f(a), map26(fromIterable3))), mapConcatChunk(identity)));
var mapEffectSequential = dual(2, (self, f) => {
  const loop5 = (iterator) => {
    const next6 = iterator.next();
    if (next6.done) {
      return readWithCause({
        onInput: (elem) => loop5(elem[Symbol.iterator]()),
        onFailure: failCause12,
        onDone: succeed15
      });
    } else {
      const value10 = next6.value;
      return unwrap2(map26(f(value10), (a2) => flatMap20(write(of3(a2)), () => loop5(iterator))));
    }
  };
  return new StreamImpl(pipe(toChannel2(self), pipeTo(suspend6(() => loop5(empty7()[Symbol.iterator]())))));
});
var mapEffectPar = dual(3, (self, n, f) => new StreamImpl(pipe(toChannel2(self), concatMap(writeChunk), mapOutEffectPar(f, n), mapOut(of3))));
var mapError10 = dual(2, (self, f) => new StreamImpl(pipe(toChannel2(self), mapError7(f))));
var mapErrorCause6 = dual(2, (self, f) => new StreamImpl(pipe(toChannel2(self), mapErrorCause5(f))));
var merge10 = dual((args2) => isStream(args2[1]), (self, that, options) => mergeWith3(self, that, {
  onSelf: identity,
  onOther: identity,
  haltStrategy: options?.haltStrategy
}));
var mergeAll9 = dual((args2) => Symbol.iterator in args2[0], (streams, options) => flatten17(fromIterable17(streams), options));
var mergeWithTag = dual(2, (streams, options) => {
  const keys15 = Object.keys(streams);
  const values15 = keys15.map((key) => streams[key].pipe(map33((value10) => ({
    _tag: key,
    value: value10
  }))));
  return mergeAll9(values15, options);
});
var mergeEither = dual(2, (self, that) => mergeWith3(self, that, {
  onSelf: left2,
  onOther: right2
}));
var mergeLeft = dual(2, (left3, right3) => pipe(left3, merge10(drain3(right3))));
var mergeRight = dual(2, (left3, right3) => pipe(drain3(left3), merge10(right3)));
var mergeWith3 = dual(3, (self, other, options) => {
  const strategy = options.haltStrategy ? fromInput2(options.haltStrategy) : Both2;
  const handler = (terminate) => (exit4) => terminate || !isSuccess(exit4) ? (
    // TODO: remove
    Done4(suspend4(() => exit4))
  ) : Await2((exit5) => suspend4(() => exit5));
  return new StreamImpl(mergeWith2(toChannel2(map33(self, options.onSelf)), {
    other: toChannel2(map33(other, options.onOther)),
    onSelfDone: handler(strategy._tag === "Either" || strategy._tag === "Left"),
    onOtherDone: handler(strategy._tag === "Either" || strategy._tag === "Right")
  }));
});
var mkString2 = (self) => run4(self, mkString);
var never8 = fromEffect9(never5);
var onEnd = dual(2, (self, effect4) => concat3(self, drain3(fromEffect9(effect4))));
var onError4 = dual(2, (self, cleanup) => pipe(self, catchAllCause7((cause3) => fromEffect9(pipe(cleanup(cause3), zipRight7(failCause10(cause3)))))));
var onDone = dual(2, (self, cleanup) => new StreamImpl(pipe(toChannel2(self), ensuringWith((exit4) => isSuccess(exit4) ? cleanup() : _void))));
var onStart = dual(2, (self, effect4) => unwrap4(as8(effect4, self)));
var orDie8 = (self) => pipe(self, orDieWith5(identity));
var orDieWith5 = dual(2, (self, f) => new StreamImpl(pipe(toChannel2(self), orDieWith3(f))));
var orElse13 = dual(2, (self, that) => new StreamImpl(pipe(toChannel2(self), orElse10(() => toChannel2(that())))));
var orElseEither7 = dual(2, (self, that) => pipe(self, map33(left2), orElse13(() => pipe(that(), map33(right2)))));
var orElseFail4 = dual(2, (self, error4) => pipe(self, orElse13(() => failSync10(error4))));
var orElseIfEmpty = dual(2, (self, element2) => pipe(self, orElseIfEmptyChunk(() => of3(element2()))));
var orElseIfEmptyChunk = dual(2, (self, chunk7) => pipe(self, orElseIfEmptyStream(() => new StreamImpl(write(chunk7())))));
var orElseIfEmptyStream = dual(2, (self, stream2) => {
  const writer = readWith({
    onInput: (input) => {
      if (isEmpty2(input)) {
        return suspend6(() => writer);
      }
      return pipe(write(input), zipRight8(identityChannel()));
    },
    onFailure: fail14,
    onDone: () => suspend6(() => toChannel2(stream2()))
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(writer)));
});
var orElseSucceed5 = dual(2, (self, value10) => pipe(self, orElse13(() => sync14(value10))));
var paginate = (s, f) => paginateChunk(s, (s2) => {
  const page = f(s2);
  return [of3(page[0]), page[1]];
});
var paginateChunk = (s, f) => {
  const loop5 = (s2) => {
    const page = f(s2);
    return match2(page[1], {
      onNone: () => zipRight8(write(page[0]), void_8),
      onSome: (s3) => flatMap20(write(page[0]), () => loop5(s3))
    });
  };
  return new StreamImpl(suspend6(() => loop5(s)));
};
var paginateChunkEffect = (s, f) => {
  const loop5 = (s2) => unwrap2(map26(f(s2), ([chunk7, option11]) => match2(option11, {
    onNone: () => zipRight8(write(chunk7), void_8),
    onSome: (s3) => flatMap20(write(chunk7), () => loop5(s3))
  })));
  return new StreamImpl(suspend6(() => loop5(s)));
};
var paginateEffect = (s, f) => paginateChunkEffect(s, (s2) => pipe(f(s2), map26(([a, s3]) => [of3(a), s3])));
var peel = dual(2, (self, sink) => {
  const OP_EMIT5 = "Emit";
  const OP_HALT2 = "Halt";
  const OP_END2 = "End";
  return pipe(make24(), flatMap18((deferred) => pipe(make71(), map26((handoff) => {
    const consumer = foldSink(collectLeftover(sink), {
      onFailure: (error4) => zipRight9(fromEffect7(fail3(deferred, error4)), fail15(error4)),
      onSuccess: ([z, leftovers]) => {
        const loop5 = readWithCause({
          onInput: (elements) => flatMap20(fromEffect5(offer6(handoff, {
            _tag: OP_EMIT5,
            elements
          })), () => loop5),
          onFailure: (cause3) => zipRight8(fromEffect5(offer6(handoff, {
            _tag: OP_HALT2,
            cause: cause3
          })), failCause12(cause3)),
          onDone: (_) => zipRight8(fromEffect5(offer6(handoff, {
            _tag: OP_END2
          })), void_8)
        });
        return fromChannel(pipe(fromEffect5(succeed2(deferred, z)), zipRight8(fromEffect5(pipe(handoff, offer6({
          _tag: OP_EMIT5,
          elements: leftovers
        })))), zipRight8(loop5)));
      }
    });
    const producer = pipe(take10(handoff), map26((signal) => {
      switch (signal._tag) {
        case OP_EMIT5: {
          return pipe(write(signal.elements), flatMap20(() => producer));
        }
        case OP_HALT2: {
          return failCause12(signal.cause);
        }
        case OP_END2: {
          return void_8;
        }
      }
    }), unwrap2);
    return pipe(self, tapErrorCause6((cause3) => failCause2(deferred, cause3)), run4(consumer), forkScoped3, zipRight7(_await(deferred)), map26((z) => [z, new StreamImpl(producer)]));
  }))), flatten13);
});
var partition11 = dual((args2) => typeof args2[1] === "function", (self, predicate, options) => partitionEither(self, (a) => succeed13(predicate(a) ? right2(a) : left2(a)), options));
var partitionEither = dual((args2) => typeof args2[1] === "function", (self, predicate, options) => pipe(mapEffectSequential(self, predicate), distributedWith({
  size: 2,
  maximumLag: options?.bufferSize ?? 16,
  decide: match({
    onLeft: () => succeed13((n) => n === 0),
    onRight: () => succeed13((n) => n === 1)
  })
}), flatMap18(([queue1, queue2]) => succeed13([filterMap12(flattenExitOption(fromQueue3(queue1, {
  shutdown: true
})), (_) => match(_, {
  onLeft: some3,
  onRight: none2
})), filterMap12(flattenExitOption(fromQueue3(queue2, {
  shutdown: true
})), (_) => match(_, {
  onLeft: none2,
  onRight: some3
}))]))));
var pipeThrough = dual(2, (self, sink) => new StreamImpl(pipe(toChannel2(self), pipeToOrFail(toChannel(sink)))));
var pipeThroughChannel = dual(2, (self, channel) => new StreamImpl(pipeTo(toChannel2(self), channel)));
var pipeThroughChannelOrFail = dual(2, (self, chan) => new StreamImpl(pipe(toChannel2(self), pipeToOrFail(chan))));
var prepend6 = dual(2, (self, values15) => new StreamImpl(zipRight8(write(values15), toChannel2(self))));
var provideContext8 = dual(2, (self, context15) => new StreamImpl(pipe(toChannel2(self), provideContext4(context15))));
var provideSomeContext3 = dual(2, (self, context15) => mapInputContext7(self, merge3(context15)));
var provideLayer2 = dual(2, (self, layer) => new StreamImpl(unwrapScopedWith((scope6) => buildWithScope2(layer, scope6).pipe(map26((env) => pipe(toChannel2(self), provideContext4(env)))))));
var provideService10 = dual(3, (self, tag5, resource) => provideServiceEffect4(self, tag5, succeed13(resource)));
var provideServiceEffect4 = dual(3, (self, tag5, effect4) => provideServiceStream(self, tag5, fromEffect9(effect4)));
var provideServiceStream = dual(3, (self, tag5, stream2) => contextWithStream((env) => flatMap23(stream2, (service4) => pipe(self, provideContext8(add2(env, tag5, service4))))));
var mapInputContext7 = dual(2, (self, f) => contextWithStream((env) => pipe(self, provideContext8(f(env)))));
var provideSomeLayer3 = dual(2, (self, layer) => (
  // @ts-expect-error
  // @effect-diagnostics-next-line missingEffectContext:off
  pipe(self, provideLayer2(pipe(context6(), merge8(layer))))
));
var range4 = (min11, max13, chunkSize = DefaultChunkSize) => suspend10(() => {
  if (min11 > max13) {
    return empty43;
  }
  const go5 = (min12, max14, chunkSize2) => {
    const remaining = max14 - min12 + 1;
    if (remaining > chunkSize2) {
      return pipe(write(range3(min12, min12 + chunkSize2 - 1)), flatMap20(() => go5(min12 + chunkSize2, max14, chunkSize2)));
    }
    return write(range3(min12, min12 + remaining - 1));
  };
  return new StreamImpl(go5(min11, max13, chunkSize));
});
var race5 = dual(2, (left3, right3) => raceAll4(left3, right3));
var raceAll4 = (...streams) => make24().pipe(map26((halt2) => {
  let winner = null;
  return mergeAll9(streams.map((stream2, index) => stream2.pipe(takeWhile6(() => {
    if (winner === null) {
      winner = index;
      unsafeDone(halt2, void_4);
      return true;
    }
    return winner === index;
  }), interruptWhen2(_await(halt2).pipe(flatMap18(() => winner === index ? never5 : _void))))), {
    concurrency: streams.length
  });
}), unwrap4);
var rechunk = dual(2, (self, n) => suspend10(() => {
  const target = Math.max(n, 1);
  const process2 = rechunkProcess(new StreamRechunker(target), target);
  return new StreamImpl(pipe(toChannel2(self), pipeTo(process2)));
}));
var rechunkProcess = (rechunker, target) => readWithCause({
  onInput: (chunk7) => {
    if (chunk7.length === target && rechunker.isEmpty()) {
      return flatMap20(write(chunk7), () => rechunkProcess(rechunker, target));
    }
    if (chunk7.length > 0) {
      const chunks3 = [];
      let result = void 0;
      let index = 0;
      while (index < chunk7.length) {
        while (index < chunk7.length && result === void 0) {
          result = rechunker.write(pipe(chunk7, unsafeGet4(index)));
          index = index + 1;
        }
        if (result !== void 0) {
          chunks3.push(result);
          result = void 0;
        }
      }
      return flatMap20(writeAll(...chunks3), () => rechunkProcess(rechunker, target));
    }
    return suspend6(() => rechunkProcess(rechunker, target));
  },
  onFailure: (cause3) => zipRight8(rechunker.emitIfNotEmpty(), failCause12(cause3)),
  onDone: () => rechunker.emitIfNotEmpty()
});
var StreamRechunker = class {
  n;
  builder = [];
  pos = 0;
  constructor(n) {
    this.n = n;
  }
  isEmpty() {
    return this.pos === 0;
  }
  write(elem) {
    this.builder.push(elem);
    this.pos += 1;
    if (this.pos === this.n) {
      const result = unsafeFromArray(this.builder);
      this.builder = [];
      this.pos = 0;
      return result;
    }
    return void 0;
  }
  emitIfNotEmpty() {
    if (this.pos !== 0) {
      return write(unsafeFromArray(this.builder));
    }
    return void_8;
  }
};
var refineOrDie3 = dual(2, (self, pf) => pipe(self, refineOrDieWith3(pf, identity)));
var refineOrDieWith3 = dual(3, (self, pf, f) => new StreamImpl(catchAll6(toChannel2(self), (error4) => match2(pf(error4), {
  onNone: () => failCause12(die6(f(error4))),
  onSome: fail14
}))));
var repeat4 = dual(2, (self, schedule4) => filterMap12(repeatEither(self, schedule4), (_) => match(_, {
  onLeft: none2,
  onRight: some3
})));
var repeatEffect = (effect4) => repeatEffectOption(pipe(effect4, mapError5(some3)));
var repeatEffectChunk = (effect4) => repeatEffectChunkOption(pipe(effect4, mapError5(some3)));
var repeatEffectChunkOption = (effect4) => unfoldChunkEffect(effect4, (effect5) => pipe(map26(effect5, (chunk7) => some3([chunk7, effect5])), catchAll4(match2({
  onNone: () => succeed13(none2()),
  onSome: fail12
}))));
var repeatEffectOption = (effect4) => repeatEffectChunkOption(pipe(effect4, map26(of3)));
var repeatEither = dual(2, (self, schedule4) => repeatWith(self, schedule4, {
  onElement: (a) => right2(a),
  onSchedule: left2
}));
var repeatElements = dual(2, (self, schedule4) => filterMap12(repeatElementsWith(self, schedule4, {
  onElement: (a) => some3(a),
  onSchedule: none2
}), identity));
var repeatElementsWith = dual(3, (self, schedule4, options) => {
  const driver3 = pipe(driver2(schedule4), map26((driver4) => {
    const feed = (input) => match2(head3(input), {
      onNone: () => loop5,
      onSome: (a) => zipRight8(write(of3(options.onElement(a))), step4(pipe(input, drop3(1)), a))
    });
    const step4 = (input, a) => {
      const advance = pipe(driver4.next(a), as8(pipe(write(of3(options.onElement(a))), flatMap20(() => step4(input, a)))));
      const reset3 = pipe(driver4.last, orDie4, flatMap18((b) => pipe(driver4.reset, map26(() => pipe(write(of3(options.onSchedule(b))), zipRight8(feed(input)))))));
      return pipe(advance, orElse8(() => reset3), unwrap2);
    };
    const loop5 = readWith({
      onInput: feed,
      onFailure: fail14,
      onDone: () => void_8
    });
    return loop5;
  }), unwrap2);
  return new StreamImpl(pipe(toChannel2(self), pipeTo(driver3)));
});
var repeatValue = (value10) => new StreamImpl(repeated(write(of3(value10))));
var repeatWith = dual(3, (self, schedule4, options) => {
  return pipe(driver2(schedule4), map26((driver3) => {
    const provideLastIterationInfo = provideServiceEffect4(CurrentIterationMetadata2, get13(driver3.iterationMeta));
    const process2 = pipe(self, provideLastIterationInfo, map33(options.onElement), toChannel2);
    const loop5 = unwrap2(match20(driver3.next(void 0), {
      onFailure: () => void_8,
      onSuccess: (output) => flatMap20(process2, () => zipRight8(write(of3(options.onSchedule(output))), loop5))
    }));
    return new StreamImpl(zipRight8(process2, loop5));
  }), unwrap4);
});
var repeatWithSchedule = (value10, schedule4) => repeatEffectWithSchedule(succeed13(value10), schedule4);
var repeatEffectWithSchedule = (effect4, schedule4) => flatMap23(fromEffect9(zip12(effect4, driver2(schedule4))), ([a, driver3]) => {
  const provideLastIterationInfo = provideServiceEffect3(CurrentIterationMetadata2, get13(driver3.iterationMeta));
  return concat3(succeed20(a), unfoldEffect(a, (s) => matchEffect4(driver3.next(s), {
    onFailure: succeed13,
    onSuccess: () => map26(provideLastIterationInfo(effect4), (nextA) => some3([nextA, nextA]))
  })));
});
var retry7 = dual(2, (self, policy) => driver2(policy).pipe(map26((driver3) => {
  const provideLastIterationInfo = provideServiceEffect4(CurrentIterationMetadata2, get13(driver3.iterationMeta));
  const loop5 = toChannel2(provideLastIterationInfo(self)).pipe(mapOutEffect((out) => as8(driver3.reset, out)), catchAll6((error4) => driver3.next(error4).pipe(match20({
    onFailure: () => fail14(error4),
    onSuccess: () => loop5
  }), unwrap2)));
  return loop5;
}), unwrap2, fromChannel2));
var withExecutionPlan3 = dual((args2) => isStream(args2[0]), (self, policy, options) => suspend10(() => {
  const preventFallbackOnPartialStream = options?.preventFallbackOnPartialStream ?? false;
  let i = 0;
  let lastError = none2();
  const loop5 = suspend10(() => {
    const step4 = policy.steps[i++];
    if (!step4) {
      return fail19(getOrThrow2(lastError));
    }
    let nextStream = isContext2(step4.provide) ? provideSomeContext3(self, step4.provide) : provideSomeLayer3(self, step4.provide);
    let receivedElements = false;
    if (isSome2(lastError)) {
      const error4 = lastError.value;
      let attempted = false;
      const wrapped = nextStream;
      nextStream = suspend10(() => {
        if (attempted) return wrapped;
        attempted = true;
        return fail19(error4);
      });
      nextStream = scheduleDefectRefail2(retry7(nextStream, scheduleFromStep(step4, false)));
    } else {
      const schedule4 = scheduleFromStep(step4, true);
      nextStream = schedule4 ? scheduleDefectRefail2(retry7(nextStream, schedule4)) : nextStream;
    }
    return catchAll8(preventFallbackOnPartialStream ? mapChunks(nextStream, (chunk7) => {
      receivedElements = true;
      return chunk7;
    }) : nextStream, (error4) => {
      if (preventFallbackOnPartialStream && receivedElements) {
        return fail19(error4);
      }
      lastError = some3(error4);
      return loop5;
    });
  });
  return loop5;
}));
var scheduleDefectRefail2 = (self) => catchAllCause7(self, (cause3) => failCause16(scheduleDefectRefailCause(cause3)));
var run4 = dual(2, (self, sink) => toChannel2(self).pipe(pipeToOrFail(toChannel(sink)), runDrain));
var runCollect2 = (self) => run4(self, collectAll());
var runCount = (self) => run4(self, count3);
var runDrain2 = (self) => run4(self, drain2);
var runFold = dual(3, (self, s, f) => runFoldWhile(self, s, constTrue, f));
var runFoldEffect = dual(3, (self, s, f) => runFoldWhileEffect(self, s, constTrue, f));
var runFoldScoped = dual(3, (self, s, f) => pipe(self, runFoldWhileScoped(s, constTrue, f)));
var runFoldScopedEffect = dual(3, (self, s, f) => pipe(self, runFoldWhileScopedEffect(s, constTrue, f)));
var runFoldWhile = dual(4, (self, s, cont, f) => run4(self, fold(s, cont, f)));
var runFoldWhileEffect = dual(4, (self, s, cont, f) => run4(self, foldEffect(s, cont, f)));
var runFoldWhileScoped = dual(4, (self, s, cont, f) => pipe(self, runScoped2(fold(s, cont, f))));
var runFoldWhileScopedEffect = dual(4, (self, s, cont, f) => pipe(self, runScoped2(foldEffect(s, cont, f))));
var runForEach = dual(2, (self, f) => run4(self, forEach17(f)));
var runForEachChunk = dual(2, (self, f) => run4(self, forEachChunk(f)));
var runForEachChunkScoped = dual(2, (self, f) => pipe(self, runScoped2(forEachChunk(f))));
var runForEachScoped = dual(2, (self, f) => pipe(self, runScoped2(forEach17(f))));
var runForEachWhile = dual(2, (self, f) => run4(self, forEachWhile(f)));
var runForEachWhileScoped = dual(2, (self, f) => pipe(self, runScoped2(forEachWhile(f))));
var runHead = (self) => run4(self, head8());
var runIntoPubSub = dual(2, (self, pubsub) => pipe(self, runIntoQueue(pubsub)));
var runIntoPubSubScoped = dual(2, (self, pubsub) => pipe(self, runIntoQueueScoped(pubsub)));
var runIntoQueue = dual(2, (self, queue) => pipe(self, runIntoQueueScoped(queue), scoped4));
var runIntoQueueElementsScoped = dual(2, (self, queue) => {
  const writer = readWithCause({
    onInput: (input) => flatMap20(fromEffect5(offerAll3(queue, map7(input, succeed3))), () => writer),
    onFailure: (cause3) => fromEffect5(offer3(queue, failCause3(map22(cause3, some3)))),
    onDone: () => fromEffect5(offer3(queue, fail4(none2())))
  });
  return pipe(pipeTo(toChannel2(self), writer), drain, runScoped, asVoid6);
});
var runIntoQueueScoped = dual(2, (self, queue) => {
  const writer = readWithCause({
    onInput: (input) => flatMap20(write(chunk3(input)), () => writer),
    onFailure: (cause3) => write(failCause14(cause3)),
    onDone: () => write(end4)
  });
  return pipe(pipeTo(toChannel2(self), writer), mapOutEffect((take16) => offer3(queue, take16)), drain, runScoped, asVoid6);
});
var runLast = (self) => run4(self, last6());
var runScoped2 = dual(2, (self, sink) => pipe(toChannel2(self), pipeToOrFail(toChannel(sink)), drain, runScoped));
var runSum = (self) => run4(self, sum5);
var scan3 = dual(3, (self, s, f) => pipe(self, scanEffect(s, (s2, a) => succeed13(f(s2, a)))));
var scanReduce = dual(2, (self, f) => pipe(self, scanReduceEffect((a2, a) => succeed13(f(a2, a)))));
var scanReduceEffect = dual(2, (self, f) => pipe(self, mapAccumEffect(none2(), (option11, a) => {
  switch (option11._tag) {
    case "None": {
      return succeed13([some3(a), a]);
    }
    case "Some": {
      return pipe(f(option11.value, a), map26((b) => [some3(b), b]));
    }
  }
})));
var schedule2 = dual(2, (self, schedule4) => filterMap12(scheduleWith(self, schedule4, {
  onElement: some3,
  onSchedule: none2
}), identity));
var scheduleWith = dual(3, (self, schedule4, options) => {
  const loop5 = (driver3, iterator) => {
    const next6 = iterator.next();
    if (next6.done) {
      return readWithCause({
        onInput: (chunk7) => loop5(driver3, chunk7[Symbol.iterator]()),
        onFailure: failCause12,
        onDone: succeedNow
      });
    }
    return unwrap2(matchEffect4(driver3.next(next6.value), {
      onFailure: () => pipe(driver3.last, orDie4, map26((b) => pipe(write(make9(options.onElement(next6.value), options.onSchedule(b))), flatMap20(() => loop5(driver3, iterator)))), zipLeft7(driver3.reset)),
      onSuccess: () => succeed13(pipe(write(of3(options.onElement(next6.value))), flatMap20(() => loop5(driver3, iterator))))
    }));
  };
  return new StreamImpl(pipe(fromEffect5(driver2(schedule4)), flatMap20((driver3) => pipe(toChannel2(self), pipeTo(loop5(driver3, empty7()[Symbol.iterator]()))))));
});
var scanEffect = dual(3, (self, s, f) => new StreamImpl(pipe(write(of3(s)), flatMap20(() => toChannel2(pipe(self, mapAccumEffect(s, (s2, a) => pipe(f(s2, a), map26((s3) => [s3, s3])))))))));
var scoped7 = (effect4) => new StreamImpl(ensuring5(scoped6(pipe(effect4, map26(of3))), _void));
var scopedWith4 = (f) => new StreamImpl(scopedWith3((scope6) => f(scope6).pipe(map26(of3))));
var some17 = (self) => pipe(self, mapError10(some3), someOrFail(() => none2()));
var someOrElse = dual(2, (self, fallback) => pipe(self, map33(getOrElse2(fallback))));
var someOrFail = dual(2, (self, error4) => mapEffectSequential(self, match2({
  onNone: () => failSync5(error4),
  onSome: succeed13
})));
var sliding9 = dual(2, (self, chunkSize) => slidingSize(self, chunkSize, 1));
var slidingSize = dual(3, (self, chunkSize, stepSize) => {
  if (chunkSize <= 0 || stepSize <= 0) {
    return die14(new IllegalArgumentException2("Invalid bounds - `chunkSize` and `stepSize` must be greater than zero"));
  }
  return new StreamImpl(suspend6(() => {
    const queue = new RingBuffer(chunkSize);
    const emitOnStreamEnd = (queueSize, channelEnd) => {
      if (queueSize < chunkSize) {
        const items = queue.toChunk();
        const result2 = isEmpty2(items) ? empty7() : of3(items);
        return pipe(write(result2), flatMap20(() => channelEnd));
      }
      const lastEmitIndex = queueSize - (queueSize - chunkSize) % stepSize;
      if (lastEmitIndex === queueSize) {
        return channelEnd;
      }
      const leftovers = queueSize - (lastEmitIndex - chunkSize + stepSize);
      const lastItems = pipe(queue.toChunk(), takeRight2(leftovers));
      const result = isEmpty2(lastItems) ? empty7() : of3(lastItems);
      return pipe(write(result), flatMap20(() => channelEnd));
    };
    const reader = (queueSize) => readWithCause({
      onInput: (input) => flatMap20(write(filterMap5(input, (element2, index) => {
        queue.put(element2);
        const currentIndex = queueSize + index + 1;
        if (currentIndex < chunkSize || (currentIndex - chunkSize) % stepSize > 0) {
          return none2();
        }
        return some3(queue.toChunk());
      })), () => reader(queueSize + input.length)),
      onFailure: (cause3) => emitOnStreamEnd(queueSize, failCause12(cause3)),
      onDone: () => emitOnStreamEnd(queueSize, void_8)
    });
    return pipe(toChannel2(self), pipeTo(reader(0)));
  }));
});
var split4 = dual(2, (self, predicate) => {
  const split7 = (leftovers, input) => {
    const [chunk7, remaining] = pipe(leftovers, appendAll3(input), splitWhere2(predicate));
    if (isEmpty2(chunk7) || isEmpty2(remaining)) {
      return loop5(pipe(chunk7, appendAll3(pipe(remaining, drop3(1)))));
    }
    return pipe(write(of3(chunk7)), flatMap20(() => split7(empty7(), pipe(remaining, drop3(1)))));
  };
  const loop5 = (leftovers) => readWith({
    onInput: (input) => split7(leftovers, input),
    onFailure: fail14,
    onDone: () => {
      if (isEmpty2(leftovers)) {
        return void_8;
      }
      if (isNone2(pipe(leftovers, findFirst4(predicate)))) {
        return zipRight8(write(of3(leftovers)), void_8);
      }
      return zipRight8(split7(empty7(), leftovers), void_8);
    }
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(loop5(empty7()))));
});
var splitOnChunk = dual(2, (self, delimiter) => {
  const next6 = (leftover3, delimiterIndex) => readWithCause({
    onInput: (inputChunk) => {
      let buffer5;
      const [carry, delimiterCursor] = pipe(inputChunk, reduce4([pipe(leftover3, getOrElse2(() => empty7())), delimiterIndex], ([carry2, delimiterCursor2], a) => {
        const concatenated = pipe(carry2, append3(a));
        if (delimiterCursor2 < delimiter.length && equals(a, pipe(delimiter, unsafeGet4(delimiterCursor2)))) {
          if (delimiterCursor2 + 1 === delimiter.length) {
            if (buffer5 === void 0) {
              buffer5 = [];
            }
            buffer5.push(pipe(concatenated, take3(concatenated.length - delimiter.length)));
            return [empty7(), 0];
          }
          return [concatenated, delimiterCursor2 + 1];
        }
        return [concatenated, equals(a, pipe(delimiter, unsafeGet4(0))) ? 1 : 0];
      }));
      const output = buffer5 === void 0 ? empty7() : unsafeFromArray(buffer5);
      return flatMap20(write(output), () => next6(isNonEmpty2(carry) ? some3(carry) : none2(), delimiterCursor));
    },
    onFailure: (cause3) => match2(leftover3, {
      onNone: () => failCause12(cause3),
      onSome: (chunk7) => zipRight8(write(of3(chunk7)), failCause12(cause3))
    }),
    onDone: (done17) => match2(leftover3, {
      onNone: () => succeed15(done17),
      onSome: (chunk7) => zipRight8(write(of3(chunk7)), succeed15(done17))
    })
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(next6(none2(), 0))));
});
var splitLines2 = (self) => pipeThroughChannel(self, splitLines());
var succeed20 = (value10) => fromChunk(of3(value10));
var sync14 = (evaluate4) => suspend10(() => fromChunk(of3(evaluate4())));
var suspend10 = (stream2) => new StreamImpl(suspend6(() => toChannel2(stream2())));
var take11 = dual(2, (self, n) => {
  if (!Number.isInteger(n)) {
    return die14(new IllegalArgumentException2(`${n} must be an integer`));
  }
  const loop5 = (n2) => readWith({
    onInput: (input) => {
      const taken = pipe(input, take3(Math.min(n2, Number.POSITIVE_INFINITY)));
      const leftover3 = Math.max(0, n2 - taken.length);
      const more = leftover3 > 0;
      if (more) {
        return pipe(write(taken), flatMap20(() => loop5(leftover3)));
      }
      return write(taken);
    },
    onFailure: fail14,
    onDone: succeed15
  });
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(0 < n ? loop5(n) : void_8)));
});
var takeRight4 = dual(2, (self, n) => {
  if (n <= 0) {
    return empty43;
  }
  return new StreamImpl(pipe(succeed13(new RingBuffer(n)), map26((queue) => {
    const reader = readWith({
      onInput: (input) => {
        for (const element2 of input) {
          queue.put(element2);
        }
        return reader;
      },
      onFailure: fail14,
      onDone: () => pipe(write(queue.toChunk()), zipRight8(void_8))
    });
    return pipe(toChannel2(self), pipeTo(reader));
  }), unwrap2));
});
var takeUntil3 = dual(2, (self, predicate) => {
  const loop5 = readWith({
    onInput: (input) => {
      const taken = pipe(input, takeWhile3((a) => !predicate(a)));
      const last8 = pipe(input, drop3(taken.length), take3(1));
      if (isEmpty2(last8)) {
        return pipe(write(taken), flatMap20(() => loop5));
      }
      return write(pipe(taken, appendAll3(last8)));
    },
    onFailure: fail14,
    onDone: succeed15
  });
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(loop5)));
});
var takeUntilEffect = dual(2, (self, predicate) => {
  const loop5 = (iterator) => {
    const next6 = iterator.next();
    if (next6.done) {
      return readWithCause({
        onInput: (elem) => loop5(elem[Symbol.iterator]()),
        onFailure: failCause12,
        onDone: succeed15
      });
    }
    return pipe(predicate(next6.value), map26((bool) => bool ? write(of3(next6.value)) : pipe(write(of3(next6.value)), flatMap20(() => loop5(iterator)))), unwrap2);
  };
  return new StreamImpl(pipe(toChannel2(self), pipeTo(loop5(empty7()[Symbol.iterator]()))));
});
var takeWhile6 = dual(2, (self, predicate) => {
  const loop5 = readWith({
    onInput: (input) => {
      const taken = pipe(input, takeWhile3(predicate));
      const more = taken.length === input.length;
      if (more) {
        return pipe(write(taken), flatMap20(() => loop5));
      }
      return write(taken);
    },
    onFailure: fail14,
    onDone: succeed15
  });
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(loop5)));
});
var tap9 = dual(2, (self, f) => mapEffectSequential(self, (a) => as8(f(a), a)));
var tapBoth4 = dual(2, (self, options) => pipe(self, tapError7(options.onFailure), tap9(options.onSuccess)));
var tapError7 = dual(2, (self, f) => catchAll8(self, (error4) => fromEffect9(zipRight7(f(error4), fail12(error4)))));
var tapErrorCause6 = dual(2, (self, f) => {
  const loop5 = readWithCause({
    onInput: (chunk7) => flatMap20(write(chunk7), () => loop5),
    onFailure: (cause3) => fromEffect5(zipRight7(f(cause3), failCause10(cause3))),
    onDone: succeedNow
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(loop5)));
});
var tapSink = dual(2, (self, sink) => pipe(fromEffect9(all11([bounded5(1), make24()])), flatMap23(([queue, deferred]) => {
  const right3 = flattenTake(fromQueue3(queue, {
    maxChunkSize: 1
  }));
  const loop5 = readWithCause({
    onInput: (chunk7) => pipe(fromEffect5(offer3(queue, chunk3(chunk7))), foldCauseChannel({
      onFailure: () => flatMap20(write(chunk7), () => identityChannel()),
      onSuccess: () => flatMap20(write(chunk7), () => loop5)
    })),
    onFailure: (cause3) => pipe(fromEffect5(offer3(queue, failCause14(cause3))), foldCauseChannel({
      onFailure: () => failCause12(cause3),
      onSuccess: () => failCause12(cause3)
    })),
    onDone: () => pipe(fromEffect5(offer3(queue, end4)), foldCauseChannel({
      onFailure: () => void_8,
      onSuccess: () => void_8
    }))
  });
  return pipe(new StreamImpl(pipe(pipeTo(toChannel2(self), loop5), ensuring5(zipRight7(forkDaemon3(offer3(queue, end4)), _await(deferred))))), merge10(execute(pipe(run4(right3, sink), ensuring4(zipRight7(shutdown4(queue), succeed2(deferred, void 0)))))));
})));
var throttle = dual(2, (self, options) => throttleEffect(self, {
  ...options,
  cost: (chunk7) => succeed13(options.cost(chunk7))
}));
var throttleEffect = dual(2, (self, options) => {
  if (options.strategy === "enforce") {
    return throttleEnforceEffect(self, options.cost, options.units, options.duration, options.burst ?? 0);
  }
  return throttleShapeEffect(self, options.cost, options.units, options.duration, options.burst ?? 0);
});
var throttleEnforceEffect = (self, cost, units, duration5, burst) => {
  const loop5 = (tokens, timestampMillis) => readWithCause({
    onInput: (input) => pipe(cost(input), zip12(currentTimeMillis2), map26(([weight, currentTimeMillis4]) => {
      const elapsed3 = currentTimeMillis4 - timestampMillis;
      const cycles = elapsed3 / toMillis(duration5);
      const sum7 = tokens + cycles * units;
      const max13 = units + burst < 0 ? Number.POSITIVE_INFINITY : units + burst;
      const available3 = sum7 < 0 ? max13 : Math.min(sum7, max13);
      if (weight <= available3) {
        return pipe(write(input), flatMap20(() => loop5(available3 - weight, currentTimeMillis4)));
      }
      return loop5(tokens, timestampMillis);
    }), unwrap2),
    onFailure: failCause12,
    onDone: () => void_8
  });
  const throttled = pipe(currentTimeMillis2, map26((currentTimeMillis4) => loop5(units, currentTimeMillis4)), unwrap2);
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(throttled)));
};
var throttleShapeEffect = (self, costFn, units, duration5, burst) => {
  const loop5 = (tokens, timestampMillis) => readWithCause({
    onInput: (input) => pipe(costFn(input), zip12(currentTimeMillis2), map26(([weight, currentTimeMillis4]) => {
      const elapsed3 = currentTimeMillis4 - timestampMillis;
      const cycles = elapsed3 / toMillis(duration5);
      const sum7 = tokens + cycles * units;
      const max13 = units + burst < 0 ? Number.POSITIVE_INFINITY : units + burst;
      const available3 = sum7 < 0 ? max13 : Math.min(sum7, max13);
      const remaining = available3 - weight;
      const waitCycles = remaining >= 0 ? 0 : -remaining / units;
      const delay4 = millis(Math.max(0, waitCycles * toMillis(duration5)));
      if (greaterThan5(delay4, zero2)) {
        return pipe(fromEffect5(sleep2(delay4)), zipRight8(write(input)), flatMap20(() => loop5(remaining, currentTimeMillis4)));
      }
      return flatMap20(write(input), () => loop5(remaining, currentTimeMillis4));
    }), unwrap2),
    onFailure: failCause12,
    onDone: () => void_8
  });
  const throttled = pipe(currentTimeMillis2, map26((currentTimeMillis4) => loop5(units, currentTimeMillis4)), unwrap2);
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(throttled)));
};
var tick = (interval) => repeatWithSchedule(void 0, spaced2(interval));
var timeout4 = dual(2, (self, duration5) => pipe(toPull2(self), map26(timeoutFail2({
  onTimeout: () => none2(),
  duration: duration5
})), fromPull2));
var timeoutFail3 = dual(3, (self, error4, duration5) => pipe(self, timeoutTo3(duration5, failSync10(error4))));
var timeoutFailCause3 = dual(3, (self, cause3, duration5) => pipe(toPull2(self), map26(timeoutFailCause2({
  onTimeout: () => map22(cause3(), some3),
  duration: duration5
})), fromPull2));
var timeoutTo3 = dual(3, (self, duration5, that) => {
  const StreamTimeout = new RuntimeException2("Stream Timeout");
  return pipe(self, timeoutFailCause3(() => die6(StreamTimeout), duration5), catchSomeCause3((cause3) => isDieType2(cause3) && isRuntimeException2(cause3.defect) && cause3.defect.message !== void 0 && cause3.defect.message === "Stream Timeout" ? some3(that) : none2()));
});
var pubsubFromOptions = (options) => {
  if (typeof options === "number") {
    return bounded4(options);
  } else if (options.capacity === "unbounded") {
    return unbounded4({
      replay: options.replay
    });
  }
  switch (options.strategy) {
    case "dropping":
      return dropping3(options);
    case "sliding":
      return sliding3(options);
    default:
      return bounded4(options);
  }
};
var toPubSub2 = dual(2, (self, capacity10) => pipe(acquireRelease3(pubsubFromOptions(capacity10), (pubsub) => shutdown3(pubsub)), tap5((pubsub) => pipe(self, runIntoPubSubScoped(pubsub), forkScoped3))));
var toPull2 = (self) => map26(toPull(toChannel2(self)), (pull) => pipe(pull, mapError5(some3), flatMap18(match({
  onLeft: () => fail12(none2()),
  onRight: succeed13
}))));
var toQueue2 = dual((args2) => isStream(args2[0]), (self, options) => tap5(acquireRelease3(options?.strategy === "unbounded" ? unbounded5() : options?.strategy === "dropping" ? dropping4(options.capacity ?? 2) : options?.strategy === "sliding" ? sliding4(options.capacity ?? 2) : bounded5(options?.capacity ?? 2), (queue) => shutdown4(queue)), (queue) => forkScoped3(runIntoQueueScoped(self, queue))));
var toQueueOfElements = dual((args2) => isStream(args2[0]), (self, options) => tap5(acquireRelease3(bounded5(options?.capacity ?? 2), (queue) => shutdown4(queue)), (queue) => forkScoped3(runIntoQueueElementsScoped(self, queue))));
var toReadableStream = dual((args2) => isStream(args2[0]), (self, options) => toReadableStreamRuntime(self, defaultRuntime2, options));
var toReadableStreamEffect = dual((args2) => isStream(args2[0]), (self, options) => map26(runtime4(), (runtime8) => toReadableStreamRuntime(self, runtime8, options)));
var toReadableStreamRuntime = dual((args2) => isStream(args2[0]), (self, runtime8, options) => {
  const runFork4 = runFork3(runtime8);
  let currentResolve = void 0;
  let fiber = void 0;
  const latch = unsafeMakeLatch2(false);
  return new ReadableStream({
    start(controller) {
      fiber = runFork4(runForEachChunk(self, (chunk7) => {
        if (chunk7.length === 0) return _void;
        return latch.whenOpen(sync8(() => {
          latch.unsafeClose();
          for (const item of chunk7) {
            controller.enqueue(item);
          }
          currentResolve();
          currentResolve = void 0;
        }));
      }));
      fiber.addObserver((exit4) => {
        try {
          if (exit4._tag === "Failure") {
            controller.error(squash(exit4.cause));
          } else {
            controller.close();
          }
        } catch {
        }
      });
    },
    pull() {
      return new Promise((resolve) => {
        currentResolve = resolve;
        runSync2(latch.open);
      });
    },
    cancel() {
      if (!fiber) return;
      return runPromise2(asVoid6(interrupt7(fiber)));
    }
  }, options?.strategy);
});
var transduce = dual(2, (self, sink) => {
  const newChannel = suspend6(() => {
    const leftovers = {
      ref: empty7()
    };
    const upstreamDone = {
      ref: false
    };
    const buffer5 = suspend6(() => {
      const leftover3 = leftovers.ref;
      if (isEmpty2(leftover3)) {
        return readWith({
          onInput: (input) => pipe(write(input), flatMap20(() => buffer5)),
          onFailure: fail14,
          onDone: succeedNow
        });
      }
      leftovers.ref = empty7();
      return pipe(writeChunk(leftover3), flatMap20(() => buffer5));
    });
    const concatAndGet = (chunk7) => {
      const leftover3 = leftovers.ref;
      const concatenated = appendAll3(leftover3, filter5(chunk7, (chunk8) => chunk8.length !== 0));
      leftovers.ref = concatenated;
      return concatenated;
    };
    const upstreamMarker = readWith({
      onInput: (input) => flatMap20(write(input), () => upstreamMarker),
      onFailure: fail14,
      onDone: (done17) => zipRight8(sync10(() => {
        upstreamDone.ref = true;
      }), succeedNow(done17))
    });
    const transducer = pipe(sink, toChannel, collectElements, flatMap20(([leftover3, z]) => pipe(succeed15([upstreamDone.ref, concatAndGet(leftover3)]), flatMap20(([done17, newLeftovers]) => {
      const nextChannel = done17 && isEmpty2(newLeftovers) ? void_8 : transducer;
      return pipe(write(of3(z)), flatMap20(() => nextChannel));
    }))));
    return pipe(toChannel2(self), pipeTo(upstreamMarker), pipeTo(buffer5), pipeToOrFail(transducer));
  });
  return new StreamImpl(newChannel);
});
var toAsyncIterableRuntime = dual((args2) => isStream(args2[0]), (self, runtime8) => {
  const runFork4 = runFork3(runtime8);
  return {
    [Symbol.asyncIterator]() {
      let currentResolve = void 0;
      let currentReject = void 0;
      let fiber = void 0;
      const latch = unsafeMakeLatch2(false);
      let returned = false;
      return {
        next() {
          if (!fiber) {
            fiber = runFork4(runForEach(self, (value10) => latch.whenOpen(sync8(() => {
              latch.unsafeClose();
              currentResolve({
                done: false,
                value: value10
              });
              currentResolve = currentReject = void 0;
            }))));
            fiber.addObserver((exit4) => {
              if (returned) return;
              fiber = runFork2(latch.whenOpen(sync8(() => {
                if (exit4._tag === "Failure") {
                  currentReject(squash(exit4.cause));
                } else {
                  currentResolve({
                    done: true,
                    value: void 0
                  });
                }
                currentResolve = currentReject = void 0;
              })));
            });
          }
          return new Promise((resolve, reject3) => {
            currentResolve = resolve;
            currentReject = reject3;
            latch.unsafeOpen();
          });
        },
        return() {
          returned = true;
          if (!fiber) return Promise.resolve({
            done: true,
            value: void 0
          });
          return runPromise2(as8(interrupt7(fiber), {
            done: true,
            value: void 0
          }));
        }
      };
    }
  };
});
var toAsyncIterable = (self) => toAsyncIterableRuntime(self, defaultRuntime2);
var toAsyncIterableEffect = (self) => map26(runtime4(), (runtime8) => toAsyncIterableRuntime(self, runtime8));
var unfold5 = (s, f) => unfoldChunk(s, (s2) => pipe(f(s2), map2(([a, s3]) => [of3(a), s3])));
var unfoldChunk = (s, f) => {
  const loop5 = (s2) => match2(f(s2), {
    onNone: () => void_8,
    onSome: ([chunk7, s3]) => flatMap20(write(chunk7), () => loop5(s3))
  });
  return new StreamImpl(suspend6(() => loop5(s)));
};
var unfoldChunkEffect = (s, f) => suspend10(() => {
  const loop5 = (s2) => unwrap2(map26(f(s2), match2({
    onNone: () => void_8,
    onSome: ([chunk7, s3]) => flatMap20(write(chunk7), () => loop5(s3))
  })));
  return new StreamImpl(loop5(s));
});
var unfoldEffect = (s, f) => unfoldChunkEffect(s, (s2) => pipe(f(s2), map26(map2(([a, s3]) => [of3(a), s3]))));
var void_11 = succeed20(void 0);
var unwrap4 = (effect4) => flatten17(fromEffect9(effect4));
var unwrapScoped5 = (effect4) => flatten17(scoped7(effect4));
var unwrapScopedWith3 = (f) => flatten17(scopedWith4((scope6) => f(scope6)));
var updateService6 = dual(3, (self, tag5, f) => pipe(self, mapInputContext7((context15) => pipe(context15, add2(tag5, f(pipe(context15, unsafeGet3(tag5))))))));
var when5 = dual(2, (self, test3) => pipe(self, whenEffect3(sync8(test3))));
var whenCase = (evaluate4, pf) => whenCaseEffect(pf)(sync8(evaluate4));
var whenCaseEffect = dual(2, (self, pf) => pipe(fromEffect9(self), flatMap23((a) => pipe(pf(a), getOrElse2(() => empty43)))));
var whenEffect3 = dual(2, (self, effect4) => pipe(fromEffect9(effect4), flatMap23((bool) => bool ? self : empty43)));
var withSpan6 = function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self = arguments[0];
    return new StreamImpl(withSpan5(toChannel2(self), name, options));
  }
  return (self) => new StreamImpl(withSpan5(toChannel2(self), name, options));
};
var zip16 = dual(2, (self, that) => pipe(self, zipWith17(that, (a, a2) => [a, a2])));
var zipFlatten2 = dual(2, (self, that) => pipe(self, zipWith17(that, (a, a2) => [...a, a2])));
var zipAll = dual(2, (self, options) => zipAllWith(self, {
  other: options.other,
  onSelf: (a) => [a, options.defaultOther],
  onOther: (a2) => [options.defaultSelf, a2],
  onBoth: (a, a2) => [a, a2]
}));
var zipAllLeft = dual(3, (self, other, defaultSelf) => zipAllWith(self, {
  other,
  onSelf: identity,
  onOther: () => defaultSelf,
  onBoth: (a) => a
}));
var zipAllRight = dual(3, (self, other, defaultRight) => zipAllWith(self, {
  other,
  onSelf: () => defaultRight,
  onOther: identity,
  onBoth: (_, a2) => a2
}));
var zipAllSortedByKey = dual(2, (self, options) => zipAllSortedByKeyWith(self, {
  other: options.other,
  onSelf: (a) => [a, options.defaultOther],
  onOther: (a2) => [options.defaultSelf, a2],
  onBoth: (a, a2) => [a, a2],
  order: options.order
}));
var zipAllSortedByKeyLeft = dual(2, (self, options) => zipAllSortedByKeyWith(self, {
  other: options.other,
  onSelf: identity,
  onOther: () => options.defaultSelf,
  onBoth: (a) => a,
  order: options.order
}));
var zipAllSortedByKeyRight = dual(2, (self, options) => zipAllSortedByKeyWith(self, {
  other: options.other,
  onSelf: () => options.defaultOther,
  onOther: identity,
  onBoth: (_, a2) => a2,
  order: options.order
}));
var zipAllSortedByKeyWith = dual(2, (self, options) => {
  const pull = (state, pullLeft, pullRight) => {
    switch (state._tag) {
      case OP_DRAIN_LEFT: {
        return pipe(pullLeft, match20({
          onFailure: fail4,
          onSuccess: (leftChunk) => succeed3([map7(leftChunk, ([k, a]) => [k, options.onSelf(a)]), DrainLeft])
        }));
      }
      case OP_DRAIN_RIGHT: {
        return pipe(pullRight, match20({
          onFailure: fail4,
          onSuccess: (rightChunk) => succeed3([map7(rightChunk, ([k, a2]) => [k, options.onOther(a2)]), DrainRight])
        }));
      }
      case OP_PULL_BOTH: {
        return pipe(unsome2(pullLeft), zip12(unsome2(pullRight), {
          concurrent: true
        }), matchEffect4({
          onFailure: (error4) => succeed13(fail4(some3(error4))),
          onSuccess: ([leftOption, rightOption]) => {
            if (isSome2(leftOption) && isSome2(rightOption)) {
              if (isEmpty2(leftOption.value) && isEmpty2(rightOption.value)) {
                return pull(PullBoth, pullLeft, pullRight);
              }
              if (isEmpty2(leftOption.value)) {
                return pull(PullLeft(rightOption.value), pullLeft, pullRight);
              }
              if (isEmpty2(rightOption.value)) {
                return pull(PullRight(leftOption.value), pullLeft, pullRight);
              }
              return succeed13(succeed3(merge16(leftOption.value, rightOption.value)));
            }
            if (isSome2(leftOption) && isNone2(rightOption)) {
              if (isEmpty2(leftOption.value)) {
                return pull(DrainLeft, pullLeft, pullRight);
              }
              return succeed13(succeed3([pipe(leftOption.value, map7(([k, a]) => [k, options.onSelf(a)])), DrainLeft]));
            }
            if (isNone2(leftOption) && isSome2(rightOption)) {
              if (isEmpty2(rightOption.value)) {
                return pull(DrainRight, pullLeft, pullRight);
              }
              return succeed13(succeed3([pipe(rightOption.value, map7(([k, a2]) => [k, options.onOther(a2)])), DrainRight]));
            }
            return succeed13(fail4(none2()));
          }
        }));
      }
      case OP_PULL_LEFT: {
        return matchEffect4(pullLeft, {
          onFailure: match2({
            onNone: () => succeed13(succeed3([pipe(state.rightChunk, map7(([k, a2]) => [k, options.onOther(a2)])), DrainRight])),
            onSome: (error4) => succeed13(fail4(some3(error4)))
          }),
          onSuccess: (leftChunk) => isEmpty2(leftChunk) ? pull(PullLeft(state.rightChunk), pullLeft, pullRight) : succeed13(succeed3(merge16(leftChunk, state.rightChunk)))
        });
      }
      case OP_PULL_RIGHT: {
        return matchEffect4(pullRight, {
          onFailure: match2({
            onNone: () => succeed13(succeed3([map7(state.leftChunk, ([k, a]) => [k, options.onSelf(a)]), DrainLeft])),
            onSome: (error4) => succeed13(fail4(some3(error4)))
          }),
          onSuccess: (rightChunk) => isEmpty2(rightChunk) ? pull(PullRight(state.leftChunk), pullLeft, pullRight) : succeed13(succeed3(merge16(state.leftChunk, rightChunk)))
        });
      }
    }
  };
  const merge16 = (leftChunk, rightChunk) => {
    const hasNext = (chunk7, index) => index < chunk7.length - 1;
    const builder = [];
    let state = void 0;
    let leftIndex = 0;
    let rightIndex = 0;
    let leftTuple = pipe(leftChunk, unsafeGet4(leftIndex));
    let rightTuple = pipe(rightChunk, unsafeGet4(rightIndex));
    let k1 = leftTuple[0];
    let a = leftTuple[1];
    let k2 = rightTuple[0];
    let a2 = rightTuple[1];
    let loop5 = true;
    while (loop5) {
      const compare2 = options.order(k1, k2);
      if (compare2 === 0) {
        builder.push([k1, options.onBoth(a, a2)]);
        if (hasNext(leftChunk, leftIndex) && hasNext(rightChunk, rightIndex)) {
          leftIndex = leftIndex + 1;
          rightIndex = rightIndex + 1;
          leftTuple = pipe(leftChunk, unsafeGet4(leftIndex));
          rightTuple = pipe(rightChunk, unsafeGet4(rightIndex));
          k1 = leftTuple[0];
          a = leftTuple[1];
          k2 = rightTuple[0];
          a2 = rightTuple[1];
        } else if (hasNext(leftChunk, leftIndex)) {
          state = PullRight(pipe(leftChunk, drop3(leftIndex + 1)));
          loop5 = false;
        } else if (hasNext(rightChunk, rightIndex)) {
          state = PullLeft(pipe(rightChunk, drop3(rightIndex + 1)));
          loop5 = false;
        } else {
          state = PullBoth;
          loop5 = false;
        }
      } else if (compare2 < 0) {
        builder.push([k1, options.onSelf(a)]);
        if (hasNext(leftChunk, leftIndex)) {
          leftIndex = leftIndex + 1;
          leftTuple = pipe(leftChunk, unsafeGet4(leftIndex));
          k1 = leftTuple[0];
          a = leftTuple[1];
        } else {
          const rightBuilder = [];
          rightBuilder.push(rightTuple);
          while (hasNext(rightChunk, rightIndex)) {
            rightIndex = rightIndex + 1;
            rightTuple = pipe(rightChunk, unsafeGet4(rightIndex));
            rightBuilder.push(rightTuple);
          }
          state = PullLeft(unsafeFromArray(rightBuilder));
          loop5 = false;
        }
      } else {
        builder.push([k2, options.onOther(a2)]);
        if (hasNext(rightChunk, rightIndex)) {
          rightIndex = rightIndex + 1;
          rightTuple = pipe(rightChunk, unsafeGet4(rightIndex));
          k2 = rightTuple[0];
          a2 = rightTuple[1];
        } else {
          const leftBuilder = [];
          leftBuilder.push(leftTuple);
          while (hasNext(leftChunk, leftIndex)) {
            leftIndex = leftIndex + 1;
            leftTuple = pipe(leftChunk, unsafeGet4(leftIndex));
            leftBuilder.push(leftTuple);
          }
          state = PullRight(unsafeFromArray(leftBuilder));
          loop5 = false;
        }
      }
    }
    return [unsafeFromArray(builder), state];
  };
  return combineChunks(self, options.other, PullBoth, pull);
});
var zipAllWith = dual(2, (self, options) => {
  const pull = (state, pullLeft, pullRight) => {
    switch (state._tag) {
      case OP_DRAIN_LEFT: {
        return matchEffect4(pullLeft, {
          onFailure: (error4) => succeed13(fail4(error4)),
          onSuccess: (leftChunk) => succeed13(succeed3([map7(leftChunk, options.onSelf), DrainLeft]))
        });
      }
      case OP_DRAIN_RIGHT: {
        return matchEffect4(pullRight, {
          onFailure: (error4) => succeed13(fail4(error4)),
          onSuccess: (rightChunk) => succeed13(succeed3([map7(rightChunk, options.onOther), DrainRight]))
        });
      }
      case OP_PULL_BOTH: {
        return pipe(unsome2(pullLeft), zip12(unsome2(pullRight), {
          concurrent: true
        }), matchEffect4({
          onFailure: (error4) => succeed13(fail4(some3(error4))),
          onSuccess: ([leftOption, rightOption]) => {
            if (isSome2(leftOption) && isSome2(rightOption)) {
              if (isEmpty2(leftOption.value) && isEmpty2(rightOption.value)) {
                return pull(PullBoth, pullLeft, pullRight);
              }
              if (isEmpty2(leftOption.value)) {
                return pull(PullLeft(rightOption.value), pullLeft, pullRight);
              }
              if (isEmpty2(rightOption.value)) {
                return pull(PullRight(leftOption.value), pullLeft, pullRight);
              }
              return succeed13(succeed3(zip27(leftOption.value, rightOption.value, options.onBoth)));
            }
            if (isSome2(leftOption) && isNone2(rightOption)) {
              return succeed13(succeed3([map7(leftOption.value, options.onSelf), DrainLeft]));
            }
            if (isNone2(leftOption) && isSome2(rightOption)) {
              return succeed13(succeed3([map7(rightOption.value, options.onOther), DrainRight]));
            }
            return succeed13(fail4(none2()));
          }
        }));
      }
      case OP_PULL_LEFT: {
        return matchEffect4(pullLeft, {
          onFailure: match2({
            onNone: () => succeed13(succeed3([map7(state.rightChunk, options.onOther), DrainRight])),
            onSome: (error4) => succeed13(fail4(some3(error4)))
          }),
          onSuccess: (leftChunk) => {
            if (isEmpty2(leftChunk)) {
              return pull(PullLeft(state.rightChunk), pullLeft, pullRight);
            }
            if (isEmpty2(state.rightChunk)) {
              return pull(PullRight(leftChunk), pullLeft, pullRight);
            }
            return succeed13(succeed3(zip27(leftChunk, state.rightChunk, options.onBoth)));
          }
        });
      }
      case OP_PULL_RIGHT: {
        return matchEffect4(pullRight, {
          onFailure: match2({
            onNone: () => succeed13(succeed3([map7(state.leftChunk, options.onSelf), DrainLeft])),
            onSome: (error4) => succeed13(fail4(some3(error4)))
          }),
          onSuccess: (rightChunk) => {
            if (isEmpty2(rightChunk)) {
              return pull(PullRight(state.leftChunk), pullLeft, pullRight);
            }
            if (isEmpty2(state.leftChunk)) {
              return pull(PullLeft(rightChunk), pullLeft, pullRight);
            }
            return succeed13(succeed3(zip27(state.leftChunk, rightChunk, options.onBoth)));
          }
        });
      }
    }
  };
  const zip27 = (leftChunk, rightChunk, f) => {
    const [output, either14] = zipChunks(leftChunk, rightChunk, f);
    switch (either14._tag) {
      case "Left": {
        if (isEmpty2(either14.left)) {
          return [output, PullBoth];
        }
        return [output, PullRight(either14.left)];
      }
      case "Right": {
        if (isEmpty2(either14.right)) {
          return [output, PullBoth];
        }
        return [output, PullLeft(either14.right)];
      }
    }
  };
  return combineChunks(self, options.other, PullBoth, pull);
});
var zipLatest = dual(2, (left3, right3) => pipe(left3, zipLatestWith(right3, (a, a2) => [a, a2])));
var zipLatestAll = (...streams) => {
  if (streams.length === 0) {
    return empty43;
  } else if (streams.length === 1) {
    return map33(streams[0], (x) => [x]);
  }
  const [head13, ...tail5] = streams;
  return zipLatestWith(head13, zipLatestAll(...tail5), (first5, second) => [first5, ...second]);
};
var zipLatestWith = dual(3, (left3, right3, f) => {
  const pullNonEmpty = (pull) => pipe(pull, flatMap18((chunk7) => isEmpty2(chunk7) ? pullNonEmpty(pull) : succeed13(chunk7)));
  return pipe(toPull2(left3), map26(pullNonEmpty), zip12(pipe(toPull2(right3), map26(pullNonEmpty))), flatMap18(([left4, right4]) => pipe(fromEffectOption(raceWith2(left4, right4, {
    onSelfDone: (leftDone, rightFiber) => pipe(suspend4(() => leftDone), zipWith12(join4(rightFiber), (l, r) => [l, r, true])),
    onOtherDone: (rightDone, leftFiber) => pipe(suspend4(() => rightDone), zipWith12(join4(leftFiber), (l, r) => [r, l, false]))
  })), flatMap23(([l, r, leftFirst]) => pipe(fromEffect9(make37([unsafeLast(l), unsafeLast(r)])), flatMap23((latest) => pipe(fromChunk(leftFirst ? pipe(r, map7((a2) => f(unsafeLast(l), a2))) : pipe(l, map7((a) => f(a, unsafeLast(r))))), concat3(pipe(repeatEffectOption(left4), mergeEither(repeatEffectOption(right4)), mapEffectSequential(match({
    onLeft: (leftChunk) => modify8(latest, ([_, rightLatest]) => [pipe(leftChunk, map7((a) => f(a, rightLatest))), [unsafeLast(leftChunk), rightLatest]]),
    onRight: (rightChunk) => modify8(latest, ([leftLatest, _]) => [pipe(rightChunk, map7((a2) => f(leftLatest, a2))), [leftLatest, unsafeLast(rightChunk)]])
  })), flatMap23(fromChunk))))))), toPull2)), fromPull2);
});
var zipLeft12 = dual(2, (left3, right3) => pipe(left3, zipWithChunks(right3, (left4, right4) => {
  if (left4.length > right4.length) {
    return [pipe(left4, take3(right4.length)), left2(pipe(left4, take3(right4.length)))];
  }
  return [left4, right2(pipe(right4, drop3(left4.length)))];
})));
var zipRight12 = dual(2, (left3, right3) => pipe(left3, zipWithChunks(right3, (left4, right4) => {
  if (left4.length > right4.length) {
    return [right4, left2(pipe(left4, take3(right4.length)))];
  }
  return [pipe(right4, take3(left4.length)), right2(pipe(right4, drop3(left4.length)))];
})));
var zipWith17 = dual(3, (left3, right3, f) => pipe(left3, zipWithChunks(right3, (leftChunk, rightChunk) => zipChunks(leftChunk, rightChunk, f))));
var zipWithChunks = dual(3, (self, that, f) => {
  const pull = (state, pullLeft, pullRight) => {
    switch (state._tag) {
      case OP_PULL_BOTH2: {
        return pipe(unsome2(pullLeft), zip12(unsome2(pullRight), {
          concurrent: true
        }), matchEffect4({
          onFailure: (error4) => succeed13(fail4(some3(error4))),
          onSuccess: ([leftOption, rightOption]) => {
            if (isSome2(leftOption) && isSome2(rightOption)) {
              if (isEmpty2(leftOption.value) && isEmpty2(rightOption.value)) {
                return pull(PullBoth2, pullLeft, pullRight);
              }
              if (isEmpty2(leftOption.value)) {
                return pull(PullLeft2(rightOption.value), pullLeft, pullRight);
              }
              if (isEmpty2(rightOption.value)) {
                return pull(PullRight2(leftOption.value), pullLeft, pullRight);
              }
              return succeed13(succeed3(zip27(leftOption.value, rightOption.value)));
            }
            return succeed13(fail4(none2()));
          }
        }));
      }
      case OP_PULL_LEFT2: {
        return matchEffect4(pullLeft, {
          onFailure: (error4) => succeed13(fail4(error4)),
          onSuccess: (leftChunk) => {
            if (isEmpty2(leftChunk)) {
              return pull(PullLeft2(state.rightChunk), pullLeft, pullRight);
            }
            if (isEmpty2(state.rightChunk)) {
              return pull(PullRight2(leftChunk), pullLeft, pullRight);
            }
            return succeed13(succeed3(zip27(leftChunk, state.rightChunk)));
          }
        });
      }
      case OP_PULL_RIGHT2: {
        return matchEffect4(pullRight, {
          onFailure: (error4) => succeed13(fail4(error4)),
          onSuccess: (rightChunk) => {
            if (isEmpty2(rightChunk)) {
              return pull(PullRight2(state.leftChunk), pullLeft, pullRight);
            }
            if (isEmpty2(state.leftChunk)) {
              return pull(PullLeft2(rightChunk), pullLeft, pullRight);
            }
            return succeed13(succeed3(zip27(state.leftChunk, rightChunk)));
          }
        });
      }
    }
  };
  const zip27 = (leftChunk, rightChunk) => {
    const [output, either14] = f(leftChunk, rightChunk);
    switch (either14._tag) {
      case "Left": {
        if (isEmpty2(either14.left)) {
          return [output, PullBoth2];
        }
        return [output, PullRight2(either14.left)];
      }
      case "Right": {
        if (isEmpty2(either14.right)) {
          return [output, PullBoth2];
        }
        return [output, PullLeft2(either14.right)];
      }
    }
  };
  return pipe(self, combineChunks(that, PullBoth2, pull));
});
var zipWithIndex = (self) => pipe(self, mapAccum5(0, (index, a) => [index + 1, [a, index]]));
var zipWithNext = (self) => {
  const process2 = (last8) => readWithCause({
    onInput: (input) => {
      const [newLast, chunk7] = mapAccum2(input, last8, (prev, curr) => [some3(curr), pipe(prev, map2((a) => [a, curr]))]);
      const output = filterMap5(chunk7, (option11) => isSome2(option11) ? some3([option11.value[0], some3(option11.value[1])]) : none2());
      return flatMap20(write(output), () => process2(newLast));
    },
    onFailure: failCause12,
    onDone: () => match2(last8, {
      onNone: () => void_8,
      onSome: (value10) => zipRight8(write(of3([value10, none2()])), void_8)
    })
  });
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(process2(none2()))));
};
var zipWithPrevious = (self) => pipe(self, mapAccum5(none2(), (prev, curr) => [some3(curr), [prev, curr]]));
var zipWithPreviousAndNext = (self) => pipe(zipWithNext(zipWithPrevious(self)), map33(([[prev, curr], next6]) => [prev, curr, pipe(next6, map2((tuple7) => tuple7[1]))]));
var zipChunks = (left3, right3, f) => {
  if (left3.length > right3.length) {
    return [pipe(left3, take3(right3.length), zipWith5(right3, f)), left2(pipe(left3, drop3(right3.length)))];
  }
  return [pipe(left3, zipWith5(pipe(right3, take3(left3.length)), f)), right2(pipe(right3, drop3(left3.length)))];
};
var Do7 = succeed20({});
var bind9 = dual((args2) => typeof args2[0] !== "string", (self, tag5, f, options) => flatMap23(self, (k) => map33(f(k), (a) => ({
  ...k,
  [tag5]: a
})), options));
var bindTo9 = bindTo(map33);
var let_9 = let_(map33);
var channelToStream = (self) => {
  return new StreamImpl(self);
};
var decodeText = dual((args2) => isStream(args2[0]), (self, encoding = "utf-8") => suspend10(() => {
  const decoder2 = new TextDecoder(encoding);
  return map33(self, (s) => decoder2.decode(s));
}));
var encodeText = (self) => suspend10(() => {
  const encoder2 = new TextEncoder();
  return map33(self, (s) => encoder2.encode(s));
});
var fromEventListener = (target, type3, options) => asyncPush((emit2) => acquireRelease3(sync8(() => target.addEventListener(type3, emit2.single, options)), () => sync8(() => target.removeEventListener(type3, emit2.single, options))), {
  bufferSize: typeof options === "object" ? options.bufferSize : void 0
});

// ../../node_modules/effect/dist/esm/Channel.js
var ChannelTypeId4 = ChannelTypeId3;
var ChannelExceptionTypeId2 = ChannelExceptionTypeId;
var isChannel2 = isChannel;
var acquireUseRelease6 = acquireUseRelease4;
var acquireReleaseOut2 = acquireReleaseOut;
var as14 = as9;
var asVoid10 = asVoid7;
var buffer3 = buffer;
var bufferChunk2 = bufferChunk;
var catchAll9 = catchAll6;
var catchAllCause8 = catchAllCause6;
var concatAll3 = concatAll;
var concatAllWith2 = concatAllWith;
var concatMap2 = concatMap;
var concatMapWith2 = concatMapWith;
var concatMapWithCustom2 = concatMapWithCustom;
var collect4 = collect2;
var concatOut2 = concatOut;
var mapInput10 = mapInput7;
var mapInputEffect5 = mapInputEffect2;
var mapInputError2 = mapInputError;
var mapInputErrorEffect2 = mapInputErrorEffect;
var mapInputIn2 = mapInputIn;
var mapInputInEffect2 = mapInputInEffect;
var doneCollect2 = doneCollect;
var drain4 = drain;
var embedInput2 = embedInput;
var emitCollect2 = emitCollect;
var ensuring10 = ensuring5;
var ensuringWith4 = ensuringWith;
var context11 = context7;
var contextWith7 = contextWith3;
var contextWithChannel2 = contextWithChannel;
var contextWithEffect6 = contextWithEffect3;
var fail20 = fail14;
var failSync11 = failSync7;
var failCause17 = failCause12;
var failCauseSync10 = failCauseSync7;
var flatMap24 = flatMap20;
var flatten18 = flatten15;
var foldChannel2 = foldChannel;
var foldCauseChannel2 = foldCauseChannel;
var fromEffect10 = fromEffect5;
var fromEither5 = fromEither3;
var fromInput4 = fromInput;
var fromPubSub4 = fromPubSub;
var fromPubSubScoped2 = fromPubSubScoped;
var fromOption8 = fromOption6;
var fromQueue4 = fromQueue;
var identity5 = identityChannel;
var interruptWhen3 = interruptWhen;
var interruptWhenDeferred3 = interruptWhenDeferred;
var map34 = map28;
var mapEffect8 = mapEffect5;
var mapError11 = mapError7;
var mapErrorCause7 = mapErrorCause5;
var mapOut2 = mapOut;
var mapOutEffect2 = mapOutEffect;
var mapOutEffectPar2 = mapOutEffectPar;
var mergeAll10 = mergeAll7;
var mergeAllUnbounded2 = mergeAllUnbounded;
var mergeAllUnboundedWith2 = mergeAllUnboundedWith;
var mergeAllWith2 = mergeAllWith;
var mergeMap2 = mergeMap;
var mergeOut2 = mergeOut;
var mergeOutWith2 = mergeOutWith;
var mergeWith4 = mergeWith2;
var never9 = never6;
var orDie9 = orDie6;
var orDieWith6 = orDieWith3;
var orElse14 = orElse10;
var pipeTo2 = pipeTo;
var pipeToOrFail2 = pipeToOrFail;
var provideContext9 = provideContext4;
var provideLayer3 = provideLayer;
var mapInputContext8 = mapInputContext4;
var provideSomeLayer4 = provideSomeLayer2;
var provideService11 = provideService6;
var read2 = read;
var readOrFail2 = readOrFail;
var readWith2 = readWith;
var readWithCause2 = readWithCause;
var repeated2 = repeated;
var run5 = run2;
var runCollect3 = runCollect;
var runDrain3 = runDrain;
var runScoped3 = runScoped;
var scoped8 = scoped6;
var scopedWith5 = scopedWith3;
var splitLines3 = splitLines;
var succeed21 = succeed15;
var suspend11 = suspend6;
var sync15 = sync10;
var toPubSub3 = toPubSub;
var toPull3 = toPull;
var toPullIn2 = toPullIn;
var toQueue3 = toQueue;
var toSink = channelToSink;
var toStream = channelToStream;
var void_12 = void_8;
var unwrap5 = unwrap2;
var unwrapScoped6 = unwrapScoped3;
var unwrapScopedWith4 = unwrapScopedWith;
var updateService7 = updateService5;
var withSpan7 = withSpan5;
var write2 = write;
var writeAll2 = writeAll;
var writeChunk2 = writeChunk;
var zip17 = zip13;
var zipLeft13 = zipLeft8;
var zipRight13 = zipRight8;
var ChannelException2 = ChannelException;
var isChannelException2 = isChannelException;

// ../../node_modules/effect/dist/esm/ChildExecutorDecision.js
var ChildExecutorDecision_exports = {};
__export(ChildExecutorDecision_exports, {
  ChildExecutorDecisionTypeId: () => ChildExecutorDecisionTypeId2,
  Close: () => Close2,
  Continue: () => Continue2,
  Yield: () => Yield3,
  isChildExecutorDecision: () => isChildExecutorDecision2,
  isClose: () => isClose2,
  isContinue: () => isContinue4,
  isYield: () => isYield2,
  match: () => match33
});
var ChildExecutorDecisionTypeId2 = ChildExecutorDecisionTypeId;
var Continue2 = Continue;
var Close2 = Close;
var Yield3 = Yield2;
var isChildExecutorDecision2 = isChildExecutorDecision;
var isContinue4 = isContinue3;
var isClose2 = isClose;
var isYield2 = isYield;
var match33 = match22;

// ../../node_modules/effect/dist/esm/Config.js
var Config_exports = {};
__export(Config_exports, {
  ConfigTypeId: () => ConfigTypeId2,
  all: () => all14,
  array: () => array7,
  boolean: () => boolean5,
  branded: () => branded2,
  chunk: () => chunk5,
  date: () => date3,
  duration: () => duration4,
  fail: () => fail22,
  hashMap: () => hashMap4,
  hashSet: () => hashSet4,
  integer: () => integer3,
  isConfig: () => isConfig2,
  literal: () => literal2,
  logLevel: () => logLevel2,
  map: () => map36,
  mapAttempt: () => mapAttempt3,
  mapOrFail: () => mapOrFail2,
  nested: () => nested4,
  nonEmptyString: () => nonEmptyString2,
  number: () => number5,
  option: () => option7,
  orElse: () => orElse16,
  orElseIf: () => orElseIf2,
  port: () => port2,
  primitive: () => primitive2,
  redacted: () => redacted2,
  repeat: () => repeat6,
  secret: () => secret2,
  string: () => string6,
  succeed: () => succeed23,
  suspend: () => suspend13,
  sync: () => sync17,
  unwrap: () => unwrap7,
  url: () => url2,
  validate: () => validate4,
  withDefault: () => withDefault2,
  withDescription: () => withDescription2,
  zip: () => zip19,
  zipWith: () => zipWith19
});

// ../../node_modules/effect/dist/esm/ConfigError.js
var ConfigError_exports = {};
__export(ConfigError_exports, {
  And: () => And2,
  ConfigErrorTypeId: () => ConfigErrorTypeId2,
  InvalidData: () => InvalidData2,
  MissingData: () => MissingData2,
  Or: () => Or2,
  SourceUnavailable: () => SourceUnavailable2,
  Unsupported: () => Unsupported2,
  isAnd: () => isAnd2,
  isConfigError: () => isConfigError2,
  isInvalidData: () => isInvalidData2,
  isMissingData: () => isMissingData2,
  isMissingDataOnly: () => isMissingDataOnly2,
  isOr: () => isOr2,
  isSourceUnavailable: () => isSourceUnavailable2,
  isUnsupported: () => isUnsupported2,
  prefixed: () => prefixed2,
  reduceWithContext: () => reduceWithContext4
});
var ConfigErrorTypeId2 = ConfigErrorTypeId;
var And2 = And;
var Or2 = Or;
var MissingData2 = MissingData;
var InvalidData2 = InvalidData;
var SourceUnavailable2 = SourceUnavailable;
var Unsupported2 = Unsupported;
var isConfigError2 = isConfigError;
var isAnd2 = isAnd;
var isOr2 = isOr;
var isInvalidData2 = isInvalidData;
var isMissingData2 = isMissingData;
var isMissingDataOnly2 = isMissingDataOnly;
var isSourceUnavailable2 = isSourceUnavailable;
var isUnsupported2 = isUnsupported;
var prefixed2 = prefixed;
var reduceWithContext4 = reduceWithContext2;

// ../../node_modules/effect/dist/esm/internal/redacted.js
var RedactedSymbolKey = "effect/Redacted";
var redactedRegistry = globalValue("effect/Redacted/redactedRegistry", () => /* @__PURE__ */ new WeakMap());
var RedactedTypeId = Symbol.for(RedactedSymbolKey);
var proto12 = {
  [RedactedTypeId]: {
    _A: (_) => _
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toString() {
    return "<redacted>";
  },
  toJSON() {
    return "<redacted>";
  },
  [NodeInspectSymbol]() {
    return "<redacted>";
  },
  [symbol2]() {
    return pipe(hash(RedactedSymbolKey), combine2(hash(redactedRegistry.get(this))), cached(this));
  },
  [symbol3](that) {
    return isRedacted(that) && equals(redactedRegistry.get(this), redactedRegistry.get(that));
  }
};
var isRedacted = (u) => hasProperty(u, RedactedTypeId);
var make74 = (value10) => {
  const redacted3 = Object.create(proto12);
  redactedRegistry.set(redacted3, value10);
  return redacted3;
};
var value2 = (self) => {
  if (redactedRegistry.has(self)) {
    return redactedRegistry.get(self);
  } else {
    throw new Error("Unable to get redacted value");
  }
};
var unsafeWipe = (self) => redactedRegistry.delete(self);

// ../../node_modules/effect/dist/esm/internal/secret.js
var SecretSymbolKey = "effect/Secret";
var SecretTypeId = Symbol.for(SecretSymbolKey);
var isSecret = (u) => hasProperty(u, SecretTypeId);
var SecretProto = {
  ...proto12,
  [SecretTypeId]: SecretTypeId
};
var make75 = (bytes) => {
  const secret3 = Object.create(SecretProto);
  Object.defineProperty(secret3, "toString", {
    enumerable: false,
    value() {
      return "Secret(<redacted>)";
    }
  });
  Object.defineProperty(secret3, "toJSON", {
    enumerable: false,
    value() {
      return "<redacted>";
    }
  });
  Object.defineProperty(secret3, "raw", {
    enumerable: false,
    value: bytes
  });
  redactedRegistry.set(secret3, bytes.map((byte) => String.fromCharCode(byte)).join(""));
  return secret3;
};
var fromIterable18 = (iterable) => make75(fromIterable2(iterable).map((char2) => char2.charCodeAt(0)));
var fromString3 = (text) => {
  return make75(text.split("").map((char2) => char2.charCodeAt(0)));
};
var value3 = (self) => {
  return self.raw.map((byte) => String.fromCharCode(byte)).join("");
};
var unsafeWipe2 = (self) => {
  for (let i = 0; i < self.raw.length; i++) {
    self.raw[i] = 0;
  }
  redactedRegistry.delete(self);
};

// ../../node_modules/effect/dist/esm/internal/config.js
var ConfigSymbolKey = "effect/Config";
var ConfigTypeId = Symbol.for(ConfigSymbolKey);
var configVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var proto13 = {
  ...CommitPrototype,
  [ConfigTypeId]: configVariance,
  commit() {
    return config(this);
  }
};
var boolean4 = (name) => {
  const config2 = primitive("a boolean property", (text) => {
    switch (text) {
      case "true":
      case "yes":
      case "on":
      case "1": {
        return right2(true);
      }
      case "false":
      case "no":
      case "off":
      case "0": {
        return right2(false);
      }
      default: {
        const error4 = InvalidData([], `Expected a boolean value but received ${text}`);
        return left2(error4);
      }
    }
  });
  return name === void 0 ? config2 : nested3(config2, name);
};
var url = (name) => {
  const config2 = primitive("an URL property", (text) => try_({
    try: () => new URL(text),
    catch: (_) => InvalidData([], `Expected an URL value but received ${text}`)
  }));
  return name === void 0 ? config2 : nested3(config2, name);
};
var port = (name) => {
  const config2 = primitive("a network port property", (text) => {
    const result = Number(text);
    if (Number.isNaN(result) || result.toString() !== text.toString() || !Number.isInteger(result) || result < 1 || result > 65535) {
      return left2(InvalidData([], `Expected a network port value but received ${text}`));
    }
    return right2(result);
  });
  return name === void 0 ? config2 : nested3(config2, name);
};
var array6 = (config2, name) => {
  return pipe(chunk4(config2, name), map35(toArray2));
};
var chunk4 = (config2, name) => {
  return map35(name === void 0 ? repeat5(config2) : nested3(repeat5(config2), name), unsafeFromArray);
};
var date2 = (name) => {
  const config2 = primitive("a date property", (text) => {
    const result = Date.parse(text);
    if (Number.isNaN(result)) {
      return left2(InvalidData([], `Expected a Date value but received ${text}`));
    }
    return right2(new Date(result));
  });
  return name === void 0 ? config2 : nested3(config2, name);
};
var fail21 = (message) => {
  const fail30 = Object.create(proto13);
  fail30._tag = OP_FAIL2;
  fail30.message = message;
  fail30.parse = () => left2(Unsupported([], message));
  return fail30;
};
var number4 = (name) => {
  const config2 = primitive("a number property", (text) => {
    const result = Number(text);
    if (Number.isNaN(result)) {
      return left2(InvalidData([], `Expected a number value but received ${text}`));
    }
    return right2(result);
  });
  return name === void 0 ? config2 : nested3(config2, name);
};
var integer2 = (name) => {
  const config2 = primitive("an integer property", (text) => {
    const result = Number(text);
    if (!Number.isInteger(result)) {
      return left2(InvalidData([], `Expected an integer value but received ${text}`));
    }
    return right2(result);
  });
  return name === void 0 ? config2 : nested3(config2, name);
};
var literal = (...literals) => (name) => {
  const valuesString = literals.map(String).join(", ");
  const config2 = primitive(`one of (${valuesString})`, (text) => {
    const found = literals.find((value10) => String(value10) === text);
    if (found === void 0) {
      return left2(InvalidData([], `Expected one of (${valuesString}) but received ${text}`));
    }
    return right2(found);
  });
  return name === void 0 ? config2 : nested3(config2, name);
};
var logLevel = (name) => {
  const config2 = mapOrFail(string5(), (value10) => {
    const label = value10.toUpperCase();
    const level = allLogLevels.find((level2) => level2.label === label);
    return level === void 0 ? left2(InvalidData([], `Expected a log level but received ${value10}`)) : right2(level);
  });
  return name === void 0 ? config2 : nested3(config2, name);
};
var duration3 = (name) => {
  const config2 = mapOrFail(string5(), (value10) => {
    const duration5 = decodeUnknown(value10);
    return fromOption2(duration5, () => InvalidData([], `Expected a duration but received ${value10}`));
  });
  return name === void 0 ? config2 : nested3(config2, name);
};
var map35 = dual(2, (self, f) => mapOrFail(self, (a) => right2(f(a))));
var mapAttempt2 = dual(2, (self, f) => mapOrFail(self, (a) => {
  try {
    return right2(f(a));
  } catch (error4) {
    return left2(InvalidData([], error4 instanceof Error ? error4.message : `${error4}`));
  }
}));
var mapOrFail = dual(2, (self, f) => {
  const mapOrFail3 = Object.create(proto13);
  mapOrFail3._tag = OP_MAP_OR_FAIL;
  mapOrFail3.original = self;
  mapOrFail3.mapOrFail = f;
  return mapOrFail3;
});
var nested3 = dual(2, (self, name) => {
  const nested7 = Object.create(proto13);
  nested7._tag = OP_NESTED;
  nested7.name = name;
  nested7.config = self;
  return nested7;
});
var orElse15 = dual(2, (self, that) => {
  const fallback = Object.create(proto13);
  fallback._tag = OP_FALLBACK;
  fallback.first = self;
  fallback.second = suspend12(that);
  fallback.condition = constTrue;
  return fallback;
});
var orElseIf = dual(2, (self, options) => {
  const fallback = Object.create(proto13);
  fallback._tag = OP_FALLBACK;
  fallback.first = self;
  fallback.second = suspend12(options.orElse);
  fallback.condition = options.if;
  return fallback;
});
var option6 = (self) => {
  return pipe(self, map35(some3), orElseIf({
    orElse: () => succeed22(none2()),
    if: isMissingDataOnly2
  }));
};
var primitive = (description, parse3) => {
  const primitive3 = Object.create(proto13);
  primitive3._tag = OP_PRIMITIVE;
  primitive3.description = description;
  primitive3.parse = parse3;
  return primitive3;
};
var repeat5 = (self) => {
  const repeat8 = Object.create(proto13);
  repeat8._tag = OP_SEQUENCE;
  repeat8.config = self;
  return repeat8;
};
var secret = (name) => {
  const config2 = primitive("a secret property", (text) => right2(fromString3(text)));
  return name === void 0 ? config2 : nested3(config2, name);
};
var redacted = (nameOrConfig) => {
  const config2 = isConfig(nameOrConfig) ? nameOrConfig : string5(nameOrConfig);
  return map35(config2, make74);
};
var branded = dual(2, (nameOrConfig, constructor) => {
  const config2 = isConfig(nameOrConfig) ? nameOrConfig : string5(nameOrConfig);
  return mapOrFail(config2, (a) => constructor.either(a).pipe(mapLeft((brandErrors) => InvalidData([], brandErrors.map((brandError) => brandError.message).join("\n")))));
});
var hashSet3 = (config2, name) => {
  const newConfig = map35(chunk4(config2), fromIterable6);
  return name === void 0 ? newConfig : nested3(newConfig, name);
};
var string5 = (name) => {
  const config2 = primitive("a text property", right2);
  return name === void 0 ? config2 : nested3(config2, name);
};
var nonEmptyString = (name) => {
  const config2 = primitive("a non-empty text property", liftPredicate((text) => text.length > 0, () => MissingData([], "Expected a non-empty string")));
  return name === void 0 ? config2 : nested3(config2, name);
};
var all13 = (arg) => {
  if (Array.isArray(arg)) {
    return tuple6(arg);
  } else if (Symbol.iterator in arg) {
    return tuple6([...arg]);
  }
  return struct6(arg);
};
var struct6 = (r) => {
  const entries7 = Object.entries(r);
  let result = pipe(entries7[0][1], map35((value10) => ({
    [entries7[0][0]]: value10
  })));
  if (entries7.length === 1) {
    return result;
  }
  const rest = entries7.slice(1);
  for (const [key, config2] of rest) {
    result = pipe(result, zipWith18(config2, (record4, value10) => ({
      ...record4,
      [key]: value10
    })));
  }
  return result;
};
var succeed22 = (value10) => {
  const constant3 = Object.create(proto13);
  constant3._tag = OP_CONSTANT;
  constant3.value = value10;
  constant3.parse = () => right2(value10);
  return constant3;
};
var suspend12 = (config2) => {
  const lazy = Object.create(proto13);
  lazy._tag = OP_LAZY;
  lazy.config = config2;
  return lazy;
};
var sync16 = (value10) => {
  return suspend12(() => succeed22(value10()));
};
var hashMap3 = (config2, name) => {
  const table3 = Object.create(proto13);
  table3._tag = OP_HASHMAP;
  table3.valueConfig = config2;
  return name === void 0 ? table3 : nested3(table3, name);
};
var isConfig = (u) => hasProperty(u, ConfigTypeId);
var tuple6 = (tuple7) => {
  if (tuple7.length === 0) {
    return succeed22([]);
  }
  if (tuple7.length === 1) {
    return map35(tuple7[0], (x) => [x]);
  }
  let result = map35(tuple7[0], (x) => [x]);
  for (let i = 1; i < tuple7.length; i++) {
    const config2 = tuple7[i];
    result = pipe(result, zipWith18(config2, (tuple8, value10) => [...tuple8, value10]));
  }
  return result;
};
var unwrap6 = (wrapped) => {
  if (isConfig(wrapped)) {
    return wrapped;
  }
  return struct6(Object.fromEntries(Object.entries(wrapped).map(([k, a]) => [k, unwrap6(a)])));
};
var validate3 = dual(2, (self, {
  message,
  validation
}) => mapOrFail(self, (a) => {
  if (validation(a)) {
    return right2(a);
  }
  return left2(InvalidData([], message));
}));
var withDefault = dual(2, (self, def) => orElseIf(self, {
  orElse: () => succeed22(def),
  if: isMissingDataOnly2
}));
var withDescription = dual(2, (self, description) => {
  const described = Object.create(proto13);
  described._tag = OP_DESCRIBED;
  described.config = self;
  described.description = description;
  return described;
});
var zip18 = dual(2, (self, that) => zipWith18(self, that, (a, b) => [a, b]));
var zipWith18 = dual(3, (self, that, f) => {
  const zipWith23 = Object.create(proto13);
  zipWith23._tag = OP_ZIP_WITH;
  zipWith23.left = self;
  zipWith23.right = that;
  zipWith23.zip = f;
  return zipWith23;
});

// ../../node_modules/effect/dist/esm/Config.js
var ConfigTypeId2 = ConfigTypeId;
var all14 = all13;
var array7 = array6;
var boolean5 = boolean4;
var port2 = port;
var url2 = url;
var chunk5 = chunk4;
var date3 = date2;
var fail22 = fail21;
var number5 = number4;
var integer3 = integer2;
var literal2 = literal;
var logLevel2 = logLevel;
var duration4 = duration3;
var isConfig2 = isConfig;
var map36 = map35;
var mapAttempt3 = mapAttempt2;
var mapOrFail2 = mapOrFail;
var nested4 = nested3;
var orElse16 = orElse15;
var orElseIf2 = orElseIf;
var option7 = option6;
var primitive2 = primitive;
var repeat6 = repeat5;
var secret2 = secret;
var redacted2 = redacted;
var branded2 = branded;
var hashSet4 = hashSet3;
var string6 = string5;
var nonEmptyString2 = nonEmptyString;
var succeed23 = succeed22;
var suspend13 = suspend12;
var sync17 = sync16;
var hashMap4 = hashMap3;
var unwrap7 = unwrap6;
var validate4 = validate3;
var withDefault2 = withDefault;
var withDescription2 = withDescription;
var zip19 = zip18;
var zipWith19 = zipWith18;

// ../../node_modules/effect/dist/esm/ConfigProvider.js
var ConfigProvider_exports = {};
__export(ConfigProvider_exports, {
  ConfigProvider: () => ConfigProvider,
  ConfigProviderTypeId: () => ConfigProviderTypeId2,
  FlatConfigProviderTypeId: () => FlatConfigProviderTypeId2,
  constantCase: () => constantCase3,
  fromEnv: () => fromEnv2,
  fromFlat: () => fromFlat2,
  fromJson: () => fromJson2,
  fromMap: () => fromMap2,
  kebabCase: () => kebabCase3,
  lowerCase: () => lowerCase3,
  make: () => make76,
  makeFlat: () => makeFlat2,
  mapInputPath: () => mapInputPath2,
  nested: () => nested5,
  orElse: () => orElse17,
  snakeCase: () => snakeCase3,
  unnested: () => unnested3,
  upperCase: () => upperCase3,
  within: () => within2
});
var ConfigProviderTypeId2 = ConfigProviderTypeId;
var FlatConfigProviderTypeId2 = FlatConfigProviderTypeId;
var ConfigProvider = configProviderTag;
var make76 = make29;
var makeFlat2 = makeFlat;
var fromEnv2 = fromEnv;
var fromFlat2 = fromFlat;
var fromJson2 = fromJson;
var fromMap2 = fromMap;
var constantCase3 = constantCase2;
var mapInputPath2 = mapInputPath;
var kebabCase3 = kebabCase2;
var lowerCase3 = lowerCase2;
var nested5 = nested2;
var orElse17 = orElse4;
var unnested3 = unnested2;
var snakeCase3 = snakeCase2;
var upperCase3 = upperCase2;
var within2 = within;

// ../../node_modules/effect/dist/esm/ConfigProviderPathPatch.js
var ConfigProviderPathPatch_exports = {};
__export(ConfigProviderPathPatch_exports, {
  andThen: () => andThen13,
  empty: () => empty44,
  mapName: () => mapName2,
  nested: () => nested6,
  unnested: () => unnested4
});
var empty44 = empty25;
var andThen13 = andThen7;
var mapName2 = mapName;
var nested6 = nested;
var unnested4 = unnested;

// ../../node_modules/effect/dist/esm/Console.js
var Console_exports = {};
__export(Console_exports, {
  Console: () => Console,
  TypeId: () => TypeId25,
  assert: () => assert3,
  clear: () => clear3,
  consoleWith: () => consoleWith3,
  count: () => count5,
  countReset: () => countReset2,
  debug: () => debug2,
  dir: () => dir2,
  dirxml: () => dirxml2,
  error: () => error3,
  group: () => group4,
  info: () => info2,
  log: () => log4,
  setConsole: () => setConsole2,
  table: () => table2,
  time: () => time2,
  timeLog: () => timeLog2,
  trace: () => trace2,
  warn: () => warn2,
  withConsole: () => withConsole3,
  withGroup: () => withGroup2,
  withTime: () => withTime2
});
var TypeId25 = TypeId14;
var Console = consoleTag;
var withConsole3 = withConsole;
var setConsole2 = setConsole;
var consoleWith3 = consoleWith;
var assert3 = assert2;
var clear3 = clear2;
var count5 = count;
var countReset2 = countReset;
var debug2 = debug;
var dir2 = dir;
var dirxml2 = dirxml;
var error3 = error2;
var group4 = group3;
var info2 = info;
var log4 = log2;
var table2 = table;
var time2 = time;
var timeLog2 = timeLog;
var trace2 = trace;
var warn2 = warn;
var withGroup2 = withGroup;
var withTime2 = withTime;

// ../../node_modules/effect/dist/esm/DateTime.js
var DateTime_exports = {};
__export(DateTime_exports, {
  CurrentTimeZone: () => CurrentTimeZone,
  Equivalence: () => Equivalence9,
  Order: () => Order11,
  TimeZoneTypeId: () => TimeZoneTypeId2,
  TypeId: () => TypeId26,
  add: () => add7,
  addDuration: () => addDuration2,
  between: () => between7,
  clamp: () => clamp8,
  distance: () => distance2,
  distanceDuration: () => distanceDuration2,
  distanceDurationEither: () => distanceDurationEither2,
  endOf: () => endOf2,
  format: () => format6,
  formatIntl: () => formatIntl2,
  formatIso: () => formatIso3,
  formatIsoDate: () => formatIsoDate2,
  formatIsoDateUtc: () => formatIsoDateUtc2,
  formatIsoOffset: () => formatIsoOffset2,
  formatIsoZoned: () => formatIsoZoned2,
  formatLocal: () => formatLocal2,
  formatUtc: () => formatUtc2,
  getPart: () => getPart2,
  getPartUtc: () => getPartUtc2,
  greaterThan: () => greaterThan10,
  greaterThanOrEqualTo: () => greaterThanOrEqualTo7,
  isDateTime: () => isDateTime2,
  isFuture: () => isFuture2,
  isPast: () => isPast2,
  isTimeZone: () => isTimeZone2,
  isTimeZoneNamed: () => isTimeZoneNamed2,
  isTimeZoneOffset: () => isTimeZoneOffset2,
  isUtc: () => isUtc2,
  isZoned: () => isZoned2,
  layerCurrentZone: () => layerCurrentZone,
  layerCurrentZoneLocal: () => layerCurrentZoneLocal,
  layerCurrentZoneNamed: () => layerCurrentZoneNamed,
  layerCurrentZoneOffset: () => layerCurrentZoneOffset,
  lessThan: () => lessThan14,
  lessThanOrEqualTo: () => lessThanOrEqualTo7,
  make: () => make77,
  makeZoned: () => makeZoned2,
  makeZonedFromString: () => makeZonedFromString2,
  mapEpochMillis: () => mapEpochMillis2,
  match: () => match34,
  max: () => max12,
  min: () => min10,
  mutate: () => mutate6,
  mutateUtc: () => mutateUtc2,
  nearest: () => nearest2,
  now: () => now2,
  nowAsDate: () => nowAsDate2,
  nowInCurrentZone: () => nowInCurrentZone,
  removeTime: () => removeTime2,
  setParts: () => setParts2,
  setPartsUtc: () => setPartsUtc2,
  setZone: () => setZone2,
  setZoneCurrent: () => setZoneCurrent,
  setZoneNamed: () => setZoneNamed2,
  setZoneOffset: () => setZoneOffset2,
  startOf: () => startOf2,
  subtract: () => subtract6,
  subtractDuration: () => subtractDuration2,
  toDate: () => toDate2,
  toDateUtc: () => toDateUtc2,
  toEpochMillis: () => toEpochMillis2,
  toParts: () => toParts2,
  toPartsUtc: () => toPartsUtc2,
  toUtc: () => toUtc2,
  unsafeFromDate: () => unsafeFromDate2,
  unsafeIsFuture: () => unsafeIsFuture2,
  unsafeIsPast: () => unsafeIsPast2,
  unsafeMake: () => unsafeMake14,
  unsafeMakeZoned: () => unsafeMakeZoned2,
  unsafeNow: () => unsafeNow2,
  unsafeSetZoneNamed: () => unsafeSetZoneNamed2,
  withCurrentZone: () => withCurrentZone,
  withCurrentZoneLocal: () => withCurrentZoneLocal,
  withCurrentZoneNamed: () => withCurrentZoneNamed,
  withCurrentZoneOffset: () => withCurrentZoneOffset,
  withDate: () => withDate2,
  withDateUtc: () => withDateUtc2,
  zoneFromString: () => zoneFromString2,
  zoneMakeLocal: () => zoneMakeLocal2,
  zoneMakeNamed: () => zoneMakeNamed2,
  zoneMakeNamedEffect: () => zoneMakeNamedEffect2,
  zoneMakeOffset: () => zoneMakeOffset2,
  zoneToString: () => zoneToString2,
  zoneUnsafeMakeNamed: () => zoneUnsafeMakeNamed2,
  zonedOffset: () => zonedOffset2,
  zonedOffsetIso: () => zonedOffsetIso2
});
var TypeId26 = TypeId20;
var TimeZoneTypeId2 = TimeZoneTypeId;
var isDateTime2 = isDateTime;
var isTimeZone2 = isTimeZone;
var isTimeZoneOffset2 = isTimeZoneOffset;
var isTimeZoneNamed2 = isTimeZoneNamed;
var isUtc2 = isUtc;
var isZoned2 = isZoned;
var Equivalence9 = Equivalence6;
var Order11 = Order9;
var clamp8 = clamp7;
var unsafeFromDate2 = unsafeFromDate;
var unsafeMake14 = unsafeMake11;
var unsafeMakeZoned2 = unsafeMakeZoned;
var makeZoned2 = makeZoned;
var make77 = make57;
var makeZonedFromString2 = makeZonedFromString;
var now2 = now;
var nowAsDate2 = nowAsDate;
var unsafeNow2 = unsafeNow;
var toUtc2 = toUtc;
var setZone2 = setZone;
var setZoneOffset2 = setZoneOffset;
var zoneUnsafeMakeNamed2 = zoneUnsafeMakeNamed;
var zoneMakeOffset2 = zoneMakeOffset;
var zoneMakeNamed2 = zoneMakeNamed;
var zoneMakeNamedEffect2 = zoneMakeNamedEffect;
var zoneMakeLocal2 = zoneMakeLocal;
var zoneFromString2 = zoneFromString;
var zoneToString2 = zoneToString;
var setZoneNamed2 = setZoneNamed;
var unsafeSetZoneNamed2 = unsafeSetZoneNamed;
var distance2 = distance;
var distanceDurationEither2 = distanceDurationEither;
var distanceDuration2 = distanceDuration;
var min10 = min9;
var max12 = max11;
var greaterThan10 = greaterThan9;
var greaterThanOrEqualTo7 = greaterThanOrEqualTo6;
var lessThan14 = lessThan13;
var lessThanOrEqualTo7 = lessThanOrEqualTo6;
var between7 = between6;
var isFuture2 = isFuture;
var unsafeIsFuture2 = unsafeIsFuture;
var isPast2 = isPast;
var unsafeIsPast2 = unsafeIsPast;
var toDateUtc2 = toDateUtc;
var toDate2 = toDate;
var zonedOffset2 = zonedOffset;
var zonedOffsetIso2 = zonedOffsetIso;
var toEpochMillis2 = toEpochMillis;
var removeTime2 = removeTime;
var toParts2 = toParts;
var toPartsUtc2 = toPartsUtc;
var getPartUtc2 = getPartUtc;
var getPart2 = getPart;
var setParts2 = setParts;
var setPartsUtc2 = setPartsUtc;
var CurrentTimeZone = class extends Tag2("effect/DateTime/CurrentTimeZone")() {
};
var setZoneCurrent = (self) => map26(CurrentTimeZone, (zone) => setZone2(self, zone));
var withCurrentZone = dual(2, (effect4, zone) => provideService5(effect4, CurrentTimeZone, zone));
var withCurrentZoneLocal = (effect4) => provideServiceEffect3(effect4, CurrentTimeZone, sync8(zoneMakeLocal2));
var withCurrentZoneOffset = dual(2, (effect4, offset) => provideService5(effect4, CurrentTimeZone, zoneMakeOffset2(offset)));
var withCurrentZoneNamed = dual(2, (effect4, zone) => provideServiceEffect3(effect4, CurrentTimeZone, zoneMakeNamedEffect2(zone)));
var nowInCurrentZone = flatMap18(now2, setZoneCurrent);
var mutate6 = mutate5;
var mutateUtc2 = mutateUtc;
var mapEpochMillis2 = mapEpochMillis;
var withDate2 = withDate;
var withDateUtc2 = withDateUtc;
var match34 = match17;
var addDuration2 = addDuration;
var subtractDuration2 = subtractDuration;
var add7 = add6;
var subtract6 = subtract5;
var startOf2 = startOf;
var endOf2 = endOf;
var nearest2 = nearest;
var format6 = format5;
var formatLocal2 = formatLocal;
var formatUtc2 = formatUtc;
var formatIntl2 = formatIntl;
var formatIso3 = formatIso2;
var formatIsoDate2 = formatIsoDate;
var formatIsoDateUtc2 = formatIsoDateUtc;
var formatIsoOffset2 = formatIsoOffset;
var formatIsoZoned2 = formatIsoZoned;
var layerCurrentZone = (zone) => succeed14(CurrentTimeZone, zone);
var layerCurrentZoneOffset = (offset) => succeed14(CurrentTimeZone, zoneMakeOffset(offset));
var layerCurrentZoneNamed = (zoneId) => effect(CurrentTimeZone, zoneMakeNamedEffect(zoneId));
var layerCurrentZoneLocal = sync9(CurrentTimeZone, zoneMakeLocal2);

// ../../node_modules/effect/dist/esm/DefaultServices.js
var DefaultServices_exports = {};
__export(DefaultServices_exports, {
  currentServices: () => currentServices2,
  liveServices: () => liveServices2
});
var liveServices2 = liveServices;
var currentServices2 = currentServices;

// ../../node_modules/effect/dist/esm/Encoding.js
var Encoding_exports = {};
__export(Encoding_exports, {
  DecodeException: () => DecodeException2,
  DecodeExceptionTypeId: () => DecodeExceptionTypeId2,
  EncodeException: () => EncodeException2,
  EncodeExceptionTypeId: () => EncodeExceptionTypeId2,
  decodeBase64: () => decodeBase64,
  decodeBase64String: () => decodeBase64String,
  decodeBase64Url: () => decodeBase64Url,
  decodeBase64UrlString: () => decodeBase64UrlString,
  decodeHex: () => decodeHex,
  decodeHexString: () => decodeHexString,
  decodeUriComponent: () => decodeUriComponent,
  encodeBase64: () => encodeBase64,
  encodeBase64Url: () => encodeBase64Url,
  encodeHex: () => encodeHex,
  encodeUriComponent: () => encodeUriComponent,
  isDecodeException: () => isDecodeException2,
  isEncodeException: () => isEncodeException2
});

// ../../node_modules/effect/dist/esm/internal/encoding/common.js
var DecodeExceptionTypeId = Symbol.for("effect/Encoding/errors/Decode");
var DecodeException = (input, message) => {
  const out = {
    _tag: "DecodeException",
    [DecodeExceptionTypeId]: DecodeExceptionTypeId,
    input
  };
  if (isString(message)) {
    out.message = message;
  }
  return out;
};
var isDecodeException = (u) => hasProperty(u, DecodeExceptionTypeId);
var EncodeExceptionTypeId = Symbol.for("effect/Encoding/errors/Encode");
var EncodeException = (input, message) => {
  const out = {
    _tag: "EncodeException",
    [EncodeExceptionTypeId]: EncodeExceptionTypeId,
    input
  };
  if (isString(message)) {
    out.message = message;
  }
  return out;
};
var isEncodeException = (u) => hasProperty(u, EncodeExceptionTypeId);
var encoder = new TextEncoder();
var decoder = new TextDecoder();

// ../../node_modules/effect/dist/esm/internal/encoding/base64.js
var encode = (bytes) => {
  const length6 = bytes.length;
  let result = "";
  let i;
  for (i = 2; i < length6; i += 3) {
    result += base64abc[bytes[i - 2] >> 2];
    result += base64abc[(bytes[i - 2] & 3) << 4 | bytes[i - 1] >> 4];
    result += base64abc[(bytes[i - 1] & 15) << 2 | bytes[i] >> 6];
    result += base64abc[bytes[i] & 63];
  }
  if (i === length6 + 1) {
    result += base64abc[bytes[i - 2] >> 2];
    result += base64abc[(bytes[i - 2] & 3) << 4];
    result += "==";
  }
  if (i === length6) {
    result += base64abc[bytes[i - 2] >> 2];
    result += base64abc[(bytes[i - 2] & 3) << 4 | bytes[i - 1] >> 4];
    result += base64abc[(bytes[i - 1] & 15) << 2];
    result += "=";
  }
  return result;
};
var decode2 = (str) => {
  const stripped = stripCrlf(str);
  const length6 = stripped.length;
  if (length6 % 4 !== 0) {
    return left2(DecodeException(stripped, `Length must be a multiple of 4, but is ${length6}`));
  }
  const index = stripped.indexOf("=");
  if (index !== -1 && (index < length6 - 2 || index === length6 - 2 && stripped[length6 - 1] !== "=")) {
    return left2(DecodeException(stripped, "Found a '=' character, but it is not at the end"));
  }
  try {
    const missingOctets = stripped.endsWith("==") ? 2 : stripped.endsWith("=") ? 1 : 0;
    const result = new Uint8Array(3 * (length6 / 4) - missingOctets);
    for (let i = 0, j = 0; i < length6; i += 4, j += 3) {
      const buffer5 = getBase64Code(stripped.charCodeAt(i)) << 18 | getBase64Code(stripped.charCodeAt(i + 1)) << 12 | getBase64Code(stripped.charCodeAt(i + 2)) << 6 | getBase64Code(stripped.charCodeAt(i + 3));
      result[j] = buffer5 >> 16;
      result[j + 1] = buffer5 >> 8 & 255;
      result[j + 2] = buffer5 & 255;
    }
    return right2(result);
  } catch (e) {
    return left2(DecodeException(stripped, e instanceof Error ? e.message : "Invalid input"));
  }
};
var stripCrlf = (str) => str.replace(/[\n\r]/g, "");
function getBase64Code(charCode) {
  if (charCode >= base64codes.length) {
    throw new TypeError(`Invalid character ${String.fromCharCode(charCode)}`);
  }
  const code = base64codes[charCode];
  if (code === 255) {
    throw new TypeError(`Invalid character ${String.fromCharCode(charCode)}`);
  }
  return code;
}
var base64abc = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "+", "/"];
var base64codes = [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 62, 255, 255, 255, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 255, 255, 255, 0, 255, 255, 255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 255, 255, 255, 255, 255, 255, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51];

// ../../node_modules/effect/dist/esm/internal/encoding/base64Url.js
var encode2 = (data) => encode(data).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
var decode3 = (str) => {
  const stripped = stripCrlf(str);
  const length6 = stripped.length;
  if (length6 % 4 === 1) {
    return left2(DecodeException(stripped, `Length should be a multiple of 4, but is ${length6}`));
  }
  if (!/^[-_A-Z0-9]*?={0,2}$/i.test(stripped)) {
    return left2(DecodeException(stripped, "Invalid input"));
  }
  let sanitized = length6 % 4 === 2 ? `${stripped}==` : length6 % 4 === 3 ? `${stripped}=` : stripped;
  sanitized = sanitized.replace(/-/g, "+").replace(/_/g, "/");
  return decode2(sanitized);
};

// ../../node_modules/effect/dist/esm/internal/encoding/hex.js
var encode3 = (bytes) => {
  let result = "";
  for (let i = 0; i < bytes.length; ++i) {
    result += bytesToHex[bytes[i]];
  }
  return result;
};
var decode4 = (str) => {
  const bytes = new TextEncoder().encode(str);
  if (bytes.length % 2 !== 0) {
    return left2(DecodeException(str, `Length must be a multiple of 2, but is ${bytes.length}`));
  }
  try {
    const length6 = bytes.length / 2;
    const result = new Uint8Array(length6);
    for (let i = 0; i < length6; i++) {
      const a = fromHexChar(bytes[i * 2]);
      const b = fromHexChar(bytes[i * 2 + 1]);
      result[i] = a << 4 | b;
    }
    return right2(result);
  } catch (e) {
    return left2(DecodeException(str, e instanceof Error ? e.message : "Invalid input"));
  }
};
var bytesToHex = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
var fromHexChar = (byte) => {
  if (48 <= byte && byte <= 57) {
    return byte - 48;
  }
  if (97 <= byte && byte <= 102) {
    return byte - 97 + 10;
  }
  if (65 <= byte && byte <= 70) {
    return byte - 65 + 10;
  }
  throw new TypeError("Invalid input");
};

// ../../node_modules/effect/dist/esm/Encoding.js
var encodeBase64 = (input) => typeof input === "string" ? encode(encoder.encode(input)) : encode(input);
var decodeBase64 = (str) => decode2(str);
var decodeBase64String = (str) => map(decodeBase64(str), (_) => decoder.decode(_));
var encodeBase64Url = (input) => typeof input === "string" ? encode2(encoder.encode(input)) : encode2(input);
var decodeBase64Url = (str) => decode3(str);
var decodeBase64UrlString = (str) => map(decodeBase64Url(str), (_) => decoder.decode(_));
var encodeHex = (input) => typeof input === "string" ? encode3(encoder.encode(input)) : encode3(input);
var decodeHex = (str) => decode4(str);
var decodeHexString = (str) => map(decodeHex(str), (_) => decoder.decode(_));
var encodeUriComponent = (str) => try_({
  try: () => encodeURIComponent(str),
  catch: (e) => EncodeException2(str, e instanceof Error ? e.message : "Invalid input")
});
var decodeUriComponent = (str) => try_({
  try: () => decodeURIComponent(str),
  catch: (e) => DecodeException2(str, e instanceof Error ? e.message : "Invalid input")
});
var DecodeExceptionTypeId2 = DecodeExceptionTypeId;
var DecodeException2 = DecodeException;
var isDecodeException2 = isDecodeException;
var EncodeExceptionTypeId2 = EncodeExceptionTypeId;
var EncodeException2 = EncodeException;
var isEncodeException2 = isEncodeException;

// ../../node_modules/effect/dist/esm/ExecutionPlan.js
var ExecutionPlan_exports = {};
__export(ExecutionPlan_exports, {
  TypeId: () => TypeId27,
  isExecutionPlan: () => isExecutionPlan2,
  make: () => make78,
  merge: () => merge11
});
var TypeId27 = TypeId22;
var isExecutionPlan2 = isExecutionPlan;
var make78 = (...steps) => makeProto(steps.map((options, i) => {
  if (options.attempts && options.attempts < 1) {
    throw new Error(`ExecutionPlan.make: step[${i}].attempts must be greater than 0`);
  }
  return {
    schedule: options.schedule,
    attempts: options.attempts,
    while: options.while ? (input) => suspend4(() => {
      const result = options.while(input);
      return typeof result === "boolean" ? succeed13(result) : result;
    }) : void 0,
    provide: options.provide
  };
}));
var Proto3 = {
  [TypeId27]: TypeId27,
  get withRequirements() {
    const self = this;
    return contextWith2((context15) => makeProto(self.steps.map((step4) => ({
      ...step4,
      provide: isLayer2(step4.provide) ? provide3(step4.provide, succeedContext2(context15)) : step4.provide
    }))));
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeProto = (steps) => {
  const self = Object.create(Proto3);
  self.steps = steps;
  return self;
};
var merge11 = (...plans) => makeProto(plans.flatMap((plan) => plan.steps));

// ../../node_modules/effect/dist/esm/FiberHandle.js
var FiberHandle_exports = {};
__export(FiberHandle_exports, {
  TypeId: () => TypeId28,
  awaitEmpty: () => awaitEmpty,
  clear: () => clear4,
  get: () => get18,
  isFiberHandle: () => isFiberHandle,
  join: () => join5,
  make: () => make79,
  makeRuntime: () => makeRuntime,
  makeRuntimePromise: () => makeRuntimePromise,
  run: () => run6,
  runtime: () => runtime5,
  runtimePromise: () => runtimePromise,
  set: () => set11,
  unsafeGet: () => unsafeGet10,
  unsafeSet: () => unsafeSet3
});
var TypeId28 = Symbol.for("effect/FiberHandle");
var isFiberHandle = (u) => hasProperty(u, TypeId28);
var Proto4 = {
  [TypeId28]: TypeId28,
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "FiberHandle",
      state: this.state
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var unsafeMake15 = (deferred) => {
  const self = Object.create(Proto4);
  self.state = {
    _tag: "Open",
    fiber: void 0
  };
  self.deferred = deferred;
  return self;
};
var make79 = () => acquireRelease3(map26(make24(), (deferred) => unsafeMake15(deferred)), (handle) => withFiberRuntime2((parent) => {
  const state = handle.state;
  if (state._tag === "Closed") return _void;
  handle.state = {
    _tag: "Closed"
  };
  return state.fiber ? intoDeferred2(asVoid6(interruptAs(state.fiber, combine5(parent.id(), internalFiberId))), handle.deferred) : done2(handle.deferred, void_4);
}));
var makeRuntime = () => flatMap18(make79(), (self) => runtime5(self)());
var makeRuntimePromise = () => flatMap18(make79(), (self) => runtimePromise(self)());
var internalFiberIdId = -1;
var internalFiberId = make17(internalFiberIdId, 0);
var isInternalInterruption = reduceWithContext3(void 0, {
  emptyCase: constFalse,
  failCase: constFalse,
  dieCase: constFalse,
  interruptCase: (_, fiberId5) => has4(ids2(fiberId5), internalFiberIdId),
  sequentialCase: (_, left3, right3) => left3 || right3,
  parallelCase: (_, left3, right3) => left3 || right3
});
var unsafeSet3 = dual((args2) => isFiberHandle(args2[0]), (self, fiber, options) => {
  if (self.state._tag === "Closed") {
    fiber.unsafeInterruptAsFork(combine5(options?.interruptAs ?? none4, internalFiberId));
    return;
  } else if (self.state.fiber !== void 0) {
    if (options?.onlyIfMissing === true) {
      fiber.unsafeInterruptAsFork(combine5(options?.interruptAs ?? none4, internalFiberId));
      return;
    } else if (self.state.fiber === fiber) {
      return;
    }
    self.state.fiber.unsafeInterruptAsFork(combine5(options?.interruptAs ?? none4, internalFiberId));
    self.state.fiber = void 0;
  }
  self.state.fiber = fiber;
  fiber.addObserver((exit4) => {
    if (self.state._tag === "Open" && fiber === self.state.fiber) {
      self.state.fiber = void 0;
    }
    if (isFailure2(exit4) && (options?.propagateInterruption === true ? !isInternalInterruption(exit4.cause) : !isInterruptedOnly2(exit4.cause))) {
      unsafeDone(self.deferred, exit4);
    }
  });
});
var set11 = dual((args2) => isFiberHandle(args2[0]), (self, fiber, options) => fiberIdWith2((fiberId5) => sync8(() => unsafeSet3(self, fiber, {
  interruptAs: fiberId5,
  onlyIfMissing: options?.onlyIfMissing,
  propagateInterruption: options?.propagateInterruption
}))));
var unsafeGet10 = (self) => self.state._tag === "Closed" ? none2() : fromNullable2(self.state.fiber);
var get18 = (self) => suspend4(() => unsafeGet10(self));
var clear4 = (self) => uninterruptibleMask3((restore) => withFiberRuntime2((fiber) => {
  if (self.state._tag === "Closed" || self.state.fiber === void 0) {
    return _void;
  }
  return zipRight7(restore(interruptAs(self.state.fiber, combine5(fiber.id(), internalFiberId))), sync8(() => {
    if (self.state._tag === "Open") {
      self.state.fiber = void 0;
    }
  }));
}));
var constInterruptedFiber = /* @__PURE__ */ function() {
  let fiber = void 0;
  return () => {
    if (fiber === void 0) {
      fiber = runFork2(interrupt8);
    }
    return fiber;
  };
}();
var run6 = function() {
  const self = arguments[0];
  if (isEffect2(arguments[1])) {
    return runImpl(self, arguments[1], arguments[2]);
  }
  const options = arguments[1];
  return (effect4) => runImpl(self, effect4, options);
};
var runImpl = (self, effect4, options) => fiberIdWith2((fiberId5) => {
  if (self.state._tag === "Closed") {
    return interrupt8;
  } else if (self.state.fiber !== void 0 && options?.onlyIfMissing === true) {
    return sync8(constInterruptedFiber);
  }
  return tap5(forkDaemon3(effect4), (fiber) => unsafeSet3(self, fiber, {
    ...options,
    interruptAs: fiberId5
  }));
});
var runtime5 = (self) => () => map26(runtime4(), (runtime8) => {
  const runFork4 = runFork3(runtime8);
  return (effect4, options) => {
    if (self.state._tag === "Closed") {
      return constInterruptedFiber();
    } else if (self.state.fiber !== void 0 && options?.onlyIfMissing === true) {
      return constInterruptedFiber();
    }
    const fiber = runFork4(effect4, options);
    unsafeSet3(self, fiber, options);
    return fiber;
  };
});
var runtimePromise = (self) => () => map26(runtime5(self)(), (runFork4) => (effect4, options) => new Promise((resolve, reject3) => runFork4(effect4, options).addObserver((exit4) => {
  if (isSuccess(exit4)) {
    resolve(exit4.value);
  } else {
    reject3(squash(exit4.cause));
  }
})));
var join5 = (self) => _await(self.deferred);
var awaitEmpty = (self) => suspend4(() => {
  if (self.state._tag === "Closed" || self.state.fiber === void 0) {
    return _void;
  }
  return _await3(self.state.fiber);
});

// ../../node_modules/effect/dist/esm/FiberMap.js
var FiberMap_exports = {};
__export(FiberMap_exports, {
  TypeId: () => TypeId29,
  awaitEmpty: () => awaitEmpty2,
  clear: () => clear5,
  get: () => get19,
  has: () => has10,
  isFiberMap: () => isFiberMap,
  join: () => join6,
  make: () => make80,
  makeRuntime: () => makeRuntime2,
  makeRuntimePromise: () => makeRuntimePromise2,
  remove: () => remove11,
  run: () => run7,
  runtime: () => runtime6,
  runtimePromise: () => runtimePromise2,
  set: () => set12,
  size: () => size25,
  unsafeGet: () => unsafeGet11,
  unsafeHas: () => unsafeHas,
  unsafeSet: () => unsafeSet4
});
var TypeId29 = Symbol.for("effect/FiberMap");
var isFiberMap = (u) => hasProperty(u, TypeId29);
var Proto5 = {
  [TypeId29]: TypeId29,
  [Symbol.iterator]() {
    if (this.state._tag === "Closed") {
      return empty2();
    }
    return this.state.backing[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "FiberMap",
      state: this.state
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var unsafeMake16 = (backing, deferred) => {
  const self = Object.create(Proto5);
  self.state = {
    _tag: "Open",
    backing
  };
  self.deferred = deferred;
  return self;
};
var make80 = () => acquireRelease3(map26(make24(), (deferred) => unsafeMake16(empty23(), deferred)), (map49) => withFiberRuntime2((parent) => {
  const state = map49.state;
  if (state._tag === "Closed") return _void;
  map49.state = {
    _tag: "Closed"
  };
  return interruptAllAs2(map4(state.backing, ([, fiber]) => fiber), combine5(parent.id(), internalFiberId2)).pipe(intoDeferred2(map49.deferred));
}));
var makeRuntime2 = () => flatMap18(make80(), (self) => runtime6(self)());
var makeRuntimePromise2 = () => flatMap18(make80(), (self) => runtimePromise2(self)());
var internalFiberIdId2 = -1;
var internalFiberId2 = make17(internalFiberIdId2, 0);
var isInternalInterruption2 = reduceWithContext3(void 0, {
  emptyCase: constFalse,
  failCase: constFalse,
  dieCase: constFalse,
  interruptCase: (_, fiberId5) => has4(ids2(fiberId5), internalFiberIdId2),
  sequentialCase: (_, left3, right3) => left3 || right3,
  parallelCase: (_, left3, right3) => left3 || right3
});
var unsafeSet4 = dual((args2) => isFiberMap(args2[0]), (self, key, fiber, options) => {
  if (self.state._tag === "Closed") {
    fiber.unsafeInterruptAsFork(combine5(options?.interruptAs ?? none4, internalFiberId2));
    return;
  }
  const previous2 = get9(self.state.backing, key);
  if (previous2._tag === "Some") {
    if (options?.onlyIfMissing === true) {
      fiber.unsafeInterruptAsFork(combine5(options?.interruptAs ?? none4, internalFiberId2));
      return;
    } else if (previous2.value === fiber) {
      return;
    }
    previous2.value.unsafeInterruptAsFork(combine5(options?.interruptAs ?? none4, internalFiberId2));
  }
  set5(self.state.backing, key, fiber);
  fiber.addObserver((exit4) => {
    if (self.state._tag === "Closed") {
      return;
    }
    const current2 = get9(self.state.backing, key);
    if (isSome2(current2) && fiber === current2.value) {
      remove8(self.state.backing, key);
    }
    if (isFailure2(exit4) && (options?.propagateInterruption === true ? !isInternalInterruption2(exit4.cause) : !isInterruptedOnly2(exit4.cause))) {
      unsafeDone(self.deferred, exit4);
    }
  });
});
var set12 = dual((args2) => isFiberMap(args2[0]), (self, key, fiber, options) => fiberIdWith2((fiberId5) => sync8(() => unsafeSet4(self, key, fiber, {
  ...options,
  interruptAs: fiberId5
}))));
var unsafeGet11 = dual(2, (self, key) => self.state._tag === "Closed" ? none2() : get9(self.state.backing, key));
var get19 = dual(2, (self, key) => suspend4(() => unsafeGet11(self, key)));
var unsafeHas = dual(2, (self, key) => self.state._tag === "Closed" ? false : has6(self.state.backing, key));
var has10 = dual(2, (self, key) => sync8(() => unsafeHas(self, key)));
var remove11 = dual(2, (self, key) => withFiberRuntime2((removeFiber) => {
  if (self.state._tag === "Closed") {
    return _void;
  }
  const fiber = get9(self.state.backing, key);
  if (fiber._tag === "None") {
    return _void;
  }
  return interruptAs(fiber.value, combine5(removeFiber.id(), internalFiberId2));
}));
var clear5 = (self) => withFiberRuntime2((clearFiber) => {
  if (self.state._tag === "Closed") {
    return _void;
  }
  return forEach16(self.state.backing, ([, fiber]) => (
    // will be removed by the observer
    interruptAs(fiber, combine5(clearFiber.id(), internalFiberId2))
  ));
});
var constInterruptedFiber2 = /* @__PURE__ */ function() {
  let fiber = void 0;
  return () => {
    if (fiber === void 0) {
      fiber = runFork2(interrupt8);
    }
    return fiber;
  };
}();
var run7 = function() {
  const self = arguments[0];
  if (isEffect2(arguments[2])) {
    return runImpl2(self, arguments[1], arguments[2], arguments[3]);
  }
  const key = arguments[1];
  const options = arguments[2];
  return (effect4) => runImpl2(self, key, effect4, options);
};
var runImpl2 = (self, key, effect4, options) => fiberIdWith2((fiberId5) => {
  if (self.state._tag === "Closed") {
    return interrupt8;
  } else if (options?.onlyIfMissing === true && unsafeHas(self, key)) {
    return sync8(constInterruptedFiber2);
  }
  return tap5(forkDaemon3(effect4), (fiber) => unsafeSet4(self, key, fiber, {
    ...options,
    interruptAs: fiberId5
  }));
});
var runtime6 = (self) => () => map26(runtime4(), (runtime8) => {
  const runFork4 = runFork3(runtime8);
  return (key, effect4, options) => {
    if (self.state._tag === "Closed") {
      return constInterruptedFiber2();
    } else if (options?.onlyIfMissing === true && unsafeHas(self, key)) {
      return constInterruptedFiber2();
    }
    const fiber = runFork4(effect4, options);
    unsafeSet4(self, key, fiber, options);
    return fiber;
  };
});
var runtimePromise2 = (self) => () => map26(runtime6(self)(), (runFork4) => (key, effect4, options) => new Promise((resolve, reject3) => runFork4(key, effect4, options).addObserver((exit4) => {
  if (isSuccess(exit4)) {
    resolve(exit4.value);
  } else {
    reject3(squash(exit4.cause));
  }
})));
var size25 = (self) => sync8(() => self.state._tag === "Closed" ? 0 : size10(self.state.backing));
var join6 = (self) => _await(self.deferred);
var awaitEmpty2 = (self) => whileLoop3({
  while: () => self.state._tag === "Open" && size10(self.state.backing) > 0,
  body: () => _await3(unsafeHead(self)[1]),
  step: constVoid
});

// ../../node_modules/effect/dist/esm/FiberSet.js
var FiberSet_exports = {};
__export(FiberSet_exports, {
  TypeId: () => TypeId30,
  add: () => add8,
  awaitEmpty: () => awaitEmpty3,
  clear: () => clear6,
  isFiberSet: () => isFiberSet,
  join: () => join7,
  make: () => make81,
  makeRuntime: () => makeRuntime3,
  makeRuntimePromise: () => makeRuntimePromise3,
  run: () => run8,
  runtime: () => runtime7,
  runtimePromise: () => runtimePromise3,
  size: () => size26,
  unsafeAdd: () => unsafeAdd
});
var TypeId30 = Symbol.for("effect/FiberSet");
var isFiberSet = (u) => hasProperty(u, TypeId30);
var Proto6 = {
  [TypeId30]: TypeId30,
  [Symbol.iterator]() {
    if (this.state._tag === "Closed") {
      return empty2();
    }
    return this.state.backing[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "FiberMap",
      state: this.state
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var unsafeMake17 = (backing, deferred) => {
  const self = Object.create(Proto6);
  self.state = {
    _tag: "Open",
    backing
  };
  self.deferred = deferred;
  return self;
};
var make81 = () => acquireRelease3(map26(make24(), (deferred) => unsafeMake17(/* @__PURE__ */ new Set(), deferred)), (set26) => withFiberRuntime2((parent) => {
  const state = set26.state;
  if (state._tag === "Closed") return _void;
  set26.state = {
    _tag: "Closed"
  };
  const fibers2 = state.backing;
  return interruptAllAs2(fibers2, combine5(parent.id(), internalFiberId3)).pipe(intoDeferred2(set26.deferred));
}));
var makeRuntime3 = () => flatMap18(make81(), (self) => runtime7(self)());
var makeRuntimePromise3 = () => flatMap18(make81(), (self) => runtimePromise3(self)());
var internalFiberIdId3 = -1;
var internalFiberId3 = make17(internalFiberIdId3, 0);
var isInternalInterruption3 = reduceWithContext3(void 0, {
  emptyCase: constFalse,
  failCase: constFalse,
  dieCase: constFalse,
  interruptCase: (_, fiberId5) => has4(ids2(fiberId5), internalFiberIdId3),
  sequentialCase: (_, left3, right3) => left3 || right3,
  parallelCase: (_, left3, right3) => left3 || right3
});
var unsafeAdd = dual((args2) => isFiberSet(args2[0]), (self, fiber, options) => {
  if (self.state._tag === "Closed") {
    fiber.unsafeInterruptAsFork(combine5(options?.interruptAs ?? none4, internalFiberId3));
    return;
  } else if (self.state.backing.has(fiber)) {
    return;
  }
  self.state.backing.add(fiber);
  fiber.addObserver((exit4) => {
    if (self.state._tag === "Closed") {
      return;
    }
    self.state.backing.delete(fiber);
    if (isFailure2(exit4) && (options?.propagateInterruption === true ? !isInternalInterruption3(exit4.cause) : !isInterruptedOnly2(exit4.cause))) {
      unsafeDone(self.deferred, exit4);
    }
  });
});
var add8 = dual((args2) => isFiberSet(args2[0]), (self, fiber, options) => fiberIdWith2((fiberId5) => sync8(() => unsafeAdd(self, fiber, {
  ...options,
  interruptAs: fiberId5
}))));
var clear6 = (self) => withFiberRuntime2((clearFiber) => {
  if (self.state._tag === "Closed") {
    return _void;
  }
  return forEach16(self.state.backing, (fiber) => (
    // will be removed by the observer
    interruptAs(fiber, combine5(clearFiber.id(), internalFiberId3))
  ));
});
var constInterruptedFiber3 = /* @__PURE__ */ function() {
  let fiber = void 0;
  return () => {
    if (fiber === void 0) {
      fiber = runFork2(interrupt8);
    }
    return fiber;
  };
}();
var run8 = function() {
  const self = arguments[0];
  if (!isEffect2(arguments[1])) {
    const options = arguments[1];
    return (effect4) => runImpl3(self, effect4, options);
  }
  return runImpl3(self, arguments[1], arguments[2]);
};
var runImpl3 = (self, effect4, options) => fiberIdWith2((fiberId5) => {
  if (self.state._tag === "Closed") {
    return sync8(constInterruptedFiber3);
  }
  return tap5(forkDaemon3(effect4), (fiber) => unsafeAdd(self, fiber, {
    ...options,
    interruptAs: fiberId5
  }));
});
var runtime7 = (self) => () => map26(runtime4(), (runtime8) => {
  const runFork4 = runFork3(runtime8);
  return (effect4, options) => {
    if (self.state._tag === "Closed") {
      return constInterruptedFiber3();
    }
    const fiber = runFork4(effect4, options);
    unsafeAdd(self, fiber);
    return fiber;
  };
});
var runtimePromise3 = (self) => () => map26(runtime7(self)(), (runFork4) => (effect4, options) => new Promise((resolve, reject3) => runFork4(effect4, options).addObserver((exit4) => {
  if (isSuccess(exit4)) {
    resolve(exit4.value);
  } else {
    reject3(squash(exit4.cause));
  }
})));
var size26 = (self) => sync8(() => self.state._tag === "Closed" ? 0 : self.state.backing.size);
var join7 = (self) => _await(self.deferred);
var awaitEmpty3 = (self) => whileLoop3({
  while: () => self.state._tag === "Open" && self.state.backing.size > 0,
  body: () => _await3(unsafeHead(self)),
  step: constVoid
});

// ../../node_modules/effect/dist/esm/GroupBy.js
var GroupBy_exports = {};
__export(GroupBy_exports, {
  GroupByTypeId: () => GroupByTypeId2,
  evaluate: () => evaluate3,
  filter: () => filter20,
  first: () => first4,
  make: () => make83
});

// ../../node_modules/effect/dist/esm/internal/groupBy.js
var GroupBySymbolKey = "effect/GroupBy";
var GroupByTypeId = Symbol.for(GroupBySymbolKey);
var groupByVariance = {
  /* c8 ignore next */
  _R: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _K: (_) => _,
  /* c8 ignore next */
  _V: (_) => _
};
var isGroupBy = (u) => hasProperty(u, GroupByTypeId);
var evaluate2 = dual((args2) => isGroupBy(args2[0]), (self, f, options) => flatMap23(self.grouped, ([key, queue]) => f(key, flattenTake(fromQueue3(queue, {
  shutdown: true
}))), {
  concurrency: "unbounded",
  bufferSize: options?.bufferSize ?? 16
}));
var filter19 = dual(2, (self, predicate) => make82(pipe(self.grouped, filterEffect((tuple7) => {
  if (predicate(tuple7[0])) {
    return pipe(succeed13(tuple7), as8(true));
  }
  return pipe(shutdown4(tuple7[1]), as8(false));
}))));
var first3 = dual(2, (self, n) => make82(pipe(zipWithIndex(self.grouped), filterEffect((tuple7) => {
  const index = tuple7[1];
  const queue = tuple7[0][1];
  if (index < n) {
    return pipe(succeed13(tuple7), as8(true));
  }
  return pipe(shutdown4(queue), as8(false));
}), map33((tuple7) => tuple7[0]))));
var make82 = (grouped3) => ({
  [GroupByTypeId]: groupByVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  grouped: grouped3
});
var groupBy3 = dual((args2) => isStream(args2[0]), (self, f, options) => make82(unwrapScoped5(gen6(function* () {
  const decider = yield* make24();
  const output = yield* acquireRelease3(bounded5(options?.bufferSize ?? 16), (queue) => shutdown4(queue));
  const ref = yield* make37(/* @__PURE__ */ new Map());
  const add13 = yield* pipe(mapEffectSequential(self, f), distributedWithDynamicCallback(options?.bufferSize ?? 16, ([key, value10]) => flatMap18(_await(decider), (f2) => f2(key, value10)), (exit4) => offer3(output, exit4)));
  yield* succeed2(decider, (key, _) => pipe(get13(ref), map26((map49) => fromNullable2(map49.get(key))), flatMap18(match2({
    onNone: () => flatMap18(add13, ([index, queue]) => zipRight7(update4(ref, (map49) => map49.set(key, index)), pipe(offer3(output, succeed3([key, mapDequeue(queue, (exit4) => new TakeImpl(pipe(exit4, map15((tuple7) => of3(tuple7[1])))))])), as8((n) => n === index)))),
    onSome: (index) => succeed13((n) => n === index)
  }))));
  return flattenExitOption(fromQueue3(output, {
    shutdown: true
  }));
}))));
var mapEffectOptions = dual((args2) => typeof args2[0] !== "function", (self, f, options) => {
  if (options?.key) {
    return evaluate2(groupByKey(self, options.key, {
      bufferSize: options.bufferSize
    }), (_, s) => mapEffectSequential(s, f));
  }
  return matchConcurrency(options?.concurrency, () => mapEffectSequential(self, f), (n) => options?.unordered ? flatMap23(self, (a) => fromEffect9(f(a)), {
    concurrency: n
  }) : mapEffectPar(self, n, f));
});
var bindEffect = dual((args2) => typeof args2[0] !== "string", (self, tag5, f, options) => mapEffectOptions(self, (k) => map26(f(k), (a) => ({
  ...k,
  [tag5]: a
})), options));
var mapDequeue = (dequeue, f) => new MapDequeue(dequeue, f);
var MapDequeue = class extends Class3 {
  dequeue;
  f;
  [DequeueTypeId2] = {
    _Out: (_) => _
  };
  constructor(dequeue, f) {
    super();
    this.dequeue = dequeue;
    this.f = f;
  }
  capacity() {
    return capacity5(this.dequeue);
  }
  get size() {
    return size20(this.dequeue);
  }
  unsafeSize() {
    return this.dequeue.unsafeSize();
  }
  get awaitShutdown() {
    return awaitShutdown4(this.dequeue);
  }
  isActive() {
    return this.dequeue.isActive();
  }
  get isShutdown() {
    return isShutdown4(this.dequeue);
  }
  get shutdown() {
    return shutdown4(this.dequeue);
  }
  get isFull() {
    return isFull5(this.dequeue);
  }
  get isEmpty() {
    return isEmpty18(this.dequeue);
  }
  get take() {
    return pipe(take6(this.dequeue), map26((a) => this.f(a)));
  }
  get takeAll() {
    return pipe(takeAll2(this.dequeue), map26(map7((a) => this.f(a))));
  }
  takeUpTo(max13) {
    return pipe(takeUpTo2(this.dequeue, max13), map26(map7((a) => this.f(a))));
  }
  takeBetween(min11, max13) {
    return pipe(takeBetween2(this.dequeue, min11, max13), map26(map7((a) => this.f(a))));
  }
  takeN(n) {
    return pipe(takeN2(this.dequeue, n), map26(map7((a) => this.f(a))));
  }
  poll() {
    return pipe(poll6(this.dequeue), map26(map2((a) => this.f(a))));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  commit() {
    return this.take;
  }
};
var groupByKey = dual((args2) => typeof args2[0] !== "function", (self, f, options) => {
  const loop5 = (map49, outerQueue) => readWithCause({
    onInput: (input) => flatMap20(fromEffect5(forEach16(groupByIterable(input, f), ([key, values15]) => {
      const innerQueue = map49.get(key);
      if (innerQueue === void 0) {
        return pipe(bounded5(options?.bufferSize ?? 16), flatMap18((innerQueue2) => pipe(sync8(() => {
          map49.set(key, innerQueue2);
        }), zipRight7(offer3(outerQueue, of7([key, innerQueue2]))), zipRight7(pipe(offer3(innerQueue2, chunk3(values15)), catchSomeCause2((cause3) => isInterruptedOnly2(cause3) ? some3(_void) : none2()))))));
      }
      return catchSomeCause2(offer3(innerQueue, chunk3(values15)), (cause3) => isInterruptedOnly2(cause3) ? some3(_void) : none2());
    }, {
      discard: true
    })), () => loop5(map49, outerQueue)),
    onFailure: (cause3) => fromEffect5(offer3(outerQueue, failCause14(cause3))),
    onDone: () => fromEffect5(pipe(forEach16(map49.entries(), ([_, innerQueue]) => pipe(offer3(innerQueue, end4), catchSomeCause2((cause3) => isInterruptedOnly2(cause3) ? some3(_void) : none2())), {
      discard: true
    }), zipRight7(offer3(outerQueue, end4))))
  });
  return make82(unwrapScopedWith3((scope6) => gen6(function* () {
    const map49 = /* @__PURE__ */ new Map();
    const queue = yield* unbounded5();
    yield* addFinalizer3(scope6, shutdown4(queue));
    return yield* toChannel2(self).pipe(pipeTo(loop5(map49, queue)), drain, runIn(scope6), forkIn3(scope6), as8(flattenTake(fromQueue3(queue, {
      shutdown: true
    }))));
  })));
});
var groupByIterable = dual(2, (iterable, f) => {
  const builder = [];
  const iterator = iterable[Symbol.iterator]();
  const map49 = /* @__PURE__ */ new Map();
  let next6;
  while ((next6 = iterator.next()) && !next6.done) {
    const value10 = next6.value;
    const key = f(value10);
    if (map49.has(key)) {
      const innerBuilder = map49.get(key);
      innerBuilder.push(value10);
    } else {
      const innerBuilder = [value10];
      builder.push([key, innerBuilder]);
      map49.set(key, innerBuilder);
    }
  }
  return unsafeFromArray(builder.map((tuple7) => [tuple7[0], unsafeFromArray(tuple7[1])]));
});

// ../../node_modules/effect/dist/esm/GroupBy.js
var GroupByTypeId2 = GroupByTypeId;
var evaluate3 = evaluate2;
var filter20 = filter19;
var first4 = first3;
var make83 = make82;

// ../../node_modules/effect/dist/esm/HKT.js
var HKT_exports = {};

// ../../node_modules/effect/dist/esm/JSONSchema.js
var JSONSchema_exports = {};
__export(JSONSchema_exports, {
  fromAST: () => fromAST,
  make: () => make84
});

// ../../node_modules/effect/dist/esm/ParseResult.js
var ParseResult_exports = {};
__export(ParseResult_exports, {
  ArrayFormatter: () => ArrayFormatter,
  Composite: () => Composite2,
  Forbidden: () => Forbidden,
  Missing: () => Missing,
  ParseError: () => ParseError2,
  ParseErrorTypeId: () => ParseErrorTypeId2,
  Pointer: () => Pointer,
  Refinement: () => Refinement2,
  Transformation: () => Transformation2,
  TreeFormatter: () => TreeFormatter,
  Type: () => Type2,
  Unexpected: () => Unexpected,
  asserts: () => asserts,
  decode: () => decode5,
  decodeEither: () => decodeEither,
  decodeOption: () => decodeOption,
  decodePromise: () => decodePromise,
  decodeSync: () => decodeSync,
  decodeUnknown: () => decodeUnknown2,
  decodeUnknownEither: () => decodeUnknownEither,
  decodeUnknownOption: () => decodeUnknownOption,
  decodeUnknownPromise: () => decodeUnknownPromise,
  decodeUnknownSync: () => decodeUnknownSync,
  eitherOrUndefined: () => eitherOrUndefined,
  encode: () => encode4,
  encodeEither: () => encodeEither,
  encodeOption: () => encodeOption,
  encodePromise: () => encodePromise,
  encodeSync: () => encodeSync,
  encodeUnknown: () => encodeUnknown,
  encodeUnknownEither: () => encodeUnknownEither,
  encodeUnknownOption: () => encodeUnknownOption,
  encodeUnknownPromise: () => encodeUnknownPromise,
  encodeUnknownSync: () => encodeUnknownSync,
  fail: () => fail23,
  flatMap: () => flatMap25,
  fromOption: () => fromOption9,
  getFinalTransformation: () => getFinalTransformation,
  getLiterals: () => getLiterals,
  getOption: () => getOption3,
  getRefinementExpected: () => getRefinementExpected,
  getSearchTree: () => getSearchTree,
  is: () => is,
  isComposite: () => isComposite3,
  isParseError: () => isParseError2,
  map: () => map37,
  mapBoth: () => mapBoth10,
  mapError: () => mapError12,
  mergeInternalOptions: () => mergeInternalOptions,
  orElse: () => orElse18,
  parseError: () => parseError,
  succeed: () => succeed24,
  try: () => _try,
  validate: () => validate5,
  validateEither: () => validateEither,
  validateOption: () => validateOption,
  validatePromise: () => validatePromise,
  validateSync: () => validateSync
});
var Pointer = class {
  path;
  actual;
  issue;
  /**
   * @since 3.10.0
   */
  _tag = "Pointer";
  constructor(path, actual, issue) {
    this.path = path;
    this.actual = actual;
    this.issue = issue;
  }
};
var Unexpected = class {
  actual;
  message;
  /**
   * @since 3.10.0
   */
  _tag = "Unexpected";
  constructor(actual, message) {
    this.actual = actual;
    this.message = message;
  }
};
var Missing = class {
  ast;
  message;
  /**
   * @since 3.10.0
   */
  _tag = "Missing";
  /**
   * @since 3.10.0
   */
  actual = void 0;
  constructor(ast, message) {
    this.ast = ast;
    this.message = message;
  }
};
var Composite2 = class {
  ast;
  actual;
  issues;
  output;
  /**
   * @since 3.10.0
   */
  _tag = "Composite";
  constructor(ast, actual, issues, output) {
    this.ast = ast;
    this.actual = actual;
    this.issues = issues;
    this.output = output;
  }
};
var Refinement2 = class {
  ast;
  actual;
  kind;
  issue;
  /**
   * @since 3.10.0
   */
  _tag = "Refinement";
  constructor(ast, actual, kind, issue) {
    this.ast = ast;
    this.actual = actual;
    this.kind = kind;
    this.issue = issue;
  }
};
var Transformation2 = class {
  ast;
  actual;
  kind;
  issue;
  /**
   * @since 3.10.0
   */
  _tag = "Transformation";
  constructor(ast, actual, kind, issue) {
    this.ast = ast;
    this.actual = actual;
    this.kind = kind;
    this.issue = issue;
  }
};
var Type2 = class {
  ast;
  actual;
  message;
  /**
   * @since 3.10.0
   */
  _tag = "Type";
  constructor(ast, actual, message) {
    this.ast = ast;
    this.actual = actual;
    this.message = message;
  }
};
var Forbidden = class {
  ast;
  actual;
  message;
  /**
   * @since 3.10.0
   */
  _tag = "Forbidden";
  constructor(ast, actual, message) {
    this.ast = ast;
    this.actual = actual;
    this.message = message;
  }
};
var ParseErrorTypeId2 = Symbol.for("effect/Schema/ParseErrorTypeId");
var isParseError2 = (u) => hasProperty(u, ParseErrorTypeId2);
var ParseError2 = class extends TaggedError2("ParseError") {
  /**
   * @since 3.10.0
   */
  [ParseErrorTypeId2] = ParseErrorTypeId2;
  get message() {
    return this.toString();
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return TreeFormatter.formatIssueSync(this.issue);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _id: "ParseError",
      message: this.toString()
    };
  }
  /**
   * @since 3.10.0
   */
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var parseError = (issue) => new ParseError2({
  issue
});
var succeed24 = right2;
var fail23 = left2;
var _try = try_;
var fromOption9 = fromOption2;
var isEither5 = isEither2;
var flatMap25 = dual(2, (self, f) => {
  return isEither5(self) ? match(self, {
    onLeft: left2,
    onRight: f
  }) : flatMap18(self, f);
});
var map37 = dual(2, (self, f) => {
  return isEither5(self) ? map(self, f) : map26(self, f);
});
var mapError12 = dual(2, (self, f) => {
  return isEither5(self) ? mapLeft(self, f) : mapError5(self, f);
});
var eitherOrUndefined = (self) => {
  if (isEither5(self)) {
    return self;
  }
};
var mapBoth10 = dual(2, (self, options) => {
  return isEither5(self) ? mapBoth(self, {
    onLeft: options.onFailure,
    onRight: options.onSuccess
  }) : mapBoth6(self, options);
});
var orElse18 = dual(2, (self, f) => {
  return isEither5(self) ? match(self, {
    onLeft: f,
    onRight: right2
  }) : catchAll4(self, f);
});
var mergeInternalOptions = (options, overrideOptions) => {
  if (overrideOptions === void 0 || isNumber(overrideOptions)) {
    return options;
  }
  if (options === void 0) {
    return overrideOptions;
  }
  return {
    ...options,
    ...overrideOptions
  };
};
var getEither = (ast, isDecoding, options) => {
  const parser = goMemo(ast, isDecoding);
  return (u, overrideOptions) => parser(u, mergeInternalOptions(options, overrideOptions));
};
var getSync = (ast, isDecoding, options) => {
  const parser = getEither(ast, isDecoding, options);
  return (input, overrideOptions) => getOrThrowWith(parser(input, overrideOptions), parseError);
};
var getOption3 = (ast, isDecoding, options) => {
  const parser = getEither(ast, isDecoding, options);
  return (input, overrideOptions) => getRight3(parser(input, overrideOptions));
};
var getEffect = (ast, isDecoding, options) => {
  const parser = goMemo(ast, isDecoding);
  return (input, overrideOptions) => parser(input, {
    ...mergeInternalOptions(options, overrideOptions),
    isEffectAllowed: true
  });
};
var decodeUnknownSync = (schema, options) => getSync(schema.ast, true, options);
var decodeUnknownOption = (schema, options) => getOption3(schema.ast, true, options);
var decodeUnknownEither = (schema, options) => getEither(schema.ast, true, options);
var decodeUnknownPromise = (schema, options) => {
  const parser = decodeUnknown2(schema, options);
  return (u, overrideOptions) => runPromise2(parser(u, overrideOptions));
};
var decodeUnknown2 = (schema, options) => getEffect(schema.ast, true, options);
var encodeUnknownSync = (schema, options) => getSync(schema.ast, false, options);
var encodeUnknownOption = (schema, options) => getOption3(schema.ast, false, options);
var encodeUnknownEither = (schema, options) => getEither(schema.ast, false, options);
var encodeUnknownPromise = (schema, options) => {
  const parser = encodeUnknown(schema, options);
  return (u, overrideOptions) => runPromise2(parser(u, overrideOptions));
};
var encodeUnknown = (schema, options) => getEffect(schema.ast, false, options);
var decodeSync = decodeUnknownSync;
var decodeOption = decodeUnknownOption;
var decodeEither = decodeUnknownEither;
var decodePromise = decodeUnknownPromise;
var decode5 = decodeUnknown2;
var validateSync = (schema, options) => getSync(typeAST(schema.ast), true, options);
var validateOption = (schema, options) => getOption3(typeAST(schema.ast), true, options);
var validateEither = (schema, options) => getEither(typeAST(schema.ast), true, options);
var validatePromise = (schema, options) => {
  const parser = validate5(schema, options);
  return (u, overrideOptions) => runPromise2(parser(u, overrideOptions));
};
var validate5 = (schema, options) => getEffect(typeAST(schema.ast), true, options);
var is = (schema, options) => {
  const parser = goMemo(typeAST(schema.ast), true);
  return (u, overrideOptions) => isRight2(parser(u, {
    exact: true,
    ...mergeInternalOptions(options, overrideOptions)
  }));
};
var asserts = (schema, options) => {
  const parser = goMemo(typeAST(schema.ast), true);
  return (u, overrideOptions) => {
    const result = parser(u, {
      exact: true,
      ...mergeInternalOptions(options, overrideOptions)
    });
    if (isLeft2(result)) {
      throw parseError(result.left);
    }
  };
};
var encodeSync = encodeUnknownSync;
var encodeOption = encodeUnknownOption;
var encodeEither = encodeUnknownEither;
var encodePromise = encodeUnknownPromise;
var encode4 = encodeUnknown;
var decodeMemoMap = globalValue(Symbol.for("effect/ParseResult/decodeMemoMap"), () => /* @__PURE__ */ new WeakMap());
var encodeMemoMap = globalValue(Symbol.for("effect/ParseResult/encodeMemoMap"), () => /* @__PURE__ */ new WeakMap());
var goMemo = (ast, isDecoding) => {
  const memoMap = isDecoding ? decodeMemoMap : encodeMemoMap;
  const memo2 = memoMap.get(ast);
  if (memo2) {
    return memo2;
  }
  const raw = go2(ast, isDecoding);
  const parseOptionsAnnotation = getParseOptionsAnnotation(ast);
  const parserWithOptions = isSome2(parseOptionsAnnotation) ? (i, options) => raw(i, mergeInternalOptions(options, parseOptionsAnnotation.value)) : raw;
  const decodingFallbackAnnotation = getDecodingFallbackAnnotation(ast);
  const parser = isDecoding && isSome2(decodingFallbackAnnotation) ? (i, options) => handleForbidden(orElse18(parserWithOptions(i, options), decodingFallbackAnnotation.value), ast, i, options) : parserWithOptions;
  memoMap.set(ast, parser);
  return parser;
};
var getConcurrency = (ast) => getOrUndefined2(getConcurrencyAnnotation(ast));
var getBatching = (ast) => getOrUndefined2(getBatchingAnnotation(ast));
var go2 = (ast, isDecoding) => {
  switch (ast._tag) {
    case "Refinement": {
      if (isDecoding) {
        const from = goMemo(ast.from, true);
        return (i, options) => {
          options = options ?? defaultParseOption;
          const allErrors = options?.errors === "all";
          const result = flatMap25(orElse18(from(i, options), (ef) => {
            const issue = new Refinement2(ast, i, "From", ef);
            if (allErrors && hasStableFilter(ast) && isComposite3(ef)) {
              return match2(ast.filter(i, options, ast), {
                onNone: () => left2(issue),
                onSome: (ep) => left2(new Composite2(ast, i, [issue, new Refinement2(ast, i, "Predicate", ep)]))
              });
            }
            return left2(issue);
          }), (a) => match2(ast.filter(a, options, ast), {
            onNone: () => right2(a),
            onSome: (ep) => left2(new Refinement2(ast, i, "Predicate", ep))
          }));
          return handleForbidden(result, ast, i, options);
        };
      } else {
        const from = goMemo(typeAST(ast), true);
        const to = goMemo(dropRightRefinement(ast.from), false);
        return (i, options) => handleForbidden(flatMap25(from(i, options), (a) => to(a, options)), ast, i, options);
      }
    }
    case "Transformation": {
      const transform10 = getFinalTransformation(ast.transformation, isDecoding);
      const from = isDecoding ? goMemo(ast.from, true) : goMemo(ast.to, false);
      const to = isDecoding ? goMemo(ast.to, true) : goMemo(ast.from, false);
      return (i, options) => handleForbidden(flatMap25(mapError12(from(i, options), (e) => new Transformation2(ast, i, isDecoding ? "Encoded" : "Type", e)), (a) => flatMap25(mapError12(transform10(a, options ?? defaultParseOption, ast, i), (e) => new Transformation2(ast, i, "Transformation", e)), (i2) => mapError12(to(i2, options), (e) => new Transformation2(ast, i, isDecoding ? "Type" : "Encoded", e)))), ast, i, options);
    }
    case "Declaration": {
      const parse3 = isDecoding ? ast.decodeUnknown(...ast.typeParameters) : ast.encodeUnknown(...ast.typeParameters);
      return (i, options) => handleForbidden(parse3(i, options ?? defaultParseOption, ast), ast, i, options);
    }
    case "Literal":
      return fromRefinement(ast, (u) => u === ast.literal);
    case "UniqueSymbol":
      return fromRefinement(ast, (u) => u === ast.symbol);
    case "UndefinedKeyword":
      return fromRefinement(ast, isUndefined);
    case "NeverKeyword":
      return fromRefinement(ast, isNever);
    case "UnknownKeyword":
    case "AnyKeyword":
    case "VoidKeyword":
      return right2;
    case "StringKeyword":
      return fromRefinement(ast, isString);
    case "NumberKeyword":
      return fromRefinement(ast, isNumber);
    case "BooleanKeyword":
      return fromRefinement(ast, isBoolean);
    case "BigIntKeyword":
      return fromRefinement(ast, isBigInt);
    case "SymbolKeyword":
      return fromRefinement(ast, isSymbol);
    case "ObjectKeyword":
      return fromRefinement(ast, isObject);
    case "Enums":
      return fromRefinement(ast, (u) => ast.enums.some(([_, value10]) => value10 === u));
    case "TemplateLiteral": {
      const regex = getTemplateLiteralRegExp(ast);
      return fromRefinement(ast, (u) => isString(u) && regex.test(u));
    }
    case "TupleType": {
      const elements = ast.elements.map((e) => goMemo(e.type, isDecoding));
      const rest = ast.rest.map((annotatedAST) => goMemo(annotatedAST.type, isDecoding));
      let requiredTypes = ast.elements.filter((e) => !e.isOptional);
      if (ast.rest.length > 0) {
        requiredTypes = requiredTypes.concat(ast.rest.slice(1));
      }
      const requiredLen = requiredTypes.length;
      const expectedIndexes = ast.elements.length > 0 ? ast.elements.map((_, i) => i).join(" | ") : "never";
      const concurrency = getConcurrency(ast);
      const batching = getBatching(ast);
      return (input, options) => {
        if (!isArray(input)) {
          return left2(new Type2(ast, input));
        }
        const allErrors = options?.errors === "all";
        const es = [];
        let stepKey = 0;
        const output = [];
        const len = input.length;
        for (let i2 = len; i2 <= requiredLen - 1; i2++) {
          const e = new Pointer(i2, input, new Missing(requiredTypes[i2 - len]));
          if (allErrors) {
            es.push([stepKey++, e]);
            continue;
          } else {
            return left2(new Composite2(ast, input, e, output));
          }
        }
        if (ast.rest.length === 0) {
          for (let i2 = ast.elements.length; i2 <= len - 1; i2++) {
            const e = new Pointer(i2, input, new Unexpected(input[i2], `is unexpected, expected: ${expectedIndexes}`));
            if (allErrors) {
              es.push([stepKey++, e]);
              continue;
            } else {
              return left2(new Composite2(ast, input, e, output));
            }
          }
        }
        let i = 0;
        let queue = void 0;
        for (; i < elements.length; i++) {
          if (len < i + 1) {
            if (ast.elements[i].isOptional) {
              continue;
            }
          } else {
            const parser = elements[i];
            const te = parser(input[i], options);
            if (isEither5(te)) {
              if (isLeft2(te)) {
                const e = new Pointer(i, input, te.left);
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, sortByIndex(output)));
                }
              }
              output.push([stepKey++, te.right]);
            } else {
              const nk = stepKey++;
              const index = i;
              if (!queue) {
                queue = [];
              }
              queue.push(({
                es: es2,
                output: output2
              }) => flatMap18(either6(te), (t) => {
                if (isLeft2(t)) {
                  const e = new Pointer(index, input, t.left);
                  if (allErrors) {
                    es2.push([nk, e]);
                    return _void;
                  } else {
                    return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                  }
                }
                output2.push([nk, t.right]);
                return _void;
              }));
            }
          }
        }
        if (isNonEmptyReadonlyArray(rest)) {
          const [head13, ...tail5] = rest;
          for (; i < len - tail5.length; i++) {
            const te = head13(input[i], options);
            if (isEither5(te)) {
              if (isLeft2(te)) {
                const e = new Pointer(i, input, te.left);
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, sortByIndex(output)));
                }
              } else {
                output.push([stepKey++, te.right]);
              }
            } else {
              const nk = stepKey++;
              const index = i;
              if (!queue) {
                queue = [];
              }
              queue.push(({
                es: es2,
                output: output2
              }) => flatMap18(either6(te), (t) => {
                if (isLeft2(t)) {
                  const e = new Pointer(index, input, t.left);
                  if (allErrors) {
                    es2.push([nk, e]);
                    return _void;
                  } else {
                    return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                  }
                } else {
                  output2.push([nk, t.right]);
                  return _void;
                }
              }));
            }
          }
          for (let j = 0; j < tail5.length; j++) {
            i += j;
            if (len < i + 1) {
              continue;
            } else {
              const te = tail5[j](input[i], options);
              if (isEither5(te)) {
                if (isLeft2(te)) {
                  const e = new Pointer(i, input, te.left);
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left2(new Composite2(ast, input, e, sortByIndex(output)));
                  }
                }
                output.push([stepKey++, te.right]);
              } else {
                const nk = stepKey++;
                const index = i;
                if (!queue) {
                  queue = [];
                }
                queue.push(({
                  es: es2,
                  output: output2
                }) => flatMap18(either6(te), (t) => {
                  if (isLeft2(t)) {
                    const e = new Pointer(index, input, t.left);
                    if (allErrors) {
                      es2.push([nk, e]);
                      return _void;
                    } else {
                      return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                    }
                  }
                  output2.push([nk, t.right]);
                  return _void;
                }));
              }
            }
          }
        }
        const computeResult = ({
          es: es2,
          output: output2
        }) => isNonEmptyArray2(es2) ? left2(new Composite2(ast, input, sortByIndex(es2), sortByIndex(output2))) : right2(sortByIndex(output2));
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend4(() => {
            const state = {
              es: copy(es),
              output: copy(output)
            };
            return flatMap18(forEach16(cqueue, (f) => f(state), {
              concurrency,
              batching,
              discard: true
            }), () => computeResult(state));
          });
        }
        return computeResult({
          output,
          es
        });
      };
    }
    case "TypeLiteral": {
      if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
        return fromRefinement(ast, isNotNullable);
      }
      const propertySignatures = [];
      const expectedKeysMap = {};
      const expectedKeys = [];
      for (const ps of ast.propertySignatures) {
        propertySignatures.push([goMemo(ps.type, isDecoding), ps]);
        expectedKeysMap[ps.name] = null;
        expectedKeys.push(ps.name);
      }
      const indexSignatures = ast.indexSignatures.map((is4) => [goMemo(is4.parameter, isDecoding), goMemo(is4.type, isDecoding), is4.parameter]);
      const expectedAST = Union.make(ast.indexSignatures.map((is4) => is4.parameter).concat(expectedKeys.map((key) => isSymbol(key) ? new UniqueSymbol(key) : new Literal(key))));
      const expected = goMemo(expectedAST, isDecoding);
      const concurrency = getConcurrency(ast);
      const batching = getBatching(ast);
      return (input, options) => {
        if (!isRecord(input)) {
          return left2(new Type2(ast, input));
        }
        const allErrors = options?.errors === "all";
        const es = [];
        let stepKey = 0;
        const onExcessPropertyError = options?.onExcessProperty === "error";
        const onExcessPropertyPreserve = options?.onExcessProperty === "preserve";
        const output = {};
        let inputKeys;
        if (onExcessPropertyError || onExcessPropertyPreserve) {
          inputKeys = ownKeys(input);
          for (const key of inputKeys) {
            const te = expected(key, options);
            if (isEither5(te) && isLeft2(te)) {
              if (onExcessPropertyError) {
                const e = new Pointer(key, input, new Unexpected(input[key], `is unexpected, expected: ${String(expectedAST)}`));
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, output));
                }
              } else {
                output[key] = input[key];
              }
            }
          }
        }
        let queue = void 0;
        const isExact = options?.exact === true;
        for (let i = 0; i < propertySignatures.length; i++) {
          const ps = propertySignatures[i][1];
          const name = ps.name;
          const hasKey = Object.prototype.hasOwnProperty.call(input, name);
          if (!hasKey) {
            if (ps.isOptional) {
              continue;
            } else if (isExact) {
              const e = new Pointer(name, input, new Missing(ps));
              if (allErrors) {
                es.push([stepKey++, e]);
                continue;
              } else {
                return left2(new Composite2(ast, input, e, output));
              }
            }
          }
          const parser = propertySignatures[i][0];
          const te = parser(input[name], options);
          if (isEither5(te)) {
            if (isLeft2(te)) {
              const e = new Pointer(name, input, hasKey ? te.left : new Missing(ps));
              if (allErrors) {
                es.push([stepKey++, e]);
                continue;
              } else {
                return left2(new Composite2(ast, input, e, output));
              }
            }
            output[name] = te.right;
          } else {
            const nk = stepKey++;
            const index = name;
            if (!queue) {
              queue = [];
            }
            queue.push(({
              es: es2,
              output: output2
            }) => flatMap18(either6(te), (t) => {
              if (isLeft2(t)) {
                const e = new Pointer(index, input, hasKey ? t.left : new Missing(ps));
                if (allErrors) {
                  es2.push([nk, e]);
                  return _void;
                } else {
                  return left2(new Composite2(ast, input, e, output2));
                }
              }
              output2[index] = t.right;
              return _void;
            }));
          }
        }
        for (let i = 0; i < indexSignatures.length; i++) {
          const indexSignature = indexSignatures[i];
          const parameter = indexSignature[0];
          const type3 = indexSignature[1];
          const keys15 = getKeysForIndexSignature(input, indexSignature[2]);
          for (const key of keys15) {
            const keu = parameter(key, options);
            if (isEither5(keu) && isRight2(keu)) {
              const vpr = type3(input[key], options);
              if (isEither5(vpr)) {
                if (isLeft2(vpr)) {
                  const e = new Pointer(key, input, vpr.left);
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left2(new Composite2(ast, input, e, output));
                  }
                } else {
                  if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                    output[key] = vpr.right;
                  }
                }
              } else {
                const nk = stepKey++;
                const index = key;
                if (!queue) {
                  queue = [];
                }
                queue.push(({
                  es: es2,
                  output: output2
                }) => flatMap18(either6(vpr), (tv) => {
                  if (isLeft2(tv)) {
                    const e = new Pointer(index, input, tv.left);
                    if (allErrors) {
                      es2.push([nk, e]);
                      return _void;
                    } else {
                      return left2(new Composite2(ast, input, e, output2));
                    }
                  } else {
                    if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                      output2[key] = tv.right;
                    }
                    return _void;
                  }
                }));
              }
            }
          }
        }
        const computeResult = ({
          es: es2,
          output: output2
        }) => {
          if (isNonEmptyArray2(es2)) {
            return left2(new Composite2(ast, input, sortByIndex(es2), output2));
          }
          if (options?.propertyOrder === "original") {
            const keys15 = inputKeys || ownKeys(input);
            for (const name of expectedKeys) {
              if (keys15.indexOf(name) === -1) {
                keys15.push(name);
              }
            }
            const out = {};
            for (const key of keys15) {
              if (Object.prototype.hasOwnProperty.call(output2, key)) {
                out[key] = output2[key];
              }
            }
            return right2(out);
          }
          return right2(output2);
        };
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend4(() => {
            const state = {
              es: copy(es),
              output: Object.assign({}, output)
            };
            return flatMap18(forEach16(cqueue, (f) => f(state), {
              concurrency,
              batching,
              discard: true
            }), () => computeResult(state));
          });
        }
        return computeResult({
          es,
          output
        });
      };
    }
    case "Union": {
      const searchTree = getSearchTree(ast.types, isDecoding);
      const ownKeys2 = ownKeys(searchTree.keys);
      const ownKeysLen = ownKeys2.length;
      const astTypesLen = ast.types.length;
      const map49 = /* @__PURE__ */ new Map();
      for (let i = 0; i < astTypesLen; i++) {
        map49.set(ast.types[i], goMemo(ast.types[i], isDecoding));
      }
      const concurrency = getConcurrency(ast) ?? 1;
      const batching = getBatching(ast);
      return (input, options) => {
        const es = [];
        let stepKey = 0;
        let candidates = [];
        if (ownKeysLen > 0) {
          if (isRecordOrArray(input)) {
            for (let i = 0; i < ownKeysLen; i++) {
              const name = ownKeys2[i];
              const buckets = searchTree.keys[name].buckets;
              if (Object.prototype.hasOwnProperty.call(input, name)) {
                const literal3 = String(input[name]);
                if (Object.prototype.hasOwnProperty.call(buckets, literal3)) {
                  candidates = candidates.concat(buckets[literal3]);
                } else {
                  const {
                    candidates: candidates2,
                    literals
                  } = searchTree.keys[name];
                  const literalsUnion = Union.make(literals);
                  const errorAst = candidates2.length === astTypesLen ? new TypeLiteral([new PropertySignature(name, literalsUnion, false, true)], []) : Union.make(candidates2);
                  es.push([stepKey++, new Composite2(errorAst, input, new Pointer(name, input, new Type2(literalsUnion, input[name])))]);
                }
              } else {
                const {
                  candidates: candidates2,
                  literals
                } = searchTree.keys[name];
                const fakePropertySignature = new PropertySignature(name, Union.make(literals), false, true);
                const errorAst = candidates2.length === astTypesLen ? new TypeLiteral([fakePropertySignature], []) : Union.make(candidates2);
                es.push([stepKey++, new Composite2(errorAst, input, new Pointer(name, input, new Missing(fakePropertySignature)))]);
              }
            }
          } else {
            const errorAst = searchTree.candidates.length === astTypesLen ? ast : Union.make(searchTree.candidates);
            es.push([stepKey++, new Type2(errorAst, input)]);
          }
        }
        if (searchTree.otherwise.length > 0) {
          candidates = candidates.concat(searchTree.otherwise);
        }
        let queue = void 0;
        for (let i = 0; i < candidates.length; i++) {
          const candidate = candidates[i];
          const pr = map49.get(candidate)(input, options);
          if (isEither5(pr) && (!queue || queue.length === 0)) {
            if (isRight2(pr)) {
              return pr;
            } else {
              es.push([stepKey++, pr.left]);
            }
          } else {
            const nk = stepKey++;
            if (!queue) {
              queue = [];
            }
            queue.push((state) => suspend4(() => {
              if ("finalResult" in state) {
                return _void;
              } else {
                return flatMap18(either6(pr), (t) => {
                  if (isRight2(t)) {
                    state.finalResult = t;
                  } else {
                    state.es.push([nk, t.left]);
                  }
                  return _void;
                });
              }
            }));
          }
        }
        const computeResult = (es2) => isNonEmptyArray2(es2) ? es2.length === 1 && es2[0][1]._tag === "Type" ? left2(es2[0][1]) : left2(new Composite2(ast, input, sortByIndex(es2))) : (
          // this should never happen
          left2(new Type2(ast, input))
        );
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend4(() => {
            const state = {
              es: copy(es)
            };
            return flatMap18(forEach16(cqueue, (f) => f(state), {
              concurrency,
              batching,
              discard: true
            }), () => {
              if ("finalResult" in state) {
                return state.finalResult;
              }
              return computeResult(state.es);
            });
          });
        }
        return computeResult(es);
      };
    }
    case "Suspend": {
      const get48 = memoizeThunk(() => goMemo(annotations(ast.f(), ast.annotations), isDecoding));
      return (a, options) => get48()(a, options);
    }
  }
};
var fromRefinement = (ast, refinement) => (u) => refinement(u) ? right2(u) : left2(new Type2(ast, u));
var getLiterals = (ast, isDecoding) => {
  switch (ast._tag) {
    case "Declaration": {
      const annotation = getSurrogateAnnotation(ast);
      if (isSome2(annotation)) {
        return getLiterals(annotation.value, isDecoding);
      }
      break;
    }
    case "TypeLiteral": {
      const out = [];
      for (let i = 0; i < ast.propertySignatures.length; i++) {
        const propertySignature2 = ast.propertySignatures[i];
        const type3 = isDecoding ? encodedAST(propertySignature2.type) : typeAST(propertySignature2.type);
        if (isLiteral(type3) && !propertySignature2.isOptional) {
          out.push([propertySignature2.name, type3]);
        }
      }
      return out;
    }
    case "TupleType": {
      const out = [];
      for (let i = 0; i < ast.elements.length; i++) {
        const element2 = ast.elements[i];
        const type3 = isDecoding ? encodedAST(element2.type) : typeAST(element2.type);
        if (isLiteral(type3) && !element2.isOptional) {
          out.push([i, type3]);
        }
      }
      return out;
    }
    case "Refinement":
      return getLiterals(ast.from, isDecoding);
    case "Suspend":
      return getLiterals(ast.f(), isDecoding);
    case "Transformation":
      return getLiterals(isDecoding ? ast.from : ast.to, isDecoding);
  }
  return [];
};
var getSearchTree = (members, isDecoding) => {
  const keys15 = {};
  const otherwise = [];
  const candidates = [];
  for (let i = 0; i < members.length; i++) {
    const member = members[i];
    const tags3 = getLiterals(member, isDecoding);
    if (tags3.length > 0) {
      candidates.push(member);
      for (let j = 0; j < tags3.length; j++) {
        const [key, literal3] = tags3[j];
        const hash4 = String(literal3.literal);
        keys15[key] = keys15[key] || {
          buckets: {},
          literals: [],
          candidates: []
        };
        const buckets = keys15[key].buckets;
        if (Object.prototype.hasOwnProperty.call(buckets, hash4)) {
          if (j < tags3.length - 1) {
            continue;
          }
          buckets[hash4].push(member);
          keys15[key].literals.push(literal3);
          keys15[key].candidates.push(member);
        } else {
          buckets[hash4] = [member];
          keys15[key].literals.push(literal3);
          keys15[key].candidates.push(member);
          break;
        }
      }
    } else {
      otherwise.push(member);
    }
  }
  return {
    keys: keys15,
    otherwise,
    candidates
  };
};
var dropRightRefinement = (ast) => isRefinement(ast) ? dropRightRefinement(ast.from) : ast;
var handleForbidden = (effect4, ast, actual, options) => {
  if (options?.isEffectAllowed === true) {
    return effect4;
  }
  if (isEither5(effect4)) {
    return effect4;
  }
  const scheduler2 = new SyncScheduler();
  const fiber = runFork2(effect4, {
    scheduler: scheduler2
  });
  scheduler2.flush();
  const exit4 = fiber.unsafePoll();
  if (exit4) {
    if (isSuccess(exit4)) {
      return right2(exit4.value);
    }
    const cause3 = exit4.cause;
    if (isFailType2(cause3)) {
      return left2(cause3.error);
    }
    return left2(new Forbidden(ast, actual, pretty3(cause3)));
  }
  return left2(new Forbidden(ast, actual, "cannot be be resolved synchronously, this is caused by using runSync on an effect that performs async work"));
};
var compare = ([a], [b]) => a > b ? 1 : a < b ? -1 : 0;
function sortByIndex(es) {
  return es.sort(compare).map((t) => t[1]);
}
var getFinalTransformation = (transformation, isDecoding) => {
  switch (transformation._tag) {
    case "FinalTransformation":
      return isDecoding ? transformation.decode : transformation.encode;
    case "ComposeTransformation":
      return right2;
    case "TypeLiteralTransformation":
      return (input) => {
        let out = right2(input);
        for (const pst of transformation.propertySignatureTransformations) {
          const [from, to] = isDecoding ? [pst.from, pst.to] : [pst.to, pst.from];
          const transformation2 = isDecoding ? pst.decode : pst.encode;
          const f = (input2) => {
            const o = transformation2(Object.prototype.hasOwnProperty.call(input2, from) ? some3(input2[from]) : none2());
            delete input2[from];
            if (isSome2(o)) {
              input2[to] = o.value;
            }
            return input2;
          };
          out = map37(out, f);
        }
        return out;
      };
  }
};
var makeTree = (value10, forest = []) => ({
  value: value10,
  forest
});
var TreeFormatter = {
  formatIssue: (issue) => map37(formatTree(issue), drawTree),
  formatIssueSync: (issue) => {
    const e = TreeFormatter.formatIssue(issue);
    return isEither5(e) ? getOrThrow(e) : runSync2(e);
  },
  formatError: (error4) => TreeFormatter.formatIssue(error4.issue),
  formatErrorSync: (error4) => TreeFormatter.formatIssueSync(error4.issue)
};
var drawTree = (tree) => tree.value + draw("\n", tree.forest);
var draw = (indentation, forest) => {
  let r = "";
  const len = forest.length;
  let tree;
  for (let i = 0; i < len; i++) {
    tree = forest[i];
    const isLast = i === len - 1;
    r += indentation + (isLast ? "└" : "├") + "─ " + tree.value;
    r += draw(indentation + (len > 1 && !isLast ? "│  " : "   "), tree.forest);
  }
  return r;
};
var formatTransformationKind = (kind) => {
  switch (kind) {
    case "Encoded":
      return "Encoded side transformation failure";
    case "Transformation":
      return "Transformation process failure";
    case "Type":
      return "Type side transformation failure";
  }
};
var formatRefinementKind = (kind) => {
  switch (kind) {
    case "From":
      return "From side refinement failure";
    case "Predicate":
      return "Predicate refinement failure";
  }
};
var getAnnotated = (issue) => "ast" in issue ? some3(issue.ast) : none2();
var Either_void = right2(void 0);
var getCurrentMessage = (issue) => getAnnotated(issue).pipe(flatMap2(getMessageAnnotation), match2({
  onNone: () => Either_void,
  onSome: (messageAnnotation) => {
    const union17 = messageAnnotation(issue);
    if (isString(union17)) {
      return right2({
        message: union17,
        override: false
      });
    }
    if (isEffect2(union17)) {
      return map26(union17, (message) => ({
        message,
        override: false
      }));
    }
    if (isString(union17.message)) {
      return right2({
        message: union17.message,
        override: union17.override
      });
    }
    return map26(union17.message, (message) => ({
      message,
      override: union17.override
    }));
  }
}));
var createParseIssueGuard = (tag5) => (issue) => issue._tag === tag5;
var isComposite3 = createParseIssueGuard("Composite");
var isRefinement2 = createParseIssueGuard("Refinement");
var isTransformation2 = createParseIssueGuard("Transformation");
var getMessage = (issue) => flatMap25(getCurrentMessage(issue), (currentMessage) => {
  if (currentMessage !== void 0) {
    const useInnerMessage = !currentMessage.override && (isComposite3(issue) || isRefinement2(issue) && issue.kind === "From" || isTransformation2(issue) && issue.kind !== "Transformation");
    return useInnerMessage ? isTransformation2(issue) || isRefinement2(issue) ? getMessage(issue.issue) : Either_void : right2(currentMessage.message);
  }
  return Either_void;
});
var getParseIssueTitleAnnotation2 = (issue) => getAnnotated(issue).pipe(flatMap2(getParseIssueTitleAnnotation), flatMapNullable((annotation) => annotation(issue)), getOrUndefined2);
function getRefinementExpected(ast) {
  return getDescriptionAnnotation(ast).pipe(orElse2(() => getTitleAnnotation(ast)), orElse2(() => getAutoTitleAnnotation(ast)), orElse2(() => getIdentifierAnnotation(ast)), getOrElse2(() => `{ ${ast.from} | filter }`));
}
function getDefaultTypeMessage(issue) {
  if (issue.message !== void 0) {
    return issue.message;
  }
  const expected = isRefinement(issue.ast) ? getRefinementExpected(issue.ast) : String(issue.ast);
  return `Expected ${expected}, actual ${formatUnknown(issue.actual)}`;
}
var formatTypeMessage = (issue) => map37(getMessage(issue), (message) => message ?? getParseIssueTitleAnnotation2(issue) ?? getDefaultTypeMessage(issue));
var getParseIssueTitle = (issue) => getParseIssueTitleAnnotation2(issue) ?? String(issue.ast);
var formatForbiddenMessage = (issue) => issue.message ?? "is forbidden";
var formatUnexpectedMessage = (issue) => issue.message ?? "is unexpected";
var formatMissingMessage = (issue) => {
  const missingMessageAnnotation = getMissingMessageAnnotation(issue.ast);
  if (isSome2(missingMessageAnnotation)) {
    const annotation = missingMessageAnnotation.value();
    return isString(annotation) ? right2(annotation) : annotation;
  }
  return right2(issue.message ?? "is missing");
};
var formatTree = (issue) => {
  switch (issue._tag) {
    case "Type":
      return map37(formatTypeMessage(issue), makeTree);
    case "Forbidden":
      return right2(makeTree(getParseIssueTitle(issue), [makeTree(formatForbiddenMessage(issue))]));
    case "Unexpected":
      return right2(makeTree(formatUnexpectedMessage(issue)));
    case "Missing":
      return map37(formatMissingMessage(issue), makeTree);
    case "Transformation":
      return flatMap25(getMessage(issue), (message) => {
        if (message !== void 0) {
          return right2(makeTree(message));
        }
        return map37(formatTree(issue.issue), (tree) => makeTree(getParseIssueTitle(issue), [makeTree(formatTransformationKind(issue.kind), [tree])]));
      });
    case "Refinement":
      return flatMap25(getMessage(issue), (message) => {
        if (message !== void 0) {
          return right2(makeTree(message));
        }
        return map37(formatTree(issue.issue), (tree) => makeTree(getParseIssueTitle(issue), [makeTree(formatRefinementKind(issue.kind), [tree])]));
      });
    case "Pointer":
      return map37(formatTree(issue.issue), (tree) => makeTree(formatPath(issue.path), [tree]));
    case "Composite":
      return flatMap25(getMessage(issue), (message) => {
        if (message !== void 0) {
          return right2(makeTree(message));
        }
        const parseIssueTitle = getParseIssueTitle(issue);
        return isNonEmpty(issue.issues) ? map37(forEach16(issue.issues, formatTree), (forest) => makeTree(parseIssueTitle, forest)) : map37(formatTree(issue.issues), (tree) => makeTree(parseIssueTitle, [tree]));
      });
  }
};
var makeArrayFormatterIssue = (_tag, path, message) => ({
  _tag,
  path,
  message
});
var ArrayFormatter = {
  formatIssue: (issue) => getArrayFormatterIssues(issue, void 0, []),
  formatIssueSync: (issue) => {
    const e = ArrayFormatter.formatIssue(issue);
    return isEither5(e) ? getOrThrow(e) : runSync2(e);
  },
  formatError: (error4) => ArrayFormatter.formatIssue(error4.issue),
  formatErrorSync: (error4) => ArrayFormatter.formatIssueSync(error4.issue)
};
var getArrayFormatterIssues = (issue, parentTag, path) => {
  const _tag = issue._tag;
  switch (_tag) {
    case "Type":
      return map37(formatTypeMessage(issue), (message) => [makeArrayFormatterIssue(parentTag ?? _tag, path, message)]);
    case "Forbidden":
      return right2([makeArrayFormatterIssue(_tag, path, formatForbiddenMessage(issue))]);
    case "Unexpected":
      return right2([makeArrayFormatterIssue(_tag, path, formatUnexpectedMessage(issue))]);
    case "Missing":
      return map37(formatMissingMessage(issue), (message) => [makeArrayFormatterIssue(_tag, path, message)]);
    case "Pointer":
      return getArrayFormatterIssues(issue.issue, void 0, path.concat(issue.path));
    case "Composite":
      return flatMap25(getMessage(issue), (message) => {
        if (message !== void 0) {
          return right2([makeArrayFormatterIssue(_tag, path, message)]);
        }
        return isNonEmpty(issue.issues) ? map37(forEach16(issue.issues, (issue2) => getArrayFormatterIssues(issue2, void 0, path)), flatten3) : getArrayFormatterIssues(issue.issues, void 0, path);
      });
    case "Refinement":
      return flatMap25(getMessage(issue), (message) => {
        if (message !== void 0) {
          return right2([makeArrayFormatterIssue(_tag, path, message)]);
        }
        return getArrayFormatterIssues(issue.issue, issue.kind === "Predicate" ? _tag : void 0, path);
      });
    case "Transformation":
      return flatMap25(getMessage(issue), (message) => {
        if (message !== void 0) {
          return right2([makeArrayFormatterIssue(_tag, path, message)]);
        }
        return getArrayFormatterIssues(issue.issue, issue.kind === "Transformation" ? _tag : void 0, path);
      });
  }
};

// ../../node_modules/effect/dist/esm/JSONSchema.js
var make84 = (schema) => {
  const definitions = {};
  const ast = isTransformation(schema.ast) && isParseJsonTransformation(schema.ast.from) ? schema.ast.to : schema.ast;
  const jsonSchema = fromAST(ast, {
    definitions
  });
  const out = {
    $schema,
    $defs: {},
    ...jsonSchema
  };
  if (isEmptyRecord(definitions)) {
    delete out.$defs;
  } else {
    out.$defs = definitions;
  }
  return out;
};
var fromAST = (ast, options) => {
  const definitionPath = options.definitionPath ?? "#/$defs/";
  const getRef = (id3) => definitionPath + id3;
  const target = options.target ?? "jsonSchema7";
  const handleIdentifier = options.topLevelReferenceStrategy !== "skip";
  const additionalPropertiesStrategy = options.additionalPropertiesStrategy ?? "strict";
  return go3(ast, options.definitions, handleIdentifier, [], {
    getRef,
    target,
    additionalPropertiesStrategy
  });
};
var constNever = {
  "$id": "/schemas/never",
  "not": {}
};
var constAny = {
  "$id": "/schemas/any"
};
var constUnknown = {
  "$id": "/schemas/unknown"
};
var constVoid2 = {
  "$id": "/schemas/void"
};
var constAnyObject = {
  "$id": "/schemas/object",
  "anyOf": [{
    "type": "object"
  }, {
    "type": "array"
  }]
};
var constEmpty2 = {
  "$id": "/schemas/%7B%7D",
  "anyOf": [{
    "type": "object"
  }, {
    "type": "array"
  }]
};
var $schema = "http://json-schema.org/draft-07/schema#";
var getJsonSchemaAnnotations = (ast, annotated) => {
  annotated ??= ast;
  const out = getSomes2({
    description: getDescriptionAnnotation(annotated),
    title: getTitleAnnotation(annotated),
    default: getDefaultAnnotation(annotated)
  });
  const oexamples = getExamplesAnnotation(annotated);
  if (isSome2(oexamples) && oexamples.value.length > 0) {
    const getOption4 = getOption3(ast, false);
    const examples = filterMap4(oexamples.value, (e) => getOption4(e));
    if (examples.length > 0) {
      out.examples = examples;
    }
  }
  return out;
};
var removeDefaultJsonSchemaAnnotations = (jsonSchemaAnnotations, ast) => {
  if (jsonSchemaAnnotations["title"] === ast.annotations[TitleAnnotationId]) {
    delete jsonSchemaAnnotations["title"];
  }
  if (jsonSchemaAnnotations["description"] === ast.annotations[DescriptionAnnotationId]) {
    delete jsonSchemaAnnotations["description"];
  }
  return jsonSchemaAnnotations;
};
var getASTJsonSchemaAnnotations = (ast) => {
  const jsonSchemaAnnotations = getJsonSchemaAnnotations(ast);
  switch (ast._tag) {
    case "StringKeyword":
      return removeDefaultJsonSchemaAnnotations(jsonSchemaAnnotations, stringKeyword);
    case "NumberKeyword":
      return removeDefaultJsonSchemaAnnotations(jsonSchemaAnnotations, numberKeyword);
    case "BooleanKeyword":
      return removeDefaultJsonSchemaAnnotations(jsonSchemaAnnotations, booleanKeyword);
    default:
      return jsonSchemaAnnotations;
  }
};
var pruneUndefined2 = (ast) => {
  if (isNone2(getJSONSchemaAnnotation(ast))) {
    return pruneUndefined(ast, pruneUndefined2, (ast2) => pruneUndefined2(ast2.from));
  }
};
var isParseJsonTransformation = (ast) => ast.annotations[SchemaIdAnnotationId] === ParseJsonSchemaId;
var isOverrideAnnotation = (jsonSchema) => {
  return "type" in jsonSchema || "oneOf" in jsonSchema || "anyOf" in jsonSchema || "const" in jsonSchema || "enum" in jsonSchema || "$ref" in jsonSchema;
};
var isMergeableEnum = (jsonSchema) => {
  const len = Object.keys(jsonSchema).length;
  return "enum" in jsonSchema && (len === 1 || "type" in jsonSchema && len === 2);
};
var addEnumType = (jsonSchema) => {
  if ("enum" in jsonSchema && !("type" in jsonSchema)) {
    const type3 = jsonSchema.enum.every(isString) ? "string" : jsonSchema.enum.every(isNumber) ? "number" : jsonSchema.enum.every(isBoolean) ? "boolean" : void 0;
    if (type3 !== void 0) {
      return {
        type: type3,
        ...jsonSchema
      };
    }
  }
  return jsonSchema;
};
var mergeRefinements = (from, jsonSchema, annotations4) => {
  const out = {
    ...from,
    ...annotations4,
    ...jsonSchema
  };
  out.allOf ??= [];
  const handle = (name, filter26) => {
    if (name in jsonSchema && name in from) {
      out.allOf.unshift({
        [name]: from[name]
      });
      out.allOf = out.allOf.filter(filter26);
    }
  };
  handle("minLength", (i) => i.minLength > jsonSchema.minLength);
  handle("maxLength", (i) => i.maxLength < jsonSchema.maxLength);
  handle("pattern", (i) => i.pattern !== jsonSchema.pattern);
  handle("minItems", (i) => i.minItems > jsonSchema.minItems);
  handle("maxItems", (i) => i.maxItems < jsonSchema.maxItems);
  handle("minimum", (i) => i.minimum > jsonSchema.minimum);
  handle("maximum", (i) => i.maximum < jsonSchema.maximum);
  handle("exclusiveMinimum", (i) => i.exclusiveMinimum > jsonSchema.exclusiveMinimum);
  handle("exclusiveMaximum", (i) => i.exclusiveMaximum < jsonSchema.exclusiveMaximum);
  handle("multipleOf", (i) => i.multipleOf !== jsonSchema.multipleOf);
  if (out.allOf.length === 0) {
    delete out.allOf;
  }
  return out;
};
function isContentSchemaSupported(options) {
  switch (options.target) {
    case "jsonSchema7":
      return false;
    case "jsonSchema2019-09":
    case "openApi3.1":
      return true;
  }
}
function isNullTypeKeywordSupported(options) {
  switch (options.target) {
    case "jsonSchema7":
    case "jsonSchema2019-09":
      return true;
    case "openApi3.1":
      return false;
  }
}
function isNullableKeywordSupported(options) {
  switch (options.target) {
    case "jsonSchema7":
    case "jsonSchema2019-09":
      return false;
    case "openApi3.1":
      return true;
  }
}
function getAdditionalProperties(options) {
  switch (options.additionalPropertiesStrategy) {
    case "allow":
      return true;
    case "strict":
      return false;
  }
}
var isNeverJSONSchema = (jsonSchema) => "$id" in jsonSchema && jsonSchema.$id === "/schemas/never";
var isAnyJSONSchema = (jsonSchema) => "$id" in jsonSchema && jsonSchema.$id === "/schemas/any";
var isUnknownJSONSchema = (jsonSchema) => "$id" in jsonSchema && jsonSchema.$id === "/schemas/unknown";
var isVoidJSONSchema = (jsonSchema) => "$id" in jsonSchema && jsonSchema.$id === "/schemas/void";
var shrink = (members) => {
  let i = members.findIndex(isAnyJSONSchema);
  if (i !== -1) {
    members = [members[i]];
  }
  i = members.findIndex(isUnknownJSONSchema);
  if (i !== -1) {
    members = [members[i]];
  }
  i = members.findIndex(isVoidJSONSchema);
  if (i !== -1) {
    members = [members[i]];
  }
  return members;
};
var go3 = (ast, $defs, handleIdentifier, path, options) => {
  if (handleIdentifier) {
    const identifier2 = getJSONIdentifier(ast);
    if (isSome2(identifier2)) {
      const id3 = identifier2.value;
      const escapedId = id3.replace(/~/ig, "~0").replace(/\//ig, "~1");
      const out = {
        $ref: options.getRef(escapedId)
      };
      if (!has($defs, id3)) {
        $defs[id3] = out;
        $defs[id3] = go3(ast, $defs, false, path, options);
      }
      return out;
    }
  }
  const hook = getJSONSchemaAnnotation(ast);
  if (isSome2(hook)) {
    const handler = hook.value;
    if (isRefinement(ast)) {
      const t = getTransformationFrom(ast);
      if (t === void 0) {
        return mergeRefinements(go3(ast.from, $defs, handleIdentifier, path, options), handler, getJsonSchemaAnnotations(ast));
      } else if (!isOverrideAnnotation(handler)) {
        return go3(t, $defs, handleIdentifier, path, options);
      }
    }
    if (isDeclaration(ast)) {
      return {
        ...handler,
        ...getJsonSchemaAnnotations(ast)
      };
    }
    return handler;
  }
  const surrogate = getSurrogateAnnotation(ast);
  if (isSome2(surrogate)) {
    return go3(surrogate.value, $defs, handleIdentifier, path, options);
  }
  switch (ast._tag) {
    case "Declaration":
      throw new Error(getJSONSchemaMissingAnnotationErrorMessage(path, ast));
    case "Literal": {
      const literal3 = ast.literal;
      if (literal3 === null) {
        if (isNullTypeKeywordSupported(options)) {
          return {
            type: "null",
            ...getJsonSchemaAnnotations(ast)
          };
        } else {
          return {
            // @ts-expect-error
            enum: [null],
            ...getJsonSchemaAnnotations(ast)
          };
        }
      } else if (isString(literal3)) {
        return {
          type: "string",
          enum: [literal3],
          ...getJsonSchemaAnnotations(ast)
        };
      } else if (isNumber(literal3)) {
        return {
          type: "number",
          enum: [literal3],
          ...getJsonSchemaAnnotations(ast)
        };
      } else if (isBoolean(literal3)) {
        return {
          type: "boolean",
          enum: [literal3],
          ...getJsonSchemaAnnotations(ast)
        };
      }
      throw new Error(getJSONSchemaMissingAnnotationErrorMessage(path, ast));
    }
    case "UniqueSymbol":
      throw new Error(getJSONSchemaMissingAnnotationErrorMessage(path, ast));
    case "UndefinedKeyword":
      throw new Error(getJSONSchemaMissingAnnotationErrorMessage(path, ast));
    case "VoidKeyword":
      return {
        ...constVoid2,
        ...getJsonSchemaAnnotations(ast)
      };
    case "NeverKeyword":
      return {
        ...constNever,
        ...getJsonSchemaAnnotations(ast)
      };
    case "UnknownKeyword":
      return {
        ...constUnknown,
        ...getJsonSchemaAnnotations(ast)
      };
    case "AnyKeyword":
      return {
        ...constAny,
        ...getJsonSchemaAnnotations(ast)
      };
    case "ObjectKeyword":
      return {
        ...constAnyObject,
        ...getJsonSchemaAnnotations(ast)
      };
    case "StringKeyword":
      return {
        type: "string",
        ...getASTJsonSchemaAnnotations(ast)
      };
    case "NumberKeyword":
      return {
        type: "number",
        ...getASTJsonSchemaAnnotations(ast)
      };
    case "BooleanKeyword":
      return {
        type: "boolean",
        ...getASTJsonSchemaAnnotations(ast)
      };
    case "BigIntKeyword":
      throw new Error(getJSONSchemaMissingAnnotationErrorMessage(path, ast));
    case "SymbolKeyword":
      throw new Error(getJSONSchemaMissingAnnotationErrorMessage(path, ast));
    case "TupleType": {
      const elements = ast.elements.map((e, i) => ({
        ...go3(e.type, $defs, true, path.concat(i), options),
        ...getJsonSchemaAnnotations(e.type, e)
      }));
      const rest = ast.rest.map((annotatedAST) => ({
        ...go3(annotatedAST.type, $defs, true, path, options),
        ...getJsonSchemaAnnotations(annotatedAST.type, annotatedAST)
      }));
      const output = {
        type: "array"
      };
      const len = ast.elements.length;
      if (len > 0) {
        output.minItems = len - ast.elements.filter((element2) => element2.isOptional).length;
        output.items = elements;
      }
      const restLength = rest.length;
      if (restLength > 0) {
        const head13 = rest[0];
        const isHomogeneous = restLength === 1 && ast.elements.every((e) => e.type === ast.rest[0].type);
        if (isHomogeneous) {
          output.items = head13;
        } else {
          output.additionalItems = head13;
        }
        if (restLength > 1) {
          throw new Error(getJSONSchemaUnsupportedPostRestElementsErrorMessage(path));
        }
      } else {
        if (len > 0) {
          output.additionalItems = false;
        } else {
          output.maxItems = 0;
        }
      }
      return {
        ...output,
        ...getJsonSchemaAnnotations(ast)
      };
    }
    case "TypeLiteral": {
      if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
        return {
          ...constEmpty2,
          ...getJsonSchemaAnnotations(ast)
        };
      }
      const output = {
        type: "object",
        required: [],
        properties: {},
        additionalProperties: getAdditionalProperties(options)
      };
      let patternProperties = void 0;
      let propertyNames = void 0;
      for (const is4 of ast.indexSignatures) {
        const pruned = pruneUndefined2(is4.type) ?? is4.type;
        const parameter = is4.parameter;
        switch (parameter._tag) {
          case "StringKeyword": {
            output.additionalProperties = go3(pruned, $defs, true, path, options);
            break;
          }
          case "TemplateLiteral": {
            patternProperties = go3(pruned, $defs, true, path, options);
            propertyNames = {
              type: "string",
              pattern: getTemplateLiteralRegExp(parameter).source
            };
            break;
          }
          case "Refinement": {
            patternProperties = go3(pruned, $defs, true, path, options);
            propertyNames = go3(parameter, $defs, true, path, options);
            break;
          }
          case "SymbolKeyword": {
            const indexSignaturePath = path.concat("[symbol]");
            output.additionalProperties = go3(pruned, $defs, true, indexSignaturePath, options);
            propertyNames = go3(parameter, $defs, true, indexSignaturePath, options);
            break;
          }
        }
      }
      for (let i = 0; i < ast.propertySignatures.length; i++) {
        const ps = ast.propertySignatures[i];
        const name = ps.name;
        if (isString(name)) {
          const pruned = pruneUndefined2(ps.type);
          const type3 = pruned ?? ps.type;
          output.properties[name] = {
            ...go3(type3, $defs, true, path.concat(ps.name), options),
            ...getJsonSchemaAnnotations(type3, ps)
          };
          if (!ps.isOptional && pruned === void 0) {
            output.required.push(name);
          }
        } else {
          throw new Error(getJSONSchemaUnsupportedKeyErrorMessage(name, path));
        }
      }
      if (patternProperties !== void 0) {
        delete output.additionalProperties;
        output.patternProperties = {
          "": patternProperties
        };
      }
      if (propertyNames !== void 0) {
        output.propertyNames = propertyNames;
      }
      return {
        ...output,
        ...getJsonSchemaAnnotations(ast)
      };
    }
    case "Union": {
      const members = [];
      for (const type3 of ast.types) {
        const jsonSchema = go3(type3, $defs, true, path, options);
        if (!isNeverJSONSchema(jsonSchema)) {
          const last8 = members[members.length - 1];
          if (isMergeableEnum(jsonSchema) && last8 !== void 0 && isMergeableEnum(last8)) {
            members[members.length - 1] = {
              enum: last8.enum.concat(jsonSchema.enum)
            };
          } else {
            members.push(jsonSchema);
          }
        }
      }
      const anyOf = shrink(members);
      const finalize = (anyOf2) => {
        switch (anyOf2.length) {
          case 0:
            return {
              ...constNever,
              ...getJsonSchemaAnnotations(ast)
            };
          case 1: {
            return {
              ...addEnumType(anyOf2[0]),
              ...getJsonSchemaAnnotations(ast)
            };
          }
          default:
            return {
              anyOf: anyOf2.map(addEnumType),
              ...getJsonSchemaAnnotations(ast)
            };
        }
      };
      if (isNullableKeywordSupported(options)) {
        let nullable = false;
        const nonNullables = [];
        for (const s of anyOf) {
          if ("nullable" in s) {
            nullable = true;
            const nn = {
              ...s
            };
            delete nn.nullable;
            nonNullables.push(nn);
          } else if (isMergeableEnum(s)) {
            const nnes = s.enum.filter((e) => e !== null);
            if (nnes.length < s.enum.length) {
              nullable = true;
              if (nnes.length === 0) {
                continue;
              }
              const nn = {
                ...s
              };
              nn.enum = nnes;
              nonNullables.push(nn);
            }
          } else {
            nonNullables.push(s);
          }
        }
        if (nullable) {
          const out = finalize(nonNullables);
          if (!isAnyJSONSchema(out) && !isUnknownJSONSchema(out)) {
            out.nullable = nullable;
          }
          return out;
        }
      }
      return finalize(anyOf);
    }
    case "Enums": {
      const anyOf = ast.enums.map((e) => addEnumType({
        title: e[0],
        enum: [e[1]]
      }));
      return anyOf.length >= 1 ? {
        $comment: "/schemas/enums",
        anyOf,
        ...getJsonSchemaAnnotations(ast)
      } : {
        ...constNever,
        ...getJsonSchemaAnnotations(ast)
      };
    }
    case "Refinement": {
      if (getTransformationFrom(ast) === void 0) {
        throw new Error(getJSONSchemaMissingAnnotationErrorMessage(path, ast));
      }
      return go3(ast.from, $defs, handleIdentifier, path, options);
    }
    case "TemplateLiteral": {
      const regex = getTemplateLiteralRegExp(ast);
      return {
        type: "string",
        title: String(ast),
        description: "a template literal",
        pattern: regex.source,
        ...getJsonSchemaAnnotations(ast)
      };
    }
    case "Suspend": {
      const identifier2 = orElse2(getJSONIdentifier(ast), () => getJSONIdentifier(ast.f()));
      if (isNone2(identifier2)) {
        throw new Error(getJSONSchemaMissingIdentifierAnnotationErrorMessage(path, ast));
      }
      return go3(ast.f(), $defs, handleIdentifier, path, options);
    }
    case "Transformation": {
      if (isParseJsonTransformation(ast.from)) {
        const out = {
          "type": "string",
          "contentMediaType": "application/json"
        };
        if (isContentSchemaSupported(options)) {
          out["contentSchema"] = go3(ast.to, $defs, handleIdentifier, path, options);
        }
        return out;
      }
      let next6 = ast.from;
      if (isTypeLiteralTransformation(ast.transformation)) {
        const identifier2 = getIdentifierAnnotation(ast);
        if (isSome2(identifier2) && isNone2(getIdentifierAnnotation(next6))) {
          next6 = annotations(next6, {
            [IdentifierAnnotationId]: identifier2.value
          });
        }
        const title = getTitleAnnotation(ast);
        if (isSome2(title) && isNone2(getTitleAnnotation(next6))) {
          next6 = annotations(next6, {
            [TitleAnnotationId]: title.value
          });
        }
        const description = getDescriptionAnnotation(ast);
        if (isSome2(description) && isNone2(getDescriptionAnnotation(next6))) {
          next6 = annotations(next6, {
            [DescriptionAnnotationId]: description.value
          });
        }
      }
      return go3(next6, $defs, handleIdentifier, path, options);
    }
  }
};

// ../../node_modules/effect/dist/esm/KeyedPool.js
var KeyedPool_exports = {};
__export(KeyedPool_exports, {
  KeyedPoolTypeId: () => KeyedPoolTypeId2,
  get: () => get22,
  invalidate: () => invalidate3,
  make: () => make87,
  makeWith: () => makeWith6,
  makeWithTTL: () => makeWithTTL3,
  makeWithTTLBy: () => makeWithTTLBy2
});

// ../../node_modules/effect/dist/esm/internal/pool.js
var PoolTypeId = Symbol.for("effect/Pool");
var poolVariance = {
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var isPool = (u) => hasProperty(u, PoolTypeId);
var makeWith4 = (options) => uninterruptibleMask((restore) => flatMap12(context2(), (context15) => {
  const scope6 = get4(context15, scopeTag);
  const acquire4 = mapInputContext(options.acquire, (input) => merge3(context15, input));
  const pool = new PoolImpl(scope6, acquire4, options.concurrency ?? 1, options.min, options.max, options.strategy, Math.min(Math.max(options.targetUtilization ?? 1, 0.1), 1));
  const initialize = tap2(forkDaemon2(restore(pool.resize)), (fiber) => scope6.addFinalizer(() => interruptFiber(fiber)));
  const runStrategy = tap2(forkDaemon2(restore(options.strategy.run(pool))), (fiber) => scope6.addFinalizer(() => interruptFiber(fiber)));
  return succeed(pool).pipe(zipLeft2(scope6.addFinalizer(() => pool.shutdown)), zipLeft2(initialize), zipLeft2(runStrategy));
}));
var make85 = (options) => makeWith4({
  ...options,
  min: options.size,
  max: options.size,
  strategy: strategyNoop()
});
var makeWithTTL = (options) => flatMap12(options.timeToLiveStrategy === "creation" ? strategyCreationTTL(options.timeToLive) : strategyUsageTTL(options.timeToLive), (strategy) => makeWith4({
  ...options,
  strategy
}));
var get20 = (self) => self.get;
var invalidate = dual(2, (self, item) => self.invalidate(item));
var PoolImpl = class extends Class3 {
  scope;
  acquire;
  concurrency;
  minSize;
  maxSize;
  strategy;
  targetUtilization;
  [PoolTypeId];
  isShuttingDown = false;
  semaphore;
  items = /* @__PURE__ */ new Set();
  available = /* @__PURE__ */ new Set();
  availableLatch = unsafeMakeLatch(false);
  invalidated = /* @__PURE__ */ new Set();
  waiters = 0;
  constructor(scope6, acquire4, concurrency, minSize, maxSize, strategy, targetUtilization) {
    super();
    this.scope = scope6;
    this.acquire = acquire4;
    this.concurrency = concurrency;
    this.minSize = minSize;
    this.maxSize = maxSize;
    this.strategy = strategy;
    this.targetUtilization = targetUtilization;
    this[PoolTypeId] = poolVariance;
    this.semaphore = unsafeMakeSemaphore(concurrency * maxSize);
  }
  allocate = acquireUseRelease(scopeMake2(), (scope6) => this.acquire.pipe(scopeExtend(scope6), exit, flatMap12((exit4) => {
    const item = {
      exit: exit4,
      finalizer: catchAllCause(scope6.close(exit4), reportUnhandledError),
      refCount: 0,
      disableReclaim: false
    };
    this.items.add(item);
    this.available.add(item);
    return as3(exit4._tag === "Success" ? this.strategy.onAcquire(item) : zipRight2(item.finalizer, this.strategy.onAcquire(item)), item);
  })), (scope6, exit4) => exit4._tag === "Failure" ? scope6.close(exit4) : void_3);
  get currentUsage() {
    let count9 = this.waiters;
    for (const item of this.items) {
      count9 += item.refCount;
    }
    return count9;
  }
  get targetSize() {
    if (this.isShuttingDown) return 0;
    const utilization = this.currentUsage / this.targetUtilization;
    const target = Math.ceil(utilization / this.concurrency);
    return Math.min(Math.max(this.minSize, target), this.maxSize);
  }
  get activeSize() {
    return this.items.size - this.invalidated.size;
  }
  resizeLoop = suspend(() => {
    if (this.activeSize >= this.targetSize) {
      return void_3;
    }
    const toAcquire = this.targetSize - this.activeSize;
    return this.strategy.reclaim(this).pipe(flatMap12(match2({
      onNone: () => this.allocate,
      onSome: succeed
    })), replicateEffect2(toAcquire, {
      concurrency: toAcquire
    }), zipLeft2(this.availableLatch.open), flatMap12((items) => items.some((_) => _.exit._tag === "Failure") ? void_3 : this.resizeLoop));
  });
  resizeSemaphore = unsafeMakeSemaphore(1);
  resize = this.resizeSemaphore.withPermits(1)(this.resizeLoop);
  getPoolItem = uninterruptibleMask((restore) => restore(this.semaphore.take(1)).pipe(zipRight2(scopeTag), flatMap12((scope6) => suspend(() => {
    this.waiters++;
    if (this.isShuttingDown) {
      return interrupt2;
    } else if (this.targetSize > this.activeSize) {
      const self = this;
      return flatMap12(this.resizeSemaphore.withPermitsIfAvailable(1)(forkIn2(interruptible2(this.resize), this.scope)), function loop5() {
        if (self.isShuttingDown) {
          return interrupt2;
        } else if (self.available.size > 0) {
          return succeed(unsafeHead(self.available));
        }
        self.availableLatch.unsafeClose();
        return flatMap12(self.availableLatch.await, loop5);
      });
    }
    return succeed(unsafeHead(this.available));
  }).pipe(ensuring2(sync(() => this.waiters--)), tap2((item) => {
    if (item.exit._tag === "Failure") {
      this.items.delete(item);
      this.invalidated.delete(item);
      this.available.delete(item);
      return this.semaphore.release(1);
    }
    item.refCount++;
    this.available.delete(item);
    if (item.refCount < this.concurrency) {
      this.available.add(item);
    }
    return scope6.addFinalizer(() => zipRight2(suspend(() => {
      item.refCount--;
      if (this.invalidated.has(item)) {
        return this.invalidatePoolItem(item);
      }
      this.available.add(item);
      return exitVoid;
    }), this.semaphore.release(1)));
  }), onInterrupt(() => this.semaphore.release(1))))));
  commit() {
    return this.get;
  }
  get = flatMap12(suspend(() => this.isShuttingDown ? interrupt2 : this.getPoolItem), (_) => _.exit);
  invalidate(item) {
    return suspend(() => {
      if (this.isShuttingDown) return void_3;
      for (const poolItem of this.items) {
        if (poolItem.exit._tag === "Success" && poolItem.exit.value === item) {
          poolItem.disableReclaim = true;
          return uninterruptible(this.invalidatePoolItem(poolItem));
        }
      }
      return void_3;
    });
  }
  invalidatePoolItem(poolItem) {
    return suspend(() => {
      if (!this.items.has(poolItem)) {
        return void_3;
      } else if (poolItem.refCount === 0) {
        this.items.delete(poolItem);
        this.available.delete(poolItem);
        this.invalidated.delete(poolItem);
        return zipRight2(poolItem.finalizer, forkIn2(interruptible2(this.resize), this.scope));
      }
      this.invalidated.add(poolItem);
      this.available.delete(poolItem);
      return void_3;
    });
  }
  get shutdown() {
    return suspend(() => {
      if (this.isShuttingDown) return void_3;
      this.isShuttingDown = true;
      const size40 = this.items.size;
      const semaphore = unsafeMakeSemaphore(size40);
      return forEachSequentialDiscard(this.items, (item) => {
        if (item.refCount > 0) {
          item.finalizer = zipLeft2(item.finalizer, semaphore.release(1));
          this.invalidated.add(item);
          return semaphore.take(1);
        }
        this.items.delete(item);
        this.available.delete(item);
        this.invalidated.delete(item);
        return item.finalizer;
      }).pipe(zipRight2(this.semaphore.releaseAll), zipRight2(this.availableLatch.open), zipRight2(semaphore.take(size40)));
    });
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var strategyNoop = () => ({
  run: (_) => void_3,
  onAcquire: (_) => void_3,
  reclaim: (_) => succeedNone
});
var strategyCreationTTL = (ttl) => clockWith((clock3) => map14(unbounded2(), (queue) => {
  const ttlMillis = toMillis(ttl);
  const creationTimes = /* @__PURE__ */ new WeakMap();
  return identity({
    run: (pool) => {
      const process2 = (item) => suspend(() => {
        if (!pool.items.has(item) || pool.invalidated.has(item)) {
          return void_3;
        }
        const now3 = clock3.unsafeCurrentTimeMillis();
        const created = creationTimes.get(item);
        const remaining = ttlMillis - (now3 - created);
        return remaining > 0 ? delay(process2(item), remaining) : pool.invalidatePoolItem(item);
      });
      return queue.take.pipe(tap2(process2), forever);
    },
    onAcquire: (item) => suspend(() => {
      creationTimes.set(item, clock3.unsafeCurrentTimeMillis());
      return queue.offer(item);
    }),
    reclaim: (_) => succeedNone
  });
}));
var strategyUsageTTL = (ttl) => map14(unbounded2(), (queue) => {
  return identity({
    run: (pool) => {
      const process2 = suspend(() => {
        const excess = pool.activeSize - pool.targetSize;
        if (excess <= 0) return void_3;
        return queue.take.pipe(tap2((item) => pool.invalidatePoolItem(item)), zipRight2(process2));
      });
      return process2.pipe(delay(ttl), forever);
    },
    onAcquire: (item) => queue.offer(item),
    reclaim(pool) {
      return suspend(() => {
        if (pool.invalidated.size === 0) {
          return succeedNone;
        }
        const item = head(filter2(pool.invalidated, (item2) => !item2.disableReclaim));
        if (item._tag === "None") {
          return succeedNone;
        }
        pool.invalidated.delete(item.value);
        if (item.value.refCount < pool.concurrency) {
          pool.available.add(item.value);
        }
        return as3(queue.offer(item.value), item);
      });
    }
  });
});
var reportUnhandledError = (cause3) => withFiberRuntime((fiber) => {
  const unhandledLogLevel = fiber.getFiberRef(currentUnhandledErrorLogLevel);
  if (unhandledLogLevel._tag === "Some") {
    fiber.log("Unhandled error in pool finalizer", cause3, unhandledLogLevel);
  }
  return void_3;
});

// ../../node_modules/effect/dist/esm/internal/keyedPool.js
var KeyedPoolSymbolKey = "effect/KeyedPool";
var KeyedPoolTypeId = Symbol.for(KeyedPoolSymbolKey);
var KeyedPoolMapValueSymbol = Symbol.for("effect/KeyedPool/MapValue");
var keyedPoolVariance = {
  /* c8 ignore next */
  _K: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var KeyedPoolImpl = class {
  getOrCreatePool;
  activePools;
  [KeyedPoolTypeId] = keyedPoolVariance;
  constructor(getOrCreatePool, activePools) {
    this.getOrCreatePool = getOrCreatePool;
    this.activePools = activePools;
  }
  get(key) {
    return flatMap12(this.getOrCreatePool(key), get20);
  }
  invalidate(item) {
    return flatMap12(this.activePools, forEachSequentialDiscard((pool) => pool.invalidate(item)));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var Complete = class {
  pool;
  _tag = "Complete";
  [KeyedPoolMapValueSymbol] = KeyedPoolMapValueSymbol;
  constructor(pool) {
    this.pool = pool;
  }
  [symbol2]() {
    return pipe(string2("effect/KeyedPool/Complete"), combine2(hash(this.pool)), cached(this));
  }
  [symbol3](u) {
    return isComplete(u) && equals(this.pool, u.pool);
  }
};
var isComplete = (u) => isTagged(u, "Complete") && KeyedPoolMapValueSymbol in u;
var Pending = class {
  deferred;
  _tag = "Pending";
  [KeyedPoolMapValueSymbol] = KeyedPoolMapValueSymbol;
  constructor(deferred) {
    this.deferred = deferred;
  }
  [symbol2]() {
    return pipe(string2("effect/KeyedPool/Pending"), combine2(hash(this.deferred)), cached(this));
  }
  [symbol3](u) {
    return isPending(u) && equals(this.deferred, u.deferred);
  }
};
var isPending = (u) => isTagged(u, "Pending") && KeyedPoolMapValueSymbol in u;
var makeImpl4 = (get48, min11, max13, timeToLive) => pipe(all9([context2(), fiberId, sync(() => make15(empty11())), scopeMake2()]), map14(([context15, fiberId5, map49, scope6]) => {
  const getOrCreatePool = (key) => suspend(() => {
    let value10 = getOrUndefined2(get8(get7(map49), key));
    if (value10 === void 0) {
      return uninterruptibleMask((restore) => {
        const deferred = deferredUnsafeMake(fiberId5);
        value10 = new Pending(deferred);
        let previous2 = void 0;
        if (has5(get7(map49), key)) {
          previous2 = getOrUndefined2(get8(get7(map49), key));
        } else {
          update(map49, set4(key, value10));
        }
        if (previous2 === void 0) {
          return pipe(restore(scopeExtend(makeWithTTL({
            acquire: provideContext(get48(key), context15),
            min: min11(key),
            max: max13(key),
            timeToLive: getOrElse2(timeToLive(key), () => infinity)
          }), scope6)), matchCauseEffect({
            onFailure: (cause3) => {
              const current2 = getOrUndefined2(get8(get7(map49), key));
              if (equals(current2, value10)) {
                update(map49, remove7(key));
              }
              return zipRight2(deferredFailCause(deferred, cause3), failCause(cause3));
            },
            onSuccess: (pool) => {
              update(map49, set4(key, new Complete(pool)));
              return as3(deferredSucceed(deferred, pool), pool);
            }
          }));
        }
        switch (previous2._tag) {
          case "Complete": {
            return succeed(previous2.pool);
          }
          case "Pending": {
            return restore(deferredAwait(previous2.deferred));
          }
        }
      });
    }
    switch (value10._tag) {
      case "Complete": {
        return succeed(value10.pool);
      }
      case "Pending": {
        return deferredAwait(value10.deferred);
      }
    }
  });
  const activePools = suspend(() => forEachSequential(toValues2(get7(map49)), (value10) => {
    switch (value10._tag) {
      case "Complete": {
        return succeed(value10.pool);
      }
      case "Pending": {
        return deferredAwait(value10.deferred);
      }
    }
  }));
  return new KeyedPoolImpl(getOrCreatePool, activePools);
}));
var make86 = (options) => makeImpl4(options.acquire, () => options.size, () => options.size, () => none2());
var makeWith5 = (options) => makeImpl4(options.acquire, options.size, options.size, () => none2());
var makeWithTTL2 = (options) => {
  const timeToLive = decode(options.timeToLive);
  return makeImpl4(options.acquire, options.min, options.max, () => some3(timeToLive));
};
var makeWithTTLBy = (options) => makeImpl4(options.acquire, options.min, options.max, (key) => some3(decode(options.timeToLive(key))));
var get21 = dual(2, (self, key) => self.get(key));
var invalidate2 = dual(2, (self, item) => self.invalidate(item));

// ../../node_modules/effect/dist/esm/KeyedPool.js
var KeyedPoolTypeId2 = KeyedPoolTypeId;
var make87 = make86;
var makeWith6 = makeWith5;
var makeWithTTL3 = makeWithTTL2;
var makeWithTTLBy2 = makeWithTTLBy;
var get22 = get21;
var invalidate3 = invalidate2;

// ../../node_modules/effect/dist/esm/LayerMap.js
var LayerMap_exports = {};
__export(LayerMap_exports, {
  Service: () => Service2,
  TypeId: () => TypeId33,
  fromRecord: () => fromRecord3,
  make: () => make90
});

// ../../node_modules/effect/dist/esm/RcMap.js
var RcMap_exports = {};
__export(RcMap_exports, {
  TypeId: () => TypeId32,
  get: () => get24,
  invalidate: () => invalidate5,
  keys: () => keys8,
  make: () => make89,
  touch: () => touch2
});

// ../../node_modules/effect/dist/esm/internal/rcMap.js
var TypeId31 = Symbol.for("effect/RcMap");
var variance10 = {
  _K: identity,
  _A: identity,
  _E: identity
};
var RcMapImpl = class {
  lookup;
  context;
  scope;
  idleTimeToLive;
  capacity;
  [TypeId31];
  state = {
    _tag: "Open",
    map: empty23()
  };
  semaphore = unsafeMakeSemaphore(1);
  constructor(lookup, context15, scope6, idleTimeToLive, capacity10) {
    this.lookup = lookup;
    this.context = context15;
    this.scope = scope6;
    this.idleTimeToLive = idleTimeToLive;
    this.capacity = capacity10;
    this[TypeId31] = variance10;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make88 = (options) => withFiberRuntime((fiber) => {
  const context15 = fiber.getFiberRef(currentContext);
  const scope6 = get4(context15, scopeTag);
  const self = new RcMapImpl(options.lookup, context15, scope6, options.idleTimeToLive ? decode(options.idleTimeToLive) : void 0, Math.max(options.capacity ?? Number.POSITIVE_INFINITY, 0));
  return as3(scope6.addFinalizer(() => suspend(() => {
    if (self.state._tag === "Closed") {
      return void_3;
    }
    const map49 = self.state.map;
    self.state = {
      _tag: "Closed"
    };
    return forEachSequentialDiscard(map49, ([, entry]) => scopeClose(entry.scope, exitVoid)).pipe(tap2(() => {
      clear(map49);
    }), self.semaphore.withPermits(1));
  })), self);
});
var get23 = dual(2, (self_, key) => {
  const self = self_;
  return uninterruptibleMask((restore) => getImpl(self, key, restore));
});
var getImpl = fnUntraced(function* (self, key, restore) {
  if (self.state._tag === "Closed") {
    return yield* interrupt2;
  }
  const state = self.state;
  const o = get9(state.map, key);
  let entry;
  if (o._tag === "Some") {
    entry = o.value;
    entry.refCount++;
  } else if (Number.isFinite(self.capacity) && size10(self.state.map) >= self.capacity) {
    return yield* fail2(new ExceededCapacityException(`RcMap attempted to exceed capacity of ${self.capacity}`));
  } else {
    entry = yield* self.semaphore.withPermits(1)(acquire(self, key, restore));
  }
  const scope6 = yield* scopeTag;
  yield* scope6.addFinalizer(() => entry.finalizer);
  return yield* restore(deferredAwait(entry.deferred));
});
var acquire = fnUntraced(function* (self, key, restore) {
  const scope6 = yield* scopeMake2();
  const deferred = yield* deferredMake();
  const acquire4 = self.lookup(key);
  const contextMap = new Map(self.context.unsafeMap);
  yield* restore(mapInputContext(acquire4, (inputContext) => {
    inputContext.unsafeMap.forEach((value10, key2) => {
      contextMap.set(key2, value10);
    });
    contextMap.set(scopeTag.key, scope6);
    return unsafeMake(contextMap);
  })).pipe(exit, flatMap12((exit4) => deferredDone(deferred, exit4)), forkIn2(scope6));
  const entry = {
    deferred,
    scope: scope6,
    finalizer: void 0,
    fiber: void 0,
    expiresAt: 0,
    refCount: 1
  };
  entry.finalizer = release(self, key, entry);
  if (self.state._tag === "Open") {
    set5(self.state.map, key, entry);
  }
  return entry;
});
var release = (self, key, entry) => clockWith3((clock3) => {
  entry.refCount--;
  if (entry.refCount > 0) {
    return void_3;
  } else if (self.state._tag === "Closed" || !has6(self.state.map, key) || self.idleTimeToLive === void 0) {
    if (self.state._tag === "Open") {
      remove8(self.state.map, key);
    }
    return scopeClose(entry.scope, exitVoid);
  }
  if (!isFinite(self.idleTimeToLive)) {
    return void_3;
  }
  entry.expiresAt = clock3.unsafeCurrentTimeMillis() + toMillis(self.idleTimeToLive);
  if (entry.fiber) return void_3;
  return interruptibleMask(function loop5(restore) {
    const now3 = clock3.unsafeCurrentTimeMillis();
    const remaining = entry.expiresAt - now3;
    if (remaining <= 0) {
      if (self.state._tag === "Closed" || entry.refCount > 0) return void_3;
      remove8(self.state.map, key);
      return restore(scopeClose(entry.scope, exitVoid));
    }
    return flatMap12(clock3.sleep(millis(remaining)), () => loop5(restore));
  }).pipe(ensuring2(sync(() => {
    entry.fiber = void 0;
  })), forkIn2(self.scope), tap2((fiber) => {
    entry.fiber = fiber;
  }), self.semaphore.withPermits(1));
});
var keys7 = (self) => {
  const impl = self;
  return suspend(() => impl.state._tag === "Closed" ? interrupt2 : succeed(keys4(impl.state.map)));
};
var invalidate4 = dual(2, fnUntraced(function* (self_, key) {
  const self = self_;
  if (self.state._tag === "Closed") return;
  const o = get9(self.state.map, key);
  if (o._tag === "None") return;
  const entry = o.value;
  remove8(self.state.map, key);
  if (entry.refCount > 0) return;
  yield* scopeClose(entry.scope, exitVoid);
  if (entry.fiber) yield* interruptFiber(entry.fiber);
}));
var touch = dual(2, (self_, key) => clockWith3((clock3) => {
  const self = self_;
  if (!self.idleTimeToLive || self.state._tag === "Closed") return void_3;
  const o = get9(self.state.map, key);
  if (o._tag === "None") return void_3;
  o.value.expiresAt = clock3.unsafeCurrentTimeMillis() + toMillis(self.idleTimeToLive);
  return void_3;
}));

// ../../node_modules/effect/dist/esm/RcMap.js
var TypeId32 = TypeId31;
var make89 = make88;
var get24 = get23;
var keys8 = keys7;
var invalidate5 = invalidate4;
var touch2 = touch;

// ../../node_modules/effect/dist/esm/LayerMap.js
var TypeId33 = Symbol.for("effect/LayerMap");
var make90 = fnUntraced2(function* (lookup, options) {
  const context15 = yield* context5();
  const memoMap = context15.unsafeMap.has(CurrentMemoMap2.key) ? get4(context15, CurrentMemoMap2) : yield* makeMemoMap2;
  const rcMap = yield* make89({
    lookup: (key) => scopeWith2((scope6) => diffFiberRefs2(buildWithMemoMap2(lookup(key), memoMap, scope6))).pipe(map26(([patch14, context16]) => ({
      layer: scopedContext2(withFiberRuntime((fiber) => {
        const scope6 = unsafeGet3(fiber.currentContext, Scope);
        const oldRefs = fiber.getFiberRefs();
        const newRefs = patch10(patch14, fiber.id(), oldRefs);
        const revert = diff9(newRefs, oldRefs);
        fiber.setFiberRefs(newRefs);
        return as8(addFinalizerExit(scope6, () => {
          fiber.setFiberRefs(patch10(revert, fiber.id(), fiber.getFiberRefs()));
          return _void;
        }), context16);
      })),
      runtimeEffect: withFiberRuntime2((fiber) => {
        const fiberRefs4 = patch10(patch14, fiber.id(), fiber.getFiberRefs());
        return succeed13(make66({
          context: context16,
          fiberRefs: fiberRefs4,
          runtimeFlags: defaultRuntime2.runtimeFlags
        }));
      })
    }))),
    idleTimeToLive: options?.idleTimeToLive
  });
  return identity({
    [TypeId33]: TypeId33,
    rcMap,
    get: (key) => unwrapScoped2(map26(get24(rcMap, key), ({
      layer
    }) => layer)),
    runtime: (key) => flatMap18(get24(rcMap, key), ({
      runtimeEffect
    }) => runtimeEffect),
    invalidate: (key) => invalidate5(rcMap, key)
  });
});
var fromRecord3 = (layers, options) => make90((key) => layers[key], options);
var Service2 = () => (id3, options) => {
  const Err = globalThis.Error;
  const limit = Err.stackTraceLimit;
  Err.stackTraceLimit = 2;
  const creationError = new Err();
  Err.stackTraceLimit = limit;
  function TagClass() {
  }
  const TagClass_ = TagClass;
  Object.setPrototypeOf(TagClass, Object.getPrototypeOf(GenericTag(id3)));
  TagClass.key = id3;
  Object.defineProperty(TagClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  TagClass_.DefaultWithoutDependencies = scoped5(TagClass_, "lookup" in options ? make90(options.lookup, options) : fromRecord3(options.layers, options));
  TagClass_.Default = options.dependencies && options.dependencies.length > 0 ? provide3(TagClass_.DefaultWithoutDependencies, options.dependencies) : TagClass_.DefaultWithoutDependencies;
  TagClass_.get = (key) => unwrapScoped2(map26(TagClass_, (layerMap) => layerMap.get(key)));
  TagClass_.runtime = (key) => flatMap18(TagClass_, (layerMap) => layerMap.runtime(key));
  TagClass_.invalidate = (key) => flatMap18(TagClass_, (layerMap) => layerMap.invalidate(key));
  return TagClass;
};

// ../../node_modules/effect/dist/esm/Logger.js
var Logger_exports = {};
__export(Logger_exports, {
  LoggerTypeId: () => LoggerTypeId2,
  add: () => add9,
  addEffect: () => addEffect,
  addScoped: () => addScoped,
  batched: () => batched,
  defaultLogger: () => defaultLogger2,
  filterLogLevel: () => filterLogLevel2,
  isLogger: () => isLogger2,
  json: () => json2,
  jsonLogger: () => jsonLogger3,
  logFmt: () => logFmt,
  logfmtLogger: () => logfmtLogger2,
  make: () => make91,
  map: () => map38,
  mapInput: () => mapInput11,
  mapInputOptions: () => mapInputOptions2,
  minimumLogLevel: () => minimumLogLevel2,
  none: () => none11,
  pretty: () => pretty5,
  prettyLogger: () => prettyLogger3,
  prettyLoggerDefault: () => prettyLoggerDefault2,
  remove: () => remove12,
  replace: () => replace6,
  replaceEffect: () => replaceEffect,
  replaceScoped: () => replaceScoped,
  simple: () => simple2,
  stringLogger: () => stringLogger2,
  structured: () => structured,
  structuredLogger: () => structuredLogger3,
  succeed: () => succeed25,
  sync: () => sync18,
  test: () => test2,
  tracerLogger: () => tracerLogger2,
  withConsoleError: () => withConsoleError,
  withConsoleLog: () => withConsoleLog,
  withLeveledConsole: () => withLeveledConsole,
  withMinimumLogLevel: () => withMinimumLogLevel2,
  withSpanAnnotations: () => withSpanAnnotations,
  zip: () => zip20,
  zipLeft: () => zipLeft14,
  zipRight: () => zipRight14
});

// ../../node_modules/effect/dist/esm/internal/logger-circular.js
var test = dual(2, (self, input) => self.log({
  fiberId: none3,
  logLevel: logLevelInfo,
  message: input,
  cause: empty35,
  context: empty26(),
  spans: empty12(),
  annotations: empty11(),
  date: /* @__PURE__ */ new Date()
}));

// ../../node_modules/effect/dist/esm/Logger.js
var LoggerTypeId2 = LoggerTypeId;
var make91 = makeLogger;
var add9 = addLogger;
var addEffect = addLoggerEffect;
var addScoped = addLoggerScoped;
var mapInput11 = mapInput4;
var mapInputOptions2 = mapInputOptions;
var filterLogLevel2 = filterLogLevel;
var map38 = map19;
var batched = batchedLogger;
var withConsoleLog = loggerWithConsoleLog;
var withLeveledConsole = loggerWithLeveledLog;
var withConsoleError = loggerWithConsoleError;
var none11 = none7;
var remove12 = removeLogger;
var replace6 = replaceLogger;
var replaceEffect = replaceLoggerEffect;
var replaceScoped = replaceLoggerScoped;
var simple2 = simple;
var succeed25 = succeed6;
var sync18 = sync4;
var test2 = test;
var withMinimumLogLevel2 = withMinimumLogLevel;
var withSpanAnnotations = loggerWithSpanAnnotations;
var zip20 = zip8;
var zipLeft14 = zipLeft4;
var zipRight14 = zipRight4;
var defaultLogger2 = defaultLogger;
var jsonLogger3 = jsonLogger;
var logfmtLogger2 = logfmtLogger;
var stringLogger2 = stringLogger;
var prettyLogger3 = prettyLogger;
var prettyLoggerDefault2 = prettyLoggerDefault;
var structuredLogger3 = structuredLogger;
var tracerLogger2 = tracerLogger;
var json2 = replace6(defaultLogger, jsonLogger2);
var logFmt = replace6(defaultLogger, logFmtLogger);
var pretty5 = replace6(defaultLogger, prettyLogger2);
var structured = replace6(defaultLogger, structuredLogger2);
var minimumLogLevel2 = minimumLogLevel;
var isLogger2 = isLogger;

// ../../node_modules/effect/dist/esm/Mailbox.js
var Mailbox_exports = {};
__export(Mailbox_exports, {
  ReadonlyTypeId: () => ReadonlyTypeId2,
  TypeId: () => TypeId35,
  fromStream: () => fromStream2,
  into: () => into2,
  isMailbox: () => isMailbox,
  isReadonlyMailbox: () => isReadonlyMailbox,
  make: () => make93,
  toChannel: () => toChannel4,
  toStream: () => toStream3
});

// ../../node_modules/effect/dist/esm/internal/mailbox.js
var TypeId34 = Symbol.for("effect/Mailbox");
var ReadonlyTypeId = Symbol.for("effect/Mailbox/ReadonlyMailbox");
var empty45 = empty7();
var exitEmpty = exitSucceed(empty45);
var exitFalse = exitSucceed(false);
var exitTrue = exitSucceed(true);
var constDone = [empty45, true];
var MailboxImpl = class extends Class3 {
  scheduler;
  capacity;
  strategy;
  [TypeId34] = TypeId34;
  [ReadonlyTypeId] = ReadonlyTypeId;
  state = {
    _tag: "Open",
    takers: /* @__PURE__ */ new Set(),
    offers: /* @__PURE__ */ new Set(),
    awaiters: /* @__PURE__ */ new Set()
  };
  messages = [];
  messagesChunk = empty7();
  constructor(scheduler2, capacity10, strategy) {
    super();
    this.scheduler = scheduler2;
    this.capacity = capacity10;
    this.strategy = strategy;
  }
  offer(message) {
    return suspend(() => {
      if (this.state._tag !== "Open") {
        return exitFalse;
      } else if (this.messages.length + this.messagesChunk.length >= this.capacity) {
        switch (this.strategy) {
          case "dropping":
            return exitFalse;
          case "suspend":
            if (this.capacity <= 0 && this.state.takers.size > 0) {
              this.messages.push(message);
              this.releaseTaker();
              return exitTrue;
            }
            return this.offerRemainingSingle(message);
          case "sliding":
            this.unsafeTake();
            this.messages.push(message);
            return exitTrue;
        }
      }
      this.messages.push(message);
      this.scheduleReleaseTaker();
      return exitTrue;
    });
  }
  unsafeOffer(message) {
    if (this.state._tag !== "Open") {
      return false;
    } else if (this.messages.length + this.messagesChunk.length >= this.capacity) {
      if (this.strategy === "sliding") {
        this.unsafeTake();
        this.messages.push(message);
        return true;
      } else if (this.capacity <= 0 && this.state.takers.size > 0) {
        this.messages.push(message);
        this.releaseTaker();
        return true;
      }
      return false;
    }
    this.messages.push(message);
    this.scheduleReleaseTaker();
    return true;
  }
  offerAll(messages) {
    return suspend(() => {
      if (this.state._tag !== "Open") {
        return succeed(fromIterable3(messages));
      }
      const remaining = this.unsafeOfferAllArray(messages);
      if (remaining.length === 0) {
        return exitEmpty;
      } else if (this.strategy === "dropping") {
        return succeed(unsafeFromArray(remaining));
      }
      return this.offerRemainingArray(remaining);
    });
  }
  unsafeOfferAll(messages) {
    return unsafeFromArray(this.unsafeOfferAllArray(messages));
  }
  unsafeOfferAllArray(messages) {
    if (this.state._tag !== "Open") {
      return fromIterable2(messages);
    } else if (this.capacity === Number.POSITIVE_INFINITY || this.strategy === "sliding") {
      if (this.messages.length > 0) {
        this.messagesChunk = appendAll3(this.messagesChunk, unsafeFromArray(this.messages));
      }
      if (this.strategy === "sliding") {
        this.messagesChunk = this.messagesChunk.pipe(appendAll3(fromIterable3(messages)), takeRight2(this.capacity));
      } else if (isChunk(messages)) {
        this.messagesChunk = appendAll3(this.messagesChunk, messages);
      } else {
        this.messages = fromIterable2(messages);
      }
      this.scheduleReleaseTaker();
      return [];
    }
    const free = this.capacity <= 0 ? this.state.takers.size : this.capacity - this.messages.length - this.messagesChunk.length;
    if (free === 0) {
      return fromIterable2(messages);
    }
    const remaining = [];
    let i = 0;
    for (const message of messages) {
      if (i < free) {
        this.messages.push(message);
      } else {
        remaining.push(message);
      }
      i++;
    }
    this.scheduleReleaseTaker();
    return remaining;
  }
  fail(error4) {
    return this.done(exitFail(error4));
  }
  failCause(cause3) {
    return this.done(exitFailCause(cause3));
  }
  unsafeDone(exit4) {
    if (this.state._tag !== "Open") {
      return false;
    } else if (this.state.offers.size === 0 && this.messages.length === 0 && this.messagesChunk.length === 0) {
      this.finalize(exit4);
      return true;
    }
    this.state = {
      ...this.state,
      _tag: "Closing",
      exit: exit4
    };
    return true;
  }
  shutdown = sync(() => {
    if (this.state._tag === "Done") {
      return true;
    }
    this.messages = [];
    this.messagesChunk = empty45;
    const offers = this.state.offers;
    this.finalize(this.state._tag === "Open" ? exitVoid : this.state.exit);
    if (offers.size > 0) {
      for (const entry of offers) {
        if (entry._tag === "Single") {
          entry.resume(exitFalse);
        } else {
          entry.resume(exitSucceed(unsafeFromArray(entry.remaining.slice(entry.offset))));
        }
      }
      offers.clear();
    }
    return true;
  });
  done(exit4) {
    return sync(() => this.unsafeDone(exit4));
  }
  end = this.done(exitVoid);
  clear = suspend(() => {
    if (this.state._tag === "Done") {
      return exitAs(this.state.exit, empty45);
    }
    const messages = this.unsafeTakeAll();
    this.releaseCapacity();
    return succeed(messages);
  });
  takeAll = suspend(() => {
    if (this.state._tag === "Done") {
      return exitAs(this.state.exit, constDone);
    }
    const messages = this.unsafeTakeAll();
    if (messages.length === 0) {
      return zipRight2(this.awaitTake, this.takeAll);
    }
    return succeed([messages, this.releaseCapacity()]);
  });
  takeN(n) {
    return suspend(() => {
      if (this.state._tag === "Done") {
        return exitAs(this.state.exit, constDone);
      } else if (n <= 0) {
        return succeed([empty45, false]);
      }
      n = Math.min(n, this.capacity);
      let messages;
      if (n <= this.messagesChunk.length) {
        messages = take3(this.messagesChunk, n);
        this.messagesChunk = drop3(this.messagesChunk, n);
      } else if (n <= this.messages.length + this.messagesChunk.length) {
        this.messagesChunk = appendAll3(this.messagesChunk, unsafeFromArray(this.messages));
        this.messages = [];
        messages = take3(this.messagesChunk, n);
        this.messagesChunk = drop3(this.messagesChunk, n);
      } else {
        return zipRight2(this.awaitTake, this.takeN(n));
      }
      return succeed([messages, this.releaseCapacity()]);
    });
  }
  unsafeTake() {
    if (this.state._tag === "Done") {
      return exitZipRight(this.state.exit, exitFail(new NoSuchElementException3()));
    }
    let message;
    if (this.messagesChunk.length > 0) {
      message = unsafeHead2(this.messagesChunk);
      this.messagesChunk = drop3(this.messagesChunk, 1);
    } else if (this.messages.length > 0) {
      message = this.messages[0];
      this.messagesChunk = drop3(unsafeFromArray(this.messages), 1);
      this.messages = [];
    } else if (this.capacity <= 0 && this.state.offers.size > 0) {
      this.capacity = 1;
      this.releaseCapacity();
      this.capacity = 0;
      return this.messages.length > 0 ? exitSucceed(this.messages.pop()) : void 0;
    } else {
      return void 0;
    }
    this.releaseCapacity();
    return exitSucceed(message);
  }
  take = suspend(() => this.unsafeTake() ?? zipRight2(this.awaitTake, this.take));
  await = asyncInterrupt((resume2) => {
    if (this.state._tag === "Done") {
      return resume2(this.state.exit);
    }
    this.state.awaiters.add(resume2);
    return sync(() => {
      if (this.state._tag !== "Done") {
        this.state.awaiters.delete(resume2);
      }
    });
  });
  unsafeSize() {
    const size40 = this.messages.length + this.messagesChunk.length;
    return this.state._tag === "Done" ? none2() : some3(size40);
  }
  size = sync(() => this.unsafeSize());
  commit() {
    return this.takeAll;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "effect/Mailbox",
      state: this.state._tag,
      size: this.unsafeSize().toJSON()
    };
  }
  toString() {
    return format(this);
  }
  [NodeInspectSymbol]() {
    return format(this);
  }
  offerRemainingSingle(message) {
    return asyncInterrupt((resume2) => {
      if (this.state._tag !== "Open") {
        return resume2(exitFalse);
      }
      const entry = {
        _tag: "Single",
        message,
        resume: resume2
      };
      this.state.offers.add(entry);
      return sync(() => {
        if (this.state._tag === "Open") {
          this.state.offers.delete(entry);
        }
      });
    });
  }
  offerRemainingArray(remaining) {
    return asyncInterrupt((resume2) => {
      if (this.state._tag !== "Open") {
        return resume2(exitSucceed(unsafeFromArray(remaining)));
      }
      const entry = {
        _tag: "Array",
        remaining,
        offset: 0,
        resume: resume2
      };
      this.state.offers.add(entry);
      return sync(() => {
        if (this.state._tag === "Open") {
          this.state.offers.delete(entry);
        }
      });
    });
  }
  releaseCapacity() {
    if (this.state._tag === "Done") {
      return this.state.exit._tag === "Success";
    } else if (this.state.offers.size === 0) {
      if (this.state._tag === "Closing" && this.messages.length === 0 && this.messagesChunk.length === 0) {
        this.finalize(this.state.exit);
        return this.state.exit._tag === "Success";
      }
      return false;
    }
    let n = this.capacity - this.messages.length - this.messagesChunk.length;
    for (const entry of this.state.offers) {
      if (n === 0) return false;
      else if (entry._tag === "Single") {
        this.messages.push(entry.message);
        n--;
        entry.resume(exitTrue);
        this.state.offers.delete(entry);
      } else {
        for (; entry.offset < entry.remaining.length; entry.offset++) {
          if (n === 0) return false;
          this.messages.push(entry.remaining[entry.offset]);
          n--;
        }
        entry.resume(exitEmpty);
        this.state.offers.delete(entry);
      }
    }
    return false;
  }
  awaitTake = asyncInterrupt((resume2) => {
    if (this.state._tag === "Done") {
      return resume2(this.state.exit);
    }
    this.state.takers.add(resume2);
    return sync(() => {
      if (this.state._tag !== "Done") {
        this.state.takers.delete(resume2);
      }
    });
  });
  scheduleRunning = false;
  scheduleReleaseTaker() {
    if (this.scheduleRunning) {
      return;
    }
    this.scheduleRunning = true;
    this.scheduler.scheduleTask(this.releaseTaker, 0);
  }
  releaseTaker = () => {
    this.scheduleRunning = false;
    if (this.state._tag === "Done") {
      return;
    } else if (this.state.takers.size === 0) {
      return;
    }
    const taker = unsafeHead(this.state.takers);
    this.state.takers.delete(taker);
    taker(exitVoid);
  };
  unsafeTakeAll() {
    if (this.messagesChunk.length > 0) {
      const messages = this.messages.length > 0 ? appendAll3(this.messagesChunk, unsafeFromArray(this.messages)) : this.messagesChunk;
      this.messagesChunk = empty45;
      this.messages = [];
      return messages;
    } else if (this.messages.length > 0) {
      const messages = unsafeFromArray(this.messages);
      this.messages = [];
      return messages;
    } else if (this.state._tag !== "Done" && this.state.offers.size > 0) {
      this.capacity = 1;
      this.releaseCapacity();
      this.capacity = 0;
      return of3(this.messages.pop());
    }
    return empty45;
  }
  finalize(exit4) {
    if (this.state._tag === "Done") {
      return;
    }
    const openState = this.state;
    this.state = {
      _tag: "Done",
      exit: exit4
    };
    for (const taker of openState.takers) {
      taker(exit4);
    }
    openState.takers.clear();
    for (const awaiter of openState.awaiters) {
      awaiter(exit4);
    }
    openState.awaiters.clear();
  }
};
var make92 = (capacity10) => withFiberRuntime((fiber) => succeed(new MailboxImpl(fiber.currentScheduler, typeof capacity10 === "number" ? capacity10 : capacity10?.capacity ?? Number.POSITIVE_INFINITY, typeof capacity10 === "number" ? "suspend" : capacity10?.strategy ?? "suspend")));
var into = dual(2, (effect4, self) => uninterruptibleMask((restore) => matchCauseEffect(restore(effect4), {
  onFailure: (cause3) => self.failCause(cause3),
  onSuccess: (_) => self.end
})));
var toChannel3 = (self) => {
  const loop5 = flatMap20(self.takeAll, ([messages, done17]) => done17 ? messages.length === 0 ? void_8 : write(messages) : zipRight8(write(messages), loop5));
  return loop5;
};
var toStream2 = (self) => fromChannel2(toChannel3(self));
var fromStream = dual((args2) => isStream(args2[0]), (self, options) => tap2(acquireRelease2(make92(options), (mailbox) => mailbox.shutdown), (mailbox) => {
  const writer = readWithCause({
    onInput: (input) => flatMap20(mailbox.offerAll(input), () => writer),
    onFailure: (cause3) => mailbox.failCause(cause3),
    onDone: () => mailbox.end
  });
  return scopeWith((scope6) => toChannel2(self).pipe(pipeTo(writer), runIn(scope6), forkIn2(scope6)));
}));

// ../../node_modules/effect/dist/esm/Mailbox.js
var TypeId35 = TypeId34;
var ReadonlyTypeId2 = ReadonlyTypeId;
var isMailbox = (u) => hasProperty(u, TypeId35);
var isReadonlyMailbox = (u) => hasProperty(u, ReadonlyTypeId2);
var make93 = make92;
var into2 = into;
var toChannel4 = toChannel3;
var toStream3 = toStream2;
var fromStream2 = fromStream;

// ../../node_modules/effect/dist/esm/ManagedRuntime.js
var ManagedRuntime_exports = {};
__export(ManagedRuntime_exports, {
  TypeId: () => TypeId36,
  isManagedRuntime: () => isManagedRuntime2,
  make: () => make95
});

// ../../node_modules/effect/dist/esm/internal/managedRuntime.js
var isManagedRuntime = (u) => hasProperty(u, TypeId19);
function provide4(managed, effect4) {
  return flatMap12(managed.runtimeEffect, (rt) => withFiberRuntime((fiber) => {
    fiber.setFiberRefs(rt.fiberRefs);
    fiber.currentRuntimeFlags = rt.runtimeFlags;
    return provideContext(effect4, rt.context);
  }));
}
var ManagedRuntimeProto = {
  ...CommitPrototype2,
  [TypeId19]: TypeId19,
  pipe() {
    return pipeArguments(this, arguments);
  },
  commit() {
    return this.runtimeEffect;
  }
};
var make94 = (layer, memoMap) => {
  memoMap = memoMap ?? unsafeMakeMemoMap();
  const scope6 = unsafeRunSyncEffect(scopeMake2());
  let buildFiber;
  const runtimeEffect = withFiberRuntime((fiber) => {
    if (!buildFiber) {
      buildFiber = unsafeForkEffect(tap2(extend3(toRuntimeWithMemoMap(layer, memoMap), scope6), (rt) => {
        self.cachedRuntime = rt;
      }), {
        scope: scope6,
        scheduler: fiber.currentScheduler
      });
    }
    return flatten8(buildFiber.await);
  });
  const self = Object.assign(Object.create(ManagedRuntimeProto), {
    memoMap,
    scope: scope6,
    runtimeEffect,
    cachedRuntime: void 0,
    runtime() {
      return self.cachedRuntime === void 0 ? unsafeRunPromiseEffect(self.runtimeEffect) : Promise.resolve(self.cachedRuntime);
    },
    dispose() {
      return unsafeRunPromiseEffect(self.disposeEffect);
    },
    disposeEffect: suspend(() => {
      ;
      self.runtimeEffect = die2("ManagedRuntime disposed");
      self.cachedRuntime = void 0;
      return close(self.scope, exitVoid);
    }),
    runFork(effect4, options) {
      return self.cachedRuntime === void 0 ? unsafeForkEffect(provide4(self, effect4), options) : unsafeFork3(self.cachedRuntime)(effect4, options);
    },
    runSyncExit(effect4) {
      return self.cachedRuntime === void 0 ? unsafeRunSyncExitEffect(provide4(self, effect4)) : unsafeRunSyncExit(self.cachedRuntime)(effect4);
    },
    runSync(effect4) {
      return self.cachedRuntime === void 0 ? unsafeRunSyncEffect(provide4(self, effect4)) : unsafeRunSync(self.cachedRuntime)(effect4);
    },
    runPromiseExit(effect4, options) {
      return self.cachedRuntime === void 0 ? unsafeRunPromiseExitEffect(provide4(self, effect4), options) : unsafeRunPromiseExit(self.cachedRuntime)(effect4, options);
    },
    runCallback(effect4, options) {
      return self.cachedRuntime === void 0 ? unsafeRunCallback(defaultRuntime)(provide4(self, effect4), options) : unsafeRunCallback(self.cachedRuntime)(effect4, options);
    },
    runPromise(effect4, options) {
      return self.cachedRuntime === void 0 ? unsafeRunPromiseEffect(provide4(self, effect4), options) : unsafeRunPromise(self.cachedRuntime)(effect4, options);
    }
  });
  return self;
};

// ../../node_modules/effect/dist/esm/ManagedRuntime.js
var TypeId36 = TypeId19;
var isManagedRuntime2 = isManagedRuntime;
var make95 = make94;

// ../../node_modules/effect/dist/esm/Match.js
var Match_exports = {};
__export(Match_exports, {
  MatcherTypeId: () => MatcherTypeId,
  SafeRefinementId: () => SafeRefinementId,
  any: () => any2,
  bigint: () => bigint3,
  boolean: () => boolean6,
  date: () => date4,
  defined: () => defined2,
  discriminator: () => discriminator2,
  discriminatorStartsWith: () => discriminatorStartsWith2,
  discriminators: () => discriminators2,
  discriminatorsExhaustive: () => discriminatorsExhaustive2,
  either: () => either11,
  exhaustive: () => exhaustive2,
  instanceOf: () => instanceOf2,
  instanceOfUnsafe: () => instanceOfUnsafe,
  is: () => is3,
  nonEmptyString: () => nonEmptyString4,
  not: () => not4,
  null: () => _null,
  number: () => number6,
  option: () => option9,
  orElse: () => orElse20,
  orElseAbsurd: () => orElseAbsurd2,
  record: () => record3,
  string: () => string7,
  symbol: () => symbol4,
  tag: () => tag2,
  tagStartsWith: () => tagStartsWith2,
  tags: () => tags2,
  tagsExhaustive: () => tagsExhaustive2,
  type: () => type2,
  typeTags: () => typeTags2,
  undefined: () => _undefined,
  value: () => value5,
  valueTags: () => valueTags2,
  when: () => when7,
  whenAnd: () => whenAnd2,
  whenOr: () => whenOr2,
  withReturnType: () => withReturnType2
});

// ../../node_modules/effect/dist/esm/internal/matcher.js
var TypeId37 = Symbol.for("@effect/matcher/Matcher");
var TypeMatcherProto = {
  [TypeId37]: {
    _input: identity,
    _filters: identity,
    _remaining: identity,
    _result: identity,
    _return: identity
  },
  _tag: "TypeMatcher",
  add(_case2) {
    return makeTypeMatcher([...this.cases, _case2]);
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
function makeTypeMatcher(cases) {
  const matcher = Object.create(TypeMatcherProto);
  matcher.cases = cases;
  return matcher;
}
var ValueMatcherProto = {
  [TypeId37]: {
    _input: identity,
    _filters: identity,
    _remaining: identity,
    _result: identity,
    _provided: identity,
    _return: identity
  },
  _tag: "ValueMatcher",
  add(_case2) {
    if (this.value._tag === "Right") {
      return this;
    }
    if (_case2._tag === "When" && _case2.guard(this.provided) === true) {
      return makeValueMatcher(this.provided, right2(_case2.evaluate(this.provided)));
    } else if (_case2._tag === "Not" && _case2.guard(this.provided) === false) {
      return makeValueMatcher(this.provided, right2(_case2.evaluate(this.provided)));
    }
    return this;
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
function makeValueMatcher(provided, value10) {
  const matcher = Object.create(ValueMatcherProto);
  matcher.provided = provided;
  matcher.value = value10;
  return matcher;
}
var makeWhen = (guard, evaluate4) => ({
  _tag: "When",
  guard,
  evaluate: evaluate4
});
var makeNot = (guard, evaluate4) => ({
  _tag: "Not",
  guard,
  evaluate: evaluate4
});
var makePredicate = (pattern2) => {
  if (typeof pattern2 === "function") {
    return pattern2;
  } else if (Array.isArray(pattern2)) {
    const predicates = pattern2.map(makePredicate);
    const len = predicates.length;
    return (u) => {
      if (!Array.isArray(u)) {
        return false;
      }
      for (let i = 0; i < len; i++) {
        if (predicates[i](u[i]) === false) {
          return false;
        }
      }
      return true;
    };
  } else if (pattern2 !== null && typeof pattern2 === "object") {
    const keysAndPredicates = Object.entries(pattern2).map(([k, p]) => [k, makePredicate(p)]);
    const len = keysAndPredicates.length;
    return (u) => {
      if (typeof u !== "object" || u === null) {
        return false;
      }
      for (let i = 0; i < len; i++) {
        const [key, predicate] = keysAndPredicates[i];
        if (!(key in u) || predicate(u[key]) === false) {
          return false;
        }
      }
      return true;
    };
  }
  return (u) => u === pattern2;
};
var makeOrPredicate = (patterns) => {
  const predicates = patterns.map(makePredicate);
  const len = predicates.length;
  return (u) => {
    for (let i = 0; i < len; i++) {
      if (predicates[i](u) === true) {
        return true;
      }
    }
    return false;
  };
};
var makeAndPredicate = (patterns) => {
  const predicates = patterns.map(makePredicate);
  const len = predicates.length;
  return (u) => {
    for (let i = 0; i < len; i++) {
      if (predicates[i](u) === false) {
        return false;
      }
    }
    return true;
  };
};
var type = () => makeTypeMatcher([]);
var value4 = (i) => makeValueMatcher(i, left2(i));
var valueTags = dual(2, (input, fields) => {
  const match43 = tagsExhaustive(fields)(makeTypeMatcher([]));
  return match43(input);
});
var typeTags = () => (fields) => {
  const match43 = tagsExhaustive(fields)(makeTypeMatcher([]));
  return (input) => match43(input);
};
var withReturnType = () => (self) => self;
var when6 = (pattern2, f) => (self) => self.add(makeWhen(makePredicate(pattern2), f));
var whenOr = (...args2) => (self) => {
  const onMatch = args2[args2.length - 1];
  const patterns = args2.slice(0, -1);
  return self.add(makeWhen(makeOrPredicate(patterns), onMatch));
};
var whenAnd = (...args2) => (self) => {
  const onMatch = args2[args2.length - 1];
  const patterns = args2.slice(0, -1);
  return self.add(makeWhen(makeAndPredicate(patterns), onMatch));
};
var discriminator = (field) => (...pattern2) => {
  const f = pattern2[pattern2.length - 1];
  const values15 = pattern2.slice(0, -1);
  const pred = values15.length === 1 ? (_) => _[field] === values15[0] : (_) => values15.includes(_[field]);
  return (self) => self.add(makeWhen(pred, f));
};
var discriminatorStartsWith = (field) => (pattern2, f) => {
  const pred = (_) => typeof _[field] === "string" && _[field].startsWith(pattern2);
  return (self) => self.add(makeWhen(pred, f));
};
var discriminators = (field) => (fields) => {
  const predicate = makeWhen((arg) => arg != null && arg[field] in fields, (data) => fields[data[field]](data));
  return (self) => self.add(predicate);
};
var discriminatorsExhaustive = (field) => (fields) => {
  const addCases = discriminators(field)(fields);
  return (matcher) => exhaustive(addCases(matcher));
};
var tag = discriminator("_tag");
var tagStartsWith = discriminatorStartsWith("_tag");
var tags = discriminators("_tag");
var tagsExhaustive = discriminatorsExhaustive("_tag");
var not3 = (pattern2, f) => (self) => self.add(makeNot(makePredicate(pattern2), f));
var nonEmptyString3 = (u) => typeof u === "string" && u.length > 0;
var is2 = (...literals) => {
  const len = literals.length;
  return (u) => {
    for (let i = 0; i < len; i++) {
      if (u === literals[i]) {
        return true;
      }
    }
    return false;
  };
};
var any = () => true;
var defined = (u) => u !== void 0 && u !== null;
var instanceOf = (constructor) => (u) => u instanceof constructor;
var orElse19 = (f) => (self) => {
  const result = either10(self);
  if (isEither2(result)) {
    return result._tag === "Right" ? result.right : f(result.left);
  }
  return (input) => {
    const a = result(input);
    return a._tag === "Right" ? a.right : f(a.left);
  };
};
var orElseAbsurd = (self) => orElse19(() => {
  throw new Error("effect/Match/orElseAbsurd: absurd");
})(self);
var either10 = (self) => {
  if (self._tag === "ValueMatcher") {
    return self.value;
  }
  const len = self.cases.length;
  if (len === 1) {
    const _case2 = self.cases[0];
    return (input) => {
      if (_case2._tag === "When" && _case2.guard(input) === true) {
        return right2(_case2.evaluate(input));
      } else if (_case2._tag === "Not" && _case2.guard(input) === false) {
        return right2(_case2.evaluate(input));
      }
      return left2(input);
    };
  }
  return (input) => {
    for (let i = 0; i < len; i++) {
      const _case2 = self.cases[i];
      if (_case2._tag === "When" && _case2.guard(input) === true) {
        return right2(_case2.evaluate(input));
      } else if (_case2._tag === "Not" && _case2.guard(input) === false) {
        return right2(_case2.evaluate(input));
      }
    }
    return left2(input);
  };
};
var option8 = (self) => {
  const toEither = either10(self);
  if (isEither2(toEither)) {
    return match(toEither, {
      onLeft: () => none2(),
      onRight: some3
    });
  }
  return (input) => match(toEither(input), {
    onLeft: () => none2(),
    onRight: some3
  });
};
var getExhaustiveAbsurdErrorMessage = "effect/Match/exhaustive: absurd";
var exhaustive = (self) => {
  const toEither = either10(self);
  if (isEither2(toEither)) {
    if (toEither._tag === "Right") {
      return toEither.right;
    }
    throw new Error(getExhaustiveAbsurdErrorMessage);
  }
  return (u) => {
    const result = toEither(u);
    if (result._tag === "Right") {
      return result.right;
    }
    throw new Error(getExhaustiveAbsurdErrorMessage);
  };
};

// ../../node_modules/effect/dist/esm/Match.js
var MatcherTypeId = TypeId37;
var type2 = type;
var value5 = value4;
var valueTags2 = valueTags;
var typeTags2 = typeTags;
var withReturnType2 = withReturnType;
var when7 = when6;
var whenOr2 = whenOr;
var whenAnd2 = whenAnd;
var discriminator2 = discriminator;
var discriminatorStartsWith2 = discriminatorStartsWith;
var discriminators2 = discriminators;
var discriminatorsExhaustive2 = discriminatorsExhaustive;
var tag2 = tag;
var tagStartsWith2 = tagStartsWith;
var tags2 = tags;
var tagsExhaustive2 = tagsExhaustive;
var not4 = not3;
var nonEmptyString4 = nonEmptyString3;
var is3 = is2;
var string7 = isString;
var number6 = isNumber;
var any2 = any;
var defined2 = defined;
var boolean6 = isBoolean;
var _undefined = isUndefined;
var _null = isNull;
var bigint3 = isBigInt;
var symbol4 = isSymbol;
var date4 = isDate;
var record3 = isRecord;
var instanceOf2 = instanceOf;
var instanceOfUnsafe = instanceOf;
var orElse20 = orElse19;
var orElseAbsurd2 = orElseAbsurd;
var either11 = either10;
var option9 = option8;
var exhaustive2 = exhaustive;
var SafeRefinementId = Symbol.for("effect/SafeRefinement");
var Fail2 = Symbol.for("effect/Fail");

// ../../node_modules/effect/dist/esm/MergeState.js
var MergeState_exports = {};
__export(MergeState_exports, {
  BothRunning: () => BothRunning2,
  LeftDone: () => LeftDone2,
  MergeStateTypeId: () => MergeStateTypeId2,
  RightDone: () => RightDone2,
  isBothRunning: () => isBothRunning2,
  isLeftDone: () => isLeftDone2,
  isMergeState: () => isMergeState2,
  isRightDone: () => isRightDone2,
  match: () => match35
});
var MergeStateTypeId2 = MergeStateTypeId;
var BothRunning2 = BothRunning;
var LeftDone2 = LeftDone;
var RightDone2 = RightDone;
var isMergeState2 = isMergeState;
var isBothRunning2 = isBothRunning;
var isLeftDone2 = isLeftDone;
var isRightDone2 = isRightDone;
var match35 = match26;

// ../../node_modules/effect/dist/esm/MergeStrategy.js
var MergeStrategy_exports = {};
__export(MergeStrategy_exports, {
  BackPressure: () => BackPressure3,
  BufferSliding: () => BufferSliding2,
  MergeStrategyTypeId: () => MergeStrategyTypeId2,
  isBackPressure: () => isBackPressure2,
  isBufferSliding: () => isBufferSliding2,
  isMergeStrategy: () => isMergeStrategy2,
  match: () => match36
});
var MergeStrategyTypeId2 = MergeStrategyTypeId;
var BackPressure3 = BackPressure;
var BufferSliding2 = BufferSliding;
var isMergeStrategy2 = isMergeStrategy;
var isBackPressure2 = isBackPressure;
var isBufferSliding2 = isBufferSliding;
var match36 = match27;

// ../../node_modules/effect/dist/esm/Metric.js
var Metric_exports = {};
__export(Metric_exports, {
  MetricTypeId: () => MetricTypeId2,
  counter: () => counter7,
  fiberActive: () => fiberActive2,
  fiberFailures: () => fiberFailures2,
  fiberLifetimes: () => fiberLifetimes2,
  fiberStarted: () => fiberStarted2,
  fiberSuccesses: () => fiberSuccesses2,
  frequency: () => frequency6,
  fromMetricKey: () => fromMetricKey2,
  gauge: () => gauge6,
  globalMetricRegistry: () => globalMetricRegistry2,
  histogram: () => histogram6,
  increment: () => increment5,
  incrementBy: () => incrementBy2,
  make: () => make96,
  map: () => map39,
  mapInput: () => mapInput12,
  mapType: () => mapType2,
  modify: () => modify13,
  set: () => set13,
  snapshot: () => snapshot2,
  succeed: () => succeed26,
  summary: () => summary6,
  summaryTimestamp: () => summaryTimestamp2,
  sync: () => sync19,
  tagged: () => tagged6,
  taggedWithLabels: () => taggedWithLabels3,
  taggedWithLabelsInput: () => taggedWithLabelsInput2,
  timer: () => timer3,
  timerWithBoundaries: () => timerWithBoundaries2,
  trackAll: () => trackAll2,
  trackDefect: () => trackDefect2,
  trackDefectWith: () => trackDefectWith2,
  trackDuration: () => trackDuration2,
  trackDurationWith: () => trackDurationWith2,
  trackError: () => trackError2,
  trackErrorWith: () => trackErrorWith2,
  trackSuccess: () => trackSuccess2,
  trackSuccessWith: () => trackSuccessWith2,
  unsafeSnapshot: () => unsafeSnapshot2,
  update: () => update9,
  value: () => value6,
  withConstantInput: () => withConstantInput2,
  withNow: () => withNow2,
  zip: () => zip21
});
var MetricTypeId2 = MetricTypeId;
var globalMetricRegistry2 = globalMetricRegistry;
var make96 = make44;
var mapInput12 = mapInput5;
var counter7 = counter6;
var frequency6 = frequency5;
var withConstantInput2 = withConstantInput;
var fromMetricKey2 = fromMetricKey;
var gauge6 = gauge5;
var histogram6 = histogram5;
var increment5 = increment4;
var incrementBy2 = incrementBy;
var map39 = map20;
var mapType2 = mapType;
var modify13 = modify9;
var set13 = set8;
var snapshot2 = snapshot;
var succeed26 = succeed7;
var sync19 = sync5;
var summary6 = summary5;
var summaryTimestamp2 = summaryTimestamp;
var tagged6 = tagged2;
var taggedWithLabelsInput2 = taggedWithLabelsInput;
var taggedWithLabels3 = taggedWithLabels2;
var timer3 = timer2;
var timerWithBoundaries2 = timerWithBoundaries;
var trackAll2 = trackAll;
var trackDefect2 = trackDefect;
var trackDefectWith2 = trackDefectWith;
var trackDuration2 = trackDuration;
var trackDurationWith2 = trackDurationWith;
var trackError2 = trackError;
var trackErrorWith2 = trackErrorWith;
var trackSuccess2 = trackSuccess;
var trackSuccessWith2 = trackSuccessWith;
var update9 = update5;
var value6 = value;
var withNow2 = withNow;
var zip21 = zip9;
var unsafeSnapshot2 = unsafeSnapshot;
var fiberStarted2 = fiberStarted;
var fiberSuccesses2 = fiberSuccesses;
var fiberFailures2 = fiberFailures;
var fiberLifetimes2 = fiberLifetimes;
var fiberActive2 = fiberActive;

// ../../node_modules/effect/dist/esm/MetricBoundaries.js
var MetricBoundaries_exports = {};
__export(MetricBoundaries_exports, {
  MetricBoundariesTypeId: () => MetricBoundariesTypeId2,
  exponential: () => exponential4,
  fromIterable: () => fromIterable19,
  isMetricBoundaries: () => isMetricBoundaries2,
  linear: () => linear4
});
var MetricBoundariesTypeId2 = MetricBoundariesTypeId;
var isMetricBoundaries2 = isMetricBoundaries;
var fromIterable19 = fromIterable11;
var linear4 = linear;
var exponential4 = exponential;

// ../../node_modules/effect/dist/esm/MetricHook.js
var MetricHook_exports = {};
__export(MetricHook_exports, {
  MetricHookTypeId: () => MetricHookTypeId2,
  counter: () => counter8,
  frequency: () => frequency7,
  gauge: () => gauge7,
  histogram: () => histogram7,
  make: () => make97,
  onModify: () => onModify2,
  onUpdate: () => onUpdate2,
  summary: () => summary7
});
var MetricHookTypeId2 = MetricHookTypeId;
var make97 = make41;
var counter8 = counter5;
var frequency7 = frequency4;
var gauge7 = gauge4;
var histogram7 = histogram4;
var summary7 = summary4;
var onUpdate2 = onUpdate;
var onModify2 = onModify;

// ../../node_modules/effect/dist/esm/MetricKey.js
var MetricKey_exports = {};
__export(MetricKey_exports, {
  MetricKeyTypeId: () => MetricKeyTypeId2,
  counter: () => counter9,
  frequency: () => frequency8,
  gauge: () => gauge8,
  histogram: () => histogram8,
  isMetricKey: () => isMetricKey2,
  summary: () => summary8,
  tagged: () => tagged7,
  taggedWithLabels: () => taggedWithLabels4
});
var MetricKeyTypeId2 = MetricKeyTypeId;
var isMetricKey2 = isMetricKey;
var counter9 = counter3;
var frequency8 = frequency2;
var gauge8 = gauge2;
var histogram8 = histogram2;
var summary8 = summary2;
var tagged7 = tagged;
var taggedWithLabels4 = taggedWithLabels;

// ../../node_modules/effect/dist/esm/MetricKeyType.js
var MetricKeyType_exports = {};
__export(MetricKeyType_exports, {
  CounterKeyTypeTypeId: () => CounterKeyTypeTypeId2,
  FrequencyKeyTypeTypeId: () => FrequencyKeyTypeTypeId2,
  GaugeKeyTypeTypeId: () => GaugeKeyTypeTypeId2,
  HistogramKeyTypeTypeId: () => HistogramKeyTypeTypeId2,
  MetricKeyTypeTypeId: () => MetricKeyTypeTypeId2,
  SummaryKeyTypeTypeId: () => SummaryKeyTypeTypeId2,
  counter: () => counter10,
  frequency: () => frequency9,
  gauge: () => gauge9,
  histogram: () => histogram9,
  isCounterKey: () => isCounterKey2,
  isFrequencyKey: () => isFrequencyKey2,
  isGaugeKey: () => isGaugeKey2,
  isHistogramKey: () => isHistogramKey2,
  isMetricKeyType: () => isMetricKeyType2,
  isSummaryKey: () => isSummaryKey2,
  summary: () => summary9
});
var MetricKeyTypeTypeId2 = MetricKeyTypeTypeId;
var CounterKeyTypeTypeId2 = CounterKeyTypeTypeId;
var FrequencyKeyTypeTypeId2 = FrequencyKeyTypeTypeId;
var GaugeKeyTypeTypeId2 = GaugeKeyTypeTypeId;
var HistogramKeyTypeTypeId2 = HistogramKeyTypeTypeId;
var SummaryKeyTypeTypeId2 = SummaryKeyTypeTypeId;
var counter10 = counter2;
var frequency9 = frequency;
var gauge9 = gauge;
var histogram9 = histogram;
var summary9 = summary;
var isMetricKeyType2 = isMetricKeyType;
var isCounterKey2 = isCounterKey;
var isFrequencyKey2 = isFrequencyKey;
var isGaugeKey2 = isGaugeKey;
var isHistogramKey2 = isHistogramKey;
var isSummaryKey2 = isSummaryKey;

// ../../node_modules/effect/dist/esm/MetricLabel.js
var MetricLabel_exports = {};
__export(MetricLabel_exports, {
  MetricLabelTypeId: () => MetricLabelTypeId2,
  isMetricLabel: () => isMetricLabel2,
  make: () => make98
});
var MetricLabelTypeId2 = MetricLabelTypeId;
var make98 = make39;
var isMetricLabel2 = isMetricLabel;

// ../../node_modules/effect/dist/esm/MetricPair.js
var MetricPair_exports = {};
__export(MetricPair_exports, {
  MetricPairTypeId: () => MetricPairTypeId2,
  make: () => make99,
  unsafeMake: () => unsafeMake18
});
var MetricPairTypeId2 = MetricPairTypeId;
var make99 = make42;
var unsafeMake18 = unsafeMake10;

// ../../node_modules/effect/dist/esm/MetricPolling.js
var MetricPolling_exports = {};
__export(MetricPolling_exports, {
  MetricPollingTypeId: () => MetricPollingTypeId2,
  collectAll: () => collectAll3,
  launch: () => launch4,
  make: () => make101,
  poll: () => poll10,
  pollAndUpdate: () => pollAndUpdate2,
  retry: () => retry9,
  zip: () => zip23
});

// ../../node_modules/effect/dist/esm/internal/metric/polling.js
var MetricPollingSymbolKey = "effect/MetricPolling";
var MetricPollingTypeId = Symbol.for(MetricPollingSymbolKey);
var make100 = (metric, poll13) => {
  return {
    [MetricPollingTypeId]: MetricPollingTypeId,
    pipe() {
      return pipeArguments(this, arguments);
    },
    metric,
    poll: poll13
  };
};
var collectAll2 = (iterable) => {
  const metrics = Array.from(iterable);
  return {
    [MetricPollingTypeId]: MetricPollingTypeId,
    pipe() {
      return pipeArguments(this, arguments);
    },
    metric: make44(Array.of(void 0), (inputs, extraTags) => {
      for (let i = 0; i < inputs.length; i++) {
        const pollingMetric = metrics[i];
        const input = pipe(inputs, (x) => x[i]);
        pollingMetric.metric.unsafeUpdate(input, extraTags);
      }
    }, (extraTags) => Array.from(metrics.map((pollingMetric) => pollingMetric.metric.unsafeValue(extraTags))), (inputs, extraTags) => {
      for (let i = 0; i < inputs.length; i++) {
        const pollingMetric = metrics[i];
        const input = pipe(inputs, (x) => x[i]);
        pollingMetric.metric.unsafeModify(input, extraTags);
      }
    }),
    poll: forEachSequential(metrics, (metric) => metric.poll)
  };
};
var launch3 = dual(2, (self, schedule4) => pipe(pollAndUpdate(self), zipRight2(value(self.metric)), scheduleForked(schedule4)));
var poll9 = (self) => self.poll;
var pollAndUpdate = (self) => flatMap12(self.poll, (value10) => update5(self.metric, value10));
var retry8 = dual(2, (self, policy) => ({
  [MetricPollingTypeId]: MetricPollingTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  metric: self.metric,
  poll: retry_Effect(self.poll, policy)
}));
var zip22 = dual(2, (self, that) => ({
  [MetricPollingTypeId]: MetricPollingTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  metric: pipe(self.metric, zip9(that.metric)),
  poll: zip5(self.poll, that.poll)
}));

// ../../node_modules/effect/dist/esm/MetricPolling.js
var MetricPollingTypeId2 = MetricPollingTypeId;
var make101 = make100;
var collectAll3 = collectAll2;
var launch4 = launch3;
var poll10 = poll9;
var pollAndUpdate2 = pollAndUpdate;
var retry9 = retry8;
var zip23 = zip22;

// ../../node_modules/effect/dist/esm/MetricRegistry.js
var MetricRegistry_exports = {};
__export(MetricRegistry_exports, {
  MetricRegistryTypeId: () => MetricRegistryTypeId2,
  make: () => make102
});
var MetricRegistryTypeId2 = MetricRegistryTypeId;
var make102 = make43;

// ../../node_modules/effect/dist/esm/MetricState.js
var MetricState_exports = {};
__export(MetricState_exports, {
  CounterStateTypeId: () => CounterStateTypeId2,
  FrequencyStateTypeId: () => FrequencyStateTypeId2,
  GaugeStateTypeId: () => GaugeStateTypeId2,
  HistogramStateTypeId: () => HistogramStateTypeId2,
  MetricStateTypeId: () => MetricStateTypeId2,
  SummaryStateTypeId: () => SummaryStateTypeId2,
  counter: () => counter11,
  frequency: () => frequency10,
  gauge: () => gauge10,
  histogram: () => histogram10,
  isCounterState: () => isCounterState2,
  isFrequencyState: () => isFrequencyState2,
  isGaugeState: () => isGaugeState2,
  isHistogramState: () => isHistogramState2,
  isMetricState: () => isMetricState2,
  isSummaryState: () => isSummaryState2,
  summary: () => summary10
});
var MetricStateTypeId2 = MetricStateTypeId;
var CounterStateTypeId2 = CounterStateTypeId;
var FrequencyStateTypeId2 = FrequencyStateTypeId;
var GaugeStateTypeId2 = GaugeStateTypeId;
var HistogramStateTypeId2 = HistogramStateTypeId;
var SummaryStateTypeId2 = SummaryStateTypeId;
var counter11 = counter4;
var frequency10 = frequency3;
var gauge10 = gauge3;
var histogram10 = histogram3;
var summary10 = summary3;
var isMetricState2 = isMetricState;
var isCounterState2 = isCounterState;
var isFrequencyState2 = isFrequencyState;
var isGaugeState2 = isGaugeState;
var isHistogramState2 = isHistogramState;
var isSummaryState2 = isSummaryState;

// ../../node_modules/effect/dist/esm/ModuleVersion.js
var ModuleVersion_exports = {};
__export(ModuleVersion_exports, {
  getCurrentVersion: () => getCurrentVersion2,
  setCurrentVersion: () => setCurrentVersion2
});
var getCurrentVersion2 = getCurrentVersion;
var setCurrentVersion2 = setCurrentVersion;

// ../../node_modules/effect/dist/esm/MutableHashSet.js
var MutableHashSet_exports = {};
__export(MutableHashSet_exports, {
  add: () => add10,
  clear: () => clear7,
  empty: () => empty46,
  fromIterable: () => fromIterable20,
  has: () => has11,
  make: () => make103,
  remove: () => remove13,
  size: () => size27
});
var TypeId38 = Symbol.for("effect/MutableHashSet");
var MutableHashSetProto = {
  [TypeId38]: TypeId38,
  [Symbol.iterator]() {
    return Array.from(this.keyMap).map(([_]) => _)[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableHashSet",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var fromHashMap = (keyMap) => {
  const set26 = Object.create(MutableHashSetProto);
  set26.keyMap = keyMap;
  return set26;
};
var empty46 = () => fromHashMap(empty23());
var fromIterable20 = (keys15) => fromHashMap(fromIterable9(Array.from(keys15).map((k) => [k, true])));
var make103 = (...keys15) => fromIterable20(keys15);
var add10 = dual(2, (self, key) => (set5(self.keyMap, key, true), self));
var has11 = dual(2, (self, key) => has6(self.keyMap, key));
var remove13 = dual(2, (self, key) => (remove8(self.keyMap, key), self));
var size27 = (self) => size10(self.keyMap);
var clear7 = (self) => (clear(self.keyMap), self);

// ../../node_modules/effect/dist/esm/NonEmptyIterable.js
var NonEmptyIterable_exports = {};
__export(NonEmptyIterable_exports, {
  unprepend: () => unprepend2
});
var unprepend2 = (self) => {
  const iterator = self[Symbol.iterator]();
  const next6 = iterator.next();
  if (next6.done) {
    throw new Error("BUG: NonEmptyIterator should not be empty - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  return [next6.value, iterator];
};

// ../../node_modules/effect/dist/esm/Ordering.js
var Ordering_exports = {};
__export(Ordering_exports, {
  combine: () => combine17,
  combineAll: () => combineAll5,
  combineMany: () => combineMany3,
  match: () => match37,
  reverse: () => reverse5
});
var reverse5 = (o) => o === -1 ? 1 : o === 1 ? -1 : 0;
var match37 = dual(2, (self, {
  onEqual,
  onGreaterThan,
  onLessThan
}) => self === -1 ? onLessThan() : self === 0 ? onEqual() : onGreaterThan());
var combine17 = dual(2, (self, that) => self !== 0 ? self : that);
var combineMany3 = dual(2, (self, collection) => {
  let ordering = self;
  if (ordering !== 0) {
    return ordering;
  }
  for (ordering of collection) {
    if (ordering !== 0) {
      return ordering;
    }
  }
  return ordering;
});
var combineAll5 = (collection) => combineMany3(0, collection);

// ../../node_modules/effect/dist/esm/Pool.js
var Pool_exports = {};
__export(Pool_exports, {
  PoolTypeId: () => PoolTypeId2,
  get: () => get25,
  invalidate: () => invalidate6,
  isPool: () => isPool2,
  make: () => make104,
  makeWithTTL: () => makeWithTTL4
});
var PoolTypeId2 = PoolTypeId;
var isPool2 = isPool;
var make104 = make85;
var makeWithTTL4 = makeWithTTL;
var get25 = get20;
var invalidate6 = invalidate;

// ../../node_modules/effect/dist/esm/Pretty.js
var Pretty_exports = {};
__export(Pretty_exports, {
  make: () => make105,
  match: () => match38
});
var make105 = (schema) => compile(schema.ast, []);
var getPrettyAnnotation = getAnnotation(PrettyAnnotationId);
var getMatcher = (defaultPretty) => (ast) => match2(getPrettyAnnotation(ast), {
  onNone: () => defaultPretty,
  onSome: (handler) => handler()
});
var toString = getMatcher((a) => String(a));
var stringify2 = getMatcher((a) => JSON.stringify(a));
var formatUnknown2 = getMatcher(formatUnknown);
var match38 = {
  "Declaration": (ast, go5, path) => {
    const annotation = getPrettyAnnotation(ast);
    if (isSome2(annotation)) {
      return annotation.value(...ast.typeParameters.map((tp) => go5(tp, path)));
    }
    throw new Error(getPrettyMissingAnnotationErrorMessage(path, ast));
  },
  "VoidKeyword": getMatcher(() => "void(0)"),
  "NeverKeyword": getMatcher(() => {
    throw new Error(getPrettyNeverErrorMessage);
  }),
  "Literal": getMatcher((literal3) => typeof literal3 === "bigint" ? `${String(literal3)}n` : JSON.stringify(literal3)),
  "SymbolKeyword": toString,
  "UniqueSymbol": toString,
  "TemplateLiteral": stringify2,
  "UndefinedKeyword": toString,
  "UnknownKeyword": formatUnknown2,
  "AnyKeyword": formatUnknown2,
  "ObjectKeyword": formatUnknown2,
  "StringKeyword": stringify2,
  "NumberKeyword": toString,
  "BooleanKeyword": toString,
  "BigIntKeyword": getMatcher((a) => `${String(a)}n`),
  "Enums": stringify2,
  "TupleType": (ast, go5, path) => {
    const hook = getPrettyAnnotation(ast);
    if (isSome2(hook)) {
      return hook.value();
    }
    const elements = ast.elements.map((e, i) => go5(e.type, path.concat(i)));
    const rest = ast.rest.map((annotatedAST) => go5(annotatedAST.type, path));
    return (input) => {
      const output = [];
      let i = 0;
      for (; i < elements.length; i++) {
        if (input.length < i + 1) {
          if (ast.elements[i].isOptional) {
            continue;
          }
        } else {
          output.push(elements[i](input[i]));
        }
      }
      if (isNonEmptyReadonlyArray(rest)) {
        const [head13, ...tail5] = rest;
        for (; i < input.length - tail5.length; i++) {
          output.push(head13(input[i]));
        }
        for (let j = 0; j < tail5.length; j++) {
          i += j;
          output.push(tail5[j](input[i]));
        }
      }
      return "[" + output.join(", ") + "]";
    };
  },
  "TypeLiteral": (ast, go5, path) => {
    const hook = getPrettyAnnotation(ast);
    if (isSome2(hook)) {
      return hook.value();
    }
    const propertySignaturesTypes = ast.propertySignatures.map((ps) => go5(ps.type, path.concat(ps.name)));
    const indexSignatureTypes = ast.indexSignatures.map((is4) => go5(is4.type, path));
    const expectedKeys = {};
    for (let i = 0; i < propertySignaturesTypes.length; i++) {
      expectedKeys[ast.propertySignatures[i].name] = null;
    }
    return (input) => {
      const output = [];
      for (let i = 0; i < propertySignaturesTypes.length; i++) {
        const ps = ast.propertySignatures[i];
        const name = ps.name;
        if (ps.isOptional && !Object.prototype.hasOwnProperty.call(input, name)) {
          continue;
        }
        output.push(`${formatPropertyKey(name)}: ${propertySignaturesTypes[i](input[name])}`);
      }
      if (indexSignatureTypes.length > 0) {
        for (let i = 0; i < indexSignatureTypes.length; i++) {
          const type3 = indexSignatureTypes[i];
          const keys15 = getKeysForIndexSignature(input, ast.indexSignatures[i].parameter);
          for (const key of keys15) {
            if (Object.prototype.hasOwnProperty.call(expectedKeys, key)) {
              continue;
            }
            output.push(`${formatPropertyKey(key)}: ${type3(input[key])}`);
          }
        }
      }
      return isNonEmptyReadonlyArray(output) ? "{ " + output.join(", ") + " }" : "{}";
    };
  },
  "Union": (ast, go5, path) => {
    const hook = getPrettyAnnotation(ast);
    if (isSome2(hook)) {
      return hook.value();
    }
    const types = ast.types.map((ast2) => [is({
      ast: ast2
    }), go5(ast2, path)]);
    return (a) => {
      const index = types.findIndex(([is4]) => is4(a));
      if (index === -1) {
        throw new Error(getPrettyNoMatchingSchemaErrorMessage(a, path, ast));
      }
      return types[index][1](a);
    };
  },
  "Suspend": (ast, go5, path) => {
    return match2(getPrettyAnnotation(ast), {
      onNone: () => {
        const get48 = memoizeThunk(() => go5(ast.f(), path));
        return (a) => get48()(a);
      },
      onSome: (handler) => handler()
    });
  },
  "Refinement": (ast, go5, path) => {
    return match2(getPrettyAnnotation(ast), {
      onNone: () => go5(ast.from, path),
      onSome: (handler) => handler()
    });
  },
  "Transformation": (ast, go5, path) => {
    return match2(getPrettyAnnotation(ast), {
      onNone: () => go5(ast.to, path),
      onSome: (handler) => handler()
    });
  }
};
var compile = getCompiler(match38);

// ../../node_modules/effect/dist/esm/PrimaryKey.js
var PrimaryKey_exports = {};
__export(PrimaryKey_exports, {
  symbol: () => symbol5,
  value: () => value7
});
var symbol5 = Symbol.for("effect/PrimaryKey");
var value7 = (self) => self[symbol5]();

// ../../node_modules/effect/dist/esm/RateLimiter.js
var RateLimiter_exports = {};
__export(RateLimiter_exports, {
  make: () => make107,
  withCost: () => withCost2
});

// ../../node_modules/effect/dist/esm/internal/rateLimiter.js
var make106 = ({
  algorithm = "token-bucket",
  interval,
  limit
}) => {
  switch (algorithm) {
    case "fixed-window": {
      return fixedWindow(limit, interval);
    }
    case "token-bucket": {
      return tokenBucket(limit, interval);
    }
  }
};
var tokenBucket = (limit, window2) => gen6(function* () {
  const millisPerToken = Math.ceil(toMillis(window2) / limit);
  const semaphore = yield* makeSemaphore2(limit);
  const latch = yield* makeSemaphore2(0);
  const refill = sleep5(millisPerToken).pipe(zipRight7(latch.releaseAll), zipRight7(semaphore.release(1)), flatMap18((free) => free === limit ? _void : refill));
  yield* pipe(latch.take(1), zipRight7(refill), forever4, forkScoped3, interruptible4);
  const take16 = uninterruptibleMask3((restore) => flatMap18(get14(currentCost), (cost) => zipRight7(restore(semaphore.take(cost)), latch.release(1))));
  return (effect4) => zipRight7(take16, effect4);
});
var fixedWindow = (limit, window2) => gen6(function* () {
  const semaphore = yield* makeSemaphore2(limit);
  const latch = yield* makeSemaphore2(0);
  yield* pipe(latch.take(1), zipRight7(sleep5(window2)), zipRight7(latch.releaseAll), zipRight7(semaphore.releaseAll), forever4, forkScoped3, interruptible4);
  const take16 = uninterruptibleMask3((restore) => flatMap18(get14(currentCost), (cost) => zipRight7(restore(semaphore.take(cost)), latch.release(1))));
  return (effect4) => zipRight7(take16, effect4);
});
var currentCost = globalValue(Symbol.for("effect/RateLimiter/currentCost"), () => unsafeMake12(1));
var withCost = (cost) => locally2(currentCost, cost);

// ../../node_modules/effect/dist/esm/RateLimiter.js
var make107 = make106;
var withCost2 = withCost;

// ../../node_modules/effect/dist/esm/Redacted.js
var Redacted_exports = {};
__export(Redacted_exports, {
  RedactedTypeId: () => RedactedTypeId2,
  getEquivalence: () => getEquivalence9,
  isRedacted: () => isRedacted2,
  make: () => make108,
  unsafeWipe: () => unsafeWipe3,
  value: () => value8
});
var RedactedTypeId2 = RedactedTypeId;
var isRedacted2 = isRedacted;
var make108 = make74;
var value8 = value2;
var unsafeWipe3 = unsafeWipe;
var getEquivalence9 = (isEquivalent) => make((x, y) => isEquivalent(value8(x), value8(y)));

// ../../node_modules/effect/dist/esm/Reloadable.js
var Reloadable_exports = {};
__export(Reloadable_exports, {
  ReloadableTypeId: () => ReloadableTypeId2,
  auto: () => auto2,
  autoFromConfig: () => autoFromConfig2,
  get: () => get28,
  manual: () => manual2,
  reload: () => reload2,
  reloadFork: () => reloadFork2,
  tag: () => tag3
});

// ../../node_modules/effect/dist/esm/internal/scopedRef.js
var ScopedRefSymbolKey = "effect/ScopedRef";
var ScopedRefTypeId = Symbol.for(ScopedRefSymbolKey);
var scopedRefVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var proto14 = {
  ...CommitPrototype,
  commit() {
    return get26(this);
  },
  [ScopedRefTypeId]: scopedRefVariance
};
var close2 = (self) => flatMap12(get12(self.ref), (tuple7) => tuple7[0].close(exitVoid));
var fromAcquire = (acquire4) => uninterruptible(scopeMake2().pipe(flatMap12((newScope) => acquire4.pipe(mapInputContext(add2(scopeTag, newScope)), onError((cause3) => newScope.close(exitFail(cause3))), flatMap12((value10) => makeSynchronized([newScope, value10]).pipe(flatMap12((ref) => {
  const scopedRef = Object.create(proto14);
  scopedRef.ref = ref;
  return pipe(addFinalizer2(() => close2(scopedRef)), as3(scopedRef));
})))))));
var get26 = (self) => map14(get12(self.ref), (tuple7) => tuple7[1]);
var make109 = (evaluate4) => fromAcquire(sync(evaluate4));
var set14 = dual(2, (self, acquire4) => flatten8(modifyEffect(self.ref, ([oldScope, value10]) => uninterruptible(scopeClose(oldScope, exitVoid).pipe(zipRight2(scopeMake2()), flatMap12((newScope) => exit(scopeExtend(acquire4, newScope)).pipe(flatMap12((exit4) => exitMatch(exit4, {
  onFailure: (cause3) => scopeClose(newScope, exitVoid).pipe(as3([failCause(cause3), [oldScope, value10]])),
  onSuccess: (value11) => succeed([void_3, [newScope, value11]])
})))))))));

// ../../node_modules/effect/dist/esm/internal/reloadable.js
var ReloadableSymbolKey = "effect/Reloadable";
var ReloadableTypeId = Symbol.for(ReloadableSymbolKey);
var reloadableVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var auto = (tag5, options) => scoped3(reloadableTag(tag5), pipe(build(manual(tag5, {
  layer: options.layer
})), map14(unsafeGet3(reloadableTag(tag5))), tap2((reloadable) => acquireRelease2(pipe(reloadable.reload, ignoreLogged, schedule_Effect(options.schedule), forkDaemon2), interruptFiber))));
var autoFromConfig = (tag5, options) => scoped3(reloadableTag(tag5), pipe(context2(), flatMap12((env) => pipe(build(auto(tag5, {
  layer: options.layer,
  schedule: options.scheduleFromConfig(env)
})), map14(unsafeGet3(reloadableTag(tag5)))))));
var get27 = (tag5) => flatMap12(reloadableTag(tag5), (reloadable) => get26(reloadable.scopedRef));
var manual = (tag5, options) => scoped3(reloadableTag(tag5), pipe(context2(), flatMap12((env) => pipe(fromAcquire(pipe(build(options.layer), map14(unsafeGet3(tag5)))), map14((ref) => ({
  [ReloadableTypeId]: reloadableVariance,
  scopedRef: ref,
  reload: pipe(set14(ref, pipe(build(options.layer), map14(unsafeGet3(tag5)))), provideContext(env))
}))))));
var reloadableTag = (tag5) => {
  return GenericTag(`effect/Reloadable<${tag5.key}>`);
};
var reload = (tag5) => flatMap12(reloadableTag(tag5), (reloadable) => reloadable.reload);
var reloadFork = (tag5) => flatMap12(reloadableTag(tag5), (reloadable) => pipe(reloadable.reload, ignoreLogged, forkDaemon2, asVoid2));

// ../../node_modules/effect/dist/esm/Reloadable.js
var ReloadableTypeId2 = ReloadableTypeId;
var auto2 = auto;
var autoFromConfig2 = autoFromConfig;
var get28 = get27;
var manual2 = manual;
var reload2 = reload;
var tag3 = reloadableTag;
var reloadFork2 = reloadFork;

// ../../node_modules/effect/dist/esm/RequestBlock.js
var RequestBlock_exports = {};
__export(RequestBlock_exports, {
  empty: () => empty47,
  mapRequestResolvers: () => mapRequestResolvers2,
  parallel: () => parallel5,
  reduce: () => reduce20,
  sequential: () => sequential5,
  single: () => single2
});
var single2 = single;
var empty47 = empty21;
var mapRequestResolvers2 = mapRequestResolvers;
var parallel5 = par;
var reduce20 = reduce10;
var sequential5 = seq;

// ../../node_modules/effect/dist/esm/RequestResolver.js
var RequestResolver_exports = {};
__export(RequestResolver_exports, {
  RequestResolverTypeId: () => RequestResolverTypeId2,
  around: () => around2,
  aroundRequests: () => aroundRequests2,
  batchN: () => batchN2,
  contextFromEffect: () => contextFromEffect,
  contextFromServices: () => contextFromServices,
  eitherWith: () => eitherWith4,
  fromEffect: () => fromEffect12,
  fromEffectTagged: () => fromEffectTagged2,
  fromFunction: () => fromFunction6,
  fromFunctionBatched: () => fromFunctionBatched2,
  isRequestResolver: () => isRequestResolver2,
  locally: () => locally4,
  make: () => make111,
  makeBatched: () => makeBatched3,
  makeWithEntry: () => makeWithEntry2,
  mapInputContext: () => mapInputContext10,
  never: () => never11,
  provideContext: () => provideContext11,
  race: () => race7
});

// ../../node_modules/effect/dist/esm/internal/dataSource.js
var make110 = (runAll) => new RequestResolverImpl((requests) => runAll(requests.map((_) => _.map((_2) => _2.request))));
var makeWithEntry = (runAll) => new RequestResolverImpl((requests) => runAll(requests));
var makeBatched2 = (run10) => new RequestResolverImpl((requests) => {
  if (requests.length > 1) {
    return forEachSequentialDiscard(requests, (block) => {
      const filtered = block.filter((_) => !_.state.completed).map((_) => _.request);
      if (!isNonEmptyArray2(filtered)) {
        return void_3;
      }
      return invokeWithInterrupt(run10(filtered), block);
    });
  } else if (requests.length === 1) {
    const filtered = requests[0].filter((_) => !_.state.completed).map((_) => _.request);
    if (!isNonEmptyArray2(filtered)) {
      return void_3;
    }
    return run10(filtered);
  }
  return void_3;
});
var around = dual(3, (self, before3, after3) => new RequestResolverImpl((requests) => acquireUseRelease(before3, () => self.runAll(requests), after3), make9("Around", self, before3, after3)));
var aroundRequests = dual(3, (self, before3, after3) => new RequestResolverImpl((requests) => {
  const flatRequests = requests.flatMap((chunk7) => chunk7.map((entry) => entry.request));
  return acquireUseRelease(before3(flatRequests), () => self.runAll(requests), (a2) => after3(flatRequests, a2));
}, make9("AroundRequests", self, before3, after3)));
var batchN = dual(2, (self, n) => new RequestResolverImpl((requests) => {
  return n < 1 ? die2(new IllegalArgumentException2("RequestResolver.batchN: n must be at least 1")) : self.runAll(Array.from(map7(reduce3(requests, empty7(), (acc, chunk7) => appendAll3(acc, chunksOf3(unsafeFromArray(chunk7), n))), (chunk7) => Array.from(chunk7))));
}, make9("BatchN", self, n)));
var mapInputContext9 = dual(2, (self, f) => new RequestResolverImpl((requests) => mapInputContext(self.runAll(requests), (context15) => f(context15)), make9("MapInputContext", self, f)));
var eitherWith3 = dual(3, (self, that, f) => new RequestResolverImpl((batch) => forEachSequential(batch, (requests) => {
  const [as18, bs] = pipe(requests, partitionMap3(f));
  return zipWithOptions(self.runAll(Array.of(as18)), that.runAll(Array.of(bs)), () => void 0, {
    concurrent: true
  });
}), make9("EitherWith", self, that, f)));
var fromFunction5 = (f) => makeBatched2((requests) => forEachSequentialDiscard(requests, (request2) => complete2(request2, exitSucceed(f(request2))))).identified("FromFunction", f);
var fromFunctionBatched = (f) => makeBatched2((as18) => forEach16(f(as18), (res, i) => complete2(as18[i], exitSucceed(res)), {
  discard: true
})).identified("FromFunctionBatched", f);
var fromEffect11 = (f) => makeBatched2((requests) => forEach16(requests, (a) => flatMap18(exit3(f(a)), (e) => complete2(a, e)), {
  concurrency: "unbounded",
  discard: true
})).identified("FromEffect", f);
var fromEffectTagged = () => (fns) => makeBatched2((requests) => {
  const grouped3 = {};
  const tags3 = [];
  for (let i = 0, len = requests.length; i < len; i++) {
    if (tags3.includes(requests[i]._tag)) {
      grouped3[requests[i]._tag].push(requests[i]);
    } else {
      grouped3[requests[i]._tag] = [requests[i]];
      tags3.push(requests[i]._tag);
    }
  }
  return forEach16(tags3, (tag5) => matchCauseEffect3(fns[tag5](grouped3[tag5]), {
    onFailure: (cause3) => forEach16(grouped3[tag5], (req) => complete2(req, exitFail(cause3)), {
      discard: true
    }),
    onSuccess: (res) => forEach16(grouped3[tag5], (req, i) => complete2(req, exitSucceed(res[i])), {
      discard: true
    })
  }), {
    concurrency: "unbounded",
    discard: true
  });
}).identified("FromEffectTagged", fns);
var never10 = make110(() => never5).identified("Never");
var provideContext10 = dual(2, (self, context15) => mapInputContext9(self, (_) => context15).identified("ProvideContext", self, context15));
var race6 = dual(2, (self, that) => new RequestResolverImpl((requests) => race3(self.runAll(requests), that.runAll(requests))).identified("Race", self, that));

// ../../node_modules/effect/dist/esm/RequestResolver.js
var RequestResolverTypeId2 = RequestResolverTypeId;
var contextFromEffect = (self) => contextWith2((_) => provideContext11(self, _));
var contextFromServices = (...services) => (self) => contextWith2((_) => provideContext11(self, pick3(...services)(_)));
var isRequestResolver2 = isRequestResolver;
var make111 = make110;
var makeWithEntry2 = makeWithEntry;
var makeBatched3 = makeBatched2;
var around2 = around;
var aroundRequests2 = aroundRequests;
var batchN2 = batchN;
var mapInputContext10 = mapInputContext9;
var eitherWith4 = eitherWith3;
var fromFunction6 = fromFunction5;
var fromFunctionBatched2 = fromFunctionBatched;
var fromEffect12 = fromEffect11;
var fromEffectTagged2 = fromEffectTagged;
var never11 = never10;
var provideContext11 = provideContext10;
var race7 = race6;
var locally4 = resolverLocally;

// ../../node_modules/effect/dist/esm/Resource.js
var Resource_exports = {};
__export(Resource_exports, {
  ResourceTypeId: () => ResourceTypeId2,
  auto: () => auto4,
  get: () => get30,
  manual: () => manual4,
  refresh: () => refresh2
});

// ../../node_modules/effect/dist/esm/internal/resource.js
var ResourceSymbolKey = "effect/Resource";
var ResourceTypeId = Symbol.for(ResourceSymbolKey);
var resourceVariance = {
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var proto15 = {
  ...CommitPrototype,
  commit() {
    return get29(this);
  },
  [ResourceTypeId]: resourceVariance
};
var auto3 = (acquire4, policy) => tap2(manual3(acquire4), (manual5) => acquireRelease2(pipe(refresh(manual5), schedule_Effect(policy), interruptible2, forkDaemon2), interruptFiber));
var manual3 = (acquire4) => flatMap12(context2(), (env) => pipe(fromAcquire(exit(acquire4)), map14((ref) => {
  const resource = Object.create(proto15);
  resource.scopedRef = ref;
  resource.acquire = provideContext(acquire4, env);
  return resource;
})));
var get29 = (self) => flatMap12(get26(self.scopedRef), identity);
var refresh = (self) => set14(self.scopedRef, map14(self.acquire, exitSucceed));

// ../../node_modules/effect/dist/esm/Resource.js
var ResourceTypeId2 = ResourceTypeId;
var auto4 = auto3;
var get30 = get29;
var manual4 = manual3;
var refresh2 = refresh;

// ../../node_modules/effect/dist/esm/RuntimeFlags.js
var RuntimeFlags_exports = {};
__export(RuntimeFlags_exports, {
  CooperativeYielding: () => CooperativeYielding2,
  Interruption: () => Interruption2,
  None: () => None4,
  OpSupervision: () => OpSupervision2,
  RuntimeMetrics: () => RuntimeMetrics2,
  WindDown: () => WindDown2,
  cooperativeYielding: () => cooperativeYielding2,
  diff: () => diff12,
  differ: () => differ3,
  disable: () => disable4,
  disableAll: () => disableAll2,
  disableCooperativeYielding: () => disableCooperativeYielding2,
  disableInterruption: () => disableInterruption2,
  disableOpSupervision: () => disableOpSupervision2,
  disableRuntimeMetrics: () => disableRuntimeMetrics2,
  disableWindDown: () => disableWindDown2,
  enable: () => enable4,
  enableAll: () => enableAll2,
  enableCooperativeYielding: () => enableCooperativeYielding2,
  enableInterruption: () => enableInterruption2,
  enableOpSupervision: () => enableOpSupervision2,
  enableRuntimeMetrics: () => enableRuntimeMetrics2,
  enableWindDown: () => enableWindDown2,
  interruptible: () => interruptible5,
  interruption: () => interruption2,
  isDisabled: () => isDisabled4,
  isEnabled: () => isEnabled4,
  make: () => make112,
  none: () => none12,
  opSupervision: () => opSupervision2,
  patch: () => patch13,
  render: () => render5,
  runtimeMetrics: () => runtimeMetrics2,
  toSet: () => toSet5,
  windDown: () => windDown2
});
var None4 = None2;
var Interruption2 = Interruption;
var OpSupervision2 = OpSupervision;
var RuntimeMetrics2 = RuntimeMetrics;
var WindDown2 = WindDown;
var CooperativeYielding2 = CooperativeYielding;
var cooperativeYielding2 = cooperativeYielding;
var diff12 = diff7;
var differ3 = differ;
var disable4 = disable2;
var disableAll2 = disableAll;
var disableCooperativeYielding2 = disableCooperativeYielding;
var disableInterruption2 = disableInterruption;
var disableOpSupervision2 = disableOpSupervision;
var disableRuntimeMetrics2 = disableRuntimeMetrics;
var disableWindDown2 = disableWindDown;
var enable4 = enable2;
var enableAll2 = enableAll;
var enableCooperativeYielding2 = enableCooperativeYielding;
var enableInterruption2 = enableInterruption;
var enableOpSupervision2 = enableOpSupervision;
var enableRuntimeMetrics2 = enableRuntimeMetrics;
var enableWindDown2 = enableWindDown;
var interruptible5 = interruptible;
var interruption2 = interruption;
var isEnabled4 = isEnabled2;
var isDisabled4 = isDisabled2;
var make112 = make22;
var none12 = none5;
var opSupervision2 = opSupervision;
var patch13 = patch7;
var render5 = render;
var runtimeMetrics2 = runtimeMetrics;
var toSet5 = toSet3;
var windDown2 = windDown;

// ../../node_modules/effect/dist/esm/STM.js
var STM_exports = {};
__export(STM_exports, {
  Do: () => Do8,
  STMTypeId: () => STMTypeId3,
  acquireUseRelease: () => acquireUseRelease7,
  all: () => all15,
  as: () => as15,
  asSome: () => asSome5,
  asSomeError: () => asSomeError4,
  asVoid: () => asVoid11,
  attempt: () => attempt2,
  bind: () => bind10,
  bindTo: () => bindTo10,
  catchAll: () => catchAll10,
  catchSome: () => catchSome5,
  catchTag: () => catchTag6,
  catchTags: () => catchTags5,
  check: () => check5,
  collect: () => collect5,
  collectSTM: () => collectSTM2,
  commit: () => commit3,
  commitEither: () => commitEither2,
  cond: () => cond2,
  context: () => context12,
  contextWith: () => contextWith8,
  contextWithSTM: () => contextWithSTM2,
  die: () => die15,
  dieMessage: () => dieMessage7,
  dieSync: () => dieSync9,
  either: () => either12,
  ensuring: () => ensuring11,
  eventually: () => eventually4,
  every: () => every16,
  exists: () => exists6,
  fail: () => fail24,
  failSync: () => failSync12,
  fiberId: () => fiberId4,
  filter: () => filter21,
  filterNot: () => filterNot2,
  filterOrDie: () => filterOrDie4,
  filterOrDieMessage: () => filterOrDieMessage4,
  filterOrElse: () => filterOrElse4,
  filterOrFail: () => filterOrFail5,
  firstSuccessOf: () => firstSuccessOf3,
  flatMap: () => flatMap26,
  flatten: () => flatten19,
  flip: () => flip7,
  flipWith: () => flipWith4,
  forEach: () => forEach19,
  fromEither: () => fromEither6,
  fromOption: () => fromOption10,
  gen: () => gen8,
  head: () => head10,
  if: () => if_4,
  ignore: () => ignore5,
  interrupt: () => interrupt11,
  interruptAs: () => interruptAs3,
  isFailure: () => isFailure8,
  isSTM: () => isSTM2,
  isSuccess: () => isSuccess7,
  iterate: () => iterate5,
  let: () => let_10,
  loop: () => loop4,
  map: () => map40,
  mapAttempt: () => mapAttempt4,
  mapBoth: () => mapBoth11,
  mapError: () => mapError13,
  mapInputContext: () => mapInputContext11,
  match: () => match39,
  matchSTM: () => matchSTM2,
  merge: () => merge12,
  mergeAll: () => mergeAll11,
  negate: () => negate6,
  none: () => none13,
  option: () => option10,
  orDie: () => orDie10,
  orDieWith: () => orDieWith7,
  orElse: () => orElse21,
  orElseEither: () => orElseEither8,
  orElseFail: () => orElseFail5,
  orElseOptional: () => orElseOptional2,
  orElseSucceed: () => orElseSucceed6,
  orTry: () => orTry2,
  partition: () => partition12,
  provideContext: () => provideContext12,
  provideService: () => provideService12,
  provideServiceSTM: () => provideServiceSTM2,
  provideSomeContext: () => provideSomeContext4,
  reduce: () => reduce21,
  reduceAll: () => reduceAll2,
  reduceRight: () => reduceRight7,
  refineOrDie: () => refineOrDie4,
  refineOrDieWith: () => refineOrDieWith4,
  reject: () => reject2,
  rejectSTM: () => rejectSTM2,
  repeatUntil: () => repeatUntil2,
  repeatWhile: () => repeatWhile2,
  replicate: () => replicate7,
  replicateSTM: () => replicateSTM2,
  replicateSTMDiscard: () => replicateSTMDiscard2,
  retry: () => retry10,
  retryUntil: () => retryUntil2,
  retryWhile: () => retryWhile2,
  some: () => some18,
  succeed: () => succeed27,
  succeedNone: () => succeedNone5,
  succeedSome: () => succeedSome5,
  summarized: () => summarized5,
  suspend: () => suspend14,
  sync: () => sync20,
  tap: () => tap10,
  tapBoth: () => tapBoth5,
  tapError: () => tapError8,
  try: () => try_6,
  unless: () => unless4,
  unlessSTM: () => unlessSTM2,
  unsome: () => unsome3,
  validateAll: () => validateAll4,
  validateFirst: () => validateFirst4,
  void: () => void_13,
  when: () => when8,
  whenSTM: () => whenSTM2,
  zip: () => zip24,
  zipLeft: () => zipLeft15,
  zipRight: () => zipRight15,
  zipWith: () => zipWith20
});
var STMTypeId3 = STMTypeId2;
var isSTM2 = isSTM;
var acquireUseRelease7 = acquireUseRelease5;
var all15 = all12;
var as15 = as12;
var asSome5 = asSome4;
var asSomeError4 = asSomeError3;
var asVoid11 = asVoid9;
var attempt2 = attempt;
var catchAll10 = catchAll7;
var catchSome5 = catchSome3;
var catchTag6 = catchTag4;
var catchTags5 = catchTags3;
var check5 = check4;
var collect5 = collect3;
var collectSTM2 = collectSTM;
var commit3 = commit2;
var commitEither2 = commitEither;
var cond2 = cond;
var context12 = context9;
var contextWith8 = contextWith5;
var contextWithSTM2 = contextWithSTM;
var mapInputContext11 = mapInputContext6;
var die15 = die12;
var dieMessage7 = dieMessage4;
var dieSync9 = dieSync7;
var either12 = either8;
var ensuring11 = ensuring8;
var eventually4 = eventually3;
var every16 = every15;
var exists6 = exists5;
var fail24 = fail17;
var failSync12 = failSync9;
var fiberId4 = fiberId3;
var filter21 = filter17;
var filterNot2 = filterNot;
var filterOrDie4 = filterOrDie3;
var filterOrDieMessage4 = filterOrDieMessage3;
var filterOrElse4 = filterOrElse3;
var filterOrFail5 = filterOrFail4;
var flatMap26 = flatMap22;
var flatten19 = flatten16;
var flip7 = flip6;
var flipWith4 = flipWith3;
var match39 = match31;
var matchSTM2 = matchSTM;
var forEach19 = forEach18;
var fromEither6 = fromEither4;
var fromOption10 = fromOption7;
var gen8 = gen7;
var head10 = head9;
var if_4 = if_3;
var ignore5 = ignore4;
var interrupt11 = interrupt10;
var interruptAs3 = interruptAs2;
var isFailure8 = isFailure6;
var isSuccess7 = isSuccess5;
var iterate5 = iterate3;
var loop4 = loop3;
var map40 = map31;
var mapAttempt4 = mapAttempt;
var mapBoth11 = mapBoth8;
var mapError13 = mapError9;
var merge12 = merge9;
var mergeAll11 = mergeAll8;
var negate6 = negate5;
var none13 = none10;
var option10 = option5;
var orDie10 = orDie7;
var orDieWith7 = orDieWith4;
var orElse21 = orElse12;
var orElseEither8 = orElseEither6;
var orElseFail5 = orElseFail3;
var orElseOptional2 = orElseOptional;
var orElseSucceed6 = orElseSucceed4;
var orTry2 = orTry;
var partition12 = partition10;
var provideContext12 = provideContext7;
var provideSomeContext4 = provideSomeContext2;
var provideService12 = provideService9;
var provideServiceSTM2 = provideServiceSTM;
var reduce21 = reduce19;
var reduceAll2 = reduceAll;
var reduceRight7 = reduceRight6;
var refineOrDie4 = refineOrDie2;
var refineOrDieWith4 = refineOrDieWith2;
var reject2 = reject;
var rejectSTM2 = rejectSTM;
var repeatUntil2 = repeatUntil;
var repeatWhile2 = repeatWhile;
var replicate7 = replicate6;
var replicateSTM2 = replicateSTM;
var replicateSTMDiscard2 = replicateSTMDiscard;
var retry10 = retry6;
var retryUntil2 = retryUntil;
var retryWhile2 = retryWhile;
var some18 = some16;
var succeed27 = succeed19;
var succeedNone5 = succeedNone4;
var succeedSome5 = succeedSome4;
var summarized5 = summarized4;
var suspend14 = suspend9;
var sync20 = sync13;
var tap10 = tap7;
var tapBoth5 = tapBoth3;
var tapError8 = tapError6;
var try_6 = try_5;
var unless4 = unless3;
var unlessSTM2 = unlessSTM;
var unsome3 = unsome;
var void_13 = void_10;
var validateAll4 = validateAll3;
var validateFirst4 = validateFirst3;
var when8 = when4;
var whenSTM2 = whenSTM;
var zip24 = zip15;
var zipLeft15 = zipLeft11;
var zipRight15 = zipRight11;
var zipWith20 = zipWith16;
var firstSuccessOf3 = (effects) => suspend14(() => {
  const list = fromIterable3(effects);
  if (!isNonEmpty2(list)) {
    return dieSync9(() => new IllegalArgumentException2(`Received an empty collection of effects`));
  }
  return reduce4(tailNonEmpty2(list), headNonEmpty2(list), (left3, right3) => orElse21(left3, () => right3));
});
var Do8 = succeed27({});
var bind10 = bind8;
var let_10 = let_8;
var bindTo10 = bindTo8;

// ../../node_modules/effect/dist/esm/Schema.js
var Schema_exports = {};
__export(Schema_exports, {
  Any: () => Any,
  Array: () => Array$,
  ArrayEnsure: () => ArrayEnsure,
  ArrayFormatterIssue: () => ArrayFormatterIssue,
  BetweenBigDecimalSchemaId: () => BetweenBigDecimalSchemaId,
  BetweenBigIntSchemaId: () => BetweenBigIntSchemaId,
  BetweenDateSchemaId: () => BetweenDateSchemaId,
  BetweenDurationSchemaId: () => BetweenDurationSchemaId,
  BetweenSchemaId: () => BetweenSchemaId2,
  BigDecimal: () => BigDecimal,
  BigDecimalFromNumber: () => BigDecimalFromNumber,
  BigDecimalFromSelf: () => BigDecimalFromSelf,
  BigInt: () => BigInt$,
  BigIntFromNumber: () => BigIntFromNumber,
  BigIntFromSelf: () => BigIntFromSelf,
  Boolean: () => Boolean$,
  BooleanFromString: () => BooleanFromString,
  BooleanFromUnknown: () => BooleanFromUnknown,
  BrandSchemaId: () => BrandSchemaId,
  Capitalize: () => Capitalize,
  Capitalized: () => Capitalized,
  CapitalizedSchemaId: () => CapitalizedSchemaId,
  Cause: () => Cause,
  CauseFromSelf: () => CauseFromSelf,
  Char: () => Char,
  Chunk: () => Chunk,
  ChunkFromSelf: () => ChunkFromSelf,
  Class: () => Class7,
  Config: () => Config,
  Data: () => Data,
  DataFromSelf: () => DataFromSelf,
  Date: () => Date$,
  DateFromNumber: () => DateFromNumber,
  DateFromSelf: () => DateFromSelf,
  DateFromSelfSchemaId: () => DateFromSelfSchemaId2,
  DateFromString: () => DateFromString,
  DateTimeUtc: () => DateTimeUtc,
  DateTimeUtcFromDate: () => DateTimeUtcFromDate,
  DateTimeUtcFromNumber: () => DateTimeUtcFromNumber,
  DateTimeUtcFromSelf: () => DateTimeUtcFromSelf,
  DateTimeZoned: () => DateTimeZoned,
  DateTimeZonedFromSelf: () => DateTimeZonedFromSelf,
  Defect: () => Defect,
  Duration: () => Duration,
  DurationFromMillis: () => DurationFromMillis,
  DurationFromNanos: () => DurationFromNanos,
  DurationFromSelf: () => DurationFromSelf,
  Either: () => Either3,
  EitherFromSelf: () => EitherFromSelf,
  EitherFromUnion: () => EitherFromUnion,
  EndsWithSchemaId: () => EndsWithSchemaId,
  Enums: () => Enums2,
  Exit: () => Exit,
  ExitFromSelf: () => ExitFromSelf,
  FiberId: () => FiberId,
  FiberIdFromSelf: () => FiberIdFromSelf,
  Finite: () => Finite,
  FiniteSchemaId: () => FiniteSchemaId2,
  FromPropertySignature: () => FromPropertySignature,
  GreaterThanBigDecimalSchemaId: () => GreaterThanBigDecimalSchemaId,
  GreaterThanBigIntSchemaId: () => GreaterThanBigIntSchemaId,
  GreaterThanDateSchemaId: () => GreaterThanDateSchemaId,
  GreaterThanDurationSchemaId: () => GreaterThanDurationSchemaId,
  GreaterThanOrEqualToBigDecimalSchemaId: () => GreaterThanOrEqualToBigDecimalSchemaId,
  GreaterThanOrEqualToBigIntSchemaId: () => GreaterThanOrEqualToBigIntSchemaId2,
  GreaterThanOrEqualToDateSchemaId: () => GreaterThanOrEqualToDateSchemaId,
  GreaterThanOrEqualToDurationSchemaId: () => GreaterThanOrEqualToDurationSchemaId,
  GreaterThanOrEqualToSchemaId: () => GreaterThanOrEqualToSchemaId2,
  GreaterThanSchemaId: () => GreaterThanSchemaId2,
  HashMap: () => HashMap,
  HashMapFromSelf: () => HashMapFromSelf,
  HashSet: () => HashSet,
  HashSetFromSelf: () => HashSetFromSelf,
  IncludesSchemaId: () => IncludesSchemaId,
  InstanceOfSchemaId: () => InstanceOfSchemaId,
  Int: () => Int,
  IntSchemaId: () => IntSchemaId2,
  ItemsCountSchemaId: () => ItemsCountSchemaId2,
  JsonNumber: () => JsonNumber,
  JsonNumberSchemaId: () => JsonNumberSchemaId2,
  LengthSchemaId: () => LengthSchemaId2,
  LessThanBigDecimalSchemaId: () => LessThanBigDecimalSchemaId,
  LessThanBigIntSchemaId: () => LessThanBigIntSchemaId2,
  LessThanDateSchemaId: () => LessThanDateSchemaId,
  LessThanDurationSchemaId: () => LessThanDurationSchemaId,
  LessThanOrEqualToBigDecimalSchemaId: () => LessThanOrEqualToBigDecimalSchemaId,
  LessThanOrEqualToBigIntSchemaId: () => LessThanOrEqualToBigIntSchemaId2,
  LessThanOrEqualToDateSchemaId: () => LessThanOrEqualToDateSchemaId,
  LessThanOrEqualToDurationSchemaId: () => LessThanOrEqualToDurationSchemaId,
  LessThanOrEqualToSchemaId: () => LessThanOrEqualToSchemaId2,
  LessThanSchemaId: () => LessThanSchemaId2,
  List: () => List,
  ListFromSelf: () => ListFromSelf,
  Literal: () => Literal2,
  Lowercase: () => Lowercase,
  Lowercased: () => Lowercased,
  LowercasedSchemaId: () => LowercasedSchemaId,
  Map: () => map41,
  MapFromRecord: () => MapFromRecord,
  MapFromSelf: () => MapFromSelf,
  MaxItemsSchemaId: () => MaxItemsSchemaId2,
  MaxLengthSchemaId: () => MaxLengthSchemaId2,
  MinItemsSchemaId: () => MinItemsSchemaId2,
  MinLengthSchemaId: () => MinLengthSchemaId2,
  MultipleOfSchemaId: () => MultipleOfSchemaId,
  Negative: () => Negative,
  NegativeBigDecimalFromSelf: () => NegativeBigDecimalFromSelf,
  NegativeBigDecimalSchemaId: () => NegativeBigDecimalSchemaId,
  NegativeBigInt: () => NegativeBigInt,
  NegativeBigIntFromSelf: () => NegativeBigIntFromSelf,
  Never: () => Never,
  NonEmptyArray: () => NonEmptyArray,
  NonEmptyArrayEnsure: () => NonEmptyArrayEnsure,
  NonEmptyChunk: () => NonEmptyChunk,
  NonEmptyChunkFromSelf: () => NonEmptyChunkFromSelf,
  NonEmptyString: () => NonEmptyString,
  NonEmptyTrimmedString: () => NonEmptyTrimmedString,
  NonNaN: () => NonNaN,
  NonNaNSchemaId: () => NonNaNSchemaId2,
  NonNegative: () => NonNegative,
  NonNegativeBigDecimalFromSelf: () => NonNegativeBigDecimalFromSelf,
  NonNegativeBigDecimalSchemaId: () => NonNegativeBigDecimalSchemaId,
  NonNegativeBigInt: () => NonNegativeBigInt,
  NonNegativeBigIntFromSelf: () => NonNegativeBigIntFromSelf,
  NonNegativeInt: () => NonNegativeInt,
  NonPositive: () => NonPositive,
  NonPositiveBigDecimalFromSelf: () => NonPositiveBigDecimalFromSelf,
  NonPositiveBigDecimalSchemaId: () => NonPositiveBigDecimalSchemaId,
  NonPositiveBigInt: () => NonPositiveBigInt,
  NonPositiveBigIntFromSelf: () => NonPositiveBigIntFromSelf,
  Not: () => Not,
  Null: () => Null,
  NullOr: () => NullOr,
  NullishOr: () => NullishOr,
  Number: () => Number$,
  NumberFromString: () => NumberFromString,
  Object: () => Object$,
  Option: () => Option,
  OptionFromNonEmptyTrimmedString: () => OptionFromNonEmptyTrimmedString,
  OptionFromNullOr: () => OptionFromNullOr,
  OptionFromNullishOr: () => OptionFromNullishOr,
  OptionFromSelf: () => OptionFromSelf,
  OptionFromUndefinedOr: () => OptionFromUndefinedOr,
  PatternSchemaId: () => PatternSchemaId,
  Positive: () => Positive,
  PositiveBigDecimalFromSelf: () => PositiveBigDecimalFromSelf,
  PositiveBigDecimalSchemaId: () => PositiveBigDecimalSchemaId,
  PositiveBigInt: () => PositiveBigInt,
  PositiveBigIntFromSelf: () => PositiveBigIntFromSelf,
  PropertyKey: () => PropertyKey$,
  PropertySignatureDeclaration: () => PropertySignatureDeclaration,
  PropertySignatureTransformation: () => PropertySignatureTransformation2,
  PropertySignatureTypeId: () => PropertySignatureTypeId,
  ReadonlyMap: () => ReadonlyMap,
  ReadonlyMapFromRecord: () => ReadonlyMapFromRecord,
  ReadonlyMapFromSelf: () => ReadonlyMapFromSelf,
  ReadonlySet: () => ReadonlySet,
  ReadonlySetFromSelf: () => ReadonlySetFromSelf,
  Record: () => Record,
  Redacted: () => Redacted,
  RedactedFromSelf: () => RedactedFromSelf,
  RefineSchemaId: () => RefineSchemaId,
  Set: () => set15,
  SetFromSelf: () => SetFromSelf,
  SortedSet: () => SortedSet,
  SortedSetFromSelf: () => SortedSetFromSelf,
  StartsWithSchemaId: () => StartsWithSchemaId,
  String: () => String$,
  StringFromBase64: () => StringFromBase64,
  StringFromBase64Url: () => StringFromBase64Url,
  StringFromHex: () => StringFromHex,
  StringFromUriComponent: () => StringFromUriComponent,
  Struct: () => Struct,
  Symbol: () => Symbol$,
  SymbolFromSelf: () => SymbolFromSelf,
  TaggedClass: () => TaggedClass4,
  TaggedError: () => TaggedError3,
  TaggedRequest: () => TaggedRequest,
  TaggedStruct: () => TaggedStruct,
  TemplateLiteral: () => TemplateLiteral2,
  TemplateLiteralParser: () => TemplateLiteralParser,
  TimeZone: () => TimeZone,
  TimeZoneFromSelf: () => TimeZoneFromSelf,
  TimeZoneNamed: () => TimeZoneNamed,
  TimeZoneNamedFromSelf: () => TimeZoneNamedFromSelf,
  TimeZoneOffset: () => TimeZoneOffset,
  TimeZoneOffsetFromSelf: () => TimeZoneOffsetFromSelf,
  ToPropertySignature: () => ToPropertySignature,
  Trim: () => Trim,
  Trimmed: () => Trimmed,
  TrimmedSchemaId: () => TrimmedSchemaId,
  Tuple: () => Tuple,
  TypeId: () => TypeId39,
  ULID: () => ULID,
  ULIDSchemaId: () => ULIDSchemaId,
  URL: () => URL$,
  URLFromSelf: () => URLFromSelf,
  UUID: () => UUID,
  UUIDSchemaId: () => UUIDSchemaId,
  Uint8: () => Uint8,
  Uint8Array: () => Uint8Array$,
  Uint8ArrayFromBase64: () => Uint8ArrayFromBase64,
  Uint8ArrayFromBase64Url: () => Uint8ArrayFromBase64Url,
  Uint8ArrayFromHex: () => Uint8ArrayFromHex,
  Uint8ArrayFromSelf: () => Uint8ArrayFromSelf,
  Uncapitalize: () => Uncapitalize,
  Uncapitalized: () => Uncapitalized,
  UncapitalizedSchemaId: () => UncapitalizedSchemaId,
  Undefined: () => Undefined,
  UndefinedOr: () => UndefinedOr,
  Union: () => Union2,
  UniqueSymbolFromSelf: () => UniqueSymbolFromSelf,
  Unknown: () => Unknown,
  Uppercase: () => Uppercase,
  Uppercased: () => Uppercased,
  UppercasedSchemaId: () => UppercasedSchemaId,
  ValidDateFromSelf: () => ValidDateFromSelf,
  ValidDateSchemaId: () => ValidDateSchemaId,
  Void: () => Void,
  annotations: () => annotations2,
  asSchema: () => asSchema,
  asSerializable: () => asSerializable,
  asSerializableWithResult: () => asSerializableWithResult,
  asWithResult: () => asWithResult,
  asserts: () => asserts,
  attachPropertySignature: () => attachPropertySignature,
  between: () => between8,
  betweenBigDecimal: () => betweenBigDecimal,
  betweenBigInt: () => betweenBigInt,
  betweenDate: () => betweenDate,
  betweenDuration: () => betweenDuration,
  brand: () => brand,
  capitalized: () => capitalized,
  clamp: () => clamp9,
  clampBigDecimal: () => clampBigDecimal,
  clampBigInt: () => clampBigInt,
  clampDuration: () => clampDuration,
  compose: () => compose6,
  declare: () => declare,
  decode: () => decode6,
  decodeEither: () => decodeEither2,
  decodeOption: () => decodeOption,
  decodePromise: () => decodePromise2,
  decodeSync: () => decodeSync,
  decodeUnknown: () => decodeUnknown3,
  decodeUnknownEither: () => decodeUnknownEither2,
  decodeUnknownOption: () => decodeUnknownOption,
  decodeUnknownPromise: () => decodeUnknownPromise2,
  decodeUnknownSync: () => decodeUnknownSync,
  deserialize: () => deserialize,
  deserializeExit: () => deserializeExit,
  deserializeFailure: () => deserializeFailure,
  deserializeSuccess: () => deserializeSuccess,
  element: () => element,
  encode: () => encode5,
  encodeEither: () => encodeEither2,
  encodeOption: () => encodeOption,
  encodePromise: () => encodePromise2,
  encodeSync: () => encodeSync,
  encodeUnknown: () => encodeUnknown2,
  encodeUnknownEither: () => encodeUnknownEither2,
  encodeUnknownOption: () => encodeUnknownOption,
  encodeUnknownPromise: () => encodeUnknownPromise2,
  encodeUnknownSync: () => encodeUnknownSync,
  encodedBoundSchema: () => encodedBoundSchema,
  encodedSchema: () => encodedSchema,
  endsWith: () => endsWith2,
  equivalence: () => equivalence2,
  exitSchema: () => exitSchema,
  extend: () => extend4,
  failureSchema: () => failureSchema,
  filter: () => filter22,
  filterEffect: () => filterEffect2,
  finite: () => finite,
  format: () => format7,
  fromBrand: () => fromBrand,
  fromKey: () => fromKey,
  getClassTag: () => getClassTag,
  getNumberIndexedAccess: () => getNumberIndexedAccess2,
  greaterThan: () => greaterThan11,
  greaterThanBigDecimal: () => greaterThanBigDecimal,
  greaterThanBigInt: () => greaterThanBigInt,
  greaterThanDate: () => greaterThanDate,
  greaterThanDuration: () => greaterThanDuration,
  greaterThanOrEqualTo: () => greaterThanOrEqualTo8,
  greaterThanOrEqualToBigDecimal: () => greaterThanOrEqualToBigDecimal,
  greaterThanOrEqualToBigInt: () => greaterThanOrEqualToBigInt,
  greaterThanOrEqualToDate: () => greaterThanOrEqualToDate,
  greaterThanOrEqualToDuration: () => greaterThanOrEqualToDuration,
  head: () => head11,
  headNonEmpty: () => headNonEmpty3,
  headOrElse: () => headOrElse,
  includes: () => includes3,
  instanceOf: () => instanceOf3,
  int: () => int,
  is: () => is,
  isPropertySignature: () => isPropertySignature,
  isSchema: () => isSchema,
  itemsCount: () => itemsCount,
  keyof: () => keyof2,
  length: () => length5,
  lessThan: () => lessThan15,
  lessThanBigDecimal: () => lessThanBigDecimal,
  lessThanBigInt: () => lessThanBigInt,
  lessThanDate: () => lessThanDate,
  lessThanDuration: () => lessThanDuration,
  lessThanOrEqualTo: () => lessThanOrEqualTo8,
  lessThanOrEqualToBigDecimal: () => lessThanOrEqualToBigDecimal,
  lessThanOrEqualToBigInt: () => lessThanOrEqualToBigInt,
  lessThanOrEqualToDate: () => lessThanOrEqualToDate,
  lessThanOrEqualToDuration: () => lessThanOrEqualToDuration,
  lowercased: () => lowercased,
  make: () => make113,
  makePropertySignature: () => makePropertySignature,
  maxItems: () => maxItems,
  maxLength: () => maxLength,
  minItems: () => minItems,
  minLength: () => minLength,
  multipleOf: () => multipleOf,
  mutable: () => mutable2,
  negative: () => negative,
  negativeBigDecimal: () => negativeBigDecimal,
  negativeBigInt: () => negativeBigInt,
  nonEmptyString: () => nonEmptyString5,
  nonNaN: () => nonNaN,
  nonNegative: () => nonNegative,
  nonNegativeBigDecimal: () => nonNegativeBigDecimal,
  nonNegativeBigInt: () => nonNegativeBigInt,
  nonPositive: () => nonPositive,
  nonPositiveBigDecimal: () => nonPositiveBigDecimal,
  nonPositiveBigInt: () => nonPositiveBigInt,
  omit: () => omit5,
  optional: () => optional,
  optionalElement: () => optionalElement,
  optionalToOptional: () => optionalToOptional,
  optionalToRequired: () => optionalToRequired,
  optionalWith: () => optionalWith,
  parseJson: () => parseJson,
  parseNumber: () => parseNumber,
  partial: () => partial2,
  partialWith: () => partialWith,
  pattern: () => pattern,
  pick: () => pick5,
  pickLiteral: () => pickLiteral,
  pluck: () => pluck,
  positive: () => positive,
  positiveBigDecimal: () => positiveBigDecimal,
  positiveBigInt: () => positiveBigInt,
  propertySignature: () => propertySignature,
  rename: () => rename2,
  required: () => required2,
  requiredToOptional: () => requiredToOptional,
  serializableSchema: () => serializableSchema,
  serialize: () => serialize,
  serializeExit: () => serializeExit,
  serializeFailure: () => serializeFailure,
  serializeSuccess: () => serializeSuccess,
  split: () => split5,
  standardSchemaV1: () => standardSchemaV1,
  startsWith: () => startsWith2,
  successSchema: () => successSchema,
  suspend: () => suspend15,
  symbolSerializable: () => symbolSerializable,
  symbolWithResult: () => symbolWithResult,
  tag: () => tag4,
  transform: () => transform3,
  transformLiteral: () => transformLiteral,
  transformLiterals: () => transformLiterals,
  transformOrFail: () => transformOrFail,
  trimmed: () => trimmed,
  typeSchema: () => typeSchema,
  uncapitalized: () => uncapitalized,
  uppercased: () => uppercased,
  validDate: () => validDate,
  validate: () => validate6,
  validateEither: () => validateEither2,
  validateOption: () => validateOption,
  validatePromise: () => validatePromise2,
  validateSync: () => validateSync,
  withConstructorDefault: () => withConstructorDefault,
  withDecodingDefault: () => withDecodingDefault,
  withDefaults: () => withDefaults
});

// ../../node_modules/effect/dist/esm/Struct.js
var Struct_exports = {};
__export(Struct_exports, {
  entries: () => entries3,
  evolve: () => evolve,
  get: () => get31,
  getEquivalence: () => getEquivalence10,
  getOrder: () => getOrder6,
  keys: () => keys9,
  omit: () => omit4,
  pick: () => pick4
});
var pick4 = dual((args2) => isObject(args2[0]), (s, ...keys15) => {
  const out = {};
  for (const k of keys15) {
    if (k in s) {
      out[k] = s[k];
    }
  }
  return out;
});
var omit4 = dual((args2) => isObject(args2[0]), (s, ...keys15) => {
  const out = {
    ...s
  };
  for (const k of keys15) {
    delete out[k];
  }
  return out;
});
var getEquivalence10 = struct;
var getOrder6 = struct3;
var evolve = dual(2, (obj, t) => {
  const out = {
    ...obj
  };
  for (const k in t) {
    if (Object.prototype.hasOwnProperty.call(obj, k)) {
      out[k] = t[k](obj[k]);
    }
  }
  return out;
});
var get31 = (key) => (s) => s[key];
var keys9 = (o) => Object.keys(o);
var entries3 = (obj) => Object.entries(obj);

// ../../node_modules/effect/dist/esm/Schema.js
var TypeId39 = Symbol.for("effect/Schema");
function make113(ast) {
  return class SchemaClass {
    [TypeId39] = variance11;
    static ast = ast;
    static annotations(annotations4) {
      return make113(mergeSchemaAnnotations(this.ast, annotations4));
    }
    static pipe() {
      return pipeArguments(this, arguments);
    }
    static toString() {
      return String(ast);
    }
    static Type;
    static Encoded;
    static Context;
    static [TypeId39] = variance11;
  };
}
var variance11 = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _I: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var makeStandardResult = (exit4) => isSuccess(exit4) ? exit4.value : makeStandardFailureResult(pretty3(exit4.cause));
var makeStandardFailureResult = (message) => ({
  issues: [{
    message
  }]
});
var makeStandardFailureFromParseIssue = (issue) => map26(ArrayFormatter.formatIssue(issue), (issues) => ({
  issues: issues.map((issue2) => ({
    path: issue2.path,
    message: issue2.message
  }))
}));
var standardSchemaV1 = (schema, overrideOptions) => {
  const decodeUnknown4 = decodeUnknown2(schema, {
    errors: "all"
  });
  return class StandardSchemaV1Class extends make113(schema.ast) {
    static "~standard" = {
      version: 1,
      vendor: "effect",
      validate(value10) {
        const scheduler2 = new SyncScheduler();
        const fiber = runFork2(matchEffect4(decodeUnknown4(value10, overrideOptions), {
          onFailure: makeStandardFailureFromParseIssue,
          onSuccess: (value11) => succeed13({
            value: value11
          })
        }), {
          scheduler: scheduler2
        });
        scheduler2.flush();
        const exit4 = fiber.unsafePoll();
        if (exit4) {
          return makeStandardResult(exit4);
        }
        return new Promise((resolve) => {
          fiber.addObserver((exit5) => {
            resolve(makeStandardResult(exit5));
          });
        });
      }
    };
  };
};
var builtInAnnotations = {
  schemaId: SchemaIdAnnotationId,
  message: MessageAnnotationId,
  missingMessage: MissingMessageAnnotationId,
  identifier: IdentifierAnnotationId,
  title: TitleAnnotationId,
  description: DescriptionAnnotationId,
  examples: ExamplesAnnotationId,
  default: DefaultAnnotationId,
  documentation: DocumentationAnnotationId,
  jsonSchema: JSONSchemaAnnotationId,
  arbitrary: ArbitraryAnnotationId,
  pretty: PrettyAnnotationId,
  equivalence: EquivalenceAnnotationId,
  concurrency: ConcurrencyAnnotationId,
  batching: BatchingAnnotationId,
  parseIssueTitle: ParseIssueTitleAnnotationId,
  parseOptions: ParseOptionsAnnotationId,
  decodingFallback: DecodingFallbackAnnotationId
};
var toASTAnnotations = (annotations4) => {
  if (!annotations4) {
    return {};
  }
  const out = {
    ...annotations4
  };
  for (const key in builtInAnnotations) {
    if (key in annotations4) {
      const id3 = builtInAnnotations[key];
      out[id3] = annotations4[key];
      delete out[key];
    }
  }
  return out;
};
var mergeSchemaAnnotations = (ast, annotations4) => annotations(ast, toASTAnnotations(annotations4));
function asSchema(schema) {
  return schema;
}
var format7 = (schema) => String(schema.ast);
var encodedSchema = (schema) => make113(encodedAST(schema.ast));
var encodedBoundSchema = (schema) => make113(encodedBoundAST(schema.ast));
var typeSchema = (schema) => make113(typeAST(schema.ast));
var encodeUnknown2 = (schema, options) => {
  const encodeUnknown3 = encodeUnknown(schema, options);
  return (u, overrideOptions) => mapError12(encodeUnknown3(u, overrideOptions), parseError);
};
var encodeUnknownEither2 = (schema, options) => {
  const encodeUnknownEither3 = encodeUnknownEither(schema, options);
  return (u, overrideOptions) => mapLeft(encodeUnknownEither3(u, overrideOptions), parseError);
};
var encodeUnknownPromise2 = (schema, options) => {
  const parser = encodeUnknown2(schema, options);
  return (u, overrideOptions) => runPromise2(parser(u, overrideOptions));
};
var encode5 = encodeUnknown2;
var encodeEither2 = encodeUnknownEither2;
var encodePromise2 = encodeUnknownPromise2;
var decodeUnknown3 = (schema, options) => {
  const decodeUnknown4 = decodeUnknown2(schema, options);
  return (u, overrideOptions) => mapError12(decodeUnknown4(u, overrideOptions), parseError);
};
var decodeUnknownEither2 = (schema, options) => {
  const decodeUnknownEither3 = decodeUnknownEither(schema, options);
  return (u, overrideOptions) => mapLeft(decodeUnknownEither3(u, overrideOptions), parseError);
};
var decodeUnknownPromise2 = (schema, options) => {
  const parser = decodeUnknown3(schema, options);
  return (u, overrideOptions) => runPromise2(parser(u, overrideOptions));
};
var decode6 = decodeUnknown3;
var decodeEither2 = decodeUnknownEither2;
var decodePromise2 = decodeUnknownPromise2;
var validate6 = (schema, options) => {
  const validate7 = validate5(schema, options);
  return (u, overrideOptions) => mapError12(validate7(u, overrideOptions), parseError);
};
var validateEither2 = (schema, options) => {
  const validateEither3 = validateEither(schema, options);
  return (u, overrideOptions) => mapLeft(validateEither3(u, overrideOptions), parseError);
};
var validatePromise2 = (schema, options) => {
  const parser = validate6(schema, options);
  return (u, overrideOptions) => runPromise2(parser(u, overrideOptions));
};
var isSchema = (u) => hasProperty(u, TypeId39) && isObject(u[TypeId39]);
function getDefaultLiteralAST(literals) {
  return isMembers(literals) ? Union.make(mapMembers(literals, (literal3) => new Literal(literal3))) : new Literal(literals[0]);
}
function makeLiteralClass(literals, ast = getDefaultLiteralAST(literals)) {
  return class LiteralClass extends make113(ast) {
    static annotations(annotations4) {
      return makeLiteralClass(this.literals, mergeSchemaAnnotations(this.ast, annotations4));
    }
    static literals = [...literals];
  };
}
function Literal2(...literals) {
  return isNonEmptyReadonlyArray(literals) ? makeLiteralClass(literals) : Never;
}
var pickLiteral = (...literals) => (_schema) => Literal2(...literals);
var UniqueSymbolFromSelf = (symbol6) => make113(new UniqueSymbol(symbol6));
var getDefaultEnumsAST = (enums) => new Enums(Object.keys(enums).filter((key) => typeof enums[enums[key]] !== "number").map((key) => [key, enums[key]]));
var makeEnumsClass = (enums, ast = getDefaultEnumsAST(enums)) => class EnumsClass extends make113(ast) {
  static annotations(annotations4) {
    return makeEnumsClass(this.enums, mergeSchemaAnnotations(this.ast, annotations4));
  }
  static enums = {
    ...enums
  };
};
var Enums2 = (enums) => makeEnumsClass(enums);
var TemplateLiteral2 = (...[head13, ...tail5]) => {
  const spans = [];
  let h2 = "";
  let ts = tail5;
  if (isSchema(head13)) {
    if (isLiteral(head13.ast)) {
      h2 = String(head13.ast.literal);
    } else {
      ts = [head13, ...ts];
    }
  } else {
    h2 = String(head13);
  }
  for (let i = 0; i < ts.length; i++) {
    const item = ts[i];
    if (isSchema(item)) {
      if (i < ts.length - 1) {
        const next6 = ts[i + 1];
        if (isSchema(next6)) {
          if (isLiteral(next6.ast)) {
            spans.push(new TemplateLiteralSpan(item.ast, String(next6.ast.literal)));
            i++;
            continue;
          }
        } else {
          spans.push(new TemplateLiteralSpan(item.ast, String(next6)));
          i++;
          continue;
        }
      }
      spans.push(new TemplateLiteralSpan(item.ast, ""));
    } else {
      spans.push(new TemplateLiteralSpan(new Literal(item), ""));
    }
  }
  if (isNonEmptyArray2(spans)) {
    return make113(new TemplateLiteral(h2, spans));
  } else {
    return make113(new TemplateLiteral("", [new TemplateLiteralSpan(new Literal(h2), "")]));
  }
};
function getTemplateLiteralParserCoercedElement(encoded, schema) {
  const ast = encoded.ast;
  switch (ast._tag) {
    case "Literal": {
      const literal3 = ast.literal;
      if (!isString(literal3)) {
        const s = String(literal3);
        return transform3(Literal2(s), schema, {
          strict: true,
          decode: () => literal3,
          encode: () => s
        });
      }
      break;
    }
    case "NumberKeyword":
      return compose6(NumberFromString, schema);
    case "Union": {
      const members = [];
      let hasCoercions = false;
      for (const member of ast.types) {
        const schema2 = make113(member);
        const encoded2 = encodedSchema(schema2);
        const coerced = getTemplateLiteralParserCoercedElement(encoded2, schema2);
        if (coerced) {
          hasCoercions = true;
        }
        members.push(coerced ?? schema2);
      }
      return hasCoercions ? compose6(Union2(...members), schema) : schema;
    }
  }
}
var TemplateLiteralParser = (...params) => {
  const encodedSchemas = [];
  const elements = [];
  const schemas = [];
  let coerced = false;
  for (let i = 0; i < params.length; i++) {
    const param = params[i];
    const schema = isSchema(param) ? param : Literal2(param);
    schemas.push(schema);
    const encoded = encodedSchema(schema);
    encodedSchemas.push(encoded);
    const element2 = getTemplateLiteralParserCoercedElement(encoded, schema);
    if (element2) {
      elements.push(element2);
      coerced = true;
    } else {
      elements.push(schema);
    }
  }
  const from = TemplateLiteral2(...encodedSchemas);
  const re = getTemplateLiteralCapturingRegExp(from.ast);
  let to = Tuple(...elements);
  if (coerced) {
    to = to.annotations({
      [AutoTitleAnnotationId]: format7(Tuple(...schemas))
    });
  }
  return class TemplateLiteralParserClass extends transformOrFail(from, to, {
    strict: false,
    decode: (i, _, ast) => {
      const match43 = re.exec(i);
      return match43 ? succeed24(match43.slice(1, params.length + 1)) : fail23(new Type2(ast, i, `${re.source}: no match for ${JSON.stringify(i)}`));
    },
    encode: (tuple7) => succeed24(tuple7.join(""))
  }) {
    static params = params.slice();
  };
};
var declareConstructor = (typeParameters, options, annotations4) => makeDeclareClass(typeParameters, new Declaration(typeParameters.map((tp) => tp.ast), (...typeParameters2) => options.decode(...typeParameters2.map(make113)), (...typeParameters2) => options.encode(...typeParameters2.map(make113)), toASTAnnotations(annotations4)));
var declarePrimitive = (is4, annotations4) => {
  const decodeUnknown4 = () => (input, _, ast) => is4(input) ? succeed24(input) : fail23(new Type2(ast, input));
  const encodeUnknown3 = decodeUnknown4;
  return makeDeclareClass([], new Declaration([], decodeUnknown4, encodeUnknown3, toASTAnnotations(annotations4)));
};
function makeDeclareClass(typeParameters, ast) {
  return class DeclareClass extends make113(ast) {
    static annotations(annotations4) {
      return makeDeclareClass(this.typeParameters, mergeSchemaAnnotations(this.ast, annotations4));
    }
    static typeParameters = [...typeParameters];
  };
}
var declare = function() {
  if (Array.isArray(arguments[0])) {
    const typeParameters = arguments[0];
    const options = arguments[1];
    const annotations5 = arguments[2];
    return declareConstructor(typeParameters, options, annotations5);
  }
  const is4 = arguments[0];
  const annotations4 = arguments[1];
  return declarePrimitive(is4, annotations4);
};
var BrandSchemaId = Symbol.for("effect/SchemaId/Brand");
var fromBrand = (constructor, annotations4) => (self) => {
  const out = makeBrandClass(self, new Refinement(self.ast, function predicate(a, _, ast) {
    const either14 = constructor.either(a);
    return isLeft2(either14) ? some3(new Type2(ast, a, either14.left.map((v) => v.message).join(", "))) : none2();
  }, toASTAnnotations({
    schemaId: BrandSchemaId,
    [BrandSchemaId]: {
      constructor
    },
    ...annotations4
  })));
  return out;
};
var InstanceOfSchemaId = Symbol.for("effect/SchemaId/InstanceOf");
var instanceOf3 = (constructor, annotations4) => declare((u) => u instanceof constructor, {
  title: constructor.name,
  description: `an instance of ${constructor.name}`,
  pretty: () => String,
  schemaId: InstanceOfSchemaId,
  [InstanceOfSchemaId]: {
    constructor
  },
  ...annotations4
});
var Undefined = class extends make113(undefinedKeyword) {
};
var Void = class extends make113(voidKeyword) {
};
var Null = class extends make113($null) {
};
var Never = class extends make113(neverKeyword) {
};
var Unknown = class extends make113(unknownKeyword) {
};
var Any = class extends make113(anyKeyword) {
};
var BigIntFromSelf = class extends make113(bigIntKeyword) {
};
var SymbolFromSelf = class extends make113(symbolKeyword) {
};
var String$ = class extends make113(stringKeyword) {
};
var Number$ = class extends make113(numberKeyword) {
};
var Boolean$ = class extends make113(booleanKeyword) {
};
var Object$ = class extends make113(objectKeyword) {
};
var getDefaultUnionAST = (members) => Union.make(members.map((m) => m.ast));
function makeUnionClass(members, ast = getDefaultUnionAST(members)) {
  return class UnionClass extends make113(ast) {
    static annotations(annotations4) {
      return makeUnionClass(this.members, mergeSchemaAnnotations(this.ast, annotations4));
    }
    static members = [...members];
  };
}
function Union2(...members) {
  return isMembers(members) ? makeUnionClass(members) : isNonEmptyReadonlyArray(members) ? members[0] : Never;
}
var NullOr = (self) => Union2(self, Null);
var UndefinedOr = (self) => Union2(self, Undefined);
var NullishOr = (self) => Union2(self, Null, Undefined);
var keyof2 = (self) => make113(keyof(self.ast));
var element = (self) => new ElementImpl(new OptionalType(self.ast, false), self);
var optionalElement = (self) => new ElementImpl(new OptionalType(self.ast, true), self);
var ElementImpl = class _ElementImpl {
  ast;
  from;
  [TypeId39];
  _Token;
  constructor(ast, from) {
    this.ast = ast;
    this.from = from;
  }
  annotations(annotations4) {
    return new _ElementImpl(new OptionalType(this.ast.type, this.ast.isOptional, {
      ...this.ast.annotations,
      ...toASTAnnotations(annotations4)
    }), this.from);
  }
  toString() {
    return `${this.ast.type}${this.ast.isOptional ? "?" : ""}`;
  }
};
var getDefaultTupleTypeAST = (elements, rest) => new TupleType(elements.map((el) => isSchema(el) ? new OptionalType(el.ast, false) : el.ast), rest.map((el) => isSchema(el) ? new Type(el.ast) : el.ast), true);
function makeTupleTypeClass(elements, rest, ast = getDefaultTupleTypeAST(elements, rest)) {
  return class TupleTypeClass extends make113(ast) {
    static annotations(annotations4) {
      return makeTupleTypeClass(this.elements, this.rest, mergeSchemaAnnotations(this.ast, annotations4));
    }
    static elements = [...elements];
    static rest = [...rest];
  };
}
function Tuple(...args2) {
  return Array.isArray(args2[0]) ? makeTupleTypeClass(args2[0], args2.slice(1)) : makeTupleTypeClass(args2, []);
}
function makeArrayClass(value10, ast) {
  return class ArrayClass extends makeTupleTypeClass([], [value10], ast) {
    static annotations(annotations4) {
      return makeArrayClass(this.value, mergeSchemaAnnotations(this.ast, annotations4));
    }
    static value = value10;
  };
}
var Array$ = (value10) => makeArrayClass(value10);
function makeNonEmptyArrayClass(value10, ast) {
  return class NonEmptyArrayClass extends makeTupleTypeClass([value10], [value10], ast) {
    static annotations(annotations4) {
      return makeNonEmptyArrayClass(this.value, mergeSchemaAnnotations(this.ast, annotations4));
    }
    static value = value10;
  };
}
var NonEmptyArray = (value10) => makeNonEmptyArrayClass(value10);
function ArrayEnsure(value10) {
  return transform3(Union2(value10, Array$(value10)), Array$(typeSchema(asSchema(value10))), {
    strict: true,
    decode: (i) => ensure(i),
    encode: (a) => a.length === 1 ? a[0] : a
  });
}
function NonEmptyArrayEnsure(value10) {
  return transform3(Union2(value10, NonEmptyArray(value10)), NonEmptyArray(typeSchema(asSchema(value10))), {
    strict: true,
    decode: (i) => isNonEmptyReadonlyArray(i) ? i : of2(i),
    encode: (a) => a.length === 1 ? a[0] : a
  });
}
var formatPropertySignatureToken = (isOptional) => isOptional ? '"?:"' : '":"';
var PropertySignatureDeclaration = class extends OptionalType {
  isReadonly;
  defaultValue;
  /**
   * @since 3.10.0
   */
  _tag = "PropertySignatureDeclaration";
  constructor(type3, isOptional, isReadonly, annotations4, defaultValue) {
    super(type3, isOptional, annotations4);
    this.isReadonly = isReadonly;
    this.defaultValue = defaultValue;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    const token = formatPropertySignatureToken(this.isOptional);
    const type3 = String(this.type);
    return `PropertySignature<${token}, ${type3}, never, ${token}, ${type3}>`;
  }
};
var FromPropertySignature = class extends OptionalType {
  isReadonly;
  fromKey;
  constructor(type3, isOptional, isReadonly, annotations4, fromKey2) {
    super(type3, isOptional, annotations4);
    this.isReadonly = isReadonly;
    this.fromKey = fromKey2;
  }
};
var ToPropertySignature = class extends OptionalType {
  isReadonly;
  defaultValue;
  constructor(type3, isOptional, isReadonly, annotations4, defaultValue) {
    super(type3, isOptional, annotations4);
    this.isReadonly = isReadonly;
    this.defaultValue = defaultValue;
  }
};
var formatPropertyKey2 = (p) => {
  if (p === void 0) {
    return "never";
  }
  if (isString(p)) {
    return JSON.stringify(p);
  }
  return String(p);
};
var PropertySignatureTransformation2 = class {
  from;
  to;
  decode;
  encode;
  /**
   * @since 3.10.0
   */
  _tag = "PropertySignatureTransformation";
  constructor(from, to, decode7, encode6) {
    this.from = from;
    this.to = to;
    this.decode = decode7;
    this.encode = encode6;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return `PropertySignature<${formatPropertySignatureToken(this.to.isOptional)}, ${this.to.type}, ${formatPropertyKey2(this.from.fromKey)}, ${formatPropertySignatureToken(this.from.isOptional)}, ${this.from.type}>`;
  }
};
var mergeSignatureAnnotations = (ast, annotations4) => {
  switch (ast._tag) {
    case "PropertySignatureDeclaration": {
      return new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, {
        ...ast.annotations,
        ...annotations4
      }, ast.defaultValue);
    }
    case "PropertySignatureTransformation": {
      return new PropertySignatureTransformation2(ast.from, new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, {
        ...ast.to.annotations,
        ...annotations4
      }, ast.to.defaultValue), ast.decode, ast.encode);
    }
  }
};
var PropertySignatureTypeId = Symbol.for("effect/PropertySignature");
var isPropertySignature = (u) => hasProperty(u, PropertySignatureTypeId);
var PropertySignatureImpl = class _PropertySignatureImpl {
  ast;
  [TypeId39];
  [PropertySignatureTypeId] = null;
  _TypeToken;
  _Key;
  _EncodedToken;
  _HasDefault;
  constructor(ast) {
    this.ast = ast;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  annotations(annotations4) {
    return new _PropertySignatureImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations4)));
  }
  toString() {
    return String(this.ast);
  }
};
var makePropertySignature = (ast) => new PropertySignatureImpl(ast);
var PropertySignatureWithFromImpl = class _PropertySignatureWithFromImpl extends PropertySignatureImpl {
  from;
  constructor(ast, from) {
    super(ast);
    this.from = from;
  }
  annotations(annotations4) {
    return new _PropertySignatureWithFromImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations4)), this.from);
  }
};
var propertySignature = (self) => new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(self.ast, false, true, {}, void 0), self);
var withConstructorDefault = dual(2, (self, defaultValue) => {
  const ast = self.ast;
  switch (ast._tag) {
    case "PropertySignatureDeclaration":
      return makePropertySignature(new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, ast.annotations, defaultValue));
    case "PropertySignatureTransformation":
      return makePropertySignature(new PropertySignatureTransformation2(ast.from, new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, ast.to.annotations, defaultValue), ast.decode, ast.encode));
  }
});
var applyDefaultValue = (o, defaultValue) => match2(o, {
  onNone: () => some3(defaultValue()),
  onSome: (value10) => some3(value10 === void 0 ? defaultValue() : value10)
});
var pruneUndefined3 = (ast) => pruneUndefined(ast, pruneUndefined3, (ast2) => {
  const pruned = pruneUndefined3(ast2.to);
  if (pruned) {
    return new Transformation(ast2.from, pruned, ast2.transformation);
  }
});
var withDecodingDefault = dual(2, (self, defaultValue) => {
  const ast = self.ast;
  switch (ast._tag) {
    case "PropertySignatureDeclaration": {
      const to = typeAST(ast.type);
      return makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(ast.type, ast.isOptional, ast.isReadonly, ast.annotations), new ToPropertySignature(pruneUndefined3(to) ?? to, false, true, {}, ast.defaultValue), (o) => applyDefaultValue(o, defaultValue), identity));
    }
    case "PropertySignatureTransformation": {
      const to = ast.to.type;
      return makePropertySignature(new PropertySignatureTransformation2(ast.from, new ToPropertySignature(pruneUndefined3(to) ?? to, false, ast.to.isReadonly, ast.to.annotations, ast.to.defaultValue), (o) => applyDefaultValue(ast.decode(o), defaultValue), ast.encode));
    }
  }
});
var withDefaults = dual(2, (self, defaults) => self.pipe(withDecodingDefault(defaults.decoding), withConstructorDefault(defaults.constructor)));
var fromKey = dual(2, (self, key) => {
  const ast = self.ast;
  switch (ast._tag) {
    case "PropertySignatureDeclaration": {
      return makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(ast.type, ast.isOptional, ast.isReadonly, ast.annotations, key), new ToPropertySignature(typeAST(ast.type), ast.isOptional, ast.isReadonly, {}, ast.defaultValue), identity, identity));
    }
    case "PropertySignatureTransformation":
      return makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(ast.from.type, ast.from.isOptional, ast.from.isReadonly, ast.from.annotations, key), ast.to, ast.decode, ast.encode));
  }
});
var optionalToRequired = (from, to, options) => makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(from.ast, true, true, {}, void 0), new ToPropertySignature(to.ast, false, true, {}, void 0), (o) => some3(options.decode(o)), flatMap2(options.encode)));
var requiredToOptional = (from, to, options) => makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(from.ast, false, true, {}, void 0), new ToPropertySignature(to.ast, true, true, {}, void 0), flatMap2(options.decode), (o) => some3(options.encode(o))));
var optionalToOptional = (from, to, options) => makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(from.ast, true, true, {}, void 0), new ToPropertySignature(to.ast, true, true, {}, void 0), options.decode, options.encode));
var optionalPropertySignatureAST = (self, options) => {
  const isExact = options?.exact;
  const defaultValue = options?.default;
  const isNullable2 = options?.nullable;
  const asOption = options?.as == "Option";
  const asOptionEncode = options?.onNoneEncoding ? orElse2(options.onNoneEncoding) : identity;
  if (isExact) {
    if (defaultValue) {
      if (isNullable2) {
        return withConstructorDefault(optionalToRequired(NullOr(self), typeSchema(self), {
          decode: match2({
            onNone: defaultValue,
            onSome: (a) => a === null ? defaultValue() : a
          }),
          encode: some3
        }), defaultValue).ast;
      } else {
        return withConstructorDefault(optionalToRequired(self, typeSchema(self), {
          decode: match2({
            onNone: defaultValue,
            onSome: identity
          }),
          encode: some3
        }), defaultValue).ast;
      }
    } else if (asOption) {
      if (isNullable2) {
        return optionalToRequired(NullOr(self), OptionFromSelf(typeSchema(self)), {
          decode: filter(isNotNull),
          encode: asOptionEncode
        }).ast;
      } else {
        return optionalToRequired(self, OptionFromSelf(typeSchema(self)), {
          decode: identity,
          encode: identity
        }).ast;
      }
    } else {
      if (isNullable2) {
        return optionalToOptional(NullOr(self), typeSchema(self), {
          decode: filter(isNotNull),
          encode: identity
        }).ast;
      } else {
        return new PropertySignatureDeclaration(self.ast, true, true, {}, void 0);
      }
    }
  } else {
    if (defaultValue) {
      if (isNullable2) {
        return withConstructorDefault(optionalToRequired(NullishOr(self), typeSchema(self), {
          decode: match2({
            onNone: defaultValue,
            onSome: (a) => a == null ? defaultValue() : a
          }),
          encode: some3
        }), defaultValue).ast;
      } else {
        return withConstructorDefault(optionalToRequired(UndefinedOr(self), typeSchema(self), {
          decode: match2({
            onNone: defaultValue,
            onSome: (a) => a === void 0 ? defaultValue() : a
          }),
          encode: some3
        }), defaultValue).ast;
      }
    } else if (asOption) {
      if (isNullable2) {
        return optionalToRequired(NullishOr(self), OptionFromSelf(typeSchema(self)), {
          decode: filter((a) => a != null),
          encode: asOptionEncode
        }).ast;
      } else {
        return optionalToRequired(UndefinedOr(self), OptionFromSelf(typeSchema(self)), {
          decode: filter(isNotUndefined),
          encode: asOptionEncode
        }).ast;
      }
    } else {
      if (isNullable2) {
        return optionalToOptional(NullishOr(self), UndefinedOr(typeSchema(self)), {
          decode: filter(isNotNull),
          encode: identity
        }).ast;
      } else {
        return new PropertySignatureDeclaration(UndefinedOr(self).ast, true, true, {}, void 0);
      }
    }
  }
};
var optional = (self) => {
  const ast = self.ast === undefinedKeyword || self.ast === neverKeyword ? undefinedKeyword : UndefinedOr(self).ast;
  return new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(ast, true, true, {}, void 0), self);
};
var optionalWith = dual((args2) => isSchema(args2[0]), (self, options) => {
  return new PropertySignatureWithFromImpl(optionalPropertySignatureAST(self, options), self);
});
var preserveMissingMessageAnnotation = pickAnnotations([MissingMessageAnnotationId]);
var getDefaultTypeLiteralAST = (fields, records) => {
  const ownKeys2 = ownKeys(fields);
  const pss = [];
  if (ownKeys2.length > 0) {
    const from = [];
    const to = [];
    const transformations = [];
    for (let i = 0; i < ownKeys2.length; i++) {
      const key = ownKeys2[i];
      const field = fields[key];
      if (isPropertySignature(field)) {
        const ast = field.ast;
        switch (ast._tag) {
          case "PropertySignatureDeclaration": {
            const type3 = ast.type;
            const isOptional = ast.isOptional;
            const toAnnotations = ast.annotations;
            from.push(new PropertySignature(key, type3, isOptional, true, preserveMissingMessageAnnotation(ast)));
            to.push(new PropertySignature(key, typeAST(type3), isOptional, true, toAnnotations));
            pss.push(new PropertySignature(key, type3, isOptional, true, toAnnotations));
            break;
          }
          case "PropertySignatureTransformation": {
            const fromKey2 = ast.from.fromKey ?? key;
            from.push(new PropertySignature(fromKey2, ast.from.type, ast.from.isOptional, true, ast.from.annotations));
            to.push(new PropertySignature(key, ast.to.type, ast.to.isOptional, true, ast.to.annotations));
            transformations.push(new PropertySignatureTransformation(fromKey2, key, ast.decode, ast.encode));
            break;
          }
        }
      } else {
        from.push(new PropertySignature(key, field.ast, false, true));
        to.push(new PropertySignature(key, typeAST(field.ast), false, true));
        pss.push(new PropertySignature(key, field.ast, false, true));
      }
    }
    if (isNonEmptyReadonlyArray(transformations)) {
      const issFrom = [];
      const issTo = [];
      for (const r of records) {
        const {
          indexSignatures,
          propertySignatures
        } = record2(r.key.ast, r.value.ast);
        propertySignatures.forEach((ps) => {
          from.push(ps);
          to.push(new PropertySignature(ps.name, typeAST(ps.type), ps.isOptional, ps.isReadonly, ps.annotations));
        });
        indexSignatures.forEach((is4) => {
          issFrom.push(is4);
          issTo.push(new IndexSignature(is4.parameter, typeAST(is4.type), is4.isReadonly));
        });
      }
      return new Transformation(new TypeLiteral(from, issFrom, {
        [AutoTitleAnnotationId]: "Struct (Encoded side)"
      }), new TypeLiteral(to, issTo, {
        [AutoTitleAnnotationId]: "Struct (Type side)"
      }), new TypeLiteralTransformation(transformations));
    }
  }
  const iss = [];
  for (const r of records) {
    const {
      indexSignatures,
      propertySignatures
    } = record2(r.key.ast, r.value.ast);
    propertySignatures.forEach((ps) => pss.push(ps));
    indexSignatures.forEach((is4) => iss.push(is4));
  }
  return new TypeLiteral(pss, iss);
};
var lazilyMergeDefaults = (fields, out) => {
  const ownKeys2 = ownKeys(fields);
  for (const key of ownKeys2) {
    const field = fields[key];
    if (out[key] === void 0 && isPropertySignature(field)) {
      const ast = field.ast;
      const defaultValue = ast._tag === "PropertySignatureDeclaration" ? ast.defaultValue : ast.to.defaultValue;
      if (defaultValue !== void 0) {
        out[key] = defaultValue();
      }
    }
  }
  return out;
};
function makeTypeLiteralClass(fields, records, ast = getDefaultTypeLiteralAST(fields, records)) {
  return class TypeLiteralClass extends make113(ast) {
    static annotations(annotations4) {
      return makeTypeLiteralClass(this.fields, this.records, mergeSchemaAnnotations(this.ast, annotations4));
    }
    static fields = {
      ...fields
    };
    static records = [...records];
    static make = (props, options) => {
      const propsWithDefaults = lazilyMergeDefaults(fields, {
        ...props
      });
      return getDisableValidationMakeOption(options) ? propsWithDefaults : validateSync(this)(propsWithDefaults);
    };
    static pick(...keys15) {
      return Struct(pick4(fields, ...keys15));
    }
    static omit(...keys15) {
      return Struct(omit4(fields, ...keys15));
    }
  };
}
function Struct(fields, ...records) {
  return makeTypeLiteralClass(fields, records);
}
var tag4 = (tag5) => Literal2(tag5).pipe(propertySignature, withConstructorDefault(() => tag5));
var TaggedStruct = (value10, fields) => Struct({
  _tag: tag4(value10),
  ...fields
});
function makeRecordClass(key, value10, ast) {
  return class RecordClass extends makeTypeLiteralClass({}, [{
    key,
    value: value10
  }], ast) {
    static annotations(annotations4) {
      return makeRecordClass(key, value10, mergeSchemaAnnotations(this.ast, annotations4));
    }
    static key = key;
    static value = value10;
  };
}
var Record = (options) => makeRecordClass(options.key, options.value);
var pick5 = (...keys15) => (self) => make113(pick(self.ast, keys15));
var omit5 = (...keys15) => (self) => make113(omit(self.ast, keys15));
var pluck = dual(2, (schema, key) => {
  const ps = getPropertyKeyIndexedAccess(typeAST(schema.ast), key);
  const value10 = make113(ps.isOptional ? orUndefined(ps.type) : ps.type);
  const out = transform3(schema.pipe(pick5(key)), value10, {
    strict: true,
    decode: (i) => i[key],
    encode: (a) => ps.isOptional && a === void 0 ? {} : {
      [key]: a
    }
  });
  return out;
});
function makeBrandClass(from, ast) {
  return class BrandClass extends make113(ast) {
    static annotations(annotations4) {
      return makeBrandClass(this.from, mergeSchemaAnnotations(this.ast, annotations4));
    }
    static make = (a, options) => {
      return getDisableValidationMakeOption(options) ? a : validateSync(this)(a);
    };
    static from = from;
  };
}
var brand = (brand2, annotations4) => (self) => {
  const annotation = match2(getBrandAnnotation(self.ast), {
    onNone: () => [brand2],
    onSome: (brands) => [...brands, brand2]
  });
  const ast = annotations(self.ast, toASTAnnotations({
    [BrandAnnotationId]: annotation,
    ...annotations4
  }));
  return makeBrandClass(self, ast);
};
var partial2 = (self) => make113(partial(self.ast));
var partialWith = dual((args2) => isSchema(args2[0]), (self, options) => make113(partial(self.ast, options)));
var required2 = (self) => make113(required(self.ast));
var mutable2 = (schema) => make113(mutable(schema.ast));
var intersectTypeLiterals = (x, y, path) => {
  if (isTypeLiteral(x) && isTypeLiteral(y)) {
    const propertySignatures = [...x.propertySignatures];
    for (const ps of y.propertySignatures) {
      const name = ps.name;
      const i = propertySignatures.findIndex((ps2) => ps2.name === name);
      if (i === -1) {
        propertySignatures.push(ps);
      } else {
        const {
          isOptional,
          type: type3
        } = propertySignatures[i];
        propertySignatures[i] = new PropertySignature(name, extendAST(type3, ps.type, path.concat(name)), isOptional, true);
      }
    }
    return new TypeLiteral(propertySignatures, x.indexSignatures.concat(y.indexSignatures));
  }
  throw new Error(getSchemaExtendErrorMessage(x, y, path));
};
var preserveRefinementAnnotations = omitAnnotations([IdentifierAnnotationId]);
var addRefinementToMembers = (refinement, asts) => asts.map((ast) => new Refinement(ast, refinement.filter, preserveRefinementAnnotations(refinement)));
var extendAST = (x, y, path) => Union.make(intersectUnionMembers([x], [y], path));
var getTypes = (ast) => isUnion(ast) ? ast.types : [ast];
var intersectUnionMembers = (xs, ys, path) => flatMap4(xs, (x) => flatMap4(ys, (y) => {
  switch (y._tag) {
    case "Literal": {
      if (isString(y.literal) && isStringKeyword(x) || isNumber(y.literal) && isNumberKeyword(x) || isBoolean(y.literal) && isBooleanKeyword(x)) {
        return [y];
      }
      break;
    }
    case "StringKeyword": {
      if (y === stringKeyword) {
        if (isStringKeyword(x) || isLiteral(x) && isString(x.literal)) {
          return [x];
        } else if (isRefinement(x)) {
          return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path));
        }
      } else if (x === stringKeyword) {
        return [y];
      }
      break;
    }
    case "NumberKeyword": {
      if (y === numberKeyword) {
        if (isNumberKeyword(x) || isLiteral(x) && isNumber(x.literal)) {
          return [x];
        } else if (isRefinement(x)) {
          return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path));
        }
      } else if (x === numberKeyword) {
        return [y];
      }
      break;
    }
    case "BooleanKeyword": {
      if (y === booleanKeyword) {
        if (isBooleanKeyword(x) || isLiteral(x) && isBoolean(x.literal)) {
          return [x];
        } else if (isRefinement(x)) {
          return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path));
        }
      } else if (x === booleanKeyword) {
        return [y];
      }
      break;
    }
    case "Union":
      return intersectUnionMembers(getTypes(x), y.types, path);
    case "Suspend":
      return [new Suspend(() => extendAST(x, y.f(), path))];
    case "Refinement":
      return addRefinementToMembers(y, intersectUnionMembers(getTypes(x), getTypes(y.from), path));
    case "TypeLiteral": {
      switch (x._tag) {
        case "Union":
          return intersectUnionMembers(x.types, [y], path);
        case "Suspend":
          return [new Suspend(() => extendAST(x.f(), y, path))];
        case "Refinement":
          return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path));
        case "TypeLiteral":
          return [intersectTypeLiterals(x, y, path)];
        case "Transformation": {
          const transformation = x.transformation;
          const from = intersectTypeLiterals(x.from, y, path);
          const to = intersectTypeLiterals(x.to, typeAST(y), path);
          switch (transformation._tag) {
            case "TypeLiteralTransformation":
              return [new Transformation(from, to, new TypeLiteralTransformation(transformation.propertySignatureTransformations))];
            case "ComposeTransformation":
              return [new Transformation(from, to, composeTransformation)];
            case "FinalTransformation":
              return [new Transformation(from, to, new FinalTransformation((fromA, options, ast, fromI) => map37(transformation.decode(fromA, options, ast, fromI), (partial3) => ({
                ...fromA,
                ...partial3
              })), (toI, options, ast, toA) => map37(transformation.encode(toI, options, ast, toA), (partial3) => ({
                ...toI,
                ...partial3
              }))))];
          }
        }
      }
      break;
    }
    case "Transformation": {
      if (isTransformation(x)) {
        if (isTypeLiteralTransformation(y.transformation) && isTypeLiteralTransformation(x.transformation)) {
          return [new Transformation(intersectTypeLiterals(x.from, y.from, path), intersectTypeLiterals(x.to, y.to, path), new TypeLiteralTransformation(y.transformation.propertySignatureTransformations.concat(x.transformation.propertySignatureTransformations)))];
        }
      } else {
        return intersectUnionMembers([y], [x], path);
      }
      break;
    }
  }
  throw new Error(getSchemaExtendErrorMessage(x, y, path));
}));
var extend4 = dual(2, (self, that) => make113(extendAST(self.ast, that.ast, [])));
var compose6 = dual((args2) => isSchema(args2[1]), (from, to) => makeTransformationClass(from, to, compose3(from.ast, to.ast)));
var suspend15 = (f) => make113(new Suspend(() => f().ast));
var RefineSchemaId = Symbol.for("effect/SchemaId/Refine");
function makeRefineClass(from, filter26, ast) {
  return class RefineClass extends make113(ast) {
    static annotations(annotations4) {
      return makeRefineClass(this.from, this.filter, mergeSchemaAnnotations(this.ast, annotations4));
    }
    static [RefineSchemaId] = from;
    static from = from;
    static filter = filter26;
    static make = (a, options) => {
      return getDisableValidationMakeOption(options) ? a : validateSync(this)(a);
    };
  };
}
var fromFilterPredicateReturnTypeItem = (item, ast, input) => {
  if (isBoolean(item)) {
    return item ? none2() : some3(new Type2(ast, input));
  }
  if (isString(item)) {
    return some3(new Type2(ast, input, item));
  }
  if (item !== void 0) {
    if ("_tag" in item) {
      return some3(item);
    }
    const issue = new Type2(ast, input, item.message);
    return some3(isNonEmptyReadonlyArray(item.path) ? new Pointer(item.path, input, issue) : issue);
  }
  return none2();
};
var toFilterParseIssue = (out, ast, input) => {
  if (isSingle(out)) {
    return fromFilterPredicateReturnTypeItem(out, ast, input);
  }
  if (isNonEmptyReadonlyArray(out)) {
    const issues = filterMap4(out, (issue) => fromFilterPredicateReturnTypeItem(issue, ast, input));
    if (isNonEmptyReadonlyArray(issues)) {
      return some3(issues.length === 1 ? issues[0] : new Composite2(ast, input, issues));
    }
  }
  return none2();
};
function filter22(predicate, annotations4) {
  return (self) => {
    function filter26(input, options, ast2) {
      return toFilterParseIssue(predicate(input, options, ast2), ast2, input);
    }
    const ast = new Refinement(self.ast, filter26, toASTAnnotations(annotations4));
    return makeRefineClass(self, filter26, ast);
  };
}
var filterEffect2 = dual(2, (self, f) => transformOrFail(self, typeSchema(self), {
  strict: true,
  decode: (i, options, ast) => flatMap25(f(i, options, ast), (filterReturnType) => match2(toFilterParseIssue(filterReturnType, ast, i), {
    onNone: () => succeed24(i),
    onSome: fail23
  })),
  encode: (a) => succeed24(a)
}));
function makeTransformationClass(from, to, ast) {
  return class TransformationClass extends make113(ast) {
    static annotations(annotations4) {
      return makeTransformationClass(this.from, this.to, mergeSchemaAnnotations(this.ast, annotations4));
    }
    static from = from;
    static to = to;
  };
}
var transformOrFail = dual((args2) => isSchema(args2[0]) && isSchema(args2[1]), (from, to, options) => makeTransformationClass(from, to, new Transformation(from.ast, to.ast, new FinalTransformation(options.decode, options.encode))));
var transform3 = dual((args2) => isSchema(args2[0]) && isSchema(args2[1]), (from, to, options) => transformOrFail(from, to, {
  strict: true,
  decode: (fromA, _options, _ast, toA) => succeed24(options.decode(fromA, toA)),
  encode: (toI, _options, _ast, toA) => succeed24(options.encode(toI, toA))
}));
function transformLiteral(from, to) {
  return transform3(Literal2(from), Literal2(to), {
    strict: true,
    decode: () => to,
    encode: () => from
  });
}
function transformLiterals(...pairs) {
  return Union2(...pairs.map(([from, to]) => transformLiteral(from, to)));
}
var attachPropertySignature = dual((args2) => isSchema(args2[0]), (schema, key, value10, annotations4) => {
  const ast = extend4(typeSchema(schema), Struct({
    [key]: isSymbol(value10) ? UniqueSymbolFromSelf(value10) : Literal2(value10)
  })).ast;
  return make113(new Transformation(schema.ast, annotations4 ? mergeSchemaAnnotations(ast, annotations4) : ast, new TypeLiteralTransformation([new PropertySignatureTransformation(key, key, () => some3(value10), () => none2())])));
});
var annotations2 = dual(2, (self, annotations4) => self.annotations(annotations4));
var rename2 = dual(2, (self, mapping) => make113(rename(self.ast, mapping)));
var TrimmedSchemaId = Symbol.for("effect/SchemaId/Trimmed");
var trimmed = (annotations4) => (self) => self.pipe(filter22((a) => a === a.trim(), {
  schemaId: TrimmedSchemaId,
  title: "trimmed",
  description: "a string with no leading or trailing whitespace",
  jsonSchema: {
    pattern: "^\\S[\\s\\S]*\\S$|^\\S$|^$"
  },
  ...annotations4
}));
var MaxLengthSchemaId2 = MaxLengthSchemaId;
var maxLength = (maxLength2, annotations4) => (self) => self.pipe(filter22((a) => a.length <= maxLength2, {
  schemaId: MaxLengthSchemaId2,
  title: `maxLength(${maxLength2})`,
  description: `a string at most ${maxLength2} character(s) long`,
  jsonSchema: {
    maxLength: maxLength2
  },
  ...annotations4
}));
var MinLengthSchemaId2 = MinLengthSchemaId;
var minLength = (minLength2, annotations4) => (self) => self.pipe(filter22((a) => a.length >= minLength2, {
  schemaId: MinLengthSchemaId2,
  title: `minLength(${minLength2})`,
  description: `a string at least ${minLength2} character(s) long`,
  jsonSchema: {
    minLength: minLength2
  },
  ...annotations4
}));
var LengthSchemaId2 = LengthSchemaId;
var length5 = (length6, annotations4) => (self) => {
  const minLength2 = isObject(length6) ? Math.max(0, Math.floor(length6.min)) : Math.max(0, Math.floor(length6));
  const maxLength2 = isObject(length6) ? Math.max(minLength2, Math.floor(length6.max)) : minLength2;
  if (minLength2 !== maxLength2) {
    return self.pipe(filter22((a) => a.length >= minLength2 && a.length <= maxLength2, {
      schemaId: LengthSchemaId2,
      title: `length({ min: ${minLength2}, max: ${maxLength2})`,
      description: `a string at least ${minLength2} character(s) and at most ${maxLength2} character(s) long`,
      jsonSchema: {
        minLength: minLength2,
        maxLength: maxLength2
      },
      ...annotations4
    }));
  }
  return self.pipe(filter22((a) => a.length === minLength2, {
    schemaId: LengthSchemaId2,
    title: `length(${minLength2})`,
    description: minLength2 === 1 ? `a single character` : `a string ${minLength2} character(s) long`,
    jsonSchema: {
      minLength: minLength2,
      maxLength: minLength2
    },
    ...annotations4
  }));
};
var PatternSchemaId = Symbol.for("effect/SchemaId/Pattern");
var pattern = (regex, annotations4) => (self) => {
  const source = regex.source;
  return self.pipe(filter22((a) => {
    regex.lastIndex = 0;
    return regex.test(a);
  }, {
    schemaId: PatternSchemaId,
    [PatternSchemaId]: {
      regex
    },
    // title: `pattern(/${source}/)`, // avoiding this because it can be very long
    description: `a string matching the pattern ${source}`,
    jsonSchema: {
      pattern: source
    },
    ...annotations4
  }));
};
var StartsWithSchemaId = Symbol.for("effect/SchemaId/StartsWith");
var startsWith2 = (startsWith3, annotations4) => (self) => {
  const formatted = JSON.stringify(startsWith3);
  return self.pipe(filter22((a) => a.startsWith(startsWith3), {
    schemaId: StartsWithSchemaId,
    [StartsWithSchemaId]: {
      startsWith: startsWith3
    },
    title: `startsWith(${formatted})`,
    description: `a string starting with ${formatted}`,
    jsonSchema: {
      pattern: `^${startsWith3}`
    },
    ...annotations4
  }));
};
var EndsWithSchemaId = Symbol.for("effect/SchemaId/EndsWith");
var endsWith2 = (endsWith3, annotations4) => (self) => {
  const formatted = JSON.stringify(endsWith3);
  return self.pipe(filter22((a) => a.endsWith(endsWith3), {
    schemaId: EndsWithSchemaId,
    [EndsWithSchemaId]: {
      endsWith: endsWith3
    },
    title: `endsWith(${formatted})`,
    description: `a string ending with ${formatted}`,
    jsonSchema: {
      pattern: `^.*${endsWith3}$`
    },
    ...annotations4
  }));
};
var IncludesSchemaId = Symbol.for("effect/SchemaId/Includes");
var includes3 = (searchString, annotations4) => (self) => {
  const formatted = JSON.stringify(searchString);
  return self.pipe(filter22((a) => a.includes(searchString), {
    schemaId: IncludesSchemaId,
    [IncludesSchemaId]: {
      includes: searchString
    },
    title: `includes(${formatted})`,
    description: `a string including ${formatted}`,
    jsonSchema: {
      pattern: `.*${searchString}.*`
    },
    ...annotations4
  }));
};
var LowercasedSchemaId = Symbol.for("effect/SchemaId/Lowercased");
var lowercased = (annotations4) => (self) => self.pipe(filter22((a) => a === a.toLowerCase(), {
  schemaId: LowercasedSchemaId,
  title: "lowercased",
  description: "a lowercase string",
  jsonSchema: {
    pattern: "^[^A-Z]*$"
  },
  ...annotations4
}));
var Lowercased = class extends String$.pipe(lowercased({
  identifier: "Lowercased"
})) {
};
var UppercasedSchemaId = Symbol.for("effect/SchemaId/Uppercased");
var uppercased = (annotations4) => (self) => self.pipe(filter22((a) => a === a.toUpperCase(), {
  schemaId: UppercasedSchemaId,
  title: "uppercased",
  description: "an uppercase string",
  jsonSchema: {
    pattern: "^[^a-z]*$"
  },
  ...annotations4
}));
var Uppercased = class extends String$.pipe(uppercased({
  identifier: "Uppercased"
})) {
};
var CapitalizedSchemaId = Symbol.for("effect/SchemaId/Capitalized");
var capitalized = (annotations4) => (self) => self.pipe(filter22((a) => a[0]?.toUpperCase() === a[0], {
  schemaId: CapitalizedSchemaId,
  title: "capitalized",
  description: "a capitalized string",
  jsonSchema: {
    pattern: "^[^a-z]?.*$"
  },
  ...annotations4
}));
var Capitalized = class extends String$.pipe(capitalized({
  identifier: "Capitalized"
})) {
};
var UncapitalizedSchemaId = Symbol.for("effect/SchemaId/Uncapitalized");
var uncapitalized = (annotations4) => (self) => self.pipe(filter22((a) => a[0]?.toLowerCase() === a[0], {
  schemaId: UncapitalizedSchemaId,
  title: "uncapitalized",
  description: "a uncapitalized string",
  jsonSchema: {
    pattern: "^[^A-Z]?.*$"
  },
  ...annotations4
}));
var Uncapitalized = class extends String$.pipe(uncapitalized({
  identifier: "Uncapitalized"
})) {
};
var Char = class extends String$.pipe(length5(1, {
  identifier: "Char"
})) {
};
var nonEmptyString5 = (annotations4) => minLength(1, {
  title: "nonEmptyString",
  description: "a non empty string",
  ...annotations4
});
var Lowercase = class extends transform3(String$.annotations({
  description: "a string that will be converted to lowercase"
}), Lowercased, {
  strict: true,
  decode: (i) => i.toLowerCase(),
  encode: identity
}).annotations({
  identifier: "Lowercase"
}) {
};
var Uppercase = class extends transform3(String$.annotations({
  description: "a string that will be converted to uppercase"
}), Uppercased, {
  strict: true,
  decode: (i) => i.toUpperCase(),
  encode: identity
}).annotations({
  identifier: "Uppercase"
}) {
};
var Capitalize = class extends transform3(String$.annotations({
  description: "a string that will be converted to a capitalized format"
}), Capitalized, {
  strict: true,
  decode: (i) => capitalize(i),
  encode: identity
}).annotations({
  identifier: "Capitalize"
}) {
};
var Uncapitalize = class extends transform3(String$.annotations({
  description: "a string that will be converted to an uncapitalized format"
}), Uncapitalized, {
  strict: true,
  decode: (i) => uncapitalize(i),
  encode: identity
}).annotations({
  identifier: "Uncapitalize"
}) {
};
var Trimmed = class extends String$.pipe(trimmed({
  identifier: "Trimmed"
})) {
};
var NonEmptyTrimmedString = class extends Trimmed.pipe(nonEmptyString5({
  identifier: "NonEmptyTrimmedString"
})) {
};
var Trim = class extends transform3(String$.annotations({
  description: "a string that will be trimmed"
}), Trimmed, {
  strict: true,
  decode: (i) => i.trim(),
  encode: identity
}).annotations({
  identifier: "Trim"
}) {
};
var split5 = (separator) => transform3(String$.annotations({
  description: "a string that will be split"
}), Array$(String$), {
  strict: true,
  decode: (i) => i.split(separator),
  encode: (a) => a.join(separator)
});
var getErrorMessage2 = (e) => e instanceof Error ? e.message : String(e);
var getParseJsonTransformation = (options) => transformOrFail(String$.annotations({
  description: "a string to be decoded into JSON"
}), Unknown, {
  strict: true,
  decode: (i, _, ast) => _try({
    try: () => JSON.parse(i, options?.reviver),
    catch: (e) => new Type2(ast, i, getErrorMessage2(e))
  }),
  encode: (a, _, ast) => _try({
    try: () => JSON.stringify(a, options?.replacer, options?.space),
    catch: (e) => new Type2(ast, a, getErrorMessage2(e))
  })
}).annotations({
  title: "parseJson",
  schemaId: ParseJsonSchemaId
});
var parseJson = (schemaOrOptions, o) => isSchema(schemaOrOptions) ? compose6(parseJson(o), schemaOrOptions) : getParseJsonTransformation(schemaOrOptions);
var NonEmptyString = class extends String$.pipe(nonEmptyString5({
  identifier: "NonEmptyString"
})) {
};
var UUIDSchemaId = Symbol.for("effect/SchemaId/UUID");
var uuidRegexp = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;
var UUID = class extends String$.pipe(pattern(uuidRegexp, {
  schemaId: UUIDSchemaId,
  identifier: "UUID",
  jsonSchema: {
    format: "uuid",
    pattern: uuidRegexp.source
  },
  description: "a Universally Unique Identifier",
  arbitrary: () => (fc) => fc.uuid()
})) {
};
var ULIDSchemaId = Symbol.for("effect/SchemaId/ULID");
var ulidRegexp = /^[0-7][0-9A-HJKMNP-TV-Z]{25}$/i;
var ULID = class extends String$.pipe(pattern(ulidRegexp, {
  schemaId: ULIDSchemaId,
  identifier: "ULID",
  description: "a Universally Unique Lexicographically Sortable Identifier",
  arbitrary: () => (fc) => fc.ulid()
})) {
};
var URLFromSelf = class extends instanceOf3(URL, {
  identifier: "URLFromSelf",
  arbitrary: () => (fc) => fc.webUrl().map((s) => new URL(s)),
  pretty: () => (url3) => url3.toString()
}) {
};
var URL$ = class extends transformOrFail(String$.annotations({
  description: "a string to be decoded into a URL"
}), URLFromSelf, {
  strict: true,
  decode: (i, _, ast) => _try({
    try: () => new URL(i),
    catch: (e) => new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a URL. ${getErrorMessage2(e)}`)
  }),
  encode: (a) => succeed24(a.toString())
}).annotations({
  identifier: "URL",
  pretty: () => (url3) => url3.toString()
}) {
};
var FiniteSchemaId2 = FiniteSchemaId;
var finite = (annotations4) => (self) => self.pipe(filter22(Number.isFinite, {
  schemaId: FiniteSchemaId2,
  title: "finite",
  description: "a finite number",
  jsonSchema: {
    "type": "number"
  },
  ...annotations4
}));
var GreaterThanSchemaId2 = GreaterThanSchemaId;
var greaterThan11 = (exclusiveMinimum, annotations4) => (self) => self.pipe(filter22((a) => a > exclusiveMinimum, {
  schemaId: GreaterThanSchemaId2,
  title: `greaterThan(${exclusiveMinimum})`,
  description: exclusiveMinimum === 0 ? "a positive number" : `a number greater than ${exclusiveMinimum}`,
  jsonSchema: {
    exclusiveMinimum
  },
  ...annotations4
}));
var GreaterThanOrEqualToSchemaId2 = GreaterThanOrEqualToSchemaId;
var greaterThanOrEqualTo8 = (minimum, annotations4) => (self) => self.pipe(filter22((a) => a >= minimum, {
  schemaId: GreaterThanOrEqualToSchemaId2,
  title: `greaterThanOrEqualTo(${minimum})`,
  description: minimum === 0 ? "a non-negative number" : `a number greater than or equal to ${minimum}`,
  jsonSchema: {
    minimum
  },
  ...annotations4
}));
var MultipleOfSchemaId = Symbol.for("effect/SchemaId/MultipleOf");
var multipleOf = (divisor, annotations4) => (self) => {
  const positiveDivisor = Math.abs(divisor);
  return self.pipe(filter22((a) => remainder(a, divisor) === 0, {
    schemaId: MultipleOfSchemaId,
    title: `multipleOf(${positiveDivisor})`,
    description: `a number divisible by ${positiveDivisor}`,
    jsonSchema: {
      multipleOf: positiveDivisor
    },
    ...annotations4
  }));
};
var IntSchemaId2 = IntSchemaId;
var int = (annotations4) => (self) => self.pipe(filter22((a) => Number.isSafeInteger(a), {
  schemaId: IntSchemaId2,
  title: "int",
  description: "an integer",
  jsonSchema: {
    type: "integer"
  },
  ...annotations4
}));
var LessThanSchemaId2 = LessThanSchemaId;
var lessThan15 = (exclusiveMaximum, annotations4) => (self) => self.pipe(filter22((a) => a < exclusiveMaximum, {
  schemaId: LessThanSchemaId2,
  title: `lessThan(${exclusiveMaximum})`,
  description: exclusiveMaximum === 0 ? "a negative number" : `a number less than ${exclusiveMaximum}`,
  jsonSchema: {
    exclusiveMaximum
  },
  ...annotations4
}));
var LessThanOrEqualToSchemaId2 = LessThanOrEqualToSchemaId;
var lessThanOrEqualTo8 = (maximum, annotations4) => (self) => self.pipe(filter22((a) => a <= maximum, {
  schemaId: LessThanOrEqualToSchemaId2,
  title: `lessThanOrEqualTo(${maximum})`,
  description: maximum === 0 ? "a non-positive number" : `a number less than or equal to ${maximum}`,
  jsonSchema: {
    maximum
  },
  ...annotations4
}));
var BetweenSchemaId2 = BetweenSchemaId;
var between8 = (minimum, maximum, annotations4) => (self) => self.pipe(filter22((a) => a >= minimum && a <= maximum, {
  schemaId: BetweenSchemaId2,
  title: `between(${minimum}, ${maximum})`,
  description: `a number between ${minimum} and ${maximum}`,
  jsonSchema: {
    minimum,
    maximum
  },
  ...annotations4
}));
var NonNaNSchemaId2 = NonNaNSchemaId;
var nonNaN = (annotations4) => (self) => self.pipe(filter22((a) => !Number.isNaN(a), {
  schemaId: NonNaNSchemaId2,
  title: "nonNaN",
  description: "a number excluding NaN",
  ...annotations4
}));
var positive = (annotations4) => greaterThan11(0, {
  title: "positive",
  ...annotations4
});
var negative = (annotations4) => lessThan15(0, {
  title: "negative",
  ...annotations4
});
var nonPositive = (annotations4) => lessThanOrEqualTo8(0, {
  title: "nonPositive",
  ...annotations4
});
var nonNegative = (annotations4) => greaterThanOrEqualTo8(0, {
  title: "nonNegative",
  ...annotations4
});
var clamp9 = (minimum, maximum) => (self) => {
  return transform3(self, typeSchema(self).pipe(between8(minimum, maximum)), {
    strict: false,
    decode: (i) => clamp3(i, {
      minimum,
      maximum
    }),
    encode: identity
  });
};
function parseNumber(self) {
  return transformOrFail(self, Number$, {
    strict: false,
    decode: (i, _, ast) => fromOption9(parse(i), () => new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a number`)),
    encode: (a) => succeed24(String(a))
  });
}
var NumberFromString = class extends parseNumber(String$.annotations({
  description: "a string to be decoded into a number"
})).annotations({
  identifier: "NumberFromString"
}) {
};
var Finite = class extends Number$.pipe(finite({
  identifier: "Finite"
})) {
};
var Int = class extends Number$.pipe(int({
  identifier: "Int"
})) {
};
var NonNaN = class extends Number$.pipe(nonNaN({
  identifier: "NonNaN"
})) {
};
var Positive = class extends Number$.pipe(positive({
  identifier: "Positive"
})) {
};
var Negative = class extends Number$.pipe(negative({
  identifier: "Negative"
})) {
};
var NonPositive = class extends Number$.pipe(nonPositive({
  identifier: "NonPositive"
})) {
};
var NonNegative = class extends Number$.pipe(nonNegative({
  identifier: "NonNegative"
})) {
};
var JsonNumberSchemaId2 = JsonNumberSchemaId;
var JsonNumber = class extends Number$.pipe(finite({
  schemaId: JsonNumberSchemaId2,
  identifier: "JsonNumber"
})) {
};
var Not = class extends transform3(Boolean$.annotations({
  description: "a boolean that will be negated"
}), Boolean$, {
  strict: true,
  decode: (i) => not2(i),
  encode: (a) => not2(a)
}) {
};
var encodeSymbol2 = (sym, ast) => {
  const key = Symbol.keyFor(sym);
  return key === void 0 ? fail23(new Type2(ast, sym, `Unable to encode a unique symbol ${String(sym)} into a string`)) : succeed24(key);
};
var decodeSymbol = (s) => succeed24(Symbol.for(s));
var Symbol$ = class extends transformOrFail(String$.annotations({
  description: "a string to be decoded into a globally shared symbol"
}), SymbolFromSelf, {
  strict: false,
  decode: (i) => decodeSymbol(i),
  encode: (a, _, ast) => encodeSymbol2(a, ast)
}).annotations({
  identifier: "Symbol"
}) {
};
var GreaterThanBigIntSchemaId = GreaterThanBigintSchemaId;
var greaterThanBigInt = (min11, annotations4) => (self) => self.pipe(filter22((a) => a > min11, {
  schemaId: GreaterThanBigIntSchemaId,
  [GreaterThanBigIntSchemaId]: {
    min: min11
  },
  title: `greaterThanBigInt(${min11})`,
  description: min11 === 0n ? "a positive bigint" : `a bigint greater than ${min11}n`,
  ...annotations4
}));
var GreaterThanOrEqualToBigIntSchemaId2 = GreaterThanOrEqualToBigIntSchemaId;
var greaterThanOrEqualToBigInt = (min11, annotations4) => (self) => self.pipe(filter22((a) => a >= min11, {
  schemaId: GreaterThanOrEqualToBigIntSchemaId2,
  [GreaterThanOrEqualToBigIntSchemaId2]: {
    min: min11
  },
  title: `greaterThanOrEqualToBigInt(${min11})`,
  description: min11 === 0n ? "a non-negative bigint" : `a bigint greater than or equal to ${min11}n`,
  ...annotations4
}));
var LessThanBigIntSchemaId2 = LessThanBigIntSchemaId;
var lessThanBigInt = (max13, annotations4) => (self) => self.pipe(filter22((a) => a < max13, {
  schemaId: LessThanBigIntSchemaId2,
  [LessThanBigIntSchemaId2]: {
    max: max13
  },
  title: `lessThanBigInt(${max13})`,
  description: max13 === 0n ? "a negative bigint" : `a bigint less than ${max13}n`,
  ...annotations4
}));
var LessThanOrEqualToBigIntSchemaId2 = LessThanOrEqualToBigIntSchemaId;
var lessThanOrEqualToBigInt = (max13, annotations4) => (self) => self.pipe(filter22((a) => a <= max13, {
  schemaId: LessThanOrEqualToBigIntSchemaId2,
  [LessThanOrEqualToBigIntSchemaId2]: {
    max: max13
  },
  title: `lessThanOrEqualToBigInt(${max13})`,
  description: max13 === 0n ? "a non-positive bigint" : `a bigint less than or equal to ${max13}n`,
  ...annotations4
}));
var BetweenBigIntSchemaId = BetweenBigintSchemaId;
var betweenBigInt = (min11, max13, annotations4) => (self) => self.pipe(filter22((a) => a >= min11 && a <= max13, {
  schemaId: BetweenBigIntSchemaId,
  [BetweenBigIntSchemaId]: {
    min: min11,
    max: max13
  },
  title: `betweenBigInt(${min11}, ${max13})`,
  description: `a bigint between ${min11}n and ${max13}n`,
  ...annotations4
}));
var positiveBigInt = (annotations4) => greaterThanBigInt(0n, {
  title: "positiveBigInt",
  ...annotations4
});
var negativeBigInt = (annotations4) => lessThanBigInt(0n, {
  title: "negativeBigInt",
  ...annotations4
});
var nonNegativeBigInt = (annotations4) => greaterThanOrEqualToBigInt(0n, {
  title: "nonNegativeBigInt",
  ...annotations4
});
var nonPositiveBigInt = (annotations4) => lessThanOrEqualToBigInt(0n, {
  title: "nonPositiveBigInt",
  ...annotations4
});
var clampBigInt = (minimum, maximum) => (self) => transform3(self, self.pipe(typeSchema, betweenBigInt(minimum, maximum)), {
  strict: false,
  decode: (i) => clamp5(i, {
    minimum,
    maximum
  }),
  encode: identity
});
var BigInt$ = class extends transformOrFail(String$.annotations({
  description: "a string to be decoded into a bigint"
}), BigIntFromSelf, {
  strict: true,
  decode: (i, _, ast) => fromOption9(fromString2(i), () => new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a bigint`)),
  encode: (a) => succeed24(String(a))
}).annotations({
  identifier: "BigInt"
}) {
};
var PositiveBigIntFromSelf = BigIntFromSelf.pipe(positiveBigInt({
  identifier: "PositiveBigintFromSelf"
}));
var PositiveBigInt = BigInt$.pipe(positiveBigInt({
  identifier: "PositiveBigint"
}));
var NegativeBigIntFromSelf = BigIntFromSelf.pipe(negativeBigInt({
  identifier: "NegativeBigintFromSelf"
}));
var NegativeBigInt = BigInt$.pipe(negativeBigInt({
  identifier: "NegativeBigint"
}));
var NonPositiveBigIntFromSelf = BigIntFromSelf.pipe(nonPositiveBigInt({
  identifier: "NonPositiveBigintFromSelf"
}));
var NonPositiveBigInt = BigInt$.pipe(nonPositiveBigInt({
  identifier: "NonPositiveBigint"
}));
var NonNegativeBigIntFromSelf = BigIntFromSelf.pipe(nonNegativeBigInt({
  identifier: "NonNegativeBigintFromSelf"
}));
var NonNegativeBigInt = BigInt$.pipe(nonNegativeBigInt({
  identifier: "NonNegativeBigint"
}));
var BigIntFromNumber = class extends transformOrFail(Number$.annotations({
  description: "a number to be decoded into a bigint"
}), BigIntFromSelf.pipe(betweenBigInt(BigInt(Number.MIN_SAFE_INTEGER), BigInt(Number.MAX_SAFE_INTEGER))), {
  strict: true,
  decode: (i, _, ast) => fromOption9(fromNumber2(i), () => new Type2(ast, i, `Unable to decode ${i} into a bigint`)),
  encode: (a, _, ast) => fromOption9(toNumber(a), () => new Type2(ast, a, `Unable to encode ${a}n into a number`))
}).annotations({
  identifier: "BigIntFromNumber"
}) {
};
var redactedArbitrary = (value10) => (fc) => value10(fc).map(make108);
var toComposite = (eff, onSuccess, ast, actual) => mapBoth10(eff, {
  onFailure: (e) => new Composite2(ast, actual, e),
  onSuccess
});
var redactedParse = (decodeUnknown4) => (u, options, ast) => isRedacted2(u) ? toComposite(decodeUnknown4(value8(u), options), make108, ast, u) : fail23(new Type2(ast, u));
var RedactedFromSelf = (value10) => declare([value10], {
  decode: (value11) => redactedParse(decodeUnknown2(value11)),
  encode: (value11) => redactedParse(encodeUnknown(value11))
}, {
  description: "Redacted(<redacted>)",
  pretty: () => () => "Redacted(<redacted>)",
  arbitrary: redactedArbitrary,
  equivalence: getEquivalence9
});
function Redacted(value10) {
  return transform3(value10, RedactedFromSelf(typeSchema(asSchema(value10))), {
    strict: true,
    decode: (i) => make108(i),
    encode: (a) => value8(a)
  });
}
var DurationFromSelf = class extends declare(isDuration, {
  identifier: "DurationFromSelf",
  pretty: () => String,
  arbitrary: () => (fc) => fc.oneof(fc.constant(infinity), fc.bigInt({
    min: 0n
  }).map((_) => nanos(_)), fc.maxSafeNat().map((_) => millis(_))),
  equivalence: () => Equivalence5
}) {
};
var DurationFromNanos = class extends transformOrFail(NonNegativeBigIntFromSelf.annotations({
  description: "a bigint to be decoded into a Duration"
}), DurationFromSelf.pipe(filter22((duration5) => isFinite(duration5), {
  description: "a finite duration"
})), {
  strict: true,
  decode: (i) => succeed24(nanos(i)),
  encode: (a, _, ast) => match2(toNanos(a), {
    onNone: () => fail23(new Type2(ast, a, `Unable to encode ${a} into a bigint`)),
    onSome: (nanos2) => succeed24(nanos2)
  })
}).annotations({
  identifier: "DurationFromNanos"
}) {
};
var NonNegativeInt = NonNegative.pipe(int()).annotations({
  identifier: "NonNegativeInt"
});
var DurationFromMillis = class extends transform3(NonNegative.annotations({
  description: "a non-negative number to be decoded into a Duration"
}), DurationFromSelf, {
  strict: true,
  decode: (i) => millis(i),
  encode: (a) => toMillis(a)
}).annotations({
  identifier: "DurationFromMillis"
}) {
};
var DurationValueMillis = TaggedStruct("Millis", {
  millis: NonNegativeInt
});
var DurationValueNanos = TaggedStruct("Nanos", {
  nanos: BigInt$
});
var DurationValueInfinity = TaggedStruct("Infinity", {});
var durationValueInfinity = DurationValueInfinity.make({});
var DurationValue = Union2(DurationValueMillis, DurationValueNanos, DurationValueInfinity).annotations({
  identifier: "DurationValue",
  description: "an JSON-compatible tagged union to be decoded into a Duration"
});
var FiniteHRTime = Tuple(element(NonNegativeInt).annotations({
  title: "seconds"
}), element(NonNegativeInt).annotations({
  title: "nanos"
})).annotations({
  identifier: "FiniteHRTime"
});
var InfiniteHRTime = Tuple(Literal2(-1), Literal2(0)).annotations({
  identifier: "InfiniteHRTime"
});
var HRTime = Union2(FiniteHRTime, InfiniteHRTime).annotations({
  identifier: "HRTime",
  description: "a tuple of seconds and nanos to be decoded into a Duration"
});
var isDurationValue = (u) => typeof u === "object";
var Duration = class extends transform3(Union2(DurationValue, HRTime), DurationFromSelf, {
  strict: true,
  decode: (i) => {
    if (isDurationValue(i)) {
      switch (i._tag) {
        case "Millis":
          return millis(i.millis);
        case "Nanos":
          return nanos(i.nanos);
        case "Infinity":
          return infinity;
      }
    }
    const [seconds2, nanos2] = i;
    return seconds2 === -1 ? infinity : nanos(BigInt(seconds2) * BigInt(1e9) + BigInt(nanos2));
  },
  encode: (a) => {
    switch (a.value._tag) {
      case "Millis":
        return DurationValueMillis.make({
          millis: a.value.millis
        });
      case "Nanos":
        return DurationValueNanos.make({
          nanos: a.value.nanos
        });
      case "Infinity":
        return durationValueInfinity;
    }
  }
}).annotations({
  identifier: "Duration"
}) {
};
var clampDuration = (minimum, maximum) => (self) => transform3(self, self.pipe(typeSchema, betweenDuration(minimum, maximum)), {
  strict: false,
  decode: (i) => clamp6(i, {
    minimum,
    maximum
  }),
  encode: identity
});
var LessThanDurationSchemaId = Symbol.for("effect/SchemaId/LessThanDuration");
var lessThanDuration = (max13, annotations4) => (self) => self.pipe(filter22((a) => lessThan5(a, max13), {
  schemaId: LessThanDurationSchemaId,
  [LessThanDurationSchemaId]: {
    max: max13
  },
  title: `lessThanDuration(${max13})`,
  description: `a Duration less than ${decode(max13)}`,
  ...annotations4
}));
var LessThanOrEqualToDurationSchemaId = Symbol.for("effect/schema/LessThanOrEqualToDuration");
var lessThanOrEqualToDuration = (max13, annotations4) => (self) => self.pipe(filter22((a) => lessThanOrEqualTo5(a, max13), {
  schemaId: LessThanDurationSchemaId,
  [LessThanDurationSchemaId]: {
    max: max13
  },
  title: `lessThanOrEqualToDuration(${max13})`,
  description: `a Duration less than or equal to ${decode(max13)}`,
  ...annotations4
}));
var GreaterThanDurationSchemaId = Symbol.for("effect/SchemaId/GreaterThanDuration");
var greaterThanDuration = (min11, annotations4) => (self) => self.pipe(filter22((a) => greaterThan5(a, min11), {
  schemaId: GreaterThanDurationSchemaId,
  [GreaterThanDurationSchemaId]: {
    min: min11
  },
  title: `greaterThanDuration(${min11})`,
  description: `a Duration greater than ${decode(min11)}`,
  ...annotations4
}));
var GreaterThanOrEqualToDurationSchemaId = Symbol.for("effect/schema/GreaterThanOrEqualToDuration");
var greaterThanOrEqualToDuration = (min11, annotations4) => (self) => self.pipe(filter22((a) => greaterThanOrEqualTo5(a, min11), {
  schemaId: GreaterThanOrEqualToDurationSchemaId,
  [GreaterThanOrEqualToDurationSchemaId]: {
    min: min11
  },
  title: `greaterThanOrEqualToDuration(${min11})`,
  description: `a Duration greater than or equal to ${decode(min11)}`,
  ...annotations4
}));
var BetweenDurationSchemaId = Symbol.for("effect/SchemaId/BetweenDuration");
var betweenDuration = (minimum, maximum, annotations4) => (self) => self.pipe(filter22((a) => between5(a, {
  minimum,
  maximum
}), {
  schemaId: BetweenDurationSchemaId,
  [BetweenDurationSchemaId]: {
    maximum,
    minimum
  },
  title: `betweenDuration(${minimum}, ${maximum})`,
  description: `a Duration between ${decode(minimum)} and ${decode(maximum)}`,
  ...annotations4
}));
var Uint8ArrayFromSelf = class extends declare(isUint8Array, {
  identifier: "Uint8ArrayFromSelf",
  pretty: () => (u8arr) => `new Uint8Array(${JSON.stringify(Array.from(u8arr))})`,
  arbitrary: () => (fc) => fc.uint8Array(),
  equivalence: () => getEquivalence5(equals)
}) {
};
var Uint8 = class extends Number$.pipe(between8(0, 255, {
  identifier: "Uint8",
  description: "a 8-bit unsigned integer"
})) {
};
var Uint8Array$ = class extends transform3(Array$(Uint8).annotations({
  description: "an array of 8-bit unsigned integers to be decoded into a Uint8Array"
}), Uint8ArrayFromSelf, {
  strict: true,
  decode: (i) => Uint8Array.from(i),
  encode: (a) => Array.from(a)
}).annotations({
  identifier: "Uint8Array"
}) {
};
var makeUint8ArrayTransformation = (id3, decode7, encode6) => transformOrFail(String$.annotations({
  description: "a string to be decoded into a Uint8Array"
}), Uint8ArrayFromSelf, {
  strict: true,
  decode: (i, _, ast) => mapLeft(decode7(i), (decodeException) => new Type2(ast, i, decodeException.message)),
  encode: (a) => succeed24(encode6(a))
}).annotations({
  identifier: id3
});
var Uint8ArrayFromBase64 = makeUint8ArrayTransformation("Uint8ArrayFromBase64", decodeBase64, encodeBase64);
var Uint8ArrayFromBase64Url = makeUint8ArrayTransformation("Uint8ArrayFromBase64Url", decodeBase64Url, encodeBase64Url);
var Uint8ArrayFromHex = makeUint8ArrayTransformation("Uint8ArrayFromHex", decodeHex, encodeHex);
var makeEncodingTransformation = (id3, decode7, encode6) => transformOrFail(String$.annotations({
  description: `A string that is interpreted as being ${id3}-encoded and will be decoded into a UTF-8 string`
}), String$, {
  strict: true,
  decode: (i, _, ast) => mapLeft(decode7(i), (decodeException) => new Type2(ast, i, decodeException.message)),
  encode: (a) => succeed24(encode6(a))
}).annotations({
  identifier: `StringFrom${id3}`
});
var StringFromBase64 = makeEncodingTransformation("Base64", decodeBase64String, encodeBase64);
var StringFromBase64Url = makeEncodingTransformation("Base64Url", decodeBase64UrlString, encodeBase64Url);
var StringFromHex = makeEncodingTransformation("Hex", decodeHexString, encodeHex);
var StringFromUriComponent = transformOrFail(String$.annotations({
  description: `A string that is interpreted as being UriComponent-encoded and will be decoded into a UTF-8 string`
}), String$, {
  strict: true,
  decode: (i, _, ast) => mapLeft(decodeUriComponent(i), (decodeException) => new Type2(ast, i, decodeException.message)),
  encode: (a, _, ast) => mapLeft(encodeUriComponent(a), (encodeException) => new Type2(ast, a, encodeException.message))
}).annotations({
  identifier: `StringFromUriComponent`
});
var MinItemsSchemaId2 = MinItemsSchemaId;
var minItems = (n, annotations4) => (self) => {
  const minItems2 = Math.floor(n);
  if (minItems2 < 1) {
    throw new Error(getInvalidArgumentErrorMessage(`Expected an integer greater than or equal to 1, actual ${n}`));
  }
  return self.pipe(filter22((a) => a.length >= minItems2, {
    schemaId: MinItemsSchemaId2,
    title: `minItems(${minItems2})`,
    description: `an array of at least ${minItems2} item(s)`,
    jsonSchema: {
      minItems: minItems2
    },
    [StableFilterAnnotationId]: true,
    ...annotations4
  }));
};
var MaxItemsSchemaId2 = MaxItemsSchemaId;
var maxItems = (n, annotations4) => (self) => {
  const maxItems2 = Math.floor(n);
  if (maxItems2 < 1) {
    throw new Error(getInvalidArgumentErrorMessage(`Expected an integer greater than or equal to 1, actual ${n}`));
  }
  return self.pipe(filter22((a) => a.length <= maxItems2, {
    schemaId: MaxItemsSchemaId2,
    title: `maxItems(${maxItems2})`,
    description: `an array of at most ${maxItems2} item(s)`,
    jsonSchema: {
      maxItems: maxItems2
    },
    [StableFilterAnnotationId]: true,
    ...annotations4
  }));
};
var ItemsCountSchemaId2 = ItemsCountSchemaId;
var itemsCount = (n, annotations4) => (self) => {
  const itemsCount2 = Math.floor(n);
  if (itemsCount2 < 0) {
    throw new Error(getInvalidArgumentErrorMessage(`Expected an integer greater than or equal to 0, actual ${n}`));
  }
  return self.pipe(filter22((a) => a.length === itemsCount2, {
    schemaId: ItemsCountSchemaId2,
    title: `itemsCount(${itemsCount2})`,
    description: `an array of exactly ${itemsCount2} item(s)`,
    jsonSchema: {
      minItems: itemsCount2,
      maxItems: itemsCount2
    },
    [StableFilterAnnotationId]: true,
    ...annotations4
  }));
};
var getNumberIndexedAccess2 = (self) => make113(getNumberIndexedAccess(self.ast));
function head11(self) {
  return transform3(self, OptionFromSelf(getNumberIndexedAccess2(typeSchema(self))), {
    strict: false,
    decode: (i) => head2(i),
    encode: (a) => match2(a, {
      onNone: () => [],
      onSome: of2
    })
  });
}
function headNonEmpty3(self) {
  return transform3(self, getNumberIndexedAccess2(typeSchema(self)), {
    strict: false,
    decode: (i) => headNonEmpty(i),
    encode: (a) => of2(a)
  });
}
var headOrElse = dual((args2) => isSchema(args2[0]), (self, fallback) => transformOrFail(self, getNumberIndexedAccess2(typeSchema(self)), {
  strict: true,
  decode: (i, _, ast) => i.length > 0 ? succeed24(i[0]) : fallback ? succeed24(fallback()) : fail23(new Type2(ast, i, "Unable to retrieve the first element of an empty array")),
  encode: (a) => succeed24(of2(a))
}));
var ValidDateSchemaId = Symbol.for("effect/SchemaId/ValidDate");
var validDate = (annotations4) => (self) => self.pipe(filter22((a) => !Number.isNaN(a.getTime()), {
  schemaId: ValidDateSchemaId,
  [ValidDateSchemaId]: {
    noInvalidDate: true
  },
  title: "validDate",
  description: "a valid Date",
  ...annotations4
}));
var LessThanDateSchemaId = Symbol.for("effect/SchemaId/LessThanDate");
var lessThanDate = (max13, annotations4) => (self) => self.pipe(filter22((a) => a < max13, {
  schemaId: LessThanDateSchemaId,
  [LessThanDateSchemaId]: {
    max: max13
  },
  title: `lessThanDate(${formatDate(max13)})`,
  description: `a date before ${formatDate(max13)}`,
  ...annotations4
}));
var LessThanOrEqualToDateSchemaId = Symbol.for("effect/schema/LessThanOrEqualToDate");
var lessThanOrEqualToDate = (max13, annotations4) => (self) => self.pipe(filter22((a) => a <= max13, {
  schemaId: LessThanOrEqualToDateSchemaId,
  [LessThanOrEqualToDateSchemaId]: {
    max: max13
  },
  title: `lessThanOrEqualToDate(${formatDate(max13)})`,
  description: `a date before or equal to ${formatDate(max13)}`,
  ...annotations4
}));
var GreaterThanDateSchemaId = Symbol.for("effect/SchemaId/GreaterThanDate");
var greaterThanDate = (min11, annotations4) => (self) => self.pipe(filter22((a) => a > min11, {
  schemaId: GreaterThanDateSchemaId,
  [GreaterThanDateSchemaId]: {
    min: min11
  },
  title: `greaterThanDate(${formatDate(min11)})`,
  description: `a date after ${formatDate(min11)}`,
  ...annotations4
}));
var GreaterThanOrEqualToDateSchemaId = Symbol.for("effect/schema/GreaterThanOrEqualToDate");
var greaterThanOrEqualToDate = (min11, annotations4) => (self) => self.pipe(filter22((a) => a >= min11, {
  schemaId: GreaterThanOrEqualToDateSchemaId,
  [GreaterThanOrEqualToDateSchemaId]: {
    min: min11
  },
  title: `greaterThanOrEqualToDate(${formatDate(min11)})`,
  description: `a date after or equal to ${formatDate(min11)}`,
  ...annotations4
}));
var BetweenDateSchemaId = Symbol.for("effect/SchemaId/BetweenDate");
var betweenDate = (min11, max13, annotations4) => (self) => self.pipe(filter22((a) => a <= max13 && a >= min11, {
  schemaId: BetweenDateSchemaId,
  [BetweenDateSchemaId]: {
    max: max13,
    min: min11
  },
  title: `betweenDate(${formatDate(min11)}, ${formatDate(max13)})`,
  description: `a date between ${formatDate(min11)} and ${formatDate(max13)}`,
  ...annotations4
}));
var DateFromSelfSchemaId2 = DateFromSelfSchemaId;
var DateFromSelf = class extends declare(isDate, {
  identifier: "DateFromSelf",
  schemaId: DateFromSelfSchemaId2,
  [DateFromSelfSchemaId2]: {
    noInvalidDate: false
  },
  description: "a potentially invalid Date instance",
  pretty: () => (date5) => `new Date(${JSON.stringify(date5)})`,
  arbitrary: () => (fc) => fc.date({
    noInvalidDate: false
  }),
  equivalence: () => Date2
}) {
};
var ValidDateFromSelf = class extends DateFromSelf.pipe(validDate({
  identifier: "ValidDateFromSelf",
  description: "a valid Date instance"
})) {
};
var DateFromString = class extends transform3(String$.annotations({
  description: "a string to be decoded into a Date"
}), DateFromSelf, {
  strict: true,
  decode: (i) => new Date(i),
  encode: (a) => formatDate(a)
}).annotations({
  identifier: "DateFromString"
}) {
};
var Date$ = class extends DateFromString.pipe(validDate({
  identifier: "Date"
})) {
};
var DateFromNumber = class extends transform3(Number$.annotations({
  description: "a number to be decoded into a Date"
}), DateFromSelf, {
  strict: true,
  decode: (i) => new Date(i),
  encode: (a) => a.getTime()
}).annotations({
  identifier: "DateFromNumber"
}) {
};
var DateTimeUtcFromSelf = class extends declare((u) => isDateTime2(u) && isUtc2(u), {
  identifier: "DateTimeUtcFromSelf",
  description: "a DateTime.Utc instance",
  pretty: () => (dateTime) => dateTime.toString(),
  arbitrary: () => (fc) => fc.date({
    noInvalidDate: true
  }).map((date5) => unsafeFromDate2(date5)),
  equivalence: () => Equivalence9
}) {
};
var decodeDateTimeUtc = (input, ast) => _try({
  try: () => unsafeMake14(input),
  catch: () => new Type2(ast, input, `Unable to decode ${formatUnknown(input)} into a DateTime.Utc`)
});
var DateTimeUtcFromNumber = class extends transformOrFail(Number$.annotations({
  description: "a number to be decoded into a DateTime.Utc"
}), DateTimeUtcFromSelf, {
  strict: true,
  decode: (i, _, ast) => decodeDateTimeUtc(i, ast),
  encode: (a) => succeed24(toEpochMillis2(a))
}).annotations({
  identifier: "DateTimeUtcFromNumber"
}) {
};
var DateTimeUtcFromDate = class extends transformOrFail(DateFromSelf.annotations({
  description: "a Date to be decoded into a DateTime.Utc"
}), DateTimeUtcFromSelf, {
  strict: true,
  decode: (i, _, ast) => decodeDateTimeUtc(i, ast),
  encode: (a) => succeed24(toDateUtc2(a))
}).annotations({
  identifier: "DateTimeUtcFromDate"
}) {
};
var DateTimeUtc = class extends transformOrFail(String$.annotations({
  description: "a string to be decoded into a DateTime.Utc"
}), DateTimeUtcFromSelf, {
  strict: true,
  decode: (i, _, ast) => decodeDateTimeUtc(i, ast),
  encode: (a) => succeed24(formatIso3(a))
}).annotations({
  identifier: "DateTimeUtc"
}) {
};
var timeZoneOffsetArbitrary = () => (fc) => fc.integer({
  min: -12 * 60 * 60 * 1e3,
  max: 14 * 60 * 60 * 1e3
}).map(zoneMakeOffset2);
var TimeZoneOffsetFromSelf = class extends declare(isTimeZoneOffset2, {
  identifier: "TimeZoneOffsetFromSelf",
  description: "a TimeZone.Offset instance",
  pretty: () => (zone) => zone.toString(),
  arbitrary: timeZoneOffsetArbitrary
}) {
};
var TimeZoneOffset = class extends transform3(Number$.annotations({
  description: "a number to be decoded into a TimeZone.Offset"
}), TimeZoneOffsetFromSelf, {
  strict: true,
  decode: (i) => zoneMakeOffset2(i),
  encode: (a) => a.offset
}).annotations({
  identifier: "TimeZoneOffset"
}) {
};
var timeZoneNamedArbitrary = () => (fc) => fc.constantFrom(...Intl.supportedValuesOf("timeZone")).map(zoneUnsafeMakeNamed2);
var TimeZoneNamedFromSelf = class extends declare(isTimeZoneNamed2, {
  identifier: "TimeZoneNamedFromSelf",
  description: "a TimeZone.Named instance",
  pretty: () => (zone) => zone.toString(),
  arbitrary: timeZoneNamedArbitrary
}) {
};
var TimeZoneNamed = class extends transformOrFail(String$.annotations({
  description: "a string to be decoded into a TimeZone.Named"
}), TimeZoneNamedFromSelf, {
  strict: true,
  decode: (i, _, ast) => _try({
    try: () => zoneUnsafeMakeNamed2(i),
    catch: () => new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a TimeZone.Named`)
  }),
  encode: (a) => succeed24(a.id)
}).annotations({
  identifier: "TimeZoneNamed"
}) {
};
var TimeZoneFromSelf = class extends Union2(TimeZoneOffsetFromSelf, TimeZoneNamedFromSelf) {
};
var TimeZone = class extends transformOrFail(String$.annotations({
  description: "a string to be decoded into a TimeZone"
}), TimeZoneFromSelf, {
  strict: true,
  decode: (i, _, ast) => match2(zoneFromString2(i), {
    onNone: () => fail23(new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a TimeZone`)),
    onSome: succeed24
  }),
  encode: (a) => succeed24(zoneToString2(a))
}).annotations({
  identifier: "TimeZone"
}) {
};
var timeZoneArbitrary = (fc) => fc.oneof(timeZoneOffsetArbitrary()(fc), timeZoneNamedArbitrary()(fc));
var DateTimeZonedFromSelf = class extends declare((u) => isDateTime2(u) && isZoned2(u), {
  identifier: "DateTimeZonedFromSelf",
  description: "a DateTime.Zoned instance",
  pretty: () => (dateTime) => dateTime.toString(),
  arbitrary: () => (fc) => fc.tuple(fc.integer({
    // time zone db supports +/- 1000 years or so
    min: -31536e9,
    max: 31536e9
  }), timeZoneArbitrary(fc)).map(([millis2, timeZone]) => unsafeMakeZoned2(millis2, {
    timeZone
  })),
  equivalence: () => Equivalence9
}) {
};
var DateTimeZoned = class extends transformOrFail(String$.annotations({
  description: "a string to be decoded into a DateTime.Zoned"
}), DateTimeZonedFromSelf, {
  strict: true,
  decode: (i, _, ast) => match2(makeZonedFromString2(i), {
    onNone: () => fail23(new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a DateTime.Zoned`)),
    onSome: succeed24
  }),
  encode: (a) => succeed24(formatIsoZoned2(a))
}).annotations({
  identifier: "DateTimeZoned"
}) {
};
var OptionNoneEncoded = Struct({
  _tag: Literal2("None")
}).annotations({
  description: "NoneEncoded"
});
var optionSomeEncoded = (value10) => Struct({
  _tag: Literal2("Some"),
  value: value10
}).annotations({
  description: `SomeEncoded<${format7(value10)}>`
});
var optionEncoded = (value10) => Union2(OptionNoneEncoded, optionSomeEncoded(value10)).annotations({
  description: `OptionEncoded<${format7(value10)}>`
});
var optionDecode = (input) => input._tag === "None" ? none2() : some3(input.value);
var optionArbitrary = (value10, ctx) => (fc) => fc.oneof(ctx, fc.record({
  _tag: fc.constant("None")
}), fc.record({
  _tag: fc.constant("Some"),
  value: value10(fc)
})).map(optionDecode);
var optionPretty = (value10) => match2({
  onNone: () => "none()",
  onSome: (a) => `some(${value10(a)})`
});
var optionParse = (decodeUnknown4) => (u, options, ast) => isOption2(u) ? isNone2(u) ? succeed24(none2()) : toComposite(decodeUnknown4(u.value, options), some3, ast, u) : fail23(new Type2(ast, u));
var OptionFromSelf = (value10) => {
  return declare([value10], {
    decode: (value11) => optionParse(decodeUnknown2(value11)),
    encode: (value11) => optionParse(encodeUnknown(value11))
  }, {
    description: `Option<${format7(value10)}>`,
    pretty: optionPretty,
    arbitrary: optionArbitrary,
    equivalence: getEquivalence2
  });
};
var makeNoneEncoded = {
  _tag: "None"
};
var makeSomeEncoded = (value10) => ({
  _tag: "Some",
  value: value10
});
function Option(value10) {
  const value_ = asSchema(value10);
  const out = transform3(optionEncoded(value_), OptionFromSelf(typeSchema(value_)), {
    strict: true,
    decode: (i) => optionDecode(i),
    encode: (a) => match2(a, {
      onNone: () => makeNoneEncoded,
      onSome: makeSomeEncoded
    })
  });
  return out;
}
function OptionFromNullOr(value10) {
  return transform3(NullOr(value10), OptionFromSelf(typeSchema(asSchema(value10))), {
    strict: true,
    decode: (i) => fromNullable2(i),
    encode: (a) => getOrNull2(a)
  });
}
function OptionFromNullishOr(value10, onNoneEncoding) {
  return transform3(NullishOr(value10), OptionFromSelf(typeSchema(asSchema(value10))), {
    strict: true,
    decode: (i) => fromNullable2(i),
    encode: onNoneEncoding === null ? (a) => getOrNull2(a) : (a) => getOrUndefined2(a)
  });
}
function OptionFromUndefinedOr(value10) {
  return transform3(UndefinedOr(value10), OptionFromSelf(typeSchema(asSchema(value10))), {
    strict: true,
    decode: (i) => fromNullable2(i),
    encode: (a) => getOrUndefined2(a)
  });
}
var OptionFromNonEmptyTrimmedString = class extends transform3(String$, OptionFromSelf(NonEmptyTrimmedString), {
  strict: true,
  decode: (i) => filter(some3(i.trim()), isNonEmpty7),
  encode: (a) => getOrElse2(a, () => "")
}) {
};
var rightEncoded = (right3) => Struct({
  _tag: Literal2("Right"),
  right: right3
}).annotations({
  description: `RightEncoded<${format7(right3)}>`
});
var leftEncoded = (left3) => Struct({
  _tag: Literal2("Left"),
  left: left3
}).annotations({
  description: `LeftEncoded<${format7(left3)}>`
});
var eitherEncoded = (right3, left3) => Union2(rightEncoded(right3), leftEncoded(left3)).annotations({
  description: `EitherEncoded<${format7(left3)}, ${format7(right3)}>`
});
var eitherDecode = (input) => input._tag === "Left" ? left2(input.left) : right2(input.right);
var eitherArbitrary = (right3, left3) => (fc) => fc.oneof(fc.record({
  _tag: fc.constant("Left"),
  left: left3(fc)
}), fc.record({
  _tag: fc.constant("Right"),
  right: right3(fc)
})).map(eitherDecode);
var eitherPretty = (right3, left3) => match({
  onLeft: (e) => `left(${left3(e)})`,
  onRight: (a) => `right(${right3(a)})`
});
var eitherParse = (parseRight, decodeUnknownLeft) => (u, options, ast) => isEither2(u) ? match(u, {
  onLeft: (left3) => toComposite(decodeUnknownLeft(left3, options), left2, ast, u),
  onRight: (right3) => toComposite(parseRight(right3, options), right2, ast, u)
}) : fail23(new Type2(ast, u));
var EitherFromSelf = ({
  left: left3,
  right: right3
}) => {
  return declare([right3, left3], {
    decode: (right4, left4) => eitherParse(decodeUnknown2(right4), decodeUnknown2(left4)),
    encode: (right4, left4) => eitherParse(encodeUnknown(right4), encodeUnknown(left4))
  }, {
    description: `Either<${format7(right3)}, ${format7(left3)}>`,
    pretty: eitherPretty,
    arbitrary: eitherArbitrary,
    equivalence: (right4, left4) => getEquivalence({
      left: left4,
      right: right4
    })
  });
};
var makeLeftEncoded = (left3) => ({
  _tag: "Left",
  left: left3
});
var makeRightEncoded = (right3) => ({
  _tag: "Right",
  right: right3
});
var Either3 = ({
  left: left3,
  right: right3
}) => {
  const right_ = asSchema(right3);
  const left_ = asSchema(left3);
  const out = transform3(eitherEncoded(right_, left_), EitherFromSelf({
    left: typeSchema(left_),
    right: typeSchema(right_)
  }), {
    strict: true,
    decode: (i) => eitherDecode(i),
    encode: (a) => match(a, {
      onLeft: makeLeftEncoded,
      onRight: makeRightEncoded
    })
  });
  return out;
};
var EitherFromUnion = ({
  left: left3,
  right: right3
}) => {
  const right_ = asSchema(right3);
  const left_ = asSchema(left3);
  const toright = typeSchema(right_);
  const toleft = typeSchema(left_);
  const fromRight = transform3(right_, rightEncoded(toright), {
    strict: true,
    decode: (i) => makeRightEncoded(i),
    encode: (a) => a.right
  });
  const fromLeft = transform3(left_, leftEncoded(toleft), {
    strict: true,
    decode: (i) => makeLeftEncoded(i),
    encode: (a) => a.left
  });
  const out = transform3(Union2(fromRight, fromLeft), EitherFromSelf({
    left: toleft,
    right: toright
  }), {
    strict: true,
    decode: (i) => i._tag === "Left" ? left2(i.left) : right2(i.right),
    encode: (a) => match(a, {
      onLeft: makeLeftEncoded,
      onRight: makeRightEncoded
    })
  });
  return out;
};
var mapArbitrary = (key, value10, ctx) => {
  return (fc) => {
    const items = fc.array(fc.tuple(key(fc), value10(fc)));
    return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map((as18) => new Map(as18));
  };
};
var readonlyMapPretty = (key, value10) => (map49) => `new Map([${Array.from(map49.entries()).map(([k, v]) => `[${key(k)}, ${value10(v)}]`).join(", ")}])`;
var readonlyMapEquivalence = (key, value10) => {
  const arrayEquivalence = getEquivalence5(make(([ka, va], [kb, vb]) => key(ka, kb) && value10(va, vb)));
  return make((a, b) => arrayEquivalence(Array.from(a.entries()), Array.from(b.entries())));
};
var readonlyMapParse = (decodeUnknown4) => (u, options, ast) => isMap(u) ? toComposite(decodeUnknown4(Array.from(u.entries()), options), (as18) => new Map(as18), ast, u) : fail23(new Type2(ast, u));
var mapFromSelf_ = (key, value10, description) => declare([key, value10], {
  decode: (Key2, Value2) => readonlyMapParse(decodeUnknown2(Array$(Tuple(Key2, Value2)))),
  encode: (Key2, Value2) => readonlyMapParse(encodeUnknown(Array$(Tuple(Key2, Value2))))
}, {
  description,
  pretty: readonlyMapPretty,
  arbitrary: mapArbitrary,
  equivalence: readonlyMapEquivalence
});
var ReadonlyMapFromSelf = ({
  key,
  value: value10
}) => mapFromSelf_(key, value10, `ReadonlyMap<${format7(key)}, ${format7(value10)}>`);
var MapFromSelf = ({
  key,
  value: value10
}) => mapFromSelf_(key, value10, `Map<${format7(key)}, ${format7(value10)}>`);
function ReadonlyMap({
  key,
  value: value10
}) {
  return transform3(Array$(Tuple(key, value10)), ReadonlyMapFromSelf({
    key: typeSchema(asSchema(key)),
    value: typeSchema(asSchema(value10))
  }), {
    strict: true,
    decode: (i) => new Map(i),
    encode: (a) => Array.from(a.entries())
  });
}
function map41({
  key,
  value: value10
}) {
  return transform3(Array$(Tuple(key, value10)), MapFromSelf({
    key: typeSchema(asSchema(key)),
    value: typeSchema(asSchema(value10))
  }), {
    strict: true,
    decode: (i) => new Map(i),
    encode: (a) => Array.from(a.entries())
  });
}
var ReadonlyMapFromRecord = ({
  key,
  value: value10
}) => transform3(Record({
  key: encodedBoundSchema(key),
  value: value10
}).annotations({
  description: "a record to be decoded into a ReadonlyMap"
}), ReadonlyMapFromSelf({
  key,
  value: typeSchema(value10)
}), {
  strict: true,
  decode: (i) => new Map(Object.entries(i)),
  encode: (a) => Object.fromEntries(a)
});
var MapFromRecord = ({
  key,
  value: value10
}) => transform3(Record({
  key: encodedBoundSchema(key),
  value: value10
}).annotations({
  description: "a record to be decoded into a Map"
}), MapFromSelf({
  key,
  value: typeSchema(value10)
}), {
  strict: true,
  decode: (i) => new Map(Object.entries(i)),
  encode: (a) => Object.fromEntries(a)
});
var setArbitrary = (item, ctx) => (fc) => {
  const items = fc.array(item(fc));
  return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map((as18) => new Set(as18));
};
var readonlySetPretty = (item) => (set26) => `new Set([${Array.from(set26.values()).map((a) => item(a)).join(", ")}])`;
var readonlySetEquivalence = (item) => {
  const arrayEquivalence = getEquivalence5(item);
  return make((a, b) => arrayEquivalence(Array.from(a.values()), Array.from(b.values())));
};
var readonlySetParse = (decodeUnknown4) => (u, options, ast) => isSet(u) ? toComposite(decodeUnknown4(Array.from(u.values()), options), (as18) => new Set(as18), ast, u) : fail23(new Type2(ast, u));
var setFromSelf_ = (value10, description) => declare([value10], {
  decode: (item) => readonlySetParse(decodeUnknown2(Array$(item))),
  encode: (item) => readonlySetParse(encodeUnknown(Array$(item)))
}, {
  description,
  pretty: readonlySetPretty,
  arbitrary: setArbitrary,
  equivalence: readonlySetEquivalence
});
var ReadonlySetFromSelf = (value10) => setFromSelf_(value10, `ReadonlySet<${format7(value10)}>`);
var SetFromSelf = (value10) => setFromSelf_(value10, `Set<${format7(value10)}>`);
function ReadonlySet(value10) {
  return transform3(Array$(value10), ReadonlySetFromSelf(typeSchema(asSchema(value10))), {
    strict: true,
    decode: (i) => new Set(i),
    encode: (a) => Array.from(a)
  });
}
function set15(value10) {
  return transform3(Array$(value10), SetFromSelf(typeSchema(asSchema(value10))), {
    strict: true,
    decode: (i) => new Set(i),
    encode: (a) => Array.from(a)
  });
}
var bigDecimalPretty = () => (val) => `BigDecimal(${format2(normalize(val))})`;
var bigDecimalArbitrary = () => (fc) => fc.tuple(fc.bigInt(), fc.integer({
  min: 0,
  max: 18
})).map(([value10, scale2]) => make6(value10, scale2));
var BigDecimalFromSelf = class extends declare(isBigDecimal, {
  identifier: "BigDecimalFromSelf",
  pretty: bigDecimalPretty,
  arbitrary: bigDecimalArbitrary,
  equivalence: () => Equivalence2
}) {
};
var BigDecimal = class extends transformOrFail(String$.annotations({
  description: "a string to be decoded into a BigDecimal"
}), BigDecimalFromSelf, {
  strict: true,
  decode: (i, _, ast) => fromString(i).pipe(match2({
    onNone: () => fail23(new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a BigDecimal`)),
    onSome: (val) => succeed24(normalize(val))
  })),
  encode: (a) => succeed24(format2(normalize(a)))
}).annotations({
  identifier: "BigDecimal"
}) {
};
var BigDecimalFromNumber = class extends transform3(Number$.annotations({
  description: "a number to be decoded into a BigDecimal"
}), BigDecimalFromSelf, {
  strict: true,
  decode: (i) => unsafeFromNumber(i),
  encode: (a) => unsafeToNumber(a)
}).annotations({
  identifier: "BigDecimalFromNumber"
}) {
};
var GreaterThanBigDecimalSchemaId = Symbol.for("effect/SchemaId/GreaterThanBigDecimal");
var greaterThanBigDecimal = (min11, annotations4) => (self) => {
  const formatted = format2(min11);
  return self.pipe(filter22((a) => greaterThan3(a, min11), {
    schemaId: GreaterThanBigDecimalSchemaId,
    [GreaterThanBigDecimalSchemaId]: {
      min: min11
    },
    title: `greaterThanBigDecimal(${formatted})`,
    description: `a BigDecimal greater than ${formatted}`,
    ...annotations4
  }));
};
var GreaterThanOrEqualToBigDecimalSchemaId = Symbol.for("effect/schema/GreaterThanOrEqualToBigDecimal");
var greaterThanOrEqualToBigDecimal = (min11, annotations4) => (self) => {
  const formatted = format2(min11);
  return self.pipe(filter22((a) => greaterThanOrEqualTo3(a, min11), {
    schemaId: GreaterThanOrEqualToBigDecimalSchemaId,
    [GreaterThanOrEqualToBigDecimalSchemaId]: {
      min: min11
    },
    title: `greaterThanOrEqualToBigDecimal(${formatted})`,
    description: `a BigDecimal greater than or equal to ${formatted}`,
    ...annotations4
  }));
};
var LessThanBigDecimalSchemaId = Symbol.for("effect/SchemaId/LessThanBigDecimal");
var lessThanBigDecimal = (max13, annotations4) => (self) => {
  const formatted = format2(max13);
  return self.pipe(filter22((a) => lessThan3(a, max13), {
    schemaId: LessThanBigDecimalSchemaId,
    [LessThanBigDecimalSchemaId]: {
      max: max13
    },
    title: `lessThanBigDecimal(${formatted})`,
    description: `a BigDecimal less than ${formatted}`,
    ...annotations4
  }));
};
var LessThanOrEqualToBigDecimalSchemaId = Symbol.for("effect/schema/LessThanOrEqualToBigDecimal");
var lessThanOrEqualToBigDecimal = (max13, annotations4) => (self) => {
  const formatted = format2(max13);
  return self.pipe(filter22((a) => lessThanOrEqualTo3(a, max13), {
    schemaId: LessThanOrEqualToBigDecimalSchemaId,
    [LessThanOrEqualToBigDecimalSchemaId]: {
      max: max13
    },
    title: `lessThanOrEqualToBigDecimal(${formatted})`,
    description: `a BigDecimal less than or equal to ${formatted}`,
    ...annotations4
  }));
};
var PositiveBigDecimalSchemaId = Symbol.for("effect/schema/PositiveBigDecimal");
var positiveBigDecimal = (annotations4) => (self) => self.pipe(filter22((a) => isPositive(a), {
  schemaId: PositiveBigDecimalSchemaId,
  title: "positiveBigDecimal",
  description: `a positive BigDecimal`,
  ...annotations4
}));
var PositiveBigDecimalFromSelf = BigDecimalFromSelf.pipe(positiveBigDecimal({
  identifier: "PositiveBigDecimalFromSelf"
}));
var NonNegativeBigDecimalSchemaId = Symbol.for("effect/schema/NonNegativeBigDecimal");
var nonNegativeBigDecimal = (annotations4) => (self) => self.pipe(filter22((a) => a.value >= 0n, {
  schemaId: NonNegativeBigDecimalSchemaId,
  title: "nonNegativeBigDecimal",
  description: `a non-negative BigDecimal`,
  ...annotations4
}));
var NonNegativeBigDecimalFromSelf = BigDecimalFromSelf.pipe(nonNegativeBigDecimal({
  identifier: "NonNegativeBigDecimalFromSelf"
}));
var NegativeBigDecimalSchemaId = Symbol.for("effect/schema/NegativeBigDecimal");
var negativeBigDecimal = (annotations4) => (self) => self.pipe(filter22((a) => isNegative(a), {
  schemaId: NegativeBigDecimalSchemaId,
  title: "negativeBigDecimal",
  description: `a negative BigDecimal`,
  ...annotations4
}));
var NegativeBigDecimalFromSelf = BigDecimalFromSelf.pipe(negativeBigDecimal({
  identifier: "NegativeBigDecimalFromSelf"
}));
var NonPositiveBigDecimalSchemaId = Symbol.for("effect/schema/NonPositiveBigDecimal");
var nonPositiveBigDecimal = (annotations4) => (self) => self.pipe(filter22((a) => a.value <= 0n, {
  schemaId: NonPositiveBigDecimalSchemaId,
  title: "nonPositiveBigDecimal",
  description: `a non-positive BigDecimal`,
  ...annotations4
}));
var NonPositiveBigDecimalFromSelf = BigDecimalFromSelf.pipe(nonPositiveBigDecimal({
  identifier: "NonPositiveBigDecimalFromSelf"
}));
var BetweenBigDecimalSchemaId = Symbol.for("effect/SchemaId/BetweenBigDecimal");
var betweenBigDecimal = (minimum, maximum, annotations4) => (self) => {
  const formattedMinimum = format2(minimum);
  const formattedMaximum = format2(maximum);
  return self.pipe(filter22((a) => between3(a, {
    minimum,
    maximum
  }), {
    schemaId: BetweenBigDecimalSchemaId,
    [BetweenBigDecimalSchemaId]: {
      maximum,
      minimum
    },
    title: `betweenBigDecimal(${formattedMinimum}, ${formattedMaximum})`,
    description: `a BigDecimal between ${formattedMinimum} and ${formattedMaximum}`,
    ...annotations4
  }));
};
var clampBigDecimal = (minimum, maximum) => (self) => transform3(self, self.pipe(typeSchema, betweenBigDecimal(minimum, maximum)), {
  strict: false,
  decode: (i) => clamp4(i, {
    minimum,
    maximum
  }),
  encode: identity
});
var chunkArbitrary = (item, ctx) => (fc) => {
  const items = fc.array(item(fc));
  return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map(fromIterable3);
};
var chunkPretty = (item) => (c) => `Chunk(${toReadonlyArray(c).map(item).join(", ")})`;
var chunkParse = (decodeUnknown4) => (u, options, ast) => isChunk(u) ? isEmpty2(u) ? succeed24(empty7()) : toComposite(decodeUnknown4(toReadonlyArray(u), options), fromIterable3, ast, u) : fail23(new Type2(ast, u));
var ChunkFromSelf = (value10) => {
  return declare([value10], {
    decode: (item) => chunkParse(decodeUnknown2(Array$(item))),
    encode: (item) => chunkParse(encodeUnknown(Array$(item)))
  }, {
    description: `Chunk<${format7(value10)}>`,
    pretty: chunkPretty,
    arbitrary: chunkArbitrary,
    equivalence: getEquivalence6
  });
};
function Chunk(value10) {
  return transform3(Array$(value10), ChunkFromSelf(typeSchema(asSchema(value10))), {
    strict: true,
    decode: (i) => i.length === 0 ? empty7() : fromIterable3(i),
    encode: (a) => toReadonlyArray(a)
  });
}
var nonEmptyChunkArbitrary = (item) => (fc) => array4(item(fc), {
  minLength: 1
}).map((as18) => unsafeFromNonEmptyArray(as18));
var nonEmptyChunkPretty = (item) => (c) => `NonEmptyChunk(${toReadonlyArray(c).map(item).join(", ")})`;
var nonEmptyChunkParse = (decodeUnknown4) => (u, options, ast) => isChunk(u) && isNonEmpty2(u) ? toComposite(decodeUnknown4(toReadonlyArray(u), options), unsafeFromNonEmptyArray, ast, u) : fail23(new Type2(ast, u));
var NonEmptyChunkFromSelf = (value10) => {
  return declare([value10], {
    decode: (item) => nonEmptyChunkParse(decodeUnknown2(NonEmptyArray(item))),
    encode: (item) => nonEmptyChunkParse(encodeUnknown(NonEmptyArray(item)))
  }, {
    description: `NonEmptyChunk<${format7(value10)}>`,
    pretty: nonEmptyChunkPretty,
    arbitrary: nonEmptyChunkArbitrary,
    equivalence: getEquivalence6
  });
};
function NonEmptyChunk(value10) {
  return transform3(NonEmptyArray(value10), NonEmptyChunkFromSelf(typeSchema(asSchema(value10))), {
    strict: true,
    decode: (i) => unsafeFromNonEmptyArray(i),
    encode: (a) => toReadonlyArray(a)
  });
}
var decodeData = (a) => Array.isArray(a) ? array5(a) : struct5(a);
var dataArbitrary = (item) => (fc) => item(fc).map(decodeData);
var dataPretty = (item) => (d) => `Data(${item(d)})`;
var dataParse = (decodeUnknown4) => (u, options, ast) => isEqual(u) ? toComposite(decodeUnknown4(u, options), decodeData, ast, u) : fail23(new Type2(ast, u));
var DataFromSelf = (value10) => {
  return declare([value10], {
    decode: (item) => dataParse(decodeUnknown2(item)),
    encode: (item) => dataParse(encodeUnknown(item))
  }, {
    description: `Data<${format7(value10)}>`,
    pretty: dataPretty,
    arbitrary: dataArbitrary
  });
};
var Data = (value10) => {
  return transform3(value10, DataFromSelf(typeSchema(value10)), {
    strict: false,
    decode: (i) => decodeData(i),
    encode: (a) => Array.isArray(a) ? Array.from(a) : Object.assign({}, a)
  });
};
var isField = (u) => isSchema(u) || isPropertySignature(u);
var isFields = (fields) => ownKeys(fields).every((key) => isField(fields[key]));
var getFields = (hasFields) => "fields" in hasFields ? hasFields.fields : getFields(hasFields[RefineSchemaId]);
var getSchemaFromFieldsOr = (fieldsOr) => isFields(fieldsOr) ? Struct(fieldsOr) : isSchema(fieldsOr) ? fieldsOr : Struct(getFields(fieldsOr));
var getFieldsFromFieldsOr = (fieldsOr) => isFields(fieldsOr) ? fieldsOr : getFields(fieldsOr);
var Class7 = (identifier2) => (fieldsOr, annotations4) => makeClass({
  kind: "Class",
  identifier: identifier2,
  schema: getSchemaFromFieldsOr(fieldsOr),
  fields: getFieldsFromFieldsOr(fieldsOr),
  Base: Class5,
  annotations: annotations4
});
var getClassTag = (tag5) => withConstructorDefault(propertySignature(Literal2(tag5)), () => tag5);
var TaggedClass4 = (identifier2) => (tag5, fieldsOr, annotations4) => {
  const fields = getFieldsFromFieldsOr(fieldsOr);
  const schema = getSchemaFromFieldsOr(fieldsOr);
  const newFields = {
    _tag: getClassTag(tag5)
  };
  const taggedFields = extendFields(newFields, fields);
  return class TaggedClass extends makeClass({
    kind: "TaggedClass",
    identifier: identifier2 ?? tag5,
    schema: extend4(schema, Struct(newFields)),
    fields: taggedFields,
    Base: Class5,
    annotations: annotations4
  }) {
    static _tag = tag5;
  };
};
var TaggedError3 = (identifier2) => (tag5, fieldsOr, annotations4) => {
  class Base4 extends Error4 {
  }
  ;
  Base4.prototype.name = tag5;
  const fields = getFieldsFromFieldsOr(fieldsOr);
  const schema = getSchemaFromFieldsOr(fieldsOr);
  const newFields = {
    _tag: getClassTag(tag5)
  };
  const taggedFields = extendFields(newFields, fields);
  const hasMessageField = "message" in taggedFields;
  class TaggedErrorClass extends makeClass({
    kind: "TaggedError",
    identifier: identifier2 ?? tag5,
    schema: extend4(schema, Struct(newFields)),
    fields: taggedFields,
    Base: Base4,
    annotations: annotations4,
    disableToString: true
  }) {
    static _tag = tag5;
  }
  if (!hasMessageField) {
    Object.defineProperty(TaggedErrorClass.prototype, "message", {
      get() {
        return `{ ${ownKeys(fields).map((p) => `${formatPropertyKey(p)}: ${formatUnknown(this[p])}`).join(", ")} }`;
      },
      enumerable: false,
      // mirrors the built-in Error.prototype.message, whose descriptor is also non-enumerable
      configurable: true
    });
  }
  return TaggedErrorClass;
};
var extendFields = (a, b) => {
  const out = {
    ...a
  };
  for (const key of ownKeys(b)) {
    if (key in a) {
      throw new Error(getASTDuplicatePropertySignatureErrorMessage(key));
    }
    out[key] = b[key];
  }
  return out;
};
function getDisableValidationMakeOption(options) {
  return isBoolean(options) ? options : options?.disableValidation ?? false;
}
var astCache = globalValue("effect/Schema/astCache", () => /* @__PURE__ */ new WeakMap());
var getClassAnnotations = (annotations4) => {
  if (annotations4 === void 0) {
    return [];
  } else if (Array.isArray(annotations4)) {
    return annotations4;
  } else {
    return [annotations4];
  }
};
var makeClass = ({
  Base: Base4,
  annotations: annotations4,
  disableToString,
  fields,
  identifier: identifier2,
  kind,
  schema
}) => {
  const classSymbol = Symbol.for(`effect/Schema/${kind}/${identifier2}`);
  const [typeAnnotations, transformationAnnotations, encodedAnnotations] = getClassAnnotations(annotations4);
  const typeSchema_ = typeSchema(schema);
  const declarationSurrogate = typeSchema_.annotations({
    identifier: identifier2,
    ...typeAnnotations
  });
  const typeSide = typeSchema_.annotations({
    [AutoTitleAnnotationId]: `${identifier2} (Type side)`,
    ...typeAnnotations
  });
  const constructorSchema = schema.annotations({
    [AutoTitleAnnotationId]: `${identifier2} (Constructor)`,
    ...typeAnnotations
  });
  const encodedSide = schema.annotations({
    [AutoTitleAnnotationId]: `${identifier2} (Encoded side)`,
    ...encodedAnnotations
  });
  const transformationSurrogate = schema.annotations({
    [JSONIdentifierAnnotationId]: identifier2,
    ...encodedAnnotations,
    ...typeAnnotations,
    ...transformationAnnotations
  });
  const fallbackInstanceOf = (u) => hasProperty(u, classSymbol) && is(typeSide)(u);
  const klass = class extends Base4 {
    constructor(props = {}, options = false) {
      props = {
        ...props
      };
      if (kind !== "Class") {
        delete props["_tag"];
      }
      props = lazilyMergeDefaults(fields, props);
      if (!getDisableValidationMakeOption(options)) {
        props = validateSync(constructorSchema)(props);
      }
      super(props, true);
    }
    // ----------------
    // Schema interface
    // ----------------
    static [TypeId39] = variance11;
    static get ast() {
      let out = astCache.get(this);
      if (out) {
        return out;
      }
      const declaration = declare([schema], {
        decode: () => (input, _, ast) => input instanceof this || fallbackInstanceOf(input) ? succeed24(input) : fail23(new Type2(ast, input)),
        encode: () => (input, options) => input instanceof this ? succeed24(input) : map37(encodeUnknown(typeSide)(input, options), (props) => new this(props, true))
      }, {
        identifier: identifier2,
        pretty: (pretty6) => (self) => `${identifier2}(${pretty6(self)})`,
        // @ts-expect-error
        arbitrary: (arb) => (fc) => arb(fc).map((props) => new this(props)),
        equivalence: identity,
        [SurrogateAnnotationId]: declarationSurrogate.ast,
        ...typeAnnotations
      });
      out = transform3(encodedSide, declaration, {
        strict: true,
        decode: (i) => new this(i, true),
        encode: identity
      }).annotations({
        [SurrogateAnnotationId]: transformationSurrogate.ast,
        ...transformationAnnotations
      }).ast;
      astCache.set(this, out);
      return out;
    }
    static pipe() {
      return pipeArguments(this, arguments);
    }
    static annotations(annotations5) {
      return make113(this.ast).annotations(annotations5);
    }
    static toString() {
      return `(${String(encodedSide)} <-> ${identifier2})`;
    }
    // ----------------
    // Class interface
    // ----------------
    static make(...args2) {
      return new this(...args2);
    }
    static fields = {
      ...fields
    };
    static identifier = identifier2;
    static extend(identifier3) {
      return (newFieldsOr, annotations5) => {
        const newFields = getFieldsFromFieldsOr(newFieldsOr);
        const newSchema = getSchemaFromFieldsOr(newFieldsOr);
        const extendedFields = extendFields(fields, newFields);
        return makeClass({
          kind,
          identifier: identifier3,
          schema: extend4(schema, newSchema),
          fields: extendedFields,
          Base: this,
          annotations: annotations5
        });
      };
    }
    static transformOrFail(identifier3) {
      return (newFieldsOr, options, annotations5) => {
        const transformedFields = extendFields(fields, newFieldsOr);
        return makeClass({
          kind,
          identifier: identifier3,
          schema: transformOrFail(schema, typeSchema(Struct(transformedFields)), options),
          fields: transformedFields,
          Base: this,
          annotations: annotations5
        });
      };
    }
    static transformOrFailFrom(identifier3) {
      return (newFields, options, annotations5) => {
        const transformedFields = extendFields(fields, newFields);
        return makeClass({
          kind,
          identifier: identifier3,
          schema: transformOrFail(encodedSchema(schema), Struct(transformedFields), options),
          fields: transformedFields,
          Base: this,
          annotations: annotations5
        });
      };
    }
    // ----------------
    // other
    // ----------------
    get [classSymbol]() {
      return classSymbol;
    }
  };
  if (disableToString !== true) {
    Object.defineProperty(klass.prototype, "toString", {
      value() {
        return `${identifier2}({ ${ownKeys(fields).map((p) => `${formatPropertyKey(p)}: ${formatUnknown(this[p])}`).join(", ")} })`;
      },
      configurable: true,
      writable: true
    });
  }
  return klass;
};
var FiberIdNoneEncoded = Struct({
  _tag: Literal2("None")
}).annotations({
  identifier: "FiberIdNoneEncoded"
});
var FiberIdRuntimeEncoded = Struct({
  _tag: Literal2("Runtime"),
  id: Int,
  startTimeMillis: Int
}).annotations({
  identifier: "FiberIdRuntimeEncoded"
});
var FiberIdCompositeEncoded = Struct({
  _tag: Literal2("Composite"),
  left: suspend15(() => FiberIdEncoded),
  right: suspend15(() => FiberIdEncoded)
}).annotations({
  identifier: "FiberIdCompositeEncoded"
});
var FiberIdEncoded = Union2(FiberIdNoneEncoded, FiberIdRuntimeEncoded, FiberIdCompositeEncoded).annotations({
  identifier: "FiberIdEncoded"
});
var fiberIdArbitrary = (fc) => fc.letrec((tie) => ({
  None: fc.record({
    _tag: fc.constant("None")
  }),
  Runtime: fc.record({
    _tag: fc.constant("Runtime"),
    id: fc.integer(),
    startTimeMillis: fc.integer()
  }),
  Composite: fc.record({
    _tag: fc.constant("Composite"),
    left: tie("FiberId"),
    right: tie("FiberId")
  }),
  FiberId: fc.oneof(tie("None"), tie("Runtime"), tie("Composite"))
})).FiberId.map(fiberIdDecode);
var fiberIdPretty = (fiberId5) => {
  switch (fiberId5._tag) {
    case "None":
      return "FiberId.none";
    case "Runtime":
      return `FiberId.runtime(${fiberId5.id}, ${fiberId5.startTimeMillis})`;
    case "Composite":
      return `FiberId.composite(${fiberIdPretty(fiberId5.right)}, ${fiberIdPretty(fiberId5.left)})`;
  }
};
var FiberIdFromSelf = class extends declare(isFiberId2, {
  identifier: "FiberIdFromSelf",
  pretty: () => fiberIdPretty,
  arbitrary: () => fiberIdArbitrary
}) {
};
var fiberIdDecode = (input) => {
  switch (input._tag) {
    case "None":
      return none4;
    case "Runtime":
      return runtime2(input.id, input.startTimeMillis);
    case "Composite":
      return composite2(fiberIdDecode(input.left), fiberIdDecode(input.right));
  }
};
var fiberIdEncode = (input) => {
  switch (input._tag) {
    case "None":
      return {
        _tag: "None"
      };
    case "Runtime":
      return {
        _tag: "Runtime",
        id: input.id,
        startTimeMillis: input.startTimeMillis
      };
    case "Composite":
      return {
        _tag: "Composite",
        left: fiberIdEncode(input.left),
        right: fiberIdEncode(input.right)
      };
  }
};
var FiberId = class extends transform3(FiberIdEncoded, FiberIdFromSelf, {
  strict: true,
  decode: (i) => fiberIdDecode(i),
  encode: (a) => fiberIdEncode(a)
}).annotations({
  identifier: "FiberId"
}) {
};
var causeDieEncoded = (defect) => Struct({
  _tag: Literal2("Die"),
  defect
});
var CauseEmptyEncoded = Struct({
  _tag: Literal2("Empty")
});
var causeFailEncoded = (error4) => Struct({
  _tag: Literal2("Fail"),
  error: error4
});
var CauseInterruptEncoded = Struct({
  _tag: Literal2("Interrupt"),
  fiberId: FiberIdEncoded
});
var causeEncodedId = 0;
var causeEncoded = (error4, defect) => {
  const error_ = asSchema(error4);
  const defect_ = asSchema(defect);
  const suspended3 = suspend15(() => out);
  const out = Union2(CauseEmptyEncoded, causeFailEncoded(error_), causeDieEncoded(defect_), CauseInterruptEncoded, Struct({
    _tag: Literal2("Sequential"),
    left: suspended3,
    right: suspended3
  }), Struct({
    _tag: Literal2("Parallel"),
    left: suspended3,
    right: suspended3
  })).annotations({
    title: `CauseEncoded<${format7(error4)}>`,
    [JSONIdentifierAnnotationId]: `CauseEncoded${causeEncodedId++}`
  });
  return out;
};
var causeArbitrary = (error4, defect) => (fc) => fc.letrec((tie) => ({
  Empty: fc.record({
    _tag: fc.constant("Empty")
  }),
  Fail: fc.record({
    _tag: fc.constant("Fail"),
    error: error4(fc)
  }),
  Die: fc.record({
    _tag: fc.constant("Die"),
    defect: defect(fc)
  }),
  Interrupt: fc.record({
    _tag: fc.constant("Interrupt"),
    fiberId: fiberIdArbitrary(fc)
  }),
  Sequential: fc.record({
    _tag: fc.constant("Sequential"),
    left: tie("Cause"),
    right: tie("Cause")
  }),
  Parallel: fc.record({
    _tag: fc.constant("Parallel"),
    left: tie("Cause"),
    right: tie("Cause")
  }),
  Cause: fc.oneof(tie("Empty"), tie("Fail"), tie("Die"), tie("Interrupt"), tie("Sequential"), tie("Parallel"))
})).Cause.map(causeDecode);
var causePretty = (error4) => (cause3) => {
  const f = (cause4) => {
    switch (cause4._tag) {
      case "Empty":
        return "Cause.empty";
      case "Fail":
        return `Cause.fail(${error4(cause4.error)})`;
      case "Die":
        return `Cause.die(${pretty3(cause4)})`;
      case "Interrupt":
        return `Cause.interrupt(${fiberIdPretty(cause4.fiberId)})`;
      case "Sequential":
        return `Cause.sequential(${f(cause4.left)}, ${f(cause4.right)})`;
      case "Parallel":
        return `Cause.parallel(${f(cause4.left)}, ${f(cause4.right)})`;
    }
  };
  return f(cause3);
};
var causeParse = (decodeUnknown4) => (u, options, ast) => isCause2(u) ? toComposite(decodeUnknown4(causeEncode(u), options), causeDecode, ast, u) : fail23(new Type2(ast, u));
var CauseFromSelf = ({
  defect,
  error: error4
}) => {
  return declare([error4, defect], {
    decode: (error5, defect2) => causeParse(decodeUnknown2(causeEncoded(error5, defect2))),
    encode: (error5, defect2) => causeParse(encodeUnknown(causeEncoded(error5, defect2)))
  }, {
    title: `Cause<${error4.ast}>`,
    pretty: causePretty,
    arbitrary: causeArbitrary
  });
};
function causeDecode(cause3) {
  switch (cause3._tag) {
    case "Empty":
      return empty35;
    case "Fail":
      return fail8(cause3.error);
    case "Die":
      return die6(cause3.defect);
    case "Interrupt":
      return interrupt6(fiberIdDecode(cause3.fiberId));
    case "Sequential":
      return sequential4(causeDecode(cause3.left), causeDecode(cause3.right));
    case "Parallel":
      return parallel4(causeDecode(cause3.left), causeDecode(cause3.right));
  }
}
function causeEncode(cause3) {
  switch (cause3._tag) {
    case "Empty":
      return {
        _tag: "Empty"
      };
    case "Fail":
      return {
        _tag: "Fail",
        error: cause3.error
      };
    case "Die":
      return {
        _tag: "Die",
        defect: cause3.defect
      };
    case "Interrupt":
      return {
        _tag: "Interrupt",
        fiberId: cause3.fiberId
      };
    case "Sequential":
      return {
        _tag: "Sequential",
        left: causeEncode(cause3.left),
        right: causeEncode(cause3.right)
      };
    case "Parallel":
      return {
        _tag: "Parallel",
        left: causeEncode(cause3.left),
        right: causeEncode(cause3.right)
      };
  }
}
var Cause = ({
  defect,
  error: error4
}) => {
  const error_ = asSchema(error4);
  const defect_ = asSchema(defect);
  const out = transform3(causeEncoded(error_, defect_), CauseFromSelf({
    error: typeSchema(error_),
    defect: typeSchema(defect_)
  }), {
    strict: false,
    decode: (i) => causeDecode(i),
    encode: (a) => causeEncode(a)
  });
  return out;
};
var Defect = class extends transform3(Unknown, Unknown, {
  strict: true,
  decode: (i) => {
    if (isObject(i) && "message" in i && typeof i.message === "string") {
      const err = new Error(i.message, {
        cause: i
      });
      if ("name" in i && typeof i.name === "string") {
        err.name = i.name;
      }
      err.stack = "stack" in i && typeof i.stack === "string" ? i.stack : "";
      return err;
    }
    return String(i);
  },
  encode: (a) => {
    if (a instanceof Error) {
      return {
        name: a.name,
        message: a.message
        // no stack because of security reasons
      };
    }
    return prettyErrorMessage(a);
  }
}).annotations({
  identifier: "Defect"
}) {
};
var exitFailureEncoded = (error4, defect) => Struct({
  _tag: Literal2("Failure"),
  cause: causeEncoded(error4, defect)
});
var exitSuccessEncoded = (value10) => Struct({
  _tag: Literal2("Success"),
  value: value10
});
var exitEncoded = (value10, error4, defect) => {
  return Union2(exitFailureEncoded(error4, defect), exitSuccessEncoded(value10)).annotations({
    title: `ExitEncoded<${format7(value10)}, ${format7(error4)}, ${format7(defect)}>`
  });
};
var exitDecode = (input) => {
  switch (input._tag) {
    case "Failure":
      return failCause3(causeDecode(input.cause));
    case "Success":
      return succeed3(input.value);
  }
};
var exitArbitrary = (value10, error4, defect) => (fc) => fc.oneof(fc.record({
  _tag: fc.constant("Failure"),
  cause: causeArbitrary(error4, defect)(fc)
}), fc.record({
  _tag: fc.constant("Success"),
  value: value10(fc)
})).map(exitDecode);
var exitPretty = (value10, error4) => (exit4) => exit4._tag === "Failure" ? `Exit.failCause(${causePretty(error4)(exit4.cause)})` : `Exit.succeed(${value10(exit4.value)})`;
var exitParse = (decodeUnknownValue, decodeUnknownCause) => (u, options, ast) => isExit(u) ? match7(u, {
  onFailure: (cause3) => toComposite(decodeUnknownCause(cause3, options), failCause3, ast, u),
  onSuccess: (value10) => toComposite(decodeUnknownValue(value10, options), succeed3, ast, u)
}) : fail23(new Type2(ast, u));
var ExitFromSelf = ({
  defect,
  failure,
  success
}) => declare([success, failure, defect], {
  decode: (success2, failure2, defect2) => exitParse(decodeUnknown2(success2), decodeUnknown2(CauseFromSelf({
    error: failure2,
    defect: defect2
  }))),
  encode: (success2, failure2, defect2) => exitParse(encodeUnknown(success2), encodeUnknown(CauseFromSelf({
    error: failure2,
    defect: defect2
  })))
}, {
  title: `Exit<${success.ast}, ${failure.ast}>`,
  pretty: exitPretty,
  arbitrary: exitArbitrary
});
var Exit = ({
  defect,
  failure,
  success
}) => {
  const success_ = asSchema(success);
  const failure_ = asSchema(failure);
  const defect_ = asSchema(defect);
  const out = transform3(exitEncoded(success_, failure_, defect_), ExitFromSelf({
    failure: typeSchema(failure_),
    success: typeSchema(success_),
    defect: typeSchema(defect_)
  }), {
    strict: false,
    decode: (i) => exitDecode(i),
    encode: (a) => a._tag === "Failure" ? {
      _tag: "Failure",
      cause: a.cause
    } : {
      _tag: "Success",
      value: a.value
    }
  });
  return out;
};
var hashSetArbitrary = (item, ctx) => (fc) => {
  const items = fc.array(item(fc));
  return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map(fromIterable6);
};
var hashSetPretty = (item) => (set26) => `HashSet(${Array.from(set26).map((a) => item(a)).join(", ")})`;
var hashSetEquivalence = (item) => {
  const arrayEquivalence = getEquivalence5(item);
  return make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)));
};
var hashSetParse = (decodeUnknown4) => (u, options, ast) => isHashSet2(u) ? toComposite(decodeUnknown4(Array.from(u), options), fromIterable6, ast, u) : fail23(new Type2(ast, u));
var HashSetFromSelf = (value10) => {
  return declare([value10], {
    decode: (item) => hashSetParse(decodeUnknown2(Array$(item))),
    encode: (item) => hashSetParse(encodeUnknown(Array$(item)))
  }, {
    description: `HashSet<${format7(value10)}>`,
    pretty: hashSetPretty,
    arbitrary: hashSetArbitrary,
    equivalence: hashSetEquivalence
  });
};
function HashSet(value10) {
  return transform3(Array$(value10), HashSetFromSelf(typeSchema(asSchema(value10))), {
    strict: true,
    decode: (i) => fromIterable6(i),
    encode: (a) => Array.from(a)
  });
}
var hashMapArbitrary = (key, value10, ctx) => (fc) => {
  const items = fc.array(fc.tuple(key(fc), value10(fc)));
  return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map(fromIterable7);
};
var hashMapPretty = (key, value10) => (map49) => `HashMap([${Array.from(map49).map(([k, v]) => `[${key(k)}, ${value10(v)}]`).join(", ")}])`;
var hashMapEquivalence = (key, value10) => {
  const arrayEquivalence = getEquivalence5(make(([ka, va], [kb, vb]) => key(ka, kb) && value10(va, vb)));
  return make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)));
};
var hashMapParse = (decodeUnknown4) => (u, options, ast) => isHashMap2(u) ? toComposite(decodeUnknown4(Array.from(u), options), fromIterable7, ast, u) : fail23(new Type2(ast, u));
var HashMapFromSelf = ({
  key,
  value: value10
}) => {
  return declare([key, value10], {
    decode: (key2, value11) => hashMapParse(decodeUnknown2(Array$(Tuple(key2, value11)))),
    encode: (key2, value11) => hashMapParse(encodeUnknown(Array$(Tuple(key2, value11))))
  }, {
    description: `HashMap<${format7(key)}, ${format7(value10)}>`,
    pretty: hashMapPretty,
    arbitrary: hashMapArbitrary,
    equivalence: hashMapEquivalence
  });
};
var HashMap = ({
  key,
  value: value10
}) => {
  return transform3(Array$(Tuple(key, value10)), HashMapFromSelf({
    key: typeSchema(asSchema(key)),
    value: typeSchema(asSchema(value10))
  }), {
    strict: true,
    decode: (i) => fromIterable7(i),
    encode: (a) => Array.from(a)
  });
};
var listArbitrary = (item, ctx) => (fc) => {
  const items = fc.array(item(fc));
  return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map(fromIterable8);
};
var listPretty = (item) => (set26) => `List(${Array.from(set26).map((a) => item(a)).join(", ")})`;
var listEquivalence = (item) => {
  const arrayEquivalence = getEquivalence5(item);
  return make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)));
};
var listParse = (decodeUnknown4) => (u, options, ast) => isList(u) ? toComposite(decodeUnknown4(Array.from(u), options), fromIterable8, ast, u) : fail23(new Type2(ast, u));
var ListFromSelf = (value10) => {
  return declare([value10], {
    decode: (item) => listParse(decodeUnknown2(Array$(item))),
    encode: (item) => listParse(encodeUnknown(Array$(item)))
  }, {
    description: `List<${format7(value10)}>`,
    pretty: listPretty,
    arbitrary: listArbitrary,
    equivalence: listEquivalence
  });
};
function List(value10) {
  return transform3(Array$(value10), ListFromSelf(typeSchema(asSchema(value10))), {
    strict: true,
    decode: (i) => fromIterable8(i),
    encode: (a) => Array.from(a)
  });
}
var sortedSetArbitrary = (item, ord, ctx) => (fc) => {
  const items = fc.array(item(fc));
  return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map((as18) => fromIterable14(as18, ord));
};
var sortedSetPretty = (item) => (set26) => `new SortedSet([${Array.from(values9(set26)).map((a) => item(a)).join(", ")}])`;
var sortedSetParse = (decodeUnknown4, ord) => (u, options, ast) => isSortedSet(u) ? toComposite(decodeUnknown4(Array.from(values9(u)), options), (as18) => fromIterable14(as18, ord), ast, u) : fail23(new Type2(ast, u));
var SortedSetFromSelf = (value10, ordA, ordI) => {
  return declare([value10], {
    decode: (item) => sortedSetParse(decodeUnknown2(Array$(item)), ordA),
    encode: (item) => sortedSetParse(encodeUnknown(Array$(item)), ordI)
  }, {
    description: `SortedSet<${format7(value10)}>`,
    pretty: sortedSetPretty,
    arbitrary: (arb, ctx) => sortedSetArbitrary(arb, ordA, ctx),
    equivalence: () => getEquivalence8()
  });
};
function SortedSet(value10, ordA) {
  const to = typeSchema(asSchema(value10));
  return transform3(Array$(value10), SortedSetFromSelf(to, ordA, ordA), {
    strict: true,
    decode: (i) => fromIterable14(i, ordA),
    encode: (a) => Array.from(values9(a))
  });
}
var BooleanFromUnknown = class extends transform3(Unknown, Boolean$, {
  strict: true,
  decode: (i) => isTruthy(i),
  encode: identity
}).annotations({
  identifier: "BooleanFromUnknown"
}) {
};
var BooleanFromString = class extends transform3(Literal2("true", "false").annotations({
  description: "a string to be decoded into a boolean"
}), Boolean$, {
  strict: true,
  decode: (i) => i === "true",
  encode: (a) => a ? "true" : "false"
}).annotations({
  identifier: "BooleanFromString"
}) {
};
var Config = (name, schema) => {
  const decodeUnknownEither3 = decodeUnknownEither(schema);
  return string6(name).pipe(mapOrFail2((s) => decodeUnknownEither3(s).pipe(mapLeft((error4) => InvalidData2([], TreeFormatter.formatIssueSync(error4))))));
};
var symbolSerializable = Symbol.for("effect/Schema/Serializable/symbol");
var asSerializable = (serializable) => serializable;
var serializableSchema = (self) => self[symbolSerializable];
var serialize = (self) => encodeUnknown2(self[symbolSerializable])(self);
var deserialize = dual(2, (self, value10) => decodeUnknown3(self[symbolSerializable])(value10));
var symbolWithResult = Symbol.for("effect/Schema/Serializable/symbolResult");
var asWithResult = (withExit) => withExit;
var failureSchema = (self) => self[symbolWithResult].failure;
var successSchema = (self) => self[symbolWithResult].success;
var exitSchemaCache = globalValue("effect/Schema/Serializable/exitSchemaCache", () => /* @__PURE__ */ new WeakMap());
var exitSchema = (self) => {
  const proto16 = Object.getPrototypeOf(self);
  if (!(symbolWithResult in proto16)) {
    return Exit({
      failure: failureSchema(self),
      success: successSchema(self),
      defect: Defect
    });
  }
  let schema = exitSchemaCache.get(proto16);
  if (schema === void 0) {
    schema = Exit({
      failure: failureSchema(self),
      success: successSchema(self),
      defect: Defect
    });
    exitSchemaCache.set(proto16, schema);
  }
  return schema;
};
var serializeFailure = dual(2, (self, value10) => encode5(self[symbolWithResult].failure)(value10));
var deserializeFailure = dual(2, (self, value10) => decodeUnknown3(self[symbolWithResult].failure)(value10));
var serializeSuccess = dual(2, (self, value10) => encode5(self[symbolWithResult].success)(value10));
var deserializeSuccess = dual(2, (self, value10) => decodeUnknown3(self[symbolWithResult].success)(value10));
var serializeExit = dual(2, (self, value10) => encode5(exitSchema(self))(value10));
var deserializeExit = dual(2, (self, value10) => decodeUnknown3(exitSchema(self))(value10));
var asSerializableWithResult = (procedure) => procedure;
var TaggedRequest = (identifier2) => (tag5, options, annotations4) => {
  const taggedFields = extendFields({
    _tag: getClassTag(tag5)
  }, options.payload);
  return class TaggedRequestClass extends makeClass({
    kind: "TaggedRequest",
    identifier: identifier2 ?? tag5,
    schema: Struct(taggedFields),
    fields: taggedFields,
    Base: Class6,
    annotations: annotations4
  }) {
    static _tag = tag5;
    static success = options.success;
    static failure = options.failure;
    get [symbolSerializable]() {
      return this.constructor;
    }
    get [symbolWithResult]() {
      return {
        failure: options.failure,
        success: options.success
      };
    }
  };
};
var equivalence2 = (schema) => go4(schema.ast, []);
var getEquivalenceAnnotation = getAnnotation(EquivalenceAnnotationId);
var go4 = (ast, path) => {
  const hook = getEquivalenceAnnotation(ast);
  if (isSome2(hook)) {
    switch (ast._tag) {
      case "Declaration":
        return hook.value(...ast.typeParameters.map((tp) => go4(tp, path)));
      case "Refinement":
        return hook.value(go4(ast.from, path));
      default:
        return hook.value();
    }
  }
  switch (ast._tag) {
    case "NeverKeyword":
      throw new Error(getEquivalenceUnsupportedErrorMessage(ast, path));
    case "Transformation":
      return go4(ast.to, path);
    case "Declaration":
    case "Literal":
    case "StringKeyword":
    case "TemplateLiteral":
    case "UniqueSymbol":
    case "SymbolKeyword":
    case "UnknownKeyword":
    case "AnyKeyword":
    case "NumberKeyword":
    case "BooleanKeyword":
    case "BigIntKeyword":
    case "UndefinedKeyword":
    case "VoidKeyword":
    case "Enums":
    case "ObjectKeyword":
      return equals;
    case "Refinement":
      return go4(ast.from, path);
    case "Suspend": {
      const get48 = memoizeThunk(() => go4(ast.f(), path));
      return (a, b) => get48()(a, b);
    }
    case "TupleType": {
      const elements = ast.elements.map((element2, i) => go4(element2.type, path.concat(i)));
      const rest = ast.rest.map((annotatedAST) => go4(annotatedAST.type, path));
      return make((a, b) => {
        if (!Array.isArray(a) || !Array.isArray(b)) {
          return false;
        }
        const len = a.length;
        if (len !== b.length) {
          return false;
        }
        let i = 0;
        for (; i < Math.min(len, ast.elements.length); i++) {
          if (!elements[i](a[i], b[i])) {
            return false;
          }
        }
        if (isNonEmptyReadonlyArray(rest)) {
          const [head13, ...tail5] = rest;
          for (; i < len - tail5.length; i++) {
            if (!head13(a[i], b[i])) {
              return false;
            }
          }
          for (let j = 0; j < tail5.length; j++) {
            i += j;
            if (!tail5[j](a[i], b[i])) {
              return false;
            }
          }
        }
        return true;
      });
    }
    case "TypeLiteral": {
      if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
        return equals;
      }
      const propertySignatures = ast.propertySignatures.map((ps) => go4(ps.type, path.concat(ps.name)));
      const indexSignatures = ast.indexSignatures.map((is4) => go4(is4.type, path));
      return make((a, b) => {
        if (!isRecord(a) || !isRecord(b)) {
          return false;
        }
        const aStringKeys = Object.keys(a);
        const aSymbolKeys = Object.getOwnPropertySymbols(a);
        for (let i = 0; i < propertySignatures.length; i++) {
          const ps = ast.propertySignatures[i];
          const name = ps.name;
          const aHas = Object.prototype.hasOwnProperty.call(a, name);
          const bHas = Object.prototype.hasOwnProperty.call(b, name);
          if (ps.isOptional) {
            if (aHas !== bHas) {
              return false;
            }
          }
          if (aHas && bHas && !propertySignatures[i](a[name], b[name])) {
            return false;
          }
        }
        let bSymbolKeys;
        let bStringKeys;
        for (let i = 0; i < indexSignatures.length; i++) {
          const is4 = ast.indexSignatures[i];
          const encodedParameter = getEncodedParameter(is4.parameter);
          const isSymbol3 = isSymbolKeyword(encodedParameter);
          if (isSymbol3) {
            bSymbolKeys = bSymbolKeys || Object.getOwnPropertySymbols(b);
            if (aSymbolKeys.length !== bSymbolKeys.length) {
              return false;
            }
          } else {
            bStringKeys = bStringKeys || Object.keys(b);
            if (aStringKeys.length !== bStringKeys.length) {
              return false;
            }
          }
          const aKeys = isSymbol3 ? aSymbolKeys : aStringKeys;
          for (let j = 0; j < aKeys.length; j++) {
            const key = aKeys[j];
            if (!Object.prototype.hasOwnProperty.call(b, key) || !indexSignatures[i](a[key], b[key])) {
              return false;
            }
          }
        }
        return true;
      });
    }
    case "Union": {
      const searchTree = getSearchTree(ast.types, true);
      const ownKeys2 = ownKeys(searchTree.keys);
      const len = ownKeys2.length;
      return make((a, b) => {
        let candidates = [];
        if (len > 0 && isRecordOrArray(a)) {
          for (let i = 0; i < len; i++) {
            const name = ownKeys2[i];
            const buckets = searchTree.keys[name].buckets;
            if (Object.prototype.hasOwnProperty.call(a, name)) {
              const literal3 = String(a[name]);
              if (Object.prototype.hasOwnProperty.call(buckets, literal3)) {
                candidates = candidates.concat(buckets[literal3]);
              }
            }
          }
        }
        if (searchTree.otherwise.length > 0) {
          candidates = candidates.concat(searchTree.otherwise);
        }
        const tuples = candidates.map((ast2) => [go4(ast2, path), is({
          ast: ast2
        })]);
        for (let i = 0; i < tuples.length; i++) {
          const [equivalence3, is4] = tuples[i];
          if (is4(a) && is4(b)) {
            if (equivalence3(a, b)) {
              return true;
            }
          }
        }
        return false;
      });
    }
  }
};
var SymbolStruct = TaggedStruct("symbol", {
  key: String$
}).annotations({
  description: "an object to be decoded into a globally shared symbol"
});
var SymbolFromStruct = transformOrFail(SymbolStruct, SymbolFromSelf, {
  strict: true,
  decode: (i) => decodeSymbol(i.key),
  encode: (a, _, ast) => map37(encodeSymbol2(a, ast), (key) => SymbolStruct.make({
    key
  }))
});
var PropertyKey$ = class extends Union2(String$, Number$, SymbolFromStruct).annotations({
  identifier: "PropertyKey"
}) {
};
var ArrayFormatterIssue = class extends Struct({
  _tag: propertySignature(Literal2("Pointer", "Unexpected", "Missing", "Composite", "Refinement", "Transformation", "Type", "Forbidden")).annotations({
    description: "The tag identifying the type of parse issue"
  }),
  path: propertySignature(Array$(PropertyKey$)).annotations({
    description: "The path to the property where the issue occurred"
  }),
  message: propertySignature(String$).annotations({
    description: "A descriptive message explaining the issue"
  })
}).annotations({
  identifier: "ArrayFormatterIssue",
  description: "Represents an issue returned by the ArrayFormatter formatter"
}) {
};

// ../../node_modules/effect/dist/esm/ScopedCache.js
var ScopedCache_exports = {};
__export(ScopedCache_exports, {
  ScopedCacheTypeId: () => ScopedCacheTypeId2,
  make: () => make115,
  makeWith: () => makeWith8
});

// ../../node_modules/effect/dist/esm/internal/scopedCache.js
var makeCacheState2 = (map49, keys15, accesses, updating, hits, misses) => ({
  map: map49,
  keys: keys15,
  accesses,
  updating,
  hits,
  misses
});
var initialCacheState2 = () => makeCacheState2(empty23(), makeKeySet(), unbounded(), make15(false), 0, 0);
var complete5 = (key, exit4, ownerCount, entryStats, timeToLive) => struct5({
  _tag: "Complete",
  key,
  exit: exit4,
  ownerCount,
  entryStats,
  timeToLive
});
var pending3 = (key, scoped10) => struct5({
  _tag: "Pending",
  key,
  scoped: scoped10
});
var refreshing2 = (scoped10, complete6) => struct5({
  _tag: "Refreshing",
  scoped: scoped10,
  complete: complete6
});
var toScoped = (self) => matchEffect2(self.exit, {
  onFailure: (cause3) => failCause(cause3),
  onSuccess: ([value10]) => acquireRelease2(as3(sync(() => incrementAndGet(self.ownerCount)), value10), () => releaseOwner(self))
});
var releaseOwner = (self) => matchEffect2(self.exit, {
  onFailure: () => void_3,
  onSuccess: ([, finalizer3]) => flatMap12(sync(() => decrementAndGet(self.ownerCount)), (numOwner) => when(finalizer3(void_4), () => numOwner === 0))
});
var ScopedCacheSymbolKey = "effect/ScopedCache";
var ScopedCacheTypeId = Symbol.for(ScopedCacheSymbolKey);
var scopedCacheVariance = {
  /* c8 ignore next */
  _Key: (_) => _,
  /* c8 ignore next */
  _Error: (_) => _,
  /* c8 ignore next */
  _Value: (_) => _
};
var ScopedCacheImpl = class {
  capacity;
  scopedLookup;
  clock;
  timeToLive;
  context;
  [ScopedCacheTypeId] = scopedCacheVariance;
  cacheState;
  constructor(capacity10, scopedLookup, clock3, timeToLive, context15) {
    this.capacity = capacity10;
    this.scopedLookup = scopedLookup;
    this.clock = clock3;
    this.timeToLive = timeToLive;
    this.context = context15;
    this.cacheState = initialCacheState2();
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  get cacheStats() {
    return sync(() => makeCacheStats({
      hits: this.cacheState.hits,
      misses: this.cacheState.misses,
      size: size10(this.cacheState.map)
    }));
  }
  getOption(key) {
    return suspend(() => match2(get9(this.cacheState.map, key), {
      onNone: () => succeedNone,
      onSome: (value10) => flatten8(this.resolveMapValue(value10))
    }));
  }
  getOptionComplete(key) {
    return suspend(() => match2(get9(this.cacheState.map, key), {
      onNone: () => succeedNone,
      onSome: (value10) => flatten8(this.resolveMapValue(value10, true))
    }));
  }
  contains(key) {
    return sync(() => has6(this.cacheState.map, key));
  }
  entryStats(key) {
    return sync(() => {
      const value10 = getOrUndefined2(get9(this.cacheState.map, key));
      if (value10 === void 0) {
        return none2();
      }
      switch (value10._tag) {
        case "Complete": {
          return some3(makeEntryStats(value10.entryStats.loadedMillis));
        }
        case "Pending": {
          return none2();
        }
        case "Refreshing": {
          return some3(makeEntryStats(value10.complete.entryStats.loadedMillis));
        }
      }
    });
  }
  get(key) {
    return pipe(this.lookupValueOf(key), memoize, flatMap12((lookupValue) => suspend(() => {
      let k = void 0;
      let value10 = getOrUndefined2(get9(this.cacheState.map, key));
      if (value10 === void 0) {
        k = makeMapKey(key);
        if (has6(this.cacheState.map, key)) {
          value10 = getOrUndefined2(get9(this.cacheState.map, key));
        } else {
          set5(this.cacheState.map, key, pending3(k, lookupValue));
        }
      }
      if (value10 === void 0) {
        this.trackMiss();
        return zipRight2(this.ensureMapSizeNotExceeded(k), lookupValue);
      }
      return map14(this.resolveMapValue(value10), flatMap12(match2({
        onNone: () => {
          const val = value10;
          const current2 = getOrUndefined2(get9(this.cacheState.map, key));
          if (equals(current2, value10)) {
            remove8(this.cacheState.map, key);
          }
          return pipe(this.ensureMapSizeNotExceeded(val.key), zipRight2(releaseOwner(val)), zipRight2(this.get(key)));
        },
        onSome: succeed
      })));
    })), flatten8);
  }
  invalidate(key) {
    return suspend(() => {
      if (has6(this.cacheState.map, key)) {
        const mapValue = getOrUndefined2(get9(this.cacheState.map, key));
        remove8(this.cacheState.map, key);
        switch (mapValue._tag) {
          case "Complete": {
            return releaseOwner(mapValue);
          }
          case "Pending": {
            return void_3;
          }
          case "Refreshing": {
            return releaseOwner(mapValue.complete);
          }
        }
      }
      return void_3;
    });
  }
  get invalidateAll() {
    return forEachConcurrentDiscard(fromIterable6(Array.from(this.cacheState.map).map(([key]) => key)), (key) => this.invalidate(key), false, false);
  }
  refresh(key) {
    return pipe(this.lookupValueOf(key), memoize, flatMap12((scoped10) => {
      let value10 = getOrUndefined2(get9(this.cacheState.map, key));
      let newKey = void 0;
      if (value10 === void 0) {
        newKey = makeMapKey(key);
        if (has6(this.cacheState.map, key)) {
          value10 = getOrUndefined2(get9(this.cacheState.map, key));
        } else {
          set5(this.cacheState.map, key, pending3(newKey, scoped10));
        }
      }
      let finalScoped;
      if (value10 === void 0) {
        finalScoped = zipRight2(this.ensureMapSizeNotExceeded(newKey), scoped10);
      } else {
        switch (value10._tag) {
          case "Complete": {
            if (this.hasExpired(value10.timeToLive)) {
              finalScoped = succeed(this.get(key));
            } else {
              const current2 = getOrUndefined2(get9(this.cacheState.map, key));
              if (equals(current2, value10)) {
                const mapValue = refreshing2(scoped10, value10);
                set5(this.cacheState.map, key, mapValue);
                finalScoped = scoped10;
              } else {
                finalScoped = succeed(this.get(key));
              }
            }
            break;
          }
          case "Pending": {
            finalScoped = value10.scoped;
            break;
          }
          case "Refreshing": {
            finalScoped = value10.scoped;
            break;
          }
        }
      }
      return flatMap12(finalScoped, (s) => scopedEffect(asVoid2(s)));
    }));
  }
  get size() {
    return sync(() => size10(this.cacheState.map));
  }
  resolveMapValue(value10, ignorePending = false) {
    switch (value10._tag) {
      case "Complete": {
        this.trackHit();
        if (this.hasExpired(value10.timeToLive)) {
          return succeed(succeedNone);
        }
        return as3(this.ensureMapSizeNotExceeded(value10.key), asSome(toScoped(value10)));
      }
      case "Pending": {
        this.trackHit();
        if (ignorePending) {
          return succeed(succeedNone);
        }
        return zipRight2(this.ensureMapSizeNotExceeded(value10.key), map14(value10.scoped, asSome));
      }
      case "Refreshing": {
        this.trackHit();
        if (this.hasExpired(value10.complete.timeToLive)) {
          if (ignorePending) {
            return succeed(succeedNone);
          }
          return zipRight2(this.ensureMapSizeNotExceeded(value10.complete.key), map14(value10.scoped, asSome));
        }
        return as3(this.ensureMapSizeNotExceeded(value10.complete.key), asSome(toScoped(value10.complete)));
      }
    }
  }
  lookupValueOf(key) {
    return pipe(onInterrupt(flatMap12(make55(), (scope6) => pipe(this.scopedLookup(key), provideContext(pipe(this.context, add2(Scope, scope6))), exit, map14((exit4) => [exit4, (exit5) => close(scope6, exit5)]))), () => sync(() => remove8(this.cacheState.map, key))), flatMap12(([exit4, release4]) => {
      const now3 = this.clock.unsafeCurrentTimeMillis();
      const expiredAt = now3 + toMillis(this.timeToLive(exit4));
      switch (exit4._tag) {
        case "Success": {
          const exitWithFinalizer = succeed3([exit4.value, release4]);
          const completedResult = complete5(makeMapKey(key), exitWithFinalizer, make15(1), makeEntryStats(now3), expiredAt);
          let previousValue = void 0;
          if (has6(this.cacheState.map, key)) {
            previousValue = getOrUndefined2(get9(this.cacheState.map, key));
          }
          set5(this.cacheState.map, key, completedResult);
          return sync(() => flatten8(as3(this.cleanMapValue(previousValue), toScoped(completedResult))));
        }
        case "Failure": {
          const completedResult = complete5(makeMapKey(key), exit4, make15(0), makeEntryStats(now3), expiredAt);
          let previousValue = void 0;
          if (has6(this.cacheState.map, key)) {
            previousValue = getOrUndefined2(get9(this.cacheState.map, key));
          }
          set5(this.cacheState.map, key, completedResult);
          return zipRight2(release4(exit4), sync(() => flatten8(as3(this.cleanMapValue(previousValue), toScoped(completedResult)))));
        }
      }
    }), memoize, flatten8);
  }
  hasExpired(timeToLive) {
    return this.clock.unsafeCurrentTimeMillis() > timeToLive;
  }
  trackHit() {
    this.cacheState.hits = this.cacheState.hits + 1;
  }
  trackMiss() {
    this.cacheState.misses = this.cacheState.misses + 1;
  }
  trackAccess(key) {
    const cleanedKeys = [];
    offer(this.cacheState.accesses, key);
    if (compareAndSet(this.cacheState.updating, false, true)) {
      let loop5 = true;
      while (loop5) {
        const key2 = poll2(this.cacheState.accesses, EmptyMutableQueue);
        if (key2 === EmptyMutableQueue) {
          loop5 = false;
        } else {
          this.cacheState.keys.add(key2);
        }
      }
      let size40 = size10(this.cacheState.map);
      loop5 = size40 > this.capacity;
      while (loop5) {
        const key2 = this.cacheState.keys.remove();
        if (key2 === void 0) {
          loop5 = false;
        } else {
          if (has6(this.cacheState.map, key2.current)) {
            const removed = getOrUndefined2(get9(this.cacheState.map, key2.current));
            remove8(this.cacheState.map, key2.current);
            size40 = size40 - 1;
            cleanedKeys.push(removed);
            loop5 = size40 > this.capacity;
          }
        }
      }
      set3(this.cacheState.updating, false);
    }
    return cleanedKeys;
  }
  cleanMapValue(mapValue) {
    if (mapValue === void 0) {
      return void_3;
    }
    switch (mapValue._tag) {
      case "Complete": {
        return releaseOwner(mapValue);
      }
      case "Pending": {
        return void_3;
      }
      case "Refreshing": {
        return releaseOwner(mapValue.complete);
      }
    }
  }
  ensureMapSizeNotExceeded(key) {
    return forEachConcurrentDiscard(this.trackAccess(key), (cleanedMapValue) => this.cleanMapValue(cleanedMapValue), false, false);
  }
};
var make114 = (options) => {
  const timeToLive = decode(options.timeToLive);
  return makeWith7({
    capacity: options.capacity,
    lookup: options.lookup,
    timeToLive: () => timeToLive
  });
};
var makeWith7 = (options) => flatMap12(clock, (clock3) => buildWith(options.capacity, options.lookup, clock3, (exit4) => decode(options.timeToLive(exit4))));
var buildWith = (capacity10, scopedLookup, clock3, timeToLive) => acquireRelease2(flatMap12(context2(), (context15) => sync(() => new ScopedCacheImpl(capacity10, scopedLookup, clock3, timeToLive, context15))), (cache) => cache.invalidateAll);

// ../../node_modules/effect/dist/esm/ScopedCache.js
var ScopedCacheTypeId2 = ScopedCacheTypeId;
var make115 = make114;
var makeWith8 = makeWith7;

// ../../node_modules/effect/dist/esm/ScopedRef.js
var ScopedRef_exports = {};
__export(ScopedRef_exports, {
  ScopedRefTypeId: () => ScopedRefTypeId2,
  fromAcquire: () => fromAcquire2,
  get: () => get32,
  make: () => make116,
  set: () => set16
});
var ScopedRefTypeId2 = ScopedRefTypeId;
var fromAcquire2 = fromAcquire;
var get32 = get26;
var make116 = make109;
var set16 = set14;

// ../../node_modules/effect/dist/esm/Secret.js
var Secret_exports = {};
__export(Secret_exports, {
  SecretTypeId: () => SecretTypeId2,
  fromIterable: () => fromIterable21,
  fromString: () => fromString4,
  isSecret: () => isSecret2,
  make: () => make117,
  unsafeWipe: () => unsafeWipe4,
  value: () => value9
});
var SecretTypeId2 = SecretTypeId;
var isSecret2 = isSecret;
var make117 = make75;
var fromIterable21 = fromIterable18;
var fromString4 = fromString3;
var value9 = value3;
var unsafeWipe4 = unsafeWipe2;

// ../../node_modules/effect/dist/esm/SingleProducerAsyncInput.js
var SingleProducerAsyncInput_exports = {};
__export(SingleProducerAsyncInput_exports, {
  make: () => make118
});
var make118 = make63;

// ../../node_modules/effect/dist/esm/Sink.js
var Sink_exports = {};
__export(Sink_exports, {
  SinkTypeId: () => SinkTypeId4,
  as: () => as16,
  collectAll: () => collectAll4,
  collectAllFrom: () => collectAllFrom2,
  collectAllN: () => collectAllN2,
  collectAllToMap: () => collectAllToMap2,
  collectAllToMapN: () => collectAllToMapN2,
  collectAllToSet: () => collectAllToSet2,
  collectAllToSetN: () => collectAllToSetN2,
  collectAllUntil: () => collectAllUntil2,
  collectAllUntilEffect: () => collectAllUntilEffect2,
  collectAllWhile: () => collectAllWhile2,
  collectAllWhileEffect: () => collectAllWhileEffect2,
  collectAllWhileWith: () => collectAllWhileWith2,
  collectLeftover: () => collectLeftover2,
  context: () => context13,
  contextWith: () => contextWith9,
  contextWithEffect: () => contextWithEffect7,
  contextWithSink: () => contextWithSink2,
  count: () => count6,
  die: () => die16,
  dieMessage: () => dieMessage8,
  dieSync: () => dieSync10,
  dimap: () => dimap2,
  dimapChunks: () => dimapChunks2,
  dimapChunksEffect: () => dimapChunksEffect2,
  dimapEffect: () => dimapEffect2,
  drain: () => drain5,
  drop: () => drop7,
  dropUntil: () => dropUntil5,
  dropUntilEffect: () => dropUntilEffect3,
  dropWhile: () => dropWhile7,
  dropWhileEffect: () => dropWhileEffect3,
  ensuring: () => ensuring12,
  ensuringWith: () => ensuringWith5,
  every: () => every17,
  fail: () => fail25,
  failCause: () => failCause18,
  failCauseSync: () => failCauseSync11,
  failSync: () => failSync13,
  filterInput: () => filterInput2,
  filterInputEffect: () => filterInputEffect2,
  findEffect: () => findEffect3,
  flatMap: () => flatMap27,
  fold: () => fold2,
  foldChunks: () => foldChunks2,
  foldChunksEffect: () => foldChunksEffect2,
  foldEffect: () => foldEffect2,
  foldLeft: () => foldLeft2,
  foldLeftChunks: () => foldLeftChunks2,
  foldLeftChunksEffect: () => foldLeftChunksEffect2,
  foldLeftEffect: () => foldLeftEffect2,
  foldSink: () => foldSink2,
  foldUntil: () => foldUntil2,
  foldUntilEffect: () => foldUntilEffect2,
  foldWeighted: () => foldWeighted2,
  foldWeightedDecompose: () => foldWeightedDecompose2,
  foldWeightedDecomposeEffect: () => foldWeightedDecomposeEffect2,
  foldWeightedEffect: () => foldWeightedEffect2,
  forEach: () => forEach20,
  forEachChunk: () => forEachChunk2,
  forEachChunkWhile: () => forEachChunkWhile2,
  forEachWhile: () => forEachWhile2,
  fromChannel: () => fromChannel3,
  fromEffect: () => fromEffect13,
  fromPubSub: () => fromPubSub5,
  fromPush: () => fromPush2,
  fromQueue: () => fromQueue5,
  head: () => head12,
  ignoreLeftover: () => ignoreLeftover2,
  last: () => last7,
  leftover: () => leftover2,
  map: () => map42,
  mapEffect: () => mapEffect9,
  mapError: () => mapError14,
  mapInput: () => mapInput13,
  mapInputChunks: () => mapInputChunks2,
  mapInputChunksEffect: () => mapInputChunksEffect2,
  mapInputEffect: () => mapInputEffect6,
  mapLeftover: () => mapLeftover2,
  mkString: () => mkString3,
  never: () => never12,
  orElse: () => orElse22,
  provideContext: () => provideContext13,
  race: () => race8,
  raceBoth: () => raceBoth2,
  raceWith: () => raceWith4,
  refineOrDie: () => refineOrDie5,
  refineOrDieWith: () => refineOrDieWith5,
  some: () => some19,
  splitWhere: () => splitWhere4,
  succeed: () => succeed28,
  sum: () => sum6,
  summarized: () => summarized6,
  suspend: () => suspend16,
  sync: () => sync21,
  take: () => take12,
  timed: () => timed4,
  toChannel: () => toChannel5,
  unwrap: () => unwrap8,
  unwrapScoped: () => unwrapScoped7,
  unwrapScopedWith: () => unwrapScopedWith5,
  withDuration: () => withDuration2,
  zip: () => zip25,
  zipLeft: () => zipLeft16,
  zipRight: () => zipRight16,
  zipWith: () => zipWith21
});
var SinkTypeId4 = SinkTypeId3;
var as16 = as10;
var collectAll4 = collectAll;
var collectAllN2 = collectAllN;
var collectAllFrom2 = collectAllFrom;
var collectAllToMap2 = collectAllToMap;
var collectAllToMapN2 = collectAllToMapN;
var collectAllToSet2 = collectAllToSet;
var collectAllToSetN2 = collectAllToSetN;
var collectAllUntil2 = collectAllUntil;
var collectAllUntilEffect2 = collectAllUntilEffect;
var collectAllWhile2 = collectAllWhile;
var collectAllWhileEffect2 = collectAllWhileEffect;
var collectAllWhileWith2 = collectAllWhileWith;
var collectLeftover2 = collectLeftover;
var mapInput13 = mapInput8;
var mapInputEffect6 = mapInputEffect3;
var mapInputChunks2 = mapInputChunks;
var mapInputChunksEffect2 = mapInputChunksEffect;
var count6 = count3;
var die16 = die10;
var dieMessage8 = dieMessage3;
var dieSync10 = dieSync6;
var dimap2 = dimap;
var dimapEffect2 = dimapEffect;
var dimapChunks2 = dimapChunks;
var dimapChunksEffect2 = dimapChunksEffect;
var drain5 = drain2;
var drop7 = drop5;
var dropUntil5 = dropUntil3;
var dropUntilEffect3 = dropUntilEffect;
var dropWhile7 = dropWhile5;
var dropWhileEffect3 = dropWhileEffect;
var ensuring12 = ensuring6;
var ensuringWith5 = ensuringWith2;
var context13 = context8;
var contextWith9 = contextWith4;
var contextWithEffect7 = contextWithEffect4;
var contextWithSink2 = contextWithSink;
var every17 = every14;
var fail25 = fail15;
var failSync13 = failSync8;
var failCause18 = failCause13;
var failCauseSync11 = failCauseSync8;
var filterInput2 = filterInput;
var filterInputEffect2 = filterInputEffect;
var findEffect3 = findEffect;
var fold2 = fold;
var foldSink2 = foldSink;
var foldChunks2 = foldChunks;
var foldChunksEffect2 = foldChunksEffect;
var foldEffect2 = foldEffect;
var foldLeft2 = foldLeft;
var foldLeftChunks2 = foldLeftChunks;
var foldLeftChunksEffect2 = foldLeftChunksEffect;
var foldLeftEffect2 = foldLeftEffect;
var foldUntil2 = foldUntil;
var foldUntilEffect2 = foldUntilEffect;
var foldWeighted2 = foldWeighted;
var foldWeightedDecompose2 = foldWeightedDecompose;
var foldWeightedDecomposeEffect2 = foldWeightedDecomposeEffect;
var foldWeightedEffect2 = foldWeightedEffect;
var forEach20 = forEach17;
var forEachChunk2 = forEachChunk;
var forEachChunkWhile2 = forEachChunkWhile;
var forEachWhile2 = forEachWhile;
var flatMap27 = flatMap21;
var fromChannel3 = fromChannel;
var toChannel5 = toChannel;
var fromEffect13 = fromEffect7;
var fromPubSub5 = fromPubSub2;
var fromPush2 = fromPush;
var fromQueue5 = fromQueue2;
var head12 = head8;
var ignoreLeftover2 = ignoreLeftover;
var last7 = last6;
var leftover2 = leftover;
var map42 = map29;
var mapEffect9 = mapEffect6;
var mapError14 = mapError8;
var mapLeftover2 = mapLeftover;
var mkString3 = mkString;
var never12 = never7;
var orElse22 = orElse11;
var provideContext13 = provideContext5;
var race8 = race4;
var raceBoth2 = raceBoth;
var raceWith4 = raceWith3;
var refineOrDie5 = refineOrDie;
var refineOrDieWith5 = refineOrDieWith;
var some19 = some15;
var splitWhere4 = splitWhere3;
var succeed28 = succeed16;
var sum6 = sum5;
var summarized6 = summarized3;
var suspend16 = suspend7;
var sync21 = sync11;
var take12 = take7;
var timed4 = timed3;
var unwrap8 = unwrap3;
var unwrapScoped7 = unwrapScoped4;
var unwrapScopedWith5 = unwrapScopedWith2;
var withDuration2 = withDuration;
var zip25 = zip14;
var zipLeft16 = zipLeft9;
var zipRight16 = zipRight9;
var zipWith21 = zipWith14;

// ../../node_modules/effect/dist/esm/SortedMap.js
var SortedMap_exports = {};
__export(SortedMap_exports, {
  empty: () => empty48,
  entries: () => entries4,
  fromIterable: () => fromIterable22,
  get: () => get33,
  getOrder: () => getOrder7,
  has: () => has12,
  headOption: () => headOption,
  isEmpty: () => isEmpty23,
  isNonEmpty: () => isNonEmpty8,
  isSortedMap: () => isSortedMap,
  keys: () => keys10,
  lastOption: () => lastOption,
  make: () => make119,
  map: () => map43,
  partition: () => partition13,
  reduce: () => reduce22,
  remove: () => remove14,
  set: () => set17,
  size: () => size28,
  values: () => values10
});
var TypeId40 = Symbol.for("effect/SortedMap");
var SortedMapProto = {
  [TypeId40]: {
    _K: (_) => _,
    _V: (_) => _
  },
  [symbol2]() {
    return pipe(hash(this.tree), combine2(hash("effect/SortedMap")), cached(this));
  },
  [symbol3](that) {
    return isSortedMap(that) && equals(this.tree, that.tree);
  },
  [Symbol.iterator]() {
    return this.tree[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "SortedMap",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl5 = (tree) => {
  const self = Object.create(SortedMapProto);
  self.tree = tree;
  return self;
};
var isSortedMap = (u) => hasProperty(u, TypeId40);
var empty48 = (ord) => makeImpl5(empty31(ord));
var fromIterable22 = dual(2, (iterable, ord) => makeImpl5(fromIterable13(iterable, ord)));
var make119 = (ord) => (...entries7) => fromIterable22(ord)(entries7);
var isEmpty23 = (self) => size28(self) === 0;
var isNonEmpty8 = (self) => size28(self) > 0;
var get33 = dual(2, (self, key) => findFirst10(self.tree, key));
var getOrder7 = (self) => getOrder5(self.tree);
var has12 = dual(2, (self, key) => isSome2(get33(self, key)));
var headOption = (self) => first2(self.tree);
var map43 = dual(2, (self, f) => reduce22(self, empty48(getOrder5(self.tree)), (acc, v, k) => set17(acc, k, f(v, k))));
var reduce22 = dual(3, (self, zero3, f) => reduce14(self.tree, zero3, f));
var remove14 = dual(2, (self, key) => makeImpl5(removeFirst2(self.tree, key)));
var set17 = dual(3, (self, key, value10) => has8(self.tree, key) ? makeImpl5(insert2(removeFirst2(self.tree, key), key, value10)) : makeImpl5(insert2(self.tree, key, value10)));
var size28 = (self) => size12(self.tree);
var keys10 = (self) => keys6(self.tree);
var values10 = (self) => values8(self.tree);
var entries4 = (self) => {
  const iterator = self.tree[Symbol.iterator]();
  iterator[Symbol.iterator] = () => entries4(self);
  return iterator;
};
var lastOption = (self) => last5(self.tree);
var partition13 = dual(2, (self, predicate) => {
  const ord = getOrder5(self.tree);
  let right3 = empty48(ord);
  let left3 = empty48(ord);
  for (const value10 of self) {
    if (predicate(value10[0])) {
      right3 = set17(right3, value10[0], value10[1]);
    } else {
      left3 = set17(left3, value10[0], value10[1]);
    }
  }
  return [left3, right3];
});

// ../../node_modules/effect/dist/esm/Stream.js
var Stream_exports = {};
__export(Stream_exports, {
  DefaultChunkSize: () => DefaultChunkSize2,
  Do: () => Do9,
  StreamTypeId: () => StreamTypeId4,
  accumulate: () => accumulate2,
  accumulateChunks: () => accumulateChunks2,
  acquireRelease: () => acquireRelease5,
  aggregate: () => aggregate2,
  aggregateWithin: () => aggregateWithin2,
  aggregateWithinEither: () => aggregateWithinEither2,
  as: () => as17,
  async: () => _async2,
  asyncEffect: () => asyncEffect4,
  asyncPush: () => asyncPush2,
  asyncScoped: () => asyncScoped2,
  bind: () => bind11,
  bindEffect: () => bindEffect2,
  bindTo: () => bindTo11,
  branchAfter: () => branchAfter2,
  broadcast: () => broadcast2,
  broadcastDynamic: () => broadcastDynamic2,
  broadcastedQueues: () => broadcastedQueues2,
  broadcastedQueuesDynamic: () => broadcastedQueuesDynamic2,
  buffer: () => buffer4,
  bufferChunks: () => bufferChunks2,
  catchAll: () => catchAll11,
  catchAllCause: () => catchAllCause9,
  catchSome: () => catchSome6,
  catchSomeCause: () => catchSomeCause4,
  catchTag: () => catchTag7,
  catchTags: () => catchTags6,
  changes: () => changes2,
  changesWith: () => changesWith2,
  changesWithEffect: () => changesWithEffect2,
  chunks: () => chunks2,
  chunksWith: () => chunksWith2,
  combine: () => combine18,
  combineChunks: () => combineChunks2,
  concat: () => concat4,
  concatAll: () => concatAll4,
  context: () => context14,
  contextWith: () => contextWith10,
  contextWithEffect: () => contextWithEffect8,
  contextWithStream: () => contextWithStream2,
  cross: () => cross2,
  crossLeft: () => crossLeft2,
  crossRight: () => crossRight2,
  crossWith: () => crossWith2,
  debounce: () => debounce2,
  decodeText: () => decodeText2,
  die: () => die17,
  dieMessage: () => dieMessage9,
  dieSync: () => dieSync11,
  distributedWith: () => distributedWith2,
  distributedWithDynamic: () => distributedWithDynamic2,
  drain: () => drain6,
  drainFork: () => drainFork2,
  drop: () => drop8,
  dropRight: () => dropRight4,
  dropUntil: () => dropUntil6,
  dropUntilEffect: () => dropUntilEffect4,
  dropWhile: () => dropWhile8,
  dropWhileEffect: () => dropWhileEffect4,
  either: () => either13,
  empty: () => empty49,
  encodeText: () => encodeText2,
  ensuring: () => ensuring13,
  ensuringWith: () => ensuringWith6,
  execute: () => execute2,
  fail: () => fail26,
  failCause: () => failCause19,
  failCauseSync: () => failCauseSync12,
  failSync: () => failSync14,
  filter: () => filter23,
  filterEffect: () => filterEffect3,
  filterMap: () => filterMap13,
  filterMapEffect: () => filterMapEffect2,
  filterMapWhile: () => filterMapWhile5,
  filterMapWhileEffect: () => filterMapWhileEffect2,
  finalizer: () => finalizer2,
  find: () => find4,
  findEffect: () => findEffect4,
  flatMap: () => flatMap28,
  flatten: () => flatten20,
  flattenChunks: () => flattenChunks2,
  flattenEffect: () => flattenEffect2,
  flattenExitOption: () => flattenExitOption2,
  flattenIterables: () => flattenIterables2,
  flattenTake: () => flattenTake2,
  forever: () => forever7,
  fromAsyncIterable: () => fromAsyncIterable2,
  fromChannel: () => fromChannel4,
  fromChunk: () => fromChunk2,
  fromChunkPubSub: () => fromChunkPubSub2,
  fromChunkQueue: () => fromChunkQueue2,
  fromChunks: () => fromChunks2,
  fromEffect: () => fromEffect14,
  fromEffectOption: () => fromEffectOption2,
  fromEventListener: () => fromEventListener2,
  fromIterable: () => fromIterable23,
  fromIterableEffect: () => fromIterableEffect2,
  fromIteratorSucceed: () => fromIteratorSucceed2,
  fromPubSub: () => fromPubSub6,
  fromPull: () => fromPull3,
  fromQueue: () => fromQueue6,
  fromReadableStream: () => fromReadableStream2,
  fromReadableStreamByob: () => fromReadableStreamByob2,
  fromSchedule: () => fromSchedule2,
  fromTPubSub: () => fromTPubSub2,
  fromTQueue: () => fromTQueue2,
  groupAdjacentBy: () => groupAdjacentBy2,
  groupBy: () => groupBy4,
  groupByKey: () => groupByKey2,
  grouped: () => grouped2,
  groupedWithin: () => groupedWithin2,
  haltAfter: () => haltAfter2,
  haltWhen: () => haltWhen2,
  haltWhenDeferred: () => haltWhenDeferred2,
  identity: () => identity6,
  interleave: () => interleave2,
  interleaveWith: () => interleaveWith2,
  interruptAfter: () => interruptAfter3,
  interruptWhen: () => interruptWhen4,
  interruptWhenDeferred: () => interruptWhenDeferred4,
  intersperse: () => intersperse4,
  intersperseAffixes: () => intersperseAffixes2,
  iterate: () => iterate6,
  let: () => let_11,
  make: () => make120,
  map: () => map44,
  mapAccum: () => mapAccum6,
  mapAccumEffect: () => mapAccumEffect2,
  mapBoth: () => mapBoth12,
  mapChunks: () => mapChunks2,
  mapChunksEffect: () => mapChunksEffect2,
  mapConcat: () => mapConcat2,
  mapConcatChunk: () => mapConcatChunk2,
  mapConcatChunkEffect: () => mapConcatChunkEffect2,
  mapConcatEffect: () => mapConcatEffect2,
  mapEffect: () => mapEffect10,
  mapError: () => mapError15,
  mapErrorCause: () => mapErrorCause8,
  mapInputContext: () => mapInputContext12,
  merge: () => merge13,
  mergeAll: () => mergeAll12,
  mergeEither: () => mergeEither2,
  mergeLeft: () => mergeLeft2,
  mergeRight: () => mergeRight2,
  mergeWith: () => mergeWith5,
  mergeWithTag: () => mergeWithTag2,
  mkString: () => mkString4,
  never: () => never13,
  onDone: () => onDone2,
  onEnd: () => onEnd2,
  onError: () => onError5,
  onStart: () => onStart2,
  orDie: () => orDie11,
  orDieWith: () => orDieWith8,
  orElse: () => orElse23,
  orElseEither: () => orElseEither9,
  orElseFail: () => orElseFail6,
  orElseIfEmpty: () => orElseIfEmpty2,
  orElseIfEmptyChunk: () => orElseIfEmptyChunk2,
  orElseIfEmptyStream: () => orElseIfEmptyStream2,
  orElseSucceed: () => orElseSucceed7,
  paginate: () => paginate2,
  paginateChunk: () => paginateChunk2,
  paginateChunkEffect: () => paginateChunkEffect2,
  paginateEffect: () => paginateEffect2,
  partition: () => partition14,
  partitionEither: () => partitionEither2,
  peel: () => peel2,
  pipeThrough: () => pipeThrough2,
  pipeThroughChannel: () => pipeThroughChannel2,
  pipeThroughChannelOrFail: () => pipeThroughChannelOrFail2,
  prepend: () => prepend7,
  provideContext: () => provideContext14,
  provideLayer: () => provideLayer4,
  provideService: () => provideService13,
  provideServiceEffect: () => provideServiceEffect5,
  provideServiceStream: () => provideServiceStream2,
  provideSomeContext: () => provideSomeContext5,
  provideSomeLayer: () => provideSomeLayer5,
  race: () => race9,
  raceAll: () => raceAll5,
  range: () => range5,
  rechunk: () => rechunk2,
  refineOrDie: () => refineOrDie6,
  refineOrDieWith: () => refineOrDieWith6,
  repeat: () => repeat7,
  repeatEffect: () => repeatEffect2,
  repeatEffectChunk: () => repeatEffectChunk2,
  repeatEffectChunkOption: () => repeatEffectChunkOption2,
  repeatEffectOption: () => repeatEffectOption2,
  repeatEffectWithSchedule: () => repeatEffectWithSchedule2,
  repeatEither: () => repeatEither2,
  repeatElements: () => repeatElements2,
  repeatElementsWith: () => repeatElementsWith2,
  repeatValue: () => repeatValue2,
  repeatWith: () => repeatWith2,
  retry: () => retry11,
  run: () => run9,
  runCollect: () => runCollect4,
  runCount: () => runCount2,
  runDrain: () => runDrain4,
  runFold: () => runFold2,
  runFoldEffect: () => runFoldEffect2,
  runFoldScoped: () => runFoldScoped2,
  runFoldScopedEffect: () => runFoldScopedEffect2,
  runFoldWhile: () => runFoldWhile2,
  runFoldWhileEffect: () => runFoldWhileEffect2,
  runFoldWhileScoped: () => runFoldWhileScoped2,
  runFoldWhileScopedEffect: () => runFoldWhileScopedEffect2,
  runForEach: () => runForEach2,
  runForEachChunk: () => runForEachChunk2,
  runForEachChunkScoped: () => runForEachChunkScoped2,
  runForEachScoped: () => runForEachScoped2,
  runForEachWhile: () => runForEachWhile2,
  runForEachWhileScoped: () => runForEachWhileScoped2,
  runHead: () => runHead2,
  runIntoPubSub: () => runIntoPubSub2,
  runIntoPubSubScoped: () => runIntoPubSubScoped2,
  runIntoQueue: () => runIntoQueue2,
  runIntoQueueElementsScoped: () => runIntoQueueElementsScoped2,
  runIntoQueueScoped: () => runIntoQueueScoped2,
  runLast: () => runLast2,
  runScoped: () => runScoped4,
  runSum: () => runSum2,
  scan: () => scan4,
  scanEffect: () => scanEffect2,
  scanReduce: () => scanReduce2,
  scanReduceEffect: () => scanReduceEffect2,
  schedule: () => schedule3,
  scheduleWith: () => scheduleWith2,
  scoped: () => scoped9,
  scopedWith: () => scopedWith6,
  share: () => share2,
  sliding: () => sliding10,
  slidingSize: () => slidingSize2,
  some: () => some20,
  someOrElse: () => someOrElse2,
  someOrFail: () => someOrFail2,
  split: () => split6,
  splitLines: () => splitLines4,
  splitOnChunk: () => splitOnChunk2,
  succeed: () => succeed29,
  suspend: () => suspend17,
  sync: () => sync22,
  take: () => take13,
  takeRight: () => takeRight5,
  takeUntil: () => takeUntil4,
  takeUntilEffect: () => takeUntilEffect2,
  takeWhile: () => takeWhile7,
  tap: () => tap11,
  tapBoth: () => tapBoth6,
  tapError: () => tapError9,
  tapErrorCause: () => tapErrorCause7,
  tapSink: () => tapSink2,
  throttle: () => throttle2,
  throttleEffect: () => throttleEffect2,
  tick: () => tick2,
  timeout: () => timeout5,
  timeoutFail: () => timeoutFail4,
  timeoutFailCause: () => timeoutFailCause4,
  timeoutTo: () => timeoutTo4,
  toAsyncIterable: () => toAsyncIterable2,
  toAsyncIterableEffect: () => toAsyncIterableEffect2,
  toAsyncIterableRuntime: () => toAsyncIterableRuntime2,
  toChannel: () => toChannel6,
  toPubSub: () => toPubSub4,
  toPull: () => toPull4,
  toQueue: () => toQueue4,
  toQueueOfElements: () => toQueueOfElements2,
  toReadableStream: () => toReadableStream2,
  toReadableStreamEffect: () => toReadableStreamEffect2,
  toReadableStreamRuntime: () => toReadableStreamRuntime2,
  transduce: () => transduce2,
  unfold: () => unfold6,
  unfoldChunk: () => unfoldChunk2,
  unfoldChunkEffect: () => unfoldChunkEffect2,
  unfoldEffect: () => unfoldEffect2,
  unwrap: () => unwrap9,
  unwrapScoped: () => unwrapScoped8,
  unwrapScopedWith: () => unwrapScopedWith6,
  updateService: () => updateService8,
  void: () => void_14,
  when: () => when9,
  whenCase: () => whenCase2,
  whenCaseEffect: () => whenCaseEffect2,
  whenEffect: () => whenEffect4,
  withExecutionPlan: () => withExecutionPlan4,
  withSpan: () => withSpan8,
  zip: () => zip26,
  zipAll: () => zipAll2,
  zipAllLeft: () => zipAllLeft2,
  zipAllRight: () => zipAllRight2,
  zipAllSortedByKey: () => zipAllSortedByKey2,
  zipAllSortedByKeyLeft: () => zipAllSortedByKeyLeft2,
  zipAllSortedByKeyRight: () => zipAllSortedByKeyRight2,
  zipAllSortedByKeyWith: () => zipAllSortedByKeyWith2,
  zipAllWith: () => zipAllWith2,
  zipFlatten: () => zipFlatten3,
  zipLatest: () => zipLatest2,
  zipLatestAll: () => zipLatestAll2,
  zipLatestWith: () => zipLatestWith2,
  zipLeft: () => zipLeft17,
  zipRight: () => zipRight17,
  zipWith: () => zipWith22,
  zipWithChunks: () => zipWithChunks2,
  zipWithIndex: () => zipWithIndex2,
  zipWithNext: () => zipWithNext2,
  zipWithPrevious: () => zipWithPrevious2,
  zipWithPreviousAndNext: () => zipWithPreviousAndNext2
});
var StreamTypeId4 = StreamTypeId3;
var DefaultChunkSize2 = DefaultChunkSize;
var accumulate2 = accumulate;
var accumulateChunks2 = accumulateChunks;
var acquireRelease5 = acquireRelease4;
var aggregate2 = aggregate;
var aggregateWithin2 = aggregateWithin;
var aggregateWithinEither2 = aggregateWithinEither;
var as17 = as13;
var _async2 = _async;
var asyncEffect4 = asyncEffect3;
var asyncPush2 = asyncPush;
var asyncScoped2 = asyncScoped;
var branchAfter2 = branchAfter;
var broadcast2 = broadcast;
var share2 = share;
var broadcastDynamic2 = broadcastDynamic;
var broadcastedQueues2 = broadcastedQueues;
var broadcastedQueuesDynamic2 = broadcastedQueuesDynamic;
var buffer4 = buffer2;
var bufferChunks2 = bufferChunks;
var catchAll11 = catchAll8;
var catchAllCause9 = catchAllCause7;
var catchSome6 = catchSome4;
var catchTag7 = catchTag5;
var catchTags6 = catchTags4;
var catchSomeCause4 = catchSomeCause3;
var changes2 = changes;
var changesWith2 = changesWith;
var changesWithEffect2 = changesWithEffect;
var chunks2 = chunks;
var chunksWith2 = chunksWith;
var combine18 = combine16;
var combineChunks2 = combineChunks;
var concat4 = concat3;
var concatAll4 = concatAll2;
var cross2 = cross;
var crossLeft2 = crossLeft;
var crossRight2 = crossRight;
var crossWith2 = crossWith;
var debounce2 = debounce;
var die17 = die14;
var dieSync11 = dieSync8;
var dieMessage9 = dieMessage6;
var distributedWith2 = distributedWith;
var distributedWithDynamic2 = distributedWithDynamic;
var drain6 = drain3;
var drainFork2 = drainFork;
var drop8 = drop6;
var dropRight4 = dropRight3;
var dropUntil6 = dropUntil4;
var dropUntilEffect4 = dropUntilEffect2;
var dropWhile8 = dropWhile6;
var dropWhileEffect4 = dropWhileEffect2;
var either13 = either9;
var empty49 = empty43;
var ensuring13 = ensuring9;
var ensuringWith6 = ensuringWith3;
var context14 = context10;
var contextWith10 = contextWith6;
var contextWithEffect8 = contextWithEffect5;
var contextWithStream2 = contextWithStream;
var execute2 = execute;
var fail26 = fail19;
var failSync14 = failSync10;
var failCause19 = failCause16;
var failCauseSync12 = failCauseSync9;
var filter23 = filter18;
var filterEffect3 = filterEffect;
var filterMap13 = filterMap12;
var filterMapEffect2 = filterMapEffect;
var filterMapWhile5 = filterMapWhile4;
var filterMapWhileEffect2 = filterMapWhileEffect;
var finalizer2 = finalizer;
var find4 = find3;
var findEffect4 = findEffect2;
var flatMap28 = flatMap23;
var flatten20 = flatten17;
var flattenChunks2 = flattenChunks;
var flattenEffect2 = flattenEffect;
var flattenExitOption2 = flattenExitOption;
var flattenIterables2 = flattenIterables;
var flattenTake2 = flattenTake;
var forever7 = forever6;
var fromAsyncIterable2 = fromAsyncIterable;
var fromChannel4 = fromChannel2;
var toChannel6 = toChannel2;
var fromChunk2 = fromChunk;
var fromChunkPubSub2 = fromChunkPubSub;
var fromChunkQueue2 = fromChunkQueue;
var fromChunks2 = fromChunks;
var fromEffect14 = fromEffect9;
var fromEffectOption2 = fromEffectOption;
var fromPubSub6 = fromPubSub3;
var fromTPubSub2 = fromTPubSub;
var fromIterable23 = fromIterable17;
var fromIterableEffect2 = fromIterableEffect;
var fromIteratorSucceed2 = fromIteratorSucceed;
var fromPull3 = fromPull2;
var fromQueue6 = fromQueue3;
var fromTQueue2 = fromTQueue;
var fromReadableStream2 = fromReadableStream;
var fromReadableStreamByob2 = fromReadableStreamByob;
var fromSchedule2 = fromSchedule;
var groupAdjacentBy2 = groupAdjacentBy;
var groupBy4 = groupBy3;
var groupByKey2 = groupByKey;
var grouped2 = grouped;
var groupedWithin2 = groupedWithin;
var haltAfter2 = haltAfter;
var haltWhen2 = haltWhen;
var haltWhenDeferred2 = haltWhenDeferred;
var identity6 = identityStream;
var interleave2 = interleave;
var interleaveWith2 = interleaveWith;
var intersperse4 = intersperse3;
var intersperseAffixes2 = intersperseAffixes;
var interruptAfter3 = interruptAfter2;
var interruptWhen4 = interruptWhen2;
var interruptWhenDeferred4 = interruptWhenDeferred2;
var iterate6 = iterate4;
var make120 = make73;
var map44 = map33;
var mapAccum6 = mapAccum5;
var mapAccumEffect2 = mapAccumEffect;
var mapBoth12 = mapBoth9;
var mapChunks2 = mapChunks;
var mapChunksEffect2 = mapChunksEffect;
var mapConcat2 = mapConcat;
var mapConcatChunk2 = mapConcatChunk;
var mapConcatChunkEffect2 = mapConcatChunkEffect;
var mapConcatEffect2 = mapConcatEffect;
var mapEffect10 = mapEffectOptions;
var mapError15 = mapError10;
var mapErrorCause8 = mapErrorCause6;
var merge13 = merge10;
var mergeAll12 = mergeAll9;
var mergeWithTag2 = mergeWithTag;
var mergeWith5 = mergeWith3;
var mergeEither2 = mergeEither;
var mergeLeft2 = mergeLeft;
var mergeRight2 = mergeRight;
var mkString4 = mkString2;
var never13 = never8;
var onEnd2 = onEnd;
var onError5 = onError4;
var onDone2 = onDone;
var onStart2 = onStart;
var orDie11 = orDie8;
var orDieWith8 = orDieWith5;
var orElse23 = orElse13;
var orElseEither9 = orElseEither7;
var orElseFail6 = orElseFail4;
var orElseIfEmpty2 = orElseIfEmpty;
var orElseIfEmptyChunk2 = orElseIfEmptyChunk;
var orElseIfEmptyStream2 = orElseIfEmptyStream;
var orElseSucceed7 = orElseSucceed5;
var paginate2 = paginate;
var paginateChunk2 = paginateChunk;
var paginateChunkEffect2 = paginateChunkEffect;
var paginateEffect2 = paginateEffect;
var partition14 = partition11;
var partitionEither2 = partitionEither;
var peel2 = peel;
var pipeThrough2 = pipeThrough;
var pipeThroughChannel2 = pipeThroughChannel;
var pipeThroughChannelOrFail2 = pipeThroughChannelOrFail;
var prepend7 = prepend6;
var provideContext14 = provideContext8;
var provideSomeContext5 = provideSomeContext3;
var provideLayer4 = provideLayer2;
var provideService13 = provideService10;
var provideServiceEffect5 = provideServiceEffect4;
var provideServiceStream2 = provideServiceStream;
var mapInputContext12 = mapInputContext7;
var provideSomeLayer5 = provideSomeLayer3;
var race9 = race5;
var raceAll5 = raceAll4;
var range5 = range4;
var rechunk2 = rechunk;
var refineOrDie6 = refineOrDie3;
var refineOrDieWith6 = refineOrDieWith3;
var repeat7 = repeat4;
var repeatEffect2 = repeatEffect;
var repeatEffectChunk2 = repeatEffectChunk;
var repeatEffectChunkOption2 = repeatEffectChunkOption;
var repeatEffectOption2 = repeatEffectOption;
var repeatEffectWithSchedule2 = repeatEffectWithSchedule;
var repeatEither2 = repeatEither;
var repeatElements2 = repeatElements;
var repeatElementsWith2 = repeatElementsWith;
var repeatValue2 = repeatValue;
var repeatWith2 = repeatWith;
var retry11 = retry7;
var withExecutionPlan4 = withExecutionPlan3;
var run9 = run4;
var runCollect4 = runCollect2;
var runCount2 = runCount;
var runDrain4 = runDrain2;
var runFold2 = runFold;
var runFoldEffect2 = runFoldEffect;
var runFoldScoped2 = runFoldScoped;
var runFoldScopedEffect2 = runFoldScopedEffect;
var runFoldWhile2 = runFoldWhile;
var runFoldWhileEffect2 = runFoldWhileEffect;
var runFoldWhileScoped2 = runFoldWhileScoped;
var runFoldWhileScopedEffect2 = runFoldWhileScopedEffect;
var runForEach2 = runForEach;
var runForEachChunk2 = runForEachChunk;
var runForEachChunkScoped2 = runForEachChunkScoped;
var runForEachScoped2 = runForEachScoped;
var runForEachWhile2 = runForEachWhile;
var runForEachWhileScoped2 = runForEachWhileScoped;
var runHead2 = runHead;
var runIntoPubSub2 = runIntoPubSub;
var runIntoPubSubScoped2 = runIntoPubSubScoped;
var runIntoQueue2 = runIntoQueue;
var runIntoQueueElementsScoped2 = runIntoQueueElementsScoped;
var runIntoQueueScoped2 = runIntoQueueScoped;
var runLast2 = runLast;
var runScoped4 = runScoped2;
var runSum2 = runSum;
var scan4 = scan3;
var scanEffect2 = scanEffect;
var scanReduce2 = scanReduce;
var scanReduceEffect2 = scanReduceEffect;
var schedule3 = schedule2;
var scheduleWith2 = scheduleWith;
var scoped9 = scoped7;
var scopedWith6 = scopedWith4;
var sliding10 = sliding9;
var slidingSize2 = slidingSize;
var some20 = some17;
var someOrElse2 = someOrElse;
var someOrFail2 = someOrFail;
var split6 = split4;
var splitOnChunk2 = splitOnChunk;
var splitLines4 = splitLines2;
var succeed29 = succeed20;
var sync22 = sync14;
var suspend17 = suspend10;
var take13 = take11;
var takeRight5 = takeRight4;
var takeUntil4 = takeUntil3;
var takeUntilEffect2 = takeUntilEffect;
var takeWhile7 = takeWhile6;
var tap11 = tap9;
var tapBoth6 = tapBoth4;
var tapError9 = tapError7;
var tapErrorCause7 = tapErrorCause6;
var tapSink2 = tapSink;
var throttle2 = throttle;
var throttleEffect2 = throttleEffect;
var tick2 = tick;
var timeout5 = timeout4;
var timeoutFail4 = timeoutFail3;
var timeoutFailCause4 = timeoutFailCause3;
var timeoutTo4 = timeoutTo3;
var toPubSub4 = toPubSub2;
var toPull4 = toPull2;
var toQueue4 = toQueue2;
var toQueueOfElements2 = toQueueOfElements;
var toReadableStream2 = toReadableStream;
var toReadableStreamEffect2 = toReadableStreamEffect;
var toReadableStreamRuntime2 = toReadableStreamRuntime;
var toAsyncIterableRuntime2 = toAsyncIterableRuntime;
var toAsyncIterableEffect2 = toAsyncIterableEffect;
var toAsyncIterable2 = toAsyncIterable;
var transduce2 = transduce;
var unfold6 = unfold5;
var unfoldChunk2 = unfoldChunk;
var unfoldChunkEffect2 = unfoldChunkEffect;
var unfoldEffect2 = unfoldEffect;
var void_14 = void_11;
var unwrap9 = unwrap4;
var unwrapScoped8 = unwrapScoped5;
var unwrapScopedWith6 = unwrapScopedWith3;
var updateService8 = updateService6;
var when9 = when5;
var whenCase2 = whenCase;
var whenCaseEffect2 = whenCaseEffect;
var whenEffect4 = whenEffect3;
var withSpan8 = withSpan6;
var zip26 = zip16;
var zipFlatten3 = zipFlatten2;
var zipAll2 = zipAll;
var zipAllLeft2 = zipAllLeft;
var zipAllRight2 = zipAllRight;
var zipAllSortedByKey2 = zipAllSortedByKey;
var zipAllSortedByKeyLeft2 = zipAllSortedByKeyLeft;
var zipAllSortedByKeyRight2 = zipAllSortedByKeyRight;
var zipAllSortedByKeyWith2 = zipAllSortedByKeyWith;
var zipAllWith2 = zipAllWith;
var zipLatest2 = zipLatest;
var zipLatestAll2 = zipLatestAll;
var zipLatestWith2 = zipLatestWith;
var zipLeft17 = zipLeft12;
var zipRight17 = zipRight12;
var zipWith22 = zipWith17;
var zipWithChunks2 = zipWithChunks;
var zipWithNext2 = zipWithNext;
var zipWithPrevious2 = zipWithPrevious;
var zipWithPreviousAndNext2 = zipWithPreviousAndNext;
var zipWithIndex2 = zipWithIndex;
var Do9 = Do7;
var bind11 = bind9;
var bindEffect2 = bindEffect;
var bindTo11 = bindTo9;
var let_11 = let_9;
var decodeText2 = decodeText;
var encodeText2 = encodeText;
var fromEventListener2 = fromEventListener;

// ../../node_modules/effect/dist/esm/StreamEmit.js
var StreamEmit_exports = {};

// ../../node_modules/effect/dist/esm/Streamable.js
var Streamable_exports = {};
__export(Streamable_exports, {
  Class: () => Class8
});
var streamVariance2 = {
  /* c8 ignore next */
  _R: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var Class8 = class {
  /**
   * @since 2.0.0
   */
  [StreamTypeId4] = streamVariance2;
  /**
   * @since 2.0.0
   */
  pipe() {
    return pipeArguments(this, arguments);
  }
  /**
   * @internal
   */
  get channel() {
    return toChannel6(this.toStream());
  }
};

// ../../node_modules/effect/dist/esm/Subscribable.js
var Subscribable_exports = {};
__export(Subscribable_exports, {
  TypeId: () => TypeId41,
  isSubscribable: () => isSubscribable,
  make: () => make121,
  map: () => map45,
  mapEffect: () => mapEffect11,
  unwrap: () => unwrap10
});
var TypeId41 = Symbol.for("effect/Subscribable");
var isSubscribable = (u) => hasProperty(u, TypeId41);
var Proto7 = {
  [TypeId15]: TypeId15,
  [TypeId41]: TypeId41,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make121 = (options) => Object.assign(Object.create(Proto7), options);
var map45 = dual(2, (self, f) => make121({
  get: map26(self.get, f),
  changes: map44(self.changes, f)
}));
var mapEffect11 = dual(2, (self, f) => make121({
  get: flatMap18(self.get, f),
  changes: mapEffect10(self.changes, f)
}));
var unwrap10 = (effect4) => make121({
  get: flatMap18(effect4, (s) => s.get),
  changes: unwrap9(map26(effect4, (s) => s.changes))
});

// ../../node_modules/effect/dist/esm/SubscriptionRef.js
var SubscriptionRef_exports = {};
__export(SubscriptionRef_exports, {
  SubscriptionRefTypeId: () => SubscriptionRefTypeId2,
  get: () => get36,
  getAndSet: () => getAndSet7,
  getAndUpdate: () => getAndUpdate7,
  getAndUpdateEffect: () => getAndUpdateEffect3,
  getAndUpdateSome: () => getAndUpdateSome6,
  getAndUpdateSomeEffect: () => getAndUpdateSomeEffect3,
  make: () => make124,
  modify: () => modify16,
  modifyEffect: () => modifyEffect4,
  modifySome: () => modifySome6,
  modifySomeEffect: () => modifySomeEffect3,
  set: () => set20,
  setAndGet: () => setAndGet6,
  update: () => update11,
  updateAndGet: () => updateAndGet7,
  updateAndGetEffect: () => updateAndGetEffect3,
  updateEffect: () => updateEffect3,
  updateSome: () => updateSome6,
  updateSomeAndGet: () => updateSomeAndGet6,
  updateSomeAndGetEffect: () => updateSomeAndGetEffect2,
  updateSomeEffect: () => updateSomeEffect3
});

// ../../node_modules/effect/dist/esm/SynchronizedRef.js
var SynchronizedRef_exports = {};
__export(SynchronizedRef_exports, {
  SynchronizedRefTypeId: () => SynchronizedRefTypeId,
  get: () => get34,
  getAndSet: () => getAndSet6,
  getAndUpdate: () => getAndUpdate6,
  getAndUpdateEffect: () => getAndUpdateEffect2,
  getAndUpdateSome: () => getAndUpdateSome5,
  getAndUpdateSomeEffect: () => getAndUpdateSomeEffect2,
  make: () => make122,
  modify: () => modify14,
  modifyEffect: () => modifyEffect2,
  modifySome: () => modifySome5,
  modifySomeEffect: () => modifySomeEffect2,
  set: () => set18,
  setAndGet: () => setAndGet5,
  unsafeMake: () => unsafeMake19,
  update: () => update10,
  updateAndGet: () => updateAndGet6,
  updateAndGetEffect: () => updateAndGetEffect2,
  updateEffect: () => updateEffect2,
  updateSome: () => updateSome5,
  updateSomeAndGet: () => updateSomeAndGet5,
  updateSomeAndGetEffect: () => updateSomeAndGetEffect,
  updateSomeEffect: () => updateSomeEffect2
});
var SynchronizedRefTypeId = SynchronizedTypeId;
var make122 = makeSynchronized;
var get34 = get12;
var getAndSet6 = getAndSet2;
var getAndUpdate6 = getAndUpdate2;
var getAndUpdateEffect2 = getAndUpdateEffect;
var getAndUpdateSome5 = getAndUpdateSome;
var getAndUpdateSomeEffect2 = getAndUpdateSomeEffect;
var modify14 = modify10;
var modifyEffect2 = modifyEffect;
var modifySome5 = modifySome;
var modifySomeEffect2 = modifySomeEffect;
var set18 = set6;
var setAndGet5 = setAndGet2;
var update10 = update3;
var updateEffect2 = updateEffect;
var updateAndGet6 = updateAndGet2;
var updateAndGetEffect2 = updateAndGetEffect;
var updateSome5 = updateSome;
var updateSomeEffect2 = updateSomeEffect;
var updateSomeAndGet5 = updateSomeAndGet;
var updateSomeAndGetEffect = updateSomeAndGetEffectSynchronized;
var unsafeMake19 = unsafeMakeSynchronized;

// ../../node_modules/effect/dist/esm/internal/subscriptionRef.js
var SubscriptionRefSymbolKey = "effect/SubscriptionRef";
var SubscriptionRefTypeId = Symbol.for(SubscriptionRefSymbolKey);
var subscriptionRefVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var SubscriptionRefImpl = class extends Class3 {
  ref;
  pubsub;
  semaphore;
  [TypeId15] = TypeId15;
  [TypeId41] = TypeId41;
  [RefTypeId2] = refVariance;
  [SynchronizedRefTypeId] = synchronizedVariance;
  [SubscriptionRefTypeId] = subscriptionRefVariance;
  constructor(ref, pubsub, semaphore) {
    super();
    this.ref = ref;
    this.pubsub = pubsub;
    this.semaphore = semaphore;
    this.get = get13(this.ref);
  }
  commit() {
    return this.get;
  }
  get;
  get changes() {
    return pipe(get13(this.ref), flatMap18((a) => map26(fromPubSub3(this.pubsub, {
      scoped: true
    }), (s) => concat3(make73(a), s))), this.semaphore.withPermits(1), unwrapScoped5);
  }
  modify(f) {
    return this.modifyEffect((a) => succeed13(f(a)));
  }
  modifyEffect(f) {
    return pipe(get13(this.ref), flatMap18(f), flatMap18(([b, a]) => pipe(set7(this.ref, a), as8(b), zipLeft7(publish2(this.pubsub, a)))), this.semaphore.withPermits(1));
  }
};
var get35 = (self) => get13(self.ref);
var make123 = (value10) => pipe(all11([unbounded4(), make37(value10), makeSemaphore2(1)]), map26(([pubsub, ref, semaphore]) => new SubscriptionRefImpl(ref, pubsub, semaphore)));
var modify15 = dual(2, (self, f) => self.modify(f));
var modifyEffect3 = dual(2, (self, f) => self.modifyEffect(f));
var set19 = dual(2, (self, value10) => pipe(set7(self.ref, value10), zipLeft7(publish2(self.pubsub, value10)), self.semaphore.withPermits(1)));

// ../../node_modules/effect/dist/esm/SubscriptionRef.js
var SubscriptionRefTypeId2 = SubscriptionRefTypeId;
var get36 = get35;
var getAndSet7 = getAndSet3;
var getAndUpdate7 = getAndUpdate3;
var getAndUpdateEffect3 = getAndUpdateEffect2;
var getAndUpdateSome6 = getAndUpdateSome2;
var getAndUpdateSomeEffect3 = getAndUpdateSomeEffect2;
var make124 = make123;
var modify16 = modify15;
var modifyEffect4 = modifyEffect3;
var modifySome6 = modifySome2;
var modifySomeEffect3 = modifySomeEffect2;
var set20 = set19;
var setAndGet6 = setAndGet3;
var update11 = update4;
var updateEffect3 = updateEffect2;
var updateAndGet7 = updateAndGet3;
var updateAndGetEffect3 = updateAndGetEffect2;
var updateSome6 = updateSome2;
var updateSomeEffect3 = updateSomeEffect2;
var updateSomeAndGet6 = updateSomeAndGet2;
var updateSomeAndGetEffect2 = updateSomeAndGetEffect;

// ../../node_modules/effect/dist/esm/Supervisor.js
var Supervisor_exports = {};
__export(Supervisor_exports, {
  AbstractSupervisor: () => AbstractSupervisor,
  SupervisorTypeId: () => SupervisorTypeId2,
  addSupervisor: () => addSupervisor2,
  fibersIn: () => fibersIn2,
  fromEffect: () => fromEffect15,
  none: () => none14,
  track: () => track2,
  unsafeTrack: () => unsafeTrack2
});
var SupervisorTypeId2 = SupervisorTypeId;
var addSupervisor2 = addSupervisor;
var fibersIn2 = fibersIn;
var fromEffect15 = fromEffect2;
var none14 = none8;
var track2 = track;
var unsafeTrack2 = unsafeTrack;
var AbstractSupervisor = class {
  /**
   * @since 2.0.0
   */
  onStart(_context, _effect, _parent, _fiber) {
  }
  /**
   * @since 2.0.0
   */
  onEnd(_value, _fiber) {
  }
  /**
   * @since 2.0.0
   */
  onEffect(_fiber, _effect) {
  }
  /**
   * @since 2.0.0
   */
  onSuspend(_fiber) {
  }
  /**
   * @since 2.0.0
   */
  onResume(_fiber) {
  }
  /**
   * @since 2.0.0
   */
  map(f) {
    return new ProxySupervisor(this, map14(this.value, f));
  }
  /**
   * @since 2.0.0
   */
  zip(right3) {
    return new Zip(this, right3);
  }
  /**
   * @since 2.0.0
   */
  onRun(execution, _fiber) {
    return execution();
  }
  /**
   * @since 2.0.0
   */
  [SupervisorTypeId2] = supervisorVariance;
};

// ../../node_modules/effect/dist/esm/Symbol.js
var Symbol_exports = {};
__export(Symbol_exports, {
  Equivalence: () => Equivalence10,
  isSymbol: () => isSymbol2
});
var isSymbol2 = isSymbol;
var Equivalence10 = symbol;

// ../../node_modules/effect/dist/esm/TArray.js
var TArray_exports = {};
__export(TArray_exports, {
  TArrayTypeId: () => TArrayTypeId2,
  collectFirst: () => collectFirst2,
  collectFirstSTM: () => collectFirstSTM2,
  contains: () => contains8,
  count: () => count8,
  countSTM: () => countSTM2,
  empty: () => empty51,
  every: () => every19,
  everySTM: () => everySTM2,
  findFirst: () => findFirst13,
  findFirstIndex: () => findFirstIndex4,
  findFirstIndexFrom: () => findFirstIndexFrom2,
  findFirstIndexWhere: () => findFirstIndexWhere2,
  findFirstIndexWhereFrom: () => findFirstIndexWhereFrom2,
  findFirstIndexWhereFromSTM: () => findFirstIndexWhereFromSTM2,
  findFirstIndexWhereSTM: () => findFirstIndexWhereSTM2,
  findFirstSTM: () => findFirstSTM2,
  findLast: () => findLast5,
  findLastIndex: () => findLastIndex4,
  findLastIndexFrom: () => findLastIndexFrom2,
  findLastSTM: () => findLastSTM2,
  forEach: () => forEach22,
  fromIterable: () => fromIterable25,
  get: () => get38,
  headOption: () => headOption3,
  lastOption: () => lastOption3,
  make: () => make126,
  maxOption: () => maxOption2,
  minOption: () => minOption2,
  reduce: () => reduce24,
  reduceOption: () => reduceOption2,
  reduceOptionSTM: () => reduceOptionSTM2,
  reduceSTM: () => reduceSTM2,
  size: () => size30,
  some: () => some22,
  someSTM: () => someSTM2,
  toArray: () => toArray5,
  transform: () => transform5,
  transformSTM: () => transformSTM2,
  update: () => update13,
  updateSTM: () => updateSTM2
});

// ../../node_modules/effect/dist/esm/internal/stm/tArray.js
var TArraySymbolKey = "effect/TArray";
var TArrayTypeId = Symbol.for(TArraySymbolKey);
var tArrayVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var TArrayImpl = class {
  chunk;
  [TArrayTypeId] = tArrayVariance;
  constructor(chunk7) {
    this.chunk = chunk7;
  }
};
var collectFirst = dual(2, (self, pf) => collectFirstSTM(self, (a) => pipe(pf(a), map2(succeed19))));
var collectFirstSTM = dual(2, (self, pf) => withSTMRuntime((runtime8) => {
  let index = 0;
  let result = none2();
  while (isNone2(result) && index < self.chunk.length) {
    const element2 = pipe(self.chunk[index], unsafeGet9(runtime8.journal));
    const option11 = pf(element2);
    if (isSome2(option11)) {
      result = option11;
    }
    index = index + 1;
  }
  return pipe(result, match2({
    onNone: () => succeedNone4,
    onSome: map31(some3)
  }));
}));
var contains7 = dual(2, (self, value10) => some21(self, (a) => equals(a)(value10)));
var count7 = dual(2, (self, predicate) => reduce23(self, 0, (n, a) => predicate(a) ? n + 1 : n));
var countSTM = dual(2, (self, predicate) => reduceSTM(self, 0, (n, a) => map31(predicate(a), (bool) => bool ? n + 1 : n)));
var empty50 = () => fromIterable24([]);
var every18 = dual(2, (self, predicate) => negate5(some21(self, (a) => !predicate(a))));
var everySTM = dual(2, (self, predicate) => map31(countSTM(self, predicate), (count9) => count9 === self.chunk.length));
var findFirst12 = dual(2, (self, predicate) => collectFirst(self, (a) => predicate(a) ? some3(a) : none2()));
var findFirstIndex3 = dual(2, (self, value10) => findFirstIndexFrom(self, value10, 0));
var findFirstIndexFrom = dual(3, (self, value10, from) => findFirstIndexWhereFrom(self, (a) => equals(a)(value10), from));
var findFirstIndexWhere = dual(2, (self, predicate) => findFirstIndexWhereFrom(self, predicate, 0));
var findFirstIndexWhereFrom = dual(3, (self, predicate, from) => {
  if (from < 0) {
    return succeedNone4;
  }
  return effect3((journal) => {
    let index = from;
    let found = false;
    while (!found && index < self.chunk.length) {
      const element2 = unsafeGet9(self.chunk[index], journal);
      found = predicate(element2);
      index = index + 1;
    }
    if (found) {
      return some3(index - 1);
    }
    return none2();
  });
});
var findFirstIndexWhereSTM = dual(2, (self, predicate) => findFirstIndexWhereFromSTM(self, predicate, 0));
var findFirstIndexWhereFromSTM = dual(3, (self, predicate, from) => {
  const forIndex = (index) => index < self.chunk.length ? pipe(get17(self.chunk[index]), flatMap22(predicate), flatMap22((bool) => bool ? succeed19(some3(index)) : forIndex(index + 1))) : succeedNone4;
  return from < 0 ? succeedNone4 : forIndex(from);
});
var findFirstSTM = dual(2, (self, predicate) => {
  const init2 = [none2(), 0];
  const cont = (state) => isNone2(state[0]) && state[1] < self.chunk.length - 1;
  return map31(iterate3(init2, {
    while: cont,
    body: (state) => {
      const index = state[1];
      return pipe(get17(self.chunk[index]), flatMap22((value10) => map31(predicate(value10), (bool) => [bool ? some3(value10) : none2(), index + 1])));
    }
  }), (state) => state[0]);
});
var findLast4 = dual(2, (self, predicate) => effect3((journal) => {
  let index = self.chunk.length - 1;
  let result = none2();
  while (isNone2(result) && index >= 0) {
    const element2 = unsafeGet9(self.chunk[index], journal);
    if (predicate(element2)) {
      result = some3(element2);
    }
    index = index - 1;
  }
  return result;
}));
var findLastIndex3 = dual(2, (self, value10) => findLastIndexFrom(self, value10, self.chunk.length - 1));
var findLastIndexFrom = dual(3, (self, value10, end7) => {
  if (end7 >= self.chunk.length) {
    return succeedNone4;
  }
  return effect3((journal) => {
    let index = end7;
    let found = false;
    while (!found && index >= 0) {
      const element2 = unsafeGet9(self.chunk[index], journal);
      found = equals(element2)(value10);
      index = index - 1;
    }
    if (found) {
      return some3(index + 1);
    }
    return none2();
  });
});
var findLastSTM = dual(2, (self, predicate) => {
  const init2 = [none2(), self.chunk.length - 1];
  const cont = (state) => isNone2(state[0]) && state[1] >= 0;
  return map31(iterate3(init2, {
    while: cont,
    body: (state) => {
      const index = state[1];
      return pipe(get17(self.chunk[index]), flatMap22((value10) => map31(predicate(value10), (bool) => [bool ? some3(value10) : none2(), index - 1])));
    }
  }), (state) => state[0]);
});
var forEach21 = dual(2, (self, f) => reduceSTM(self, void 0, (_, a) => f(a)));
var fromIterable24 = (iterable) => map31(forEach18(iterable, make69), (chunk7) => new TArrayImpl(chunk7));
var get37 = dual(2, (self, index) => {
  if (index < 0 || index >= self.chunk.length) {
    return dieMessage4("Index out of bounds");
  }
  return get17(self.chunk[index]);
});
var headOption2 = (self) => self.chunk.length === 0 ? succeed19(none2()) : map31(get17(self.chunk[0]), some3);
var lastOption2 = (self) => self.chunk.length === 0 ? succeedNone4 : map31(get17(self.chunk[self.chunk.length - 1]), some3);
var make125 = (...elements) => fromIterable24(elements);
var maxOption = dual(2, (self, order) => {
  const greaterThan12 = greaterThan(order);
  return reduceOption(self, (acc, curr) => greaterThan12(acc)(curr) ? curr : acc);
});
var minOption = dual(2, (self, order) => {
  const lessThan16 = lessThan(order);
  return reduceOption(self, (acc, curr) => lessThan16(acc)(curr) ? curr : acc);
});
var reduce23 = dual(3, (self, zero3, f) => effect3((journal) => {
  let index = 0;
  let result = zero3;
  while (index < self.chunk.length) {
    const element2 = unsafeGet9(self.chunk[index], journal);
    result = f(result, element2);
    index = index + 1;
  }
  return result;
}));
var reduceOption = dual(2, (self, f) => effect3((journal) => {
  let index = 0;
  let result = void 0;
  while (index < self.chunk.length) {
    const element2 = unsafeGet9(self.chunk[index], journal);
    result = result === void 0 ? element2 : f(result, element2);
    index = index + 1;
  }
  return fromNullable2(result);
}));
var reduceOptionSTM = dual(2, (self, f) => reduceSTM(self, none2(), (acc, curr) => isSome2(acc) ? map31(f(acc.value, curr), some3) : succeedSome4(curr)));
var reduceSTM = dual(3, (self, zero3, f) => flatMap22(toArray4(self), reduce19(zero3, f)));
var size29 = (self) => self.chunk.length;
var some21 = dual(2, (self, predicate) => map31(findFirst12(self, predicate), isSome2));
var someSTM = dual(2, (self, predicate) => map31(countSTM(self, predicate), (n) => n > 0));
var toArray4 = (self) => forEach18(self.chunk, get17);
var transform4 = dual(2, (self, f) => effect3((journal) => {
  let index = 0;
  while (index < self.chunk.length) {
    const ref = self.chunk[index];
    unsafeSet2(ref, f(unsafeGet9(ref, journal)), journal);
    index = index + 1;
  }
  return void 0;
}));
var transformSTM = dual(2, (self, f) => flatMap22(forEach18(self.chunk, (ref) => flatMap22(get17(ref), f)), (chunk7) => effect3((journal) => {
  const iterator = chunk7[Symbol.iterator]();
  let index = 0;
  let next6;
  while ((next6 = iterator.next()) && !next6.done) {
    unsafeSet2(self.chunk[index], next6.value, journal);
    index = index + 1;
  }
  return void 0;
})));
var update12 = dual(3, (self, index, f) => {
  if (index < 0 || index >= self.chunk.length) {
    return dieMessage4("Index out of bounds");
  }
  return update8(self.chunk[index], f);
});
var updateSTM = dual(3, (self, index, f) => {
  if (index < 0 || index >= self.chunk.length) {
    return dieMessage4("Index out of bounds");
  }
  return pipe(get17(self.chunk[index]), flatMap22(f), flatMap22((updated) => set10(self.chunk[index], updated)));
});

// ../../node_modules/effect/dist/esm/TArray.js
var TArrayTypeId2 = TArrayTypeId;
var collectFirst2 = collectFirst;
var collectFirstSTM2 = collectFirstSTM;
var contains8 = contains7;
var count8 = count7;
var countSTM2 = countSTM;
var empty51 = empty50;
var every19 = every18;
var everySTM2 = everySTM;
var findFirst13 = findFirst12;
var findFirstIndex4 = findFirstIndex3;
var findFirstIndexFrom2 = findFirstIndexFrom;
var findFirstIndexWhere2 = findFirstIndexWhere;
var findFirstIndexWhereFrom2 = findFirstIndexWhereFrom;
var findFirstIndexWhereSTM2 = findFirstIndexWhereSTM;
var findFirstIndexWhereFromSTM2 = findFirstIndexWhereFromSTM;
var findFirstSTM2 = findFirstSTM;
var findLast5 = findLast4;
var findLastIndex4 = findLastIndex3;
var findLastIndexFrom2 = findLastIndexFrom;
var findLastSTM2 = findLastSTM;
var forEach22 = forEach21;
var fromIterable25 = fromIterable24;
var get38 = get37;
var headOption3 = headOption2;
var lastOption3 = lastOption2;
var make126 = make125;
var maxOption2 = maxOption;
var minOption2 = minOption;
var reduce24 = reduce23;
var reduceOption2 = reduceOption;
var reduceOptionSTM2 = reduceOptionSTM;
var reduceSTM2 = reduceSTM;
var size30 = size29;
var some22 = some21;
var someSTM2 = someSTM;
var toArray5 = toArray4;
var transform5 = transform4;
var transformSTM2 = transformSTM;
var update13 = update12;
var updateSTM2 = updateSTM;

// ../../node_modules/effect/dist/esm/TDeferred.js
var TDeferred_exports = {};
__export(TDeferred_exports, {
  TDeferredTypeId: () => TDeferredTypeId2,
  await: () => _await5,
  done: () => done13,
  fail: () => fail28,
  make: () => make128,
  poll: () => poll12,
  succeed: () => succeed31
});

// ../../node_modules/effect/dist/esm/internal/stm/tDeferred.js
var TDeferredSymbolKey = "effect/TDeferred";
var TDeferredTypeId = Symbol.for(TDeferredSymbolKey);
var tDeferredVariance = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _E: (_) => _
};
var TDeferredImpl = class {
  ref;
  [TDeferredTypeId] = tDeferredVariance;
  constructor(ref) {
    this.ref = ref;
  }
};
var _await4 = (self) => flatten16(collect3(get17(self.ref), (option11) => isSome2(option11) ? some3(fromEither4(option11.value)) : none2()));
var done12 = dual(2, (self, either14) => flatMap22(get17(self.ref), match2({
  onNone: () => zipRight11(set10(self.ref, some3(either14)), succeed19(true)),
  onSome: () => succeed19(false)
})));
var fail27 = dual(2, (self, error4) => done12(self, left2(error4)));
var make127 = () => map31(make69(none2()), (ref) => new TDeferredImpl(ref));
var poll11 = (self) => get17(self.ref);
var succeed30 = dual(2, (self, value10) => done12(self, right2(value10)));

// ../../node_modules/effect/dist/esm/TDeferred.js
var TDeferredTypeId2 = TDeferredTypeId;
var _await5 = _await4;
var done13 = done12;
var fail28 = fail27;
var make128 = make127;
var poll12 = poll11;
var succeed31 = succeed30;

// ../../node_modules/effect/dist/esm/TMap.js
var TMap_exports = {};
__export(TMap_exports, {
  TMapTypeId: () => TMapTypeId2,
  empty: () => empty53,
  find: () => find6,
  findAll: () => findAll4,
  findAllSTM: () => findAllSTM2,
  findSTM: () => findSTM2,
  forEach: () => forEach24,
  fromIterable: () => fromIterable27,
  get: () => get40,
  getOrElse: () => getOrElse9,
  has: () => has14,
  isEmpty: () => isEmpty25,
  keys: () => keys12,
  make: () => make130,
  merge: () => merge15,
  reduce: () => reduce26,
  reduceSTM: () => reduceSTM4,
  remove: () => remove16,
  removeAll: () => removeAll2,
  removeIf: () => removeIf2,
  retainIf: () => retainIf2,
  set: () => set22,
  setIfAbsent: () => setIfAbsent2,
  size: () => size32,
  takeFirst: () => takeFirst2,
  takeFirstSTM: () => takeFirstSTM2,
  takeSome: () => takeSome2,
  takeSomeSTM: () => takeSomeSTM2,
  toArray: () => toArray7,
  toChunk: () => toChunk3,
  toHashMap: () => toHashMap2,
  toMap: () => toMap2,
  transform: () => transform7,
  transformSTM: () => transformSTM4,
  transformValues: () => transformValues2,
  transformValuesSTM: () => transformValuesSTM2,
  updateWith: () => updateWith4,
  values: () => values12
});

// ../../node_modules/effect/dist/esm/internal/stm/tMap.js
var TMapSymbolKey = "effect/TMap";
var TMapTypeId = Symbol.for(TMapSymbolKey);
var tMapVariance = {
  /* c8 ignore next */
  _K: (_) => _,
  /* c8 ignore next */
  _V: (_) => _
};
var TMapImpl = class {
  tBuckets;
  tSize;
  [TMapTypeId] = tMapVariance;
  constructor(tBuckets, tSize) {
    this.tBuckets = tBuckets;
    this.tSize = tSize;
  }
};
var isTMap = (u) => hasProperty(u, TMapTypeId);
var InitialCapacity = 16;
var LoadFactor = 0.75;
var nextPowerOfTwo = (size40) => {
  const n = -1 >>> Math.clz32(size40 - 1);
  return n < 0 ? 1 : n + 1;
};
var hash3 = (key) => {
  const h2 = hash(key);
  return h2 ^ h2 >>> 16;
};
var indexOf2 = (k, capacity10) => hash3(k) & capacity10 - 1;
var allocate2 = (capacity10, data) => {
  const buckets = Array.from({
    length: capacity10
  }, () => empty7());
  const distinct = new Map(data);
  let size40 = 0;
  for (const entry of distinct) {
    const index = indexOf2(entry[0], capacity10);
    buckets[index] = pipe(buckets[index], prepend3(entry));
    size40 = size40 + 1;
  }
  return pipe(fromIterable24(buckets), flatMap22((buckets2) => pipe(make69(buckets2), flatMap22((tBuckets) => pipe(make69(size40), map31((tSize) => new TMapImpl(tBuckets, tSize)))))));
};
var empty52 = () => fromIterable26([]);
var find5 = dual(2, (self, pf) => findSTM(self, (key, value10) => {
  const option11 = pf(key, value10);
  if (isSome2(option11)) {
    return succeed19(option11.value);
  }
  return fail17(none2());
}));
var findSTM = dual(2, (self, f) => reduceSTM3(self, none2(), (acc, value10, key) => isNone2(acc) ? matchSTM(f(key, value10), {
  onFailure: match2({
    onNone: () => succeedNone4,
    onSome: fail17
  }),
  onSuccess: succeedSome4
}) : succeed27(acc)));
var findAll3 = dual(2, (self, pf) => findAllSTM(self, (key, value10) => {
  const option11 = pf(key, value10);
  if (isSome2(option11)) {
    return succeed19(option11.value);
  }
  return fail17(none2());
}));
var findAllSTM = dual(2, (self, pf) => map31(reduceSTM3(self, empty7(), (acc, value10, key) => matchSTM(pf(key, value10), {
  onFailure: match2({
    onNone: () => succeed19(acc),
    onSome: fail17
  }),
  onSuccess: (a) => succeed19(append3(acc, a))
})), (a) => Array.from(a)));
var forEach23 = dual(2, (self, f) => reduceSTM3(self, void 0, (_, value10, key) => asVoid9(f(key, value10))));
var fromIterable26 = (iterable) => suspend9(() => {
  const data = fromIterable3(iterable);
  const capacity10 = data.length < InitialCapacity ? InitialCapacity : nextPowerOfTwo(data.length);
  return allocate2(capacity10, data);
});
var get39 = dual(2, (self, key) => effect3((journal) => {
  const buckets = unsafeGet9(self.tBuckets, journal);
  const index = indexOf2(key, buckets.chunk.length);
  const bucket = unsafeGet9(buckets.chunk[index], journal);
  return pipe(findFirst4(bucket, (entry) => equals(entry[0])(key)), map2((entry) => entry[1]));
}));
var getOrElse8 = dual(3, (self, key, fallback) => map31(get39(self, key), getOrElse2(fallback)));
var has13 = dual(2, (self, key) => map31(get39(self, key), isSome2));
var isEmpty24 = (self) => map31(get17(self.tSize), (size40) => size40 === 0);
var keys11 = (self) => map31(toReadonlyArray2(self), map6((entry) => entry[0]));
var make129 = (...entries7) => fromIterable26(entries7);
var merge14 = dual(4, (self, key, value10, f) => flatMap22(get39(self, key), match2({
  onNone: () => as12(set21(self, key, value10), value10),
  onSome: (v0) => {
    const v1 = f(v0, value10);
    return as12(set21(self, key, v1), v1);
  }
})));
var reduce25 = dual(3, (self, zero3, f) => effect3((journal) => {
  const buckets = unsafeGet9(self.tBuckets, journal);
  let result = zero3;
  let index = 0;
  while (index < buckets.chunk.length) {
    const bucket = buckets.chunk[index];
    const items = unsafeGet9(bucket, journal);
    result = reduce4(items, result, (acc, entry) => f(acc, entry[1], entry[0]));
    index = index + 1;
  }
  return result;
}));
var reduceSTM3 = dual(3, (self, zero3, f) => flatMap22(toReadonlyArray2(self), reduce19(zero3, (acc, entry) => f(acc, entry[1], entry[0]))));
var remove15 = dual(2, (self, key) => effect3((journal) => {
  const buckets = unsafeGet9(self.tBuckets, journal);
  const index = indexOf2(key, buckets.chunk.length);
  const bucket = unsafeGet9(buckets.chunk[index], journal);
  const [toRemove, toRetain] = partition3(bucket, (entry) => equals(entry[1], key));
  if (isNonEmpty2(toRemove)) {
    const currentSize = unsafeGet9(self.tSize, journal);
    unsafeSet2(buckets.chunk[index], toRetain, journal);
    unsafeSet2(self.tSize, currentSize - 1, journal);
  }
}));
var removeAll = dual(2, (self, keys15) => effect3((journal) => {
  const iterator = keys15[Symbol.iterator]();
  let next6;
  while ((next6 = iterator.next()) && !next6.done) {
    const buckets = unsafeGet9(self.tBuckets, journal);
    const index = indexOf2(next6.value, buckets.chunk.length);
    const bucket = unsafeGet9(buckets.chunk[index], journal);
    const [toRemove, toRetain] = partition3(bucket, (entry) => equals(next6.value)(entry[0]));
    if (isNonEmpty2(toRemove)) {
      const currentSize = unsafeGet9(self.tSize, journal);
      unsafeSet2(buckets.chunk[index], toRetain, journal);
      unsafeSet2(self.tSize, currentSize - 1, journal);
    }
  }
}));
var removeIf = dual((args2) => isTMap(args2[0]), (self, predicate, options) => effect3((journal) => {
  const discard3 = options?.discard === true;
  const buckets = unsafeGet9(self.tBuckets, journal);
  const capacity10 = buckets.chunk.length;
  const removed = [];
  let index = 0;
  let newSize = 0;
  while (index < capacity10) {
    const bucket = unsafeGet9(buckets.chunk[index], journal);
    const iterator = bucket[Symbol.iterator]();
    let next6;
    let newBucket = empty7();
    while ((next6 = iterator.next()) && !next6.done) {
      const [k, v] = next6.value;
      if (!predicate(k, v)) {
        newBucket = prepend3(newBucket, next6.value);
        newSize = newSize + 1;
      } else {
        if (!discard3) {
          removed.push([k, v]);
        }
      }
    }
    unsafeSet2(buckets.chunk[index], newBucket, journal);
    index = index + 1;
  }
  unsafeSet2(self.tSize, newSize, journal);
  if (!discard3) {
    return removed;
  }
}));
var retainIf = dual((args2) => isTMap(args2[0]), (self, predicate, options) => removeIf(self, (key, value10) => !predicate(key, value10), options));
var set21 = dual(3, (self, key, value10) => {
  const resize = (journal, buckets) => {
    const capacity10 = buckets.chunk.length;
    const newCapacity = capacity10 << 1;
    const newBuckets = Array.from({
      length: newCapacity
    }, () => empty7());
    let index = 0;
    while (index < capacity10) {
      const pairs = unsafeGet9(buckets.chunk[index], journal);
      const iterator = pairs[Symbol.iterator]();
      let next6;
      while ((next6 = iterator.next()) && !next6.done) {
        const newIndex2 = indexOf2(next6.value[0], newCapacity);
        newBuckets[newIndex2] = prepend3(newBuckets[newIndex2], next6.value);
      }
      index = index + 1;
    }
    const newIndex = indexOf2(key, newCapacity);
    newBuckets[newIndex] = prepend3(newBuckets[newIndex], [key, value10]);
    const newArray = [];
    index = 0;
    while (index < newCapacity) {
      newArray[index] = new TRefImpl(newBuckets[index]);
      index = index + 1;
    }
    const newTArray = new TArrayImpl(newArray);
    unsafeSet2(self.tBuckets, newTArray, journal);
  };
  return effect3((journal) => {
    const buckets = unsafeGet9(self.tBuckets, journal);
    const capacity10 = buckets.chunk.length;
    const index = indexOf2(key, capacity10);
    const bucket = unsafeGet9(buckets.chunk[index], journal);
    const shouldUpdate = some8(bucket, (entry) => equals(key)(entry[0]));
    if (shouldUpdate) {
      const newBucket = map7(bucket, (entry) => equals(key)(entry[0]) ? [key, value10] : entry);
      unsafeSet2(buckets.chunk[index], newBucket, journal);
    } else {
      const newSize = unsafeGet9(self.tSize, journal) + 1;
      unsafeSet2(self.tSize, newSize, journal);
      if (capacity10 * LoadFactor < newSize) {
        resize(journal, buckets);
      } else {
        const newBucket = prepend3(bucket, [key, value10]);
        unsafeSet2(buckets.chunk[index], newBucket, journal);
      }
    }
  });
});
var setIfAbsent = dual(3, (self, key, value10) => flatMap22(get39(self, key), match2({
  onNone: () => set21(self, key, value10),
  onSome: () => void_10
})));
var size31 = (self) => get17(self.tSize);
var takeFirst = dual(2, (self, pf) => pipe(effect3((journal) => {
  const buckets = unsafeGet9(self.tBuckets, journal);
  const capacity10 = buckets.chunk.length;
  const size40 = unsafeGet9(self.tSize, journal);
  let result = none2();
  let index = 0;
  while (index < capacity10 && isNone2(result)) {
    const bucket = unsafeGet9(buckets.chunk[index], journal);
    const recreate = some8(bucket, (entry) => isSome2(pf(entry[0], entry[1])));
    if (recreate) {
      const iterator = bucket[Symbol.iterator]();
      let newBucket = empty7();
      let next6;
      while ((next6 = iterator.next()) && !next6.done && isNone2(result)) {
        const option11 = pf(next6.value[0], next6.value[1]);
        if (isSome2(option11) && isNone2(result)) {
          result = option11;
        } else {
          newBucket = prepend3(newBucket, next6.value);
        }
      }
      unsafeSet2(buckets.chunk[index], newBucket, journal);
    }
    index = index + 1;
  }
  if (isSome2(result)) {
    unsafeSet2(self.tSize, size40 - 1, journal);
  }
  return result;
}), collect3((option11) => isSome2(option11) ? some3(option11.value) : none2())));
var takeFirstSTM = dual(2, (self, pf) => pipe(findSTM(self, (key, value10) => map31(pf(key, value10), (a) => [key, a])), collect3((option11) => isSome2(option11) ? some3(option11.value) : none2()), flatMap22((entry) => as12(remove15(self, entry[0]), entry[1]))));
var takeSome = dual(2, (self, pf) => pipe(effect3((journal) => {
  const buckets = unsafeGet9(self.tBuckets, journal);
  const capacity10 = buckets.chunk.length;
  const builder = [];
  let newSize = 0;
  let index = 0;
  while (index < capacity10) {
    const bucket = unsafeGet9(buckets.chunk[index], journal);
    const recreate = some8(bucket, (entry) => isSome2(pf(entry[0], entry[1])));
    if (recreate) {
      const iterator = bucket[Symbol.iterator]();
      let newBucket = empty7();
      let next6;
      while ((next6 = iterator.next()) && !next6.done) {
        const option11 = pf(next6.value[0], next6.value[1]);
        if (isSome2(option11)) {
          builder.push(option11.value);
        } else {
          newBucket = prepend3(newBucket, next6.value);
          newSize = newSize + 1;
        }
      }
      unsafeSet2(buckets.chunk[index], newBucket, journal);
    } else {
      newSize = newSize + bucket.length;
    }
    index = index + 1;
  }
  unsafeSet2(self.tSize, newSize, journal);
  if (builder.length > 0) {
    return some3(builder);
  }
  return none2();
}), collect3((option11) => isSome2(option11) ? some3(option11.value) : none2())));
var takeSomeSTM = dual(2, (self, pf) => pipe(findAllSTM(self, (key, value10) => map31(pf(key, value10), (a) => [key, a])), map31((chunk7) => isNonEmptyArray2(chunk7) ? some3(chunk7) : none2()), collect3((option11) => isSome2(option11) ? some3(option11.value) : none2()), flatMap22((entries7) => as12(removeAll(self, entries7.map((entry) => entry[0])), map6(entries7, (entry) => entry[1])))));
var toReadonlyArray2 = (self) => effect3((journal) => {
  const buckets = unsafeGet9(self.tBuckets, journal);
  const capacity10 = buckets.chunk.length;
  const builder = [];
  let index = 0;
  while (index < capacity10) {
    const bucket = buckets.chunk[index];
    for (const entry of unsafeGet9(bucket, journal)) {
      builder.push(entry);
    }
    index = index + 1;
  }
  return builder;
});
var toChunk2 = (self) => reduce25(self, empty7(), (acc, value10, key) => append3(acc, [key, value10]));
var toHashMap = (self) => reduce25(self, empty11(), (acc, value10, key) => pipe(acc, set4(key, value10)));
var toArray6 = (self) => reduce25(self, [], (acc, value10, key) => {
  acc.unshift([key, value10]);
  return acc;
});
var toMap = (self) => reduce25(self, /* @__PURE__ */ new Map(), (acc, value10, key) => acc.set(key, value10));
var transform6 = dual(2, (self, f) => effect3((journal) => {
  const buckets = pipe(self.tBuckets, unsafeGet9(journal));
  const capacity10 = buckets.chunk.length;
  const newBuckets = Array.from({
    length: capacity10
  }, () => empty7());
  let newSize = 0;
  let index = 0;
  while (index < capacity10) {
    const bucket = buckets.chunk[index];
    const pairs = unsafeGet9(bucket, journal);
    const iterator = pairs[Symbol.iterator]();
    let next6;
    while ((next6 = iterator.next()) && !next6.done) {
      const newPair = f(next6.value[0], next6.value[1]);
      const index2 = indexOf2(newPair[0], capacity10);
      const newBucket = newBuckets[index2];
      if (!some8(newBucket, (entry) => equals(entry[0], newPair[0]))) {
        newBuckets[index2] = prepend3(newBucket, newPair);
        newSize = newSize + 1;
      }
    }
    index = index + 1;
  }
  index = 0;
  while (index < capacity10) {
    unsafeSet2(buckets.chunk[index], newBuckets[index], journal);
    index = index + 1;
  }
  unsafeSet2(self.tSize, newSize, journal);
}));
var transformSTM3 = dual(2, (self, f) => pipe(flatMap22(toReadonlyArray2(self), forEach18((entry) => f(entry[0], entry[1]))), flatMap22((newData) => effect3((journal) => {
  const buckets = unsafeGet9(self.tBuckets, journal);
  const capacity10 = buckets.chunk.length;
  const newBuckets = Array.from({
    length: capacity10
  }, () => empty7());
  const iterator = newData[Symbol.iterator]();
  let newSize = 0;
  let next6;
  while ((next6 = iterator.next()) && !next6.done) {
    const index2 = indexOf2(next6.value[0], capacity10);
    const newBucket = newBuckets[index2];
    if (!some8(newBucket, (entry) => equals(entry[0])(next6.value[0]))) {
      newBuckets[index2] = prepend3(newBucket, next6.value);
      newSize = newSize + 1;
    }
  }
  let index = 0;
  while (index < capacity10) {
    unsafeSet2(buckets.chunk[index], newBuckets[index], journal);
    index = index + 1;
  }
  unsafeSet2(self.tSize, newSize, journal);
}))));
var transformValues = dual(2, (self, f) => transform6(self, (key, value10) => [key, f(value10)]));
var transformValuesSTM = dual(2, (self, f) => transformSTM3(self, (key, value10) => map31(f(value10), (value11) => [key, value11])));
var updateWith3 = dual(3, (self, key, f) => flatMap22(get39(self, key), (option11) => match2(f(option11), {
  onNone: () => as12(remove15(self, key), none2()),
  onSome: (value10) => as12(set21(self, key, value10), some3(value10))
})));
var values11 = (self) => map31(toReadonlyArray2(self), map6((entry) => entry[1]));

// ../../node_modules/effect/dist/esm/TMap.js
var TMapTypeId2 = TMapTypeId;
var empty53 = empty52;
var find6 = find5;
var findSTM2 = findSTM;
var findAll4 = findAll3;
var findAllSTM2 = findAllSTM;
var forEach24 = forEach23;
var fromIterable27 = fromIterable26;
var get40 = get39;
var getOrElse9 = getOrElse8;
var has14 = has13;
var isEmpty25 = isEmpty24;
var keys12 = keys11;
var make130 = make129;
var merge15 = merge14;
var reduce26 = reduce25;
var reduceSTM4 = reduceSTM3;
var remove16 = remove15;
var removeAll2 = removeAll;
var removeIf2 = removeIf;
var retainIf2 = retainIf;
var set22 = set21;
var setIfAbsent2 = setIfAbsent;
var size32 = size31;
var takeFirst2 = takeFirst;
var takeFirstSTM2 = takeFirstSTM;
var takeSome2 = takeSome;
var takeSomeSTM2 = takeSomeSTM;
var toChunk3 = toChunk2;
var toHashMap2 = toHashMap;
var toArray7 = toArray6;
var toMap2 = toMap;
var transform7 = transform6;
var transformSTM4 = transformSTM3;
var transformValues2 = transformValues;
var transformValuesSTM2 = transformValuesSTM;
var updateWith4 = updateWith3;
var values12 = values11;

// ../../node_modules/effect/dist/esm/TPriorityQueue.js
var TPriorityQueue_exports = {};
__export(TPriorityQueue_exports, {
  TPriorityQueueTypeId: () => TPriorityQueueTypeId2,
  empty: () => empty55,
  fromIterable: () => fromIterable29,
  isEmpty: () => isEmpty27,
  isNonEmpty: () => isNonEmpty10,
  make: () => make132,
  offer: () => offer8,
  offerAll: () => offerAll7,
  peek: () => peek4,
  peekOption: () => peekOption4,
  removeIf: () => removeIf4,
  retainIf: () => retainIf4,
  size: () => size34,
  take: () => take15,
  takeAll: () => takeAll6,
  takeOption: () => takeOption2,
  takeUpTo: () => takeUpTo6,
  toArray: () => toArray9,
  toChunk: () => toChunk5
});

// ../../node_modules/effect/dist/esm/internal/stm/tPriorityQueue.js
var TPriorityQueueSymbolKey = "effect/TPriorityQueue";
var TPriorityQueueTypeId = Symbol.for(TPriorityQueueSymbolKey);
var tPriorityQueueVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var TPriorityQueueImpl = class {
  ref;
  [TPriorityQueueTypeId] = tPriorityQueueVariance;
  constructor(ref) {
    this.ref = ref;
  }
};
var empty54 = (order) => pipe(make69(empty48(order)), map31((ref) => new TPriorityQueueImpl(ref)));
var fromIterable28 = (order) => (iterable) => pipe(make69(fromIterable2(iterable).reduce((map49, value10) => pipe(map49, set17(value10, pipe(map49, get33(value10), match2({
  onNone: () => of2(value10),
  onSome: prepend2(value10)
})))), empty48(order))), map31((ref) => new TPriorityQueueImpl(ref)));
var isEmpty26 = (self) => map31(get17(self.ref), isEmpty23);
var isNonEmpty9 = (self) => map31(get17(self.ref), isNonEmpty8);
var make131 = (order) => (...elements) => fromIterable28(order)(elements);
var offer7 = dual(2, (self, value10) => update8(self.ref, (map49) => set17(map49, value10, match2(get33(map49, value10), {
  onNone: () => of2(value10),
  onSome: prepend2(value10)
}))));
var offerAll6 = dual(2, (self, values15) => update8(self.ref, (map49) => fromIterable2(values15).reduce((map50, value10) => set17(map50, value10, match2(get33(map50, value10), {
  onNone: () => of2(value10),
  onSome: prepend2(value10)
})), map49)));
var peek3 = (self) => withSTMRuntime((runtime8) => {
  const map49 = unsafeGet9(self.ref, runtime8.journal);
  return match2(headOption(map49), {
    onNone: () => retry6,
    onSome: (elements) => succeed19(elements[0])
  });
});
var peekOption3 = (self) => modify12(self.ref, (map49) => [map2(headOption(map49), (elements) => elements[0]), map49]);
var removeIf3 = dual(2, (self, predicate) => retainIf3(self, (a) => !predicate(a)));
var retainIf3 = dual(2, (self, predicate) => update8(self.ref, (map49) => reduce22(map49, empty48(getOrder7(map49)), (map50, value10, key) => {
  const filtered = filter4(value10, predicate);
  return filtered.length > 0 ? set17(map50, key, filtered) : remove14(map50, key);
})));
var size33 = (self) => modify12(self.ref, (map49) => [reduce22(map49, 0, (n, as18) => n + as18.length), map49]);
var take14 = (self) => withSTMRuntime((runtime8) => {
  const map49 = unsafeGet9(self.ref, runtime8.journal);
  return match2(headOption(map49), {
    onNone: () => retry6,
    onSome: (values15) => {
      const head13 = values15[1][0];
      const tail5 = values15[1].slice(1);
      unsafeSet2(self.ref, tail5.length > 0 ? set17(map49, head13, tail5) : remove14(map49, head13), runtime8.journal);
      return succeed19(head13);
    }
  });
});
var takeAll5 = (self) => modify12(self.ref, (map49) => {
  const builder = [];
  for (const entry of map49) {
    for (const value10 of entry[1]) {
      builder.push(value10);
    }
  }
  return [builder, empty48(getOrder7(map49))];
});
var takeOption = (self) => effect3((journal) => {
  const map49 = pipe(self.ref, unsafeGet9(journal));
  return match2(headOption(map49), {
    onNone: () => none2(),
    onSome: ([key, value10]) => {
      const tail5 = value10.slice(1);
      unsafeSet2(self.ref, tail5.length > 0 ? set17(map49, key, tail5) : remove14(map49, key), journal);
      return some3(value10[0]);
    }
  });
});
var takeUpTo5 = dual(2, (self, n) => modify12(self.ref, (map49) => {
  const builder = [];
  const iterator = map49[Symbol.iterator]();
  let updated = map49;
  let index = 0;
  let next6;
  while ((next6 = iterator.next()) && !next6.done && index < n) {
    const [key, value10] = next6.value;
    const [left3, right3] = pipe(value10, splitAt(n - index));
    for (const value11 of left3) {
      builder.push(value11);
    }
    if (right3.length > 0) {
      updated = set17(updated, key, right3);
    } else {
      updated = remove14(updated, key);
    }
    index = index + left3.length;
  }
  return [builder, updated];
}));
var toChunk4 = (self) => modify12(self.ref, (map49) => {
  const builder = [];
  for (const entry of map49) {
    for (const value10 of entry[1]) {
      builder.push(value10);
    }
  }
  return [unsafeFromArray(builder), map49];
});
var toArray8 = (self) => modify12(self.ref, (map49) => {
  const builder = [];
  for (const entry of map49) {
    for (const value10 of entry[1]) {
      builder.push(value10);
    }
  }
  return [builder, map49];
});

// ../../node_modules/effect/dist/esm/TPriorityQueue.js
var TPriorityQueueTypeId2 = TPriorityQueueTypeId;
var empty55 = empty54;
var fromIterable29 = fromIterable28;
var isEmpty27 = isEmpty26;
var isNonEmpty10 = isNonEmpty9;
var make132 = make131;
var offer8 = offer7;
var offerAll7 = offerAll6;
var peek4 = peek3;
var peekOption4 = peekOption3;
var removeIf4 = removeIf3;
var retainIf4 = retainIf3;
var size34 = size33;
var take15 = take14;
var takeAll6 = takeAll5;
var takeOption2 = takeOption;
var takeUpTo6 = takeUpTo5;
var toChunk5 = toChunk4;
var toArray9 = toArray8;

// ../../node_modules/effect/dist/esm/TRandom.js
var TRandom_exports = {};
__export(TRandom_exports, {
  TRandomTypeId: () => TRandomTypeId2,
  Tag: () => Tag5,
  live: () => live2,
  next: () => next5,
  nextBoolean: () => nextBoolean4,
  nextInt: () => nextInt4,
  nextIntBetween: () => nextIntBetween4,
  nextRange: () => nextRange4,
  shuffle: () => shuffle4
});

// ../../node_modules/effect/dist/esm/internal/stm/tRandom.js
var TRandomSymbolKey = "effect/TRandom";
var TRandomTypeId = Symbol.for(TRandomSymbolKey);
var randomInteger = (state) => {
  const prng = new PCGRandom();
  prng.setState(state);
  return [prng.integer(0), prng.getState()];
};
var randomIntegerBetween = (low, high) => {
  return (state) => {
    const prng = new PCGRandom();
    prng.setState(state);
    return [prng.integer(high - low) + low, prng.getState()];
  };
};
var randomNumber = (state) => {
  const prng = new PCGRandom();
  prng.setState(state);
  return [prng.number(), prng.getState()];
};
var withState = (state, f) => {
  return pipe(state, modify12(f));
};
var shuffleWith2 = (iterable, nextIntBounded) => {
  const swap4 = (buffer5, index1, index2) => pipe(buffer5, get37(index1), flatMap22((tmp) => pipe(buffer5, updateSTM(index1, () => pipe(buffer5, get37(index2))), zipRight11(pipe(buffer5, update12(index2, () => tmp))))));
  return pipe(fromIterable24(iterable), flatMap22((buffer5) => {
    const array8 = [];
    for (let i = array8.length; i >= 2; i = i - 1) {
      array8.push(i);
    }
    return pipe(array8, forEach18((n) => pipe(nextIntBounded(n), flatMap22((k) => swap4(buffer5, n - 1, k))), {
      discard: true
    }), zipRight11(toArray4(buffer5)));
  }));
};
var Tag4 = GenericTag("effect/TRandom");
var TRandomImpl = class {
  state;
  [TRandomTypeId] = TRandomTypeId;
  constructor(state) {
    this.state = state;
    this.next = withState(this.state, randomNumber);
    this.nextBoolean = flatMap22(this.next, (n) => succeed19(n > 0.5));
    this.nextInt = withState(this.state, randomInteger);
  }
  next;
  nextBoolean;
  nextInt;
  nextRange(min11, max13) {
    return flatMap22(this.next, (n) => succeed19((max13 - min11) * n + min11));
  }
  nextIntBetween(low, high) {
    return withState(this.state, randomIntegerBetween(low, high));
  }
  shuffle(elements) {
    return shuffleWith2(elements, (n) => this.nextIntBetween(0, n));
  }
};
var live = effect(Tag4, pipe(make69(new PCGRandom(Math.random() * 4294967296 >>> 0).getState()), map31((seed) => new TRandomImpl(seed)), commit2));
var next4 = flatMap22(Tag4, (random4) => random4.next);
var nextBoolean3 = flatMap22(Tag4, (random4) => random4.nextBoolean);
var nextInt3 = flatMap22(Tag4, (random4) => random4.nextInt);
var nextIntBetween3 = (low, high) => flatMap22(Tag4, (random4) => random4.nextIntBetween(low, high));
var nextRange3 = (min11, max13) => flatMap22(Tag4, (random4) => random4.nextRange(min11, max13));
var shuffle3 = (elements) => flatMap22(Tag4, (random4) => random4.shuffle(elements));

// ../../node_modules/effect/dist/esm/TRandom.js
var TRandomTypeId2 = TRandomTypeId;
var Tag5 = Tag4;
var live2 = live;
var next5 = next4;
var nextBoolean4 = nextBoolean3;
var nextInt4 = nextInt3;
var nextIntBetween4 = nextIntBetween3;
var nextRange4 = nextRange3;
var shuffle4 = shuffle3;

// ../../node_modules/effect/dist/esm/TReentrantLock.js
var TReentrantLock_exports = {};
__export(TReentrantLock_exports, {
  TReentrantLockTypeId: () => TReentrantLockTypeId2,
  acquireRead: () => acquireRead2,
  acquireWrite: () => acquireWrite2,
  fiberReadLocks: () => fiberReadLocks2,
  fiberWriteLocks: () => fiberWriteLocks2,
  lock: () => lock2,
  locked: () => locked2,
  make: () => make134,
  readLock: () => readLock2,
  readLocked: () => readLocked2,
  readLocks: () => readLocks2,
  releaseRead: () => releaseRead2,
  releaseWrite: () => releaseWrite2,
  withLock: () => withLock2,
  withReadLock: () => withReadLock2,
  withWriteLock: () => withWriteLock2,
  writeLock: () => writeLock2,
  writeLocked: () => writeLocked2,
  writeLocks: () => writeLocks2
});

// ../../node_modules/effect/dist/esm/internal/stm/tReentrantLock.js
var TReentrantLockSymbolKey = "effect/TReentrantLock";
var TReentrantLockTypeId = Symbol.for(TReentrantLockSymbolKey);
var WriteLockTypeId = Symbol.for("effect/TReentrantLock/WriteLock");
var ReadLockTypeId = Symbol.for("effect/TReentrantLock/ReadLock");
var TReentranLockImpl = class {
  state;
  [TReentrantLockTypeId] = TReentrantLockTypeId;
  constructor(state) {
    this.state = state;
  }
};
var ReadLock = class {
  readers;
  [ReadLockTypeId] = ReadLockTypeId;
  constructor(readers) {
    this.readers = readers;
  }
  get readLocks() {
    return Array.from(this.readers).reduce((acc, curr) => acc + curr[1], 0);
  }
  get writeLocks() {
    return 0;
  }
  readLocksHeld(fiberId5) {
    return getOrElse2(get8(this.readers, fiberId5), () => 0);
  }
  writeLocksHeld(_fiberId) {
    return 0;
  }
};
var WriteLock = class {
  readLocks;
  writeLocks;
  fiberId;
  [WriteLockTypeId] = WriteLockTypeId;
  constructor(readLocks3, writeLocks3, fiberId5) {
    this.readLocks = readLocks3;
    this.writeLocks = writeLocks3;
    this.fiberId = fiberId5;
  }
  readLocksHeld(fiberId5) {
    return equals(fiberId5)(this.fiberId) ? this.readLocks : 0;
  }
  writeLocksHeld(fiberId5) {
    return equals(fiberId5)(this.fiberId) ? this.writeLocks : 0;
  }
};
var isReadLock = (lock3) => {
  return ReadLockTypeId in lock3;
};
var isWriteLock = (lock3) => {
  return WriteLockTypeId in lock3;
};
var emptyReadLock = new ReadLock(empty11());
var makeReadLock = (fiberId5, count9) => {
  if (count9 <= 0) {
    return emptyReadLock;
  }
  return new ReadLock(make18([fiberId5, count9]));
};
var noOtherHolder = (readLock3, fiberId5) => {
  return isEmpty4(readLock3.readers) || size7(readLock3.readers) === 1 && has5(readLock3.readers, fiberId5);
};
var adjustReadLock = (readLock3, fiberId5, adjustment) => {
  const total = readLock3.readLocksHeld(fiberId5);
  const newTotal = total + adjustment;
  if (newTotal < 0) {
    throw new Error("BUG - TReentrantLock.ReadLock.adjust - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  if (newTotal === 0) {
    return new ReadLock(remove7(readLock3.readers, fiberId5));
  }
  return new ReadLock(set4(readLock3.readers, fiberId5, newTotal));
};
var adjustRead = (self, delta) => withSTMRuntime((runtime8) => {
  const lock3 = unsafeGet9(self.state, runtime8.journal);
  if (isReadLock(lock3)) {
    const result = adjustReadLock(lock3, runtime8.fiberId, delta);
    unsafeSet2(self.state, result, runtime8.journal);
    return succeed19(result.readLocksHeld(runtime8.fiberId));
  }
  if (isWriteLock(lock3) && equals(runtime8.fiberId)(lock3.fiberId)) {
    const newTotal = lock3.readLocks + delta;
    if (newTotal < 0) {
      throw new Error(`Defect: Fiber ${threadName2(runtime8.fiberId)} releasing read locks it does not hold, newTotal: ${newTotal}`);
    }
    unsafeSet2(self.state, new WriteLock(newTotal, lock3.writeLocks, runtime8.fiberId), runtime8.journal);
    return succeed19(newTotal);
  }
  return retry6;
});
var acquireRead = (self) => adjustRead(self, 1);
var acquireWrite = (self) => withSTMRuntime((runtime8) => {
  const lock3 = unsafeGet9(self.state, runtime8.journal);
  if (isReadLock(lock3) && noOtherHolder(lock3, runtime8.fiberId)) {
    unsafeSet2(self.state, new WriteLock(lock3.readLocksHeld(runtime8.fiberId), 1, runtime8.fiberId), runtime8.journal);
    return succeed19(1);
  }
  if (isWriteLock(lock3) && equals(runtime8.fiberId)(lock3.fiberId)) {
    unsafeSet2(self.state, new WriteLock(lock3.readLocks, lock3.writeLocks + 1, runtime8.fiberId), runtime8.journal);
    return succeed19(lock3.writeLocks + 1);
  }
  return retry6;
});
var fiberReadLocks = (self) => effect3((journal, fiberId5) => unsafeGet9(self.state, journal).readLocksHeld(fiberId5));
var fiberWriteLocks = (self) => effect3((journal, fiberId5) => unsafeGet9(self.state, journal).writeLocksHeld(fiberId5));
var lock = (self) => writeLock(self);
var locked = (self) => zipWith16(readLocked(self), writeLocked(self), (x, y) => x || y);
var make133 = map31(make69(emptyReadLock), (readLock3) => new TReentranLockImpl(readLock3));
var readLock = (self) => acquireRelease3(commit2(acquireRead(self)), () => commit2(releaseRead(self)));
var readLocks = (self) => map31(get17(self.state), (state) => state.readLocks);
var readLocked = (self) => map31(get17(self.state), (state) => state.readLocks > 0);
var releaseRead = (self) => adjustRead(self, -1);
var releaseWrite = (self) => withSTMRuntime((runtime8) => {
  const lock3 = unsafeGet9(self.state, runtime8.journal);
  if (isWriteLock(lock3) && lock3.writeLocks === 1 && equals(runtime8.fiberId)(lock3.fiberId)) {
    const result = makeReadLock(lock3.fiberId, lock3.readLocks);
    unsafeSet2(self.state, result, runtime8.journal);
    return succeed19(result.writeLocksHeld(runtime8.fiberId));
  }
  if (isWriteLock(lock3) && equals(runtime8.fiberId)(lock3.fiberId)) {
    const result = new WriteLock(lock3.readLocks, lock3.writeLocks - 1, runtime8.fiberId);
    unsafeSet2(self.state, result, runtime8.journal);
    return succeed19(result.writeLocksHeld(runtime8.fiberId));
  }
  throw new Error(`Defect: Fiber ${threadName2(runtime8.fiberId)} releasing write lock it does not hold`);
});
var withLock = dual(2, (effect4, self) => withWriteLock(effect4, self));
var withReadLock = dual(2, (effect4, self) => uninterruptibleMask3((restore) => zipRight7(restore(commit2(acquireRead(self))), ensuring4(effect4, commit2(releaseRead(self))))));
var withWriteLock = dual(2, (effect4, self) => uninterruptibleMask3((restore) => zipRight7(restore(commit2(acquireWrite(self))), ensuring4(effect4, commit2(releaseWrite(self))))));
var writeLock = (self) => acquireRelease3(commit2(acquireWrite(self)), () => commit2(releaseWrite(self)));
var writeLocked = (self) => map31(get17(self.state), (state) => state.writeLocks > 0);
var writeLocks = (self) => map31(get17(self.state), (state) => state.writeLocks);

// ../../node_modules/effect/dist/esm/TReentrantLock.js
var TReentrantLockTypeId2 = TReentrantLockTypeId;
var acquireRead2 = acquireRead;
var acquireWrite2 = acquireWrite;
var fiberReadLocks2 = fiberReadLocks;
var fiberWriteLocks2 = fiberWriteLocks;
var lock2 = lock;
var locked2 = locked;
var make134 = make133;
var readLock2 = readLock;
var readLocks2 = readLocks;
var readLocked2 = readLocked;
var releaseRead2 = releaseRead;
var releaseWrite2 = releaseWrite;
var withLock2 = withLock;
var withReadLock2 = withReadLock;
var withWriteLock2 = withWriteLock;
var writeLock2 = writeLock;
var writeLocked2 = writeLocked;
var writeLocks2 = writeLocks;

// ../../node_modules/effect/dist/esm/TRef.js
var TRef_exports = {};
__export(TRef_exports, {
  TRefTypeId: () => TRefTypeId2,
  get: () => get41,
  getAndSet: () => getAndSet8,
  getAndUpdate: () => getAndUpdate8,
  getAndUpdateSome: () => getAndUpdateSome7,
  make: () => make135,
  modify: () => modify17,
  modifySome: () => modifySome7,
  set: () => set23,
  setAndGet: () => setAndGet7,
  update: () => update14,
  updateAndGet: () => updateAndGet8,
  updateSome: () => updateSome7,
  updateSomeAndGet: () => updateSomeAndGet7
});
var TRefTypeId2 = TRefTypeId;
var get41 = get17;
var getAndSet8 = getAndSet5;
var getAndUpdate8 = getAndUpdate5;
var getAndUpdateSome7 = getAndUpdateSome4;
var make135 = make69;
var modify17 = modify12;
var modifySome7 = modifySome4;
var set23 = set10;
var setAndGet7 = setAndGet4;
var update14 = update8;
var updateAndGet8 = updateAndGet5;
var updateSome7 = updateSome4;
var updateSomeAndGet7 = updateSomeAndGet4;

// ../../node_modules/effect/dist/esm/TSemaphore.js
var TSemaphore_exports = {};
__export(TSemaphore_exports, {
  TSemaphoreTypeId: () => TSemaphoreTypeId2,
  acquire: () => acquire3,
  acquireN: () => acquireN2,
  available: () => available2,
  make: () => make137,
  release: () => release3,
  releaseN: () => releaseN2,
  unsafeMake: () => unsafeMake20,
  withPermit: () => withPermit2,
  withPermitScoped: () => withPermitScoped2,
  withPermits: () => withPermits2,
  withPermitsScoped: () => withPermitsScoped2
});

// ../../node_modules/effect/dist/esm/internal/stm/tSemaphore.js
var TSemaphoreSymbolKey = "effect/TSemaphore";
var TSemaphoreTypeId = Symbol.for(TSemaphoreSymbolKey);
var TSemaphoreImpl = class {
  permits;
  [TSemaphoreTypeId] = TSemaphoreTypeId;
  constructor(permits) {
    this.permits = permits;
  }
};
var make136 = (permits) => map40(make69(permits), (permits2) => new TSemaphoreImpl(permits2));
var acquire2 = (self) => acquireN(self, 1);
var acquireN = dual(2, (self, n) => withSTMRuntime((driver3) => {
  if (n < 0) {
    throw new IllegalArgumentException2(`Unexpected negative value ${n} passed to Semaphore.acquireN`);
  }
  const value10 = unsafeGet9(self.permits, driver3.journal);
  if (value10 < n) {
    return retry10;
  } else {
    return succeed27(unsafeSet2(self.permits, value10 - n, driver3.journal));
  }
}));
var available = (self) => get17(self.permits);
var release2 = (self) => releaseN(self, 1);
var releaseN = dual(2, (self, n) => withSTMRuntime((driver3) => {
  if (n < 0) {
    throw new IllegalArgumentException2(`Unexpected negative value ${n} passed to Semaphore.releaseN`);
  }
  const current2 = unsafeGet9(self.permits, driver3.journal);
  return succeed27(unsafeSet2(self.permits, current2 + n, driver3.journal));
}));
var withPermit = dual(2, (self, semaphore) => withPermits(self, semaphore, 1));
var withPermits = dual(3, (self, semaphore, permits) => uninterruptibleMask3((restore) => zipRight7(restore(commit2(acquireN(permits)(semaphore))), ensuring4(self, commit2(releaseN(permits)(semaphore))))));
var withPermitScoped = (self) => withPermitsScoped(self, 1);
var withPermitsScoped = dual(2, (self, permits) => acquireReleaseInterruptible2(commit2(acquireN(self, permits)), () => commit2(releaseN(self, permits))));
var unsafeMakeSemaphore3 = (permits) => {
  return new TSemaphoreImpl(new TRefImpl(permits));
};

// ../../node_modules/effect/dist/esm/TSemaphore.js
var TSemaphoreTypeId2 = TSemaphoreTypeId;
var acquire3 = acquire2;
var acquireN2 = acquireN;
var available2 = available;
var make137 = make136;
var release3 = release2;
var releaseN2 = releaseN;
var withPermit2 = withPermit;
var withPermits2 = withPermits;
var withPermitScoped2 = withPermitScoped;
var withPermitsScoped2 = withPermitsScoped;
var unsafeMake20 = unsafeMakeSemaphore3;

// ../../node_modules/effect/dist/esm/TSet.js
var TSet_exports = {};
__export(TSet_exports, {
  TSetTypeId: () => TSetTypeId2,
  add: () => add12,
  difference: () => difference8,
  empty: () => empty57,
  forEach: () => forEach26,
  fromIterable: () => fromIterable31,
  has: () => has16,
  intersection: () => intersection9,
  isEmpty: () => isEmpty29,
  make: () => make139,
  reduce: () => reduce28,
  reduceSTM: () => reduceSTM6,
  remove: () => remove18,
  removeAll: () => removeAll4,
  removeIf: () => removeIf6,
  retainIf: () => retainIf6,
  size: () => size36,
  takeFirst: () => takeFirst4,
  takeFirstSTM: () => takeFirstSTM4,
  takeSome: () => takeSome4,
  takeSomeSTM: () => takeSomeSTM4,
  toArray: () => toArray11,
  toChunk: () => toChunk7,
  toHashSet: () => toHashSet2,
  toReadonlySet: () => toReadonlySet2,
  transform: () => transform9,
  transformSTM: () => transformSTM6,
  union: () => union16
});

// ../../node_modules/effect/dist/esm/internal/stm/tSet.js
var TSetSymbolKey = "effect/TSet";
var TSetTypeId = Symbol.for(TSetSymbolKey);
var tSetVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var TSetImpl = class {
  tMap;
  [TSetTypeId] = tSetVariance;
  constructor(tMap) {
    this.tMap = tMap;
  }
};
var isTSet = (u) => hasProperty(u, TSetTypeId);
var add11 = dual(2, (self, value10) => set21(self.tMap, value10, void 0));
var difference7 = dual(2, (self, other) => flatMap22(toHashSet(other), (values15) => removeIf5(self, (value10) => has4(values15, value10), {
  discard: true
})));
var empty56 = () => fromIterable30([]);
var forEach25 = dual(2, (self, f) => reduceSTM5(self, void 0, (_, value10) => f(value10)));
var fromIterable30 = (iterable) => map31(fromIterable26(Array.from(iterable).map((a) => [a, void 0])), (tMap) => new TSetImpl(tMap));
var has15 = dual(2, (self, value10) => has13(self.tMap, value10));
var intersection8 = dual(2, (self, other) => flatMap22(toHashSet(other), (values15) => pipe(self, retainIf5((value10) => pipe(values15, has4(value10)), {
  discard: true
}))));
var isEmpty28 = (self) => isEmpty24(self.tMap);
var make138 = (...elements) => fromIterable30(elements);
var reduce27 = dual(3, (self, zero3, f) => reduce25(self.tMap, zero3, (acc, _, key) => f(acc, key)));
var reduceSTM5 = dual(3, (self, zero3, f) => reduceSTM3(self.tMap, zero3, (acc, _, key) => f(acc, key)));
var remove17 = dual(2, (self, value10) => remove15(self.tMap, value10));
var removeAll3 = dual(2, (self, iterable) => removeAll(self.tMap, iterable));
var removeIf5 = dual((args2) => isTSet(args2[0]), (self, predicate, options) => options?.discard === true ? removeIf(self.tMap, (key) => predicate(key), {
  discard: true
}) : pipe(removeIf(self.tMap, (key) => predicate(key)), map31(map6((entry) => entry[0]))));
var retainIf5 = dual((args2) => isTSet(args2[0]), (self, predicate, options) => options?.discard === true ? retainIf(self.tMap, (key) => predicate(key), {
  discard: true
}) : pipe(retainIf(self.tMap, (key) => predicate(key)), map31(map6((entry) => entry[0]))));
var size35 = (self) => map31(toChunk6(self), (chunk7) => chunk7.length);
var takeFirst3 = dual(2, (self, pf) => takeFirst(self.tMap, (key) => pf(key)));
var takeFirstSTM3 = dual(2, (self, pf) => takeFirstSTM(self.tMap, (key) => pf(key)));
var takeSome3 = dual(2, (self, pf) => takeSome(self.tMap, (key) => pf(key)));
var takeSomeSTM3 = dual(2, (self, pf) => takeSomeSTM(self.tMap, (key) => pf(key)));
var toChunk6 = (self) => keys11(self.tMap).pipe(map40(unsafeFromArray));
var toHashSet = (self) => reduce27(self, empty10(), (acc, value10) => pipe(acc, add4(value10)));
var toArray10 = (self) => reduce27(self, [], (acc, value10) => [...acc, value10]);
var toReadonlySet = (self) => map31(toArray10(self), (values15) => new Set(values15));
var transform8 = dual(2, (self, f) => transform6(self.tMap, (key, value10) => [f(key), value10]));
var transformSTM5 = dual(2, (self, f) => transformSTM3(self.tMap, (key, value10) => map31(f(key), (a) => [a, value10])));
var union15 = dual(2, (self, other) => forEach25(other, (value10) => add11(self, value10)));

// ../../node_modules/effect/dist/esm/TSet.js
var TSetTypeId2 = TSetTypeId;
var add12 = add11;
var difference8 = difference7;
var empty57 = empty56;
var forEach26 = forEach25;
var fromIterable31 = fromIterable30;
var has16 = has15;
var intersection9 = intersection8;
var isEmpty29 = isEmpty28;
var make139 = make138;
var reduce28 = reduce27;
var reduceSTM6 = reduceSTM5;
var remove18 = remove17;
var removeAll4 = removeAll3;
var removeIf6 = removeIf5;
var retainIf6 = retainIf5;
var size36 = size35;
var takeFirst4 = takeFirst3;
var takeFirstSTM4 = takeFirstSTM3;
var takeSome4 = takeSome3;
var takeSomeSTM4 = takeSomeSTM3;
var toChunk7 = toChunk6;
var toHashSet2 = toHashSet;
var toArray11 = toArray10;
var toReadonlySet2 = toReadonlySet;
var transform9 = transform8;
var transformSTM6 = transformSTM5;
var union16 = union15;

// ../../node_modules/effect/dist/esm/TSubscriptionRef.js
var TSubscriptionRef_exports = {};
__export(TSubscriptionRef_exports, {
  TSubscriptionRefTypeId: () => TSubscriptionRefTypeId2,
  changes: () => changes3,
  changesScoped: () => changesScoped2,
  changesStream: () => changesStream2,
  get: () => get43,
  getAndSet: () => getAndSet10,
  getAndUpdate: () => getAndUpdate10,
  getAndUpdateSome: () => getAndUpdateSome9,
  make: () => make141,
  modify: () => modify19,
  modifySome: () => modifySome9,
  set: () => set25,
  setAndGet: () => setAndGet9,
  update: () => update16,
  updateAndGet: () => updateAndGet10,
  updateSome: () => updateSome9,
  updateSomeAndGet: () => updateSomeAndGet9
});

// ../../node_modules/effect/dist/esm/internal/stm/tSubscriptionRef.js
var TSubscriptionRefSymbolKey = "effect/TSubscriptionRef";
var TSubscriptionRefTypeId = Symbol.for(TSubscriptionRefSymbolKey);
var TSubscriptionRefVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var TDequeueMerge = class {
  first;
  second;
  [TDequeueTypeId2] = tDequeueVariance;
  constructor(first5, second) {
    this.first = first5;
    this.second = second;
  }
  peek = gen8(this, function* () {
    const first5 = yield* this.peekOption;
    if (first5._tag === "Some") {
      return first5.value;
    }
    return yield* retry10;
  });
  peekOption = gen8(this, function* () {
    const first5 = yield* this.first.peekOption;
    if (first5._tag === "Some") {
      return first5;
    }
    const second = yield* this.second.peekOption;
    if (second._tag === "Some") {
      return second;
    }
    return none2();
  });
  take = gen8(this, function* () {
    if (!(yield* this.first.isEmpty)) {
      return yield* this.first.take;
    }
    if (!(yield* this.second.isEmpty)) {
      return yield* this.second.take;
    }
    return yield* retry10;
  });
  takeAll = gen8(this, function* () {
    return [...yield* this.first.takeAll, ...yield* this.second.takeAll];
  });
  takeUpTo(max13) {
    return gen8(this, function* () {
      const first5 = yield* this.first.takeUpTo(max13);
      if (first5.length >= max13) {
        return first5;
      }
      return [...first5, ...yield* this.second.takeUpTo(max13 - first5.length)];
    });
  }
  capacity() {
    return this.first.capacity() + this.second.capacity();
  }
  size = gen8(this, function* () {
    return (yield* this.first.size) + (yield* this.second.size);
  });
  isFull = gen8(this, function* () {
    return (yield* this.first.isFull) && (yield* this.second.isFull);
  });
  isEmpty = gen8(this, function* () {
    return (yield* this.first.isEmpty) && (yield* this.second.isEmpty);
  });
  shutdown = gen8(this, function* () {
    yield* this.first.shutdown;
    yield* this.second.shutdown;
  });
  isShutdown = gen8(this, function* () {
    return (yield* this.first.isShutdown) && (yield* this.second.isShutdown);
  });
  awaitShutdown = gen8(this, function* () {
    yield* this.first.awaitShutdown;
    yield* this.second.awaitShutdown;
  });
};
var TSubscriptionRefImpl = class {
  ref;
  pubsub;
  [TSubscriptionRefTypeId] = TSubscriptionRefVariance;
  [TRefTypeId2] = tRefVariance;
  constructor(ref, pubsub) {
    this.ref = ref;
    this.pubsub = pubsub;
  }
  get todos() {
    return this.ref.todos;
  }
  get versioned() {
    return this.ref.versioned;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  get changes() {
    return gen8(this, function* () {
      const first5 = yield* unbounded9();
      yield* offer5(first5, yield* get41(this.ref));
      return new TDequeueMerge(first5, yield* subscribe4(this.pubsub));
    });
  }
  modify(f) {
    return pipe(get41(this.ref), map40(f), flatMap26(([b, a]) => pipe(set23(this.ref, a), as15(b), zipLeft15(publish4(this.pubsub, a)))));
  }
};
var make140 = (value10) => pipe(all15([unbounded8(), make135(value10)]), map40(([pubsub, ref]) => new TSubscriptionRefImpl(ref, pubsub)));
var get42 = (self) => get41(self.ref);
var set24 = dual(2, (self, value10) => self.modify(() => [void 0, value10]));
var getAndSet9 = dual(2, (self, value10) => self.modify((a) => [a, value10]));
var getAndUpdate9 = dual(2, (self, f) => self.modify((a) => [a, f(a)]));
var getAndUpdateSome8 = dual(2, (self, f) => self.modify((a) => match2(f(a), {
  onNone: () => [a, a],
  onSome: (b) => [a, b]
})));
var setAndGet8 = dual(2, (self, value10) => self.modify(() => [value10, value10]));
var modify18 = dual(2, (self, f) => self.modify(f));
var modifySome8 = dual(3, (self, fallback, f) => self.modify((a) => match2(f(a), {
  onNone: () => [fallback, a],
  onSome: (b) => b
})));
var update15 = dual(2, (self, f) => self.modify((a) => [void 0, f(a)]));
var updateAndGet9 = dual(2, (self, f) => self.modify((a) => {
  const b = f(a);
  return [b, b];
}));
var updateSome8 = dual(2, (self, f) => self.modify((a) => [void 0, match2(f(a), {
  onNone: () => a,
  onSome: (b) => b
})]));
var updateSomeAndGet8 = dual(2, (self, f) => self.modify((a) => match2(f(a), {
  onNone: () => [a, a],
  onSome: (b) => [b, b]
})));
var changesScoped = (self) => acquireRelease3(self.changes, shutdown8);
var changesStream = (self) => unwrap4(map26(self.changes, fromTQueue));

// ../../node_modules/effect/dist/esm/TSubscriptionRef.js
var TSubscriptionRefTypeId2 = TSubscriptionRefTypeId;
var get43 = get42;
var getAndSet10 = getAndSet9;
var getAndUpdate10 = getAndUpdate9;
var getAndUpdateSome9 = getAndUpdateSome8;
var make141 = make140;
var modify19 = modify18;
var modifySome9 = modifySome8;
var set25 = set24;
var setAndGet9 = setAndGet8;
var update16 = update15;
var updateAndGet10 = updateAndGet9;
var updateSome9 = updateSome8;
var updateSomeAndGet9 = updateSomeAndGet8;
var changesScoped2 = changesScoped;
var changesStream2 = changesStream;
var changes3 = (self) => self.changes;

// ../../node_modules/effect/dist/esm/Take.js
var Take_exports = {};
__export(Take_exports, {
  TakeTypeId: () => TakeTypeId2,
  chunk: () => chunk6,
  die: () => die18,
  dieMessage: () => dieMessage10,
  done: () => done14,
  end: () => end6,
  fail: () => fail29,
  failCause: () => failCause20,
  fromEffect: () => fromEffect16,
  fromExit: () => fromExit2,
  fromPull: () => fromPull4,
  isDone: () => isDone8,
  isFailure: () => isFailure9,
  isSuccess: () => isSuccess8,
  make: () => make142,
  map: () => map46,
  match: () => match40,
  matchEffect: () => matchEffect6,
  of: () => of8,
  tap: () => tap12
});
var TakeTypeId2 = TakeTypeId;
var chunk6 = chunk3;
var die18 = die13;
var dieMessage10 = dieMessage5;
var done14 = done11;
var end6 = end4;
var fail29 = fail18;
var failCause20 = failCause14;
var fromEffect16 = fromEffect8;
var fromExit2 = fromExit;
var fromPull4 = fromPull;
var isDone8 = isDone7;
var isFailure9 = isFailure7;
var isSuccess8 = isSuccess6;
var make142 = make72;
var map46 = map32;
var match40 = match32;
var matchEffect6 = matchEffect5;
var of8 = of7;
var tap12 = tap8;

// ../../node_modules/effect/dist/esm/TestAnnotation.js
var TestAnnotation_exports = {};
__export(TestAnnotation_exports, {
  TestAnnotationTypeId: () => TestAnnotationTypeId,
  compose: () => compose7,
  fibers: () => fibers,
  ignored: () => ignored,
  isTestAnnotation: () => isTestAnnotation,
  make: () => make143,
  repeated: () => repeated3,
  retried: () => retried,
  tagged: () => tagged8
});
var TestAnnotationSymbolKey = "effect/TestAnnotation";
var TestAnnotationTypeId = Symbol.for(TestAnnotationSymbolKey);
var TestAnnotationImpl = class {
  identifier;
  initial;
  combine;
  [TestAnnotationTypeId] = {
    _A: (_) => _
  };
  constructor(identifier2, initial, combine20) {
    this.identifier = identifier2;
    this.initial = initial;
    this.combine = combine20;
  }
  [symbol2]() {
    return pipe(hash(TestAnnotationSymbolKey), combine2(hash(this.identifier)), cached(this));
  }
  [symbol3](that) {
    return isTestAnnotation(that) && this.identifier === that.identifier;
  }
};
var isTestAnnotation = (u) => hasProperty(u, TestAnnotationTypeId);
var make143 = (identifier2, initial, combine20) => {
  return new TestAnnotationImpl(identifier2, initial, combine20);
};
var compose7 = (left3, right3) => {
  if (isLeft2(left3) && isLeft2(right3)) {
    return left2(left3.left + right3.left);
  }
  if (isRight2(left3) && isRight2(right3)) {
    return right2(pipe(left3.right, appendAll3(right3.right)));
  }
  if (isRight2(left3) && isLeft2(right3)) {
    return right3;
  }
  if (isLeft2(left3) && isRight2(right3)) {
    return right3;
  }
  throw new Error(getBugErrorMessage("TestAnnotation.compose"));
};
var fibers = make143("fibers", left2(0), compose7);
var ignored = make143("ignored", 0, (a, b) => a + b);
var repeated3 = make143("repeated", 0, (a, b) => a + b);
var retried = make143("retried", 0, (a, b) => a + b);
var tagged8 = make143("tagged", empty10(), (a, b) => pipe(a, union6(b)));

// ../../node_modules/effect/dist/esm/TestAnnotationMap.js
var TestAnnotationMap_exports = {};
__export(TestAnnotationMap_exports, {
  TestAnnotationMapTypeId: () => TestAnnotationMapTypeId,
  annotate: () => annotate,
  combine: () => combine19,
  empty: () => empty58,
  get: () => get44,
  isTestAnnotationMap: () => isTestAnnotationMap,
  make: () => make144,
  overwrite: () => overwrite,
  update: () => update17
});
var TestAnnotationMapTypeId = Symbol.for("effect/TestAnnotationMap");
var TestAnnotationMapImpl = class {
  map;
  [TestAnnotationMapTypeId] = TestAnnotationMapTypeId;
  constructor(map49) {
    this.map = map49;
  }
};
var isTestAnnotationMap = (u) => hasProperty(u, TestAnnotationMapTypeId);
var empty58 = () => new TestAnnotationMapImpl(empty11());
var make144 = (map49) => {
  return new TestAnnotationMapImpl(map49);
};
var overwrite = dual(3, (self, key, value10) => make144(set4(self.map, key, value10)));
var update17 = dual(3, (self, key, f) => {
  let value10 = key.initial;
  if (has5(self.map, key)) {
    value10 = unsafeGet6(self.map, key);
  }
  return overwrite(self, key, f(value10));
});
var get44 = dual(2, (self, key) => {
  if (has5(self.map, key)) {
    return unsafeGet6(self.map, key);
  }
  return key.initial;
});
var annotate = dual(3, (self, key, value10) => update17(self, key, (_) => key.combine(_, value10)));
var combine19 = dual(2, (self, that) => {
  let result = self.map;
  for (const entry of that.map) {
    if (has5(result, entry[0])) {
      const value10 = get8(result, entry[0]);
      result = set4(result, entry[0], entry[0].combine(value10, entry[1]));
    } else {
      result = set4(result, entry[0], entry[1]);
    }
  }
  return make144(result);
});

// ../../node_modules/effect/dist/esm/TestAnnotations.js
var TestAnnotations_exports = {};
__export(TestAnnotations_exports, {
  TestAnnotations: () => TestAnnotations,
  TestAnnotationsTypeId: () => TestAnnotationsTypeId,
  isTestAnnotations: () => isTestAnnotations,
  make: () => make145
});
var TestAnnotationsTypeId = Symbol.for("effect/TestAnnotations");
var AnnotationsImpl = class {
  ref;
  [TestAnnotationsTypeId] = TestAnnotationsTypeId;
  constructor(ref) {
    this.ref = ref;
  }
  get(key) {
    return map14(get13(this.ref), get44(key));
  }
  annotate(key, value10) {
    return update4(this.ref, annotate(key, value10));
  }
  get supervisedFibers() {
    return descriptorWith((descriptor3) => flatMap12(this.get(fibers), (either14) => {
      switch (either14._tag) {
        case "Left": {
          return succeed(empty32(Order7));
        }
        case "Right": {
          return pipe(either14.right, forEachSequential((ref) => sync(() => get7(ref))), map14(reduce3(empty32(Order7), (a, b) => union8(a, b))), map14(filter13((fiber) => !equals(fiber.id(), descriptor3.id))));
        }
      }
    }));
  }
};
var TestAnnotations = GenericTag("effect/Annotations");
var isTestAnnotations = (u) => hasProperty(u, TestAnnotationsTypeId);
var make145 = (ref) => new AnnotationsImpl(ref);

// ../../node_modules/effect/dist/esm/TestClock.js
var TestClock_exports = {};
__export(TestClock_exports, {
  TestClock: () => TestClock,
  TestClockImpl: () => TestClockImpl,
  adjust: () => adjust,
  adjustWith: () => adjustWith,
  currentTimeMillis: () => currentTimeMillis3,
  defaultTestClock: () => defaultTestClock,
  live: () => live3,
  makeData: () => makeData,
  save: () => save,
  setTime: () => setTime,
  sleep: () => sleep6,
  sleeps: () => sleeps,
  testClock: () => testClock,
  testClockWith: () => testClockWith
});

// ../../node_modules/effect/dist/esm/internal/testing/suspendedWarningData.js
var OP_SUSPENDED_WARNING_DATA_START = "Start";
var OP_SUSPENDED_WARNING_DATA_PENDING = "Pending";
var OP_SUSPENDED_WARNING_DATA_DONE = "Done";
var start3 = {
  _tag: OP_SUSPENDED_WARNING_DATA_START
};
var pending4 = (fiber) => {
  return {
    _tag: OP_SUSPENDED_WARNING_DATA_PENDING,
    fiber
  };
};
var done15 = {
  _tag: OP_SUSPENDED_WARNING_DATA_DONE
};
var isStart = (self) => {
  return self._tag === OP_SUSPENDED_WARNING_DATA_START;
};
var isPending2 = (self) => {
  return self._tag === OP_SUSPENDED_WARNING_DATA_PENDING;
};

// ../../node_modules/effect/dist/esm/internal/testing/warningData.js
var OP_WARNING_DATA_START = "Start";
var OP_WARNING_DATA_PENDING = "Pending";
var OP_WARNING_DATA_DONE = "Done";
var start4 = {
  _tag: OP_WARNING_DATA_START
};
var pending5 = (fiber) => {
  return {
    _tag: OP_WARNING_DATA_PENDING,
    fiber
  };
};
var done16 = {
  _tag: OP_WARNING_DATA_DONE
};
var isStart2 = (self) => {
  return self._tag === OP_WARNING_DATA_START;
};
var isPending3 = (self) => {
  return self._tag === OP_WARNING_DATA_PENDING;
};

// ../../node_modules/effect/dist/esm/TestLive.js
var TestLive_exports = {};
__export(TestLive_exports, {
  TestLive: () => TestLive,
  TestLiveTypeId: () => TestLiveTypeId,
  make: () => make146
});
var TestLiveTypeId = Symbol.for("effect/TestLive");
var TestLive = GenericTag("effect/TestLive");
var LiveImpl = class {
  services;
  [TestLiveTypeId] = TestLiveTypeId;
  constructor(services) {
    this.services = services;
  }
  provide(effect4) {
    return fiberRefLocallyWith(currentServices, merge3(this.services))(effect4);
  }
};
var make146 = (services) => new LiveImpl(services);

// ../../node_modules/effect/dist/esm/TestClock.js
var makeData = (instant, sleeps2) => ({
  instant,
  sleeps: sleeps2
});
var TestClock = GenericTag("effect/TestClock");
var warning = "Warning: A test is using time, but is not advancing the test clock, which may result in the test hanging. Use TestClock.adjust to manually advance the time.";
var suspendedWarning = "Warning: A test is advancing the test clock, but a fiber is not suspending, which may result in the test hanging. Use TestAspect.diagnose to identity the fiber that is not suspending.";
var TestClockImpl = class {
  clockState;
  live;
  annotations;
  warningState;
  suspendedWarningState;
  [ClockTypeId] = ClockTypeId;
  constructor(clockState, live6, annotations4, warningState, suspendedWarningState) {
    this.clockState = clockState;
    this.live = live6;
    this.annotations = annotations4;
    this.warningState = warningState;
    this.suspendedWarningState = suspendedWarningState;
    this.currentTimeMillis = map14(get12(this.clockState), (data) => data.instant);
    this.currentTimeNanos = map14(get12(this.clockState), (data) => BigInt(data.instant * 1e6));
  }
  /**
   * Unsafely returns the current time in milliseconds.
   */
  unsafeCurrentTimeMillis() {
    return unsafeGet7(this.clockState).instant;
  }
  /**
   * Unsafely returns the current time in nanoseconds.
   */
  unsafeCurrentTimeNanos() {
    return BigInt(unsafeGet7(this.clockState).instant * 1e6);
  }
  /**
   * Returns the current clock time in milliseconds.
   */
  currentTimeMillis;
  /**
   * Returns the current clock time in nanoseconds.
   */
  currentTimeNanos;
  /**
   * Saves the `TestClock`'s current state in an effect which, when run, will
   * restore the `TestClock` state to the saved state.
   */
  get save() {
    return map14(get12(this.clockState), (data) => set6(this.clockState, data));
  }
  /**
   * Sets the current clock time to the specified instant. Any effects that
   * were scheduled to occur on or before the new time will be run in order.
   */
  setTime(instant) {
    return zipRight2(this.warningDone(), this.run(() => instant));
  }
  /**
   * Semantically blocks the current fiber until the clock time is equal to or
   * greater than the specified duration. Once the clock time is adjusted to
   * on or after the duration, the fiber will automatically be resumed.
   */
  sleep(durationInput) {
    const duration5 = decode(durationInput);
    return flatMap12(deferredMake(), (deferred) => pipe(modify7(this.clockState, (data) => {
      const end7 = data.instant + toMillis(duration5);
      if (end7 > data.instant) {
        return [true, makeData(data.instant, pipe(data.sleeps, prepend3([end7, deferred])))];
      }
      return [false, data];
    }), flatMap12((shouldAwait) => shouldAwait ? pipe(this.warningStart(), zipRight2(deferredAwait(deferred))) : pipe(deferredSucceed(deferred, void 0), asVoid2))));
  }
  /**
   * Returns a list of the times at which all queued effects are scheduled to
   * resume.
   */
  get sleeps() {
    return map14(get12(this.clockState), (data) => map7(data.sleeps, (_) => _[0]));
  }
  /**
   * Increments the current clock time by the specified duration. Any effects
   * that were scheduled to occur on or before the new time will be run in
   * order.
   */
  adjust(durationInput) {
    const duration5 = decode(durationInput);
    return zipRight2(this.warningDone(), this.run((n) => n + toMillis(duration5)));
  }
  /**
   * Increments the current clock time by the specified duration. Any effects
   * that were scheduled to occur on or before the new time will be run in
   * order.
   */
  adjustWith(durationInput) {
    const duration5 = decode(durationInput);
    return (effect4) => zipLeftOptions(effect4, this.adjust(duration5), {
      concurrent: true
    });
  }
  /**
   * Returns a set of all fibers in this test.
   */
  supervisedFibers() {
    return this.annotations.supervisedFibers;
  }
  /**
   * Captures a "snapshot" of the identifier and status of all fibers in this
   * test other than the current fiber. Fails with the `void` value if any of
   * these fibers are not done or suspended. Note that because we cannot
   * synchronize on the status of multiple fibers at the same time this
   * snapshot may not be fully consistent.
   */
  freeze() {
    return flatMap12(this.supervisedFibers(), (fibers2) => pipe(fibers2, reduce12(empty11(), (map49, fiber) => pipe(fiber.status, flatMap12((status3) => {
      if (isDone3(status3)) {
        return succeed(set4(map49, fiber.id(), status3));
      }
      if (isSuspended2(status3)) {
        return succeed(set4(map49, fiber.id(), status3));
      }
      return fail2(void 0);
    })))));
  }
  /**
   * Forks a fiber that will display a warning message if a test is using time
   * but is not advancing the `TestClock`.
   */
  warningStart() {
    return updateSomeEffect(this.warningState, (data) => isStart2(data) ? some3(pipe(this.live.provide(pipe(logWarning(warning), delay(seconds(5)))), interruptible2, fork2, map14((fiber) => pending5(fiber)))) : none2());
  }
  /**
   * Cancels the warning message that is displayed if a test is using time but
   * is not advancing the `TestClock`.
   */
  warningDone() {
    return updateSomeEffect(this.warningState, (warningData) => {
      if (isStart2(warningData)) {
        return some3(succeed(done16));
      }
      if (isPending3(warningData)) {
        return some3(pipe(interruptFiber(warningData.fiber), as3(done16)));
      }
      return none2();
    });
  }
  yieldTimer = async_((resume2) => {
    const timer4 = setTimeout(() => {
      resume2(void_3);
    }, 0);
    return sync(() => clearTimeout(timer4));
  });
  /**
   * Returns whether all descendants of this fiber are done or suspended.
   */
  suspended() {
    return pipe(this.freeze(), zip5(pipe(this.yieldTimer, zipRight2(this.freeze()))), flatMap12(([first5, last8]) => equals(first5, last8) ? succeed(first5) : fail2(void 0)));
  }
  /**
   * Polls until all descendants of this fiber are done or suspended.
   */
  awaitSuspended() {
    return pipe(this.suspendedWarningStart(), zipRight2(pipe(this.suspended(), zipWith6(pipe(this.yieldTimer, zipRight2(this.suspended())), equals), filterOrFail(identity, constVoid), eventually)), zipRight2(this.suspendedWarningDone()));
  }
  /**
   * Forks a fiber that will display a warning message if a test is advancing
   * the `TestClock` but a fiber is not suspending.
   */
  suspendedWarningStart() {
    return updateSomeEffect(this.suspendedWarningState, (suspendedWarningData) => {
      if (isStart(suspendedWarningData)) {
        return some3(pipe(this.live.provide(pipe(logWarning(suspendedWarning), zipRight2(set6(this.suspendedWarningState, done15)), delay(seconds(5)))), interruptible2, fork2, map14((fiber) => pending4(fiber))));
      }
      return none2();
    });
  }
  /**
   * Cancels the warning message that is displayed if a test is advancing the
   * `TestClock` but a fiber is not suspending.
   */
  suspendedWarningDone() {
    return updateSomeEffect(this.suspendedWarningState, (suspendedWarningData) => {
      if (isPending2(suspendedWarningData)) {
        return some3(pipe(interruptFiber(suspendedWarningData.fiber), as3(start3)));
      }
      return none2();
    });
  }
  /**
   * Runs all effects scheduled to occur on or before the specified instant,
   * which may depend on the current time, in order.
   */
  run(f) {
    return pipe(this.awaitSuspended(), zipRight2(pipe(modify7(this.clockState, (data) => {
      const end7 = f(data.instant);
      const sorted = pipe(data.sleeps, sort2(pipe(Order, mapInput3((_) => _[0]))));
      if (isNonEmpty2(sorted)) {
        const [instant, deferred] = headNonEmpty2(sorted);
        if (instant <= end7) {
          return [some3([end7, deferred]), makeData(instant, tailNonEmpty2(sorted))];
        }
      }
      return [none2(), makeData(end7, data.sleeps)];
    }), flatMap12((option11) => {
      switch (option11._tag) {
        case "None": {
          return void_3;
        }
        case "Some": {
          const [end7, deferred] = option11.value;
          return pipe(deferredSucceed(deferred, void 0), zipRight2(yieldNow()), zipRight2(this.run(() => end7)));
        }
      }
    }))));
  }
};
var live3 = (data) => scoped3(TestClock, gen4(function* ($) {
  const live6 = yield* $(TestLive);
  const annotations4 = yield* $(TestAnnotations);
  const clockState = yield* $(sync(() => unsafeMake7(data)));
  const warningState = yield* $(makeSynchronized(start4));
  const suspendedWarningState = yield* $(makeSynchronized(start3));
  const testClock2 = new TestClockImpl(clockState, live6, annotations4, warningState, suspendedWarningState);
  yield* $(withClockScoped(testClock2));
  yield* $(addFinalizer2(() => zipRight2(testClock2.warningDone(), testClock2.suspendedWarningDone())));
  return testClock2;
}));
var defaultTestClock = live3(makeData((/* @__PURE__ */ new Date(0)).getTime(), empty7()));
var adjust = (durationInput) => {
  const duration5 = decode(durationInput);
  return testClockWith((testClock2) => testClock2.adjust(duration5));
};
var adjustWith = dual(2, (effect4, durationInput) => {
  const duration5 = decode(durationInput);
  return testClockWith((testClock2) => testClock2.adjustWith(duration5)(effect4));
});
var save = () => testClockWith((testClock2) => testClock2.save);
var setTime = (input) => testClockWith((testClock2) => testClock2.setTime(typeof input === "number" ? input : unsafeMake14(input).epochMillis));
var sleep6 = (durationInput) => {
  const duration5 = decode(durationInput);
  return testClockWith((testClock2) => testClock2.sleep(duration5));
};
var sleeps = () => testClockWith((testClock2) => testClock2.sleeps);
var testClock = () => testClockWith(succeed);
var testClockWith = (f) => fiberRefGetWith(currentServices, (services) => f(pipe(services, get4(clockTag))));
var currentTimeMillis3 = testClockWith((testClock2) => testClock2.currentTimeMillis);

// ../../node_modules/effect/dist/esm/TestConfig.js
var TestConfig_exports = {};
__export(TestConfig_exports, {
  TestConfig: () => TestConfig,
  make: () => make147
});
var TestConfig = GenericTag("effect/TestConfig");
var make147 = (params) => params;

// ../../node_modules/effect/dist/esm/TestContext.js
var TestContext_exports = {};
__export(TestContext_exports, {
  LiveContext: () => LiveContext,
  TestContext: () => TestContext,
  live: () => live5
});

// ../../node_modules/effect/dist/esm/TestServices.js
var TestServices_exports = {};
__export(TestServices_exports, {
  annotate: () => annotate2,
  annotations: () => annotations3,
  annotationsLayer: () => annotationsLayer,
  annotationsWith: () => annotationsWith,
  currentServices: () => currentServices3,
  get: () => get45,
  live: () => live4,
  liveLayer: () => liveLayer,
  liveServices: () => liveServices3,
  liveWith: () => liveWith,
  provideLive: () => provideLive,
  provideWithLive: () => provideWithLive,
  repeats: () => repeats,
  retries: () => retries,
  samples: () => samples,
  shrinks: () => shrinks,
  size: () => size37,
  sized: () => sized,
  sizedLayer: () => sizedLayer,
  sizedWith: () => sizedWith,
  supervisedFibers: () => supervisedFibers,
  testConfig: () => testConfig,
  testConfigLayer: () => testConfigLayer,
  testConfigWith: () => testConfigWith,
  withAnnotations: () => withAnnotations,
  withAnnotationsScoped: () => withAnnotationsScoped,
  withLive: () => withLive,
  withLiveScoped: () => withLiveScoped,
  withSize: () => withSize,
  withSized: () => withSized,
  withSizedScoped: () => withSizedScoped,
  withTestConfig: () => withTestConfig,
  withTestConfigScoped: () => withTestConfigScoped
});

// ../../node_modules/effect/dist/esm/TestSized.js
var TestSized_exports = {};
__export(TestSized_exports, {
  TestSized: () => TestSized,
  TestSizedTypeId: () => TestSizedTypeId,
  fromFiberRef: () => fromFiberRef,
  make: () => make148
});
var TestSizedTypeId = Symbol.for("effect/TestSized");
var TestSized = GenericTag("effect/TestSized");
var SizedImpl = class {
  fiberRef;
  [TestSizedTypeId] = TestSizedTypeId;
  constructor(fiberRef) {
    this.fiberRef = fiberRef;
  }
  get size() {
    return fiberRefGet(this.fiberRef);
  }
  withSize(size40) {
    return (effect4) => fiberRefLocally(this.fiberRef, size40)(effect4);
  }
};
var make148 = (size40) => new SizedImpl(fiberRefUnsafeMake(size40));
var fromFiberRef = (fiberRef) => new SizedImpl(fiberRef);

// ../../node_modules/effect/dist/esm/TestServices.js
var liveServices3 = pipe(make8(TestAnnotations, make145(unsafeMake7(empty58()))), add2(TestLive, make146(liveServices)), add2(TestSized, make148(100)), add2(TestConfig, make147({
  repeats: 100,
  retries: 100,
  samples: 200,
  shrinks: 1e3
})));
var currentServices3 = fiberRefUnsafeMakeContext(liveServices3);
var annotations3 = () => annotationsWith(succeed);
var annotationsWith = (f) => fiberRefGetWith(currentServices3, (services) => f(get4(services, TestAnnotations)));
var withAnnotations = dual(2, (effect4, annotations4) => fiberRefLocallyWith(currentServices3, add2(TestAnnotations, annotations4))(effect4));
var withAnnotationsScoped = (annotations4) => fiberRefLocallyScopedWith(currentServices3, add2(TestAnnotations, annotations4));
var annotationsLayer = () => scoped3(TestAnnotations, pipe(sync(() => unsafeMake7(empty58())), map14(make145), tap2(withAnnotationsScoped)));
var get45 = (key) => annotationsWith((annotations4) => annotations4.get(key));
var annotate2 = (key, value10) => annotationsWith((annotations4) => annotations4.annotate(key, value10));
var supervisedFibers = () => annotationsWith((annotations4) => annotations4.supervisedFibers);
var liveWith = (f) => fiberRefGetWith(currentServices3, (services) => f(get4(services, TestLive)));
var live4 = liveWith(succeed);
var withLive = dual(2, (effect4, live6) => fiberRefLocallyWith(currentServices3, add2(TestLive, live6))(effect4));
var withLiveScoped = (live6) => fiberRefLocallyScopedWith(currentServices3, add2(TestLive, live6));
var liveLayer = () => scoped3(TestLive, pipe(context2(), map14(make146), tap2(withLiveScoped)));
var provideLive = (effect4) => liveWith((live6) => live6.provide(effect4));
var provideWithLive = dual(2, (self, f) => fiberRefGetWith(currentServices, (services) => provideLive(f(fiberRefLocally(currentServices, services)(self)))));
var sizedWith = (f) => fiberRefGetWith(currentServices3, (services) => f(get4(services, TestSized)));
var sized = sizedWith(succeed);
var withSized = dual(2, (effect4, sized2) => fiberRefLocallyWith(currentServices3, add2(TestSized, sized2))(effect4));
var withSizedScoped = (sized2) => fiberRefLocallyScopedWith(currentServices3, add2(TestSized, sized2));
var sizedLayer = (size40) => scoped3(TestSized, pipe(fiberRefMake(size40), map14(fromFiberRef), tap2(withSizedScoped)));
var size37 = sizedWith((sized2) => sized2.size);
var withSize = dual(2, (effect4, size40) => sizedWith((sized2) => sized2.withSize(size40)(effect4)));
var testConfigWith = (f) => fiberRefGetWith(currentServices3, (services) => f(get4(services, TestConfig)));
var testConfig = testConfigWith(succeed);
var withTestConfig = dual(2, (effect4, config2) => fiberRefLocallyWith(currentServices3, add2(TestConfig, config2))(effect4));
var withTestConfigScoped = (config2) => fiberRefLocallyScopedWith(currentServices3, add2(TestConfig, config2));
var testConfigLayer = (params) => scoped3(TestConfig, suspend4(() => {
  const testConfig2 = make147(params);
  return pipe(withTestConfigScoped(testConfig2), as3(testConfig2));
}));
var repeats = testConfigWith((config2) => succeed(config2.repeats));
var retries = testConfigWith((config2) => succeed(config2.retries));
var samples = testConfigWith((config2) => succeed(config2.samples));
var shrinks = testConfigWith((config2) => succeed(config2.shrinks));

// ../../node_modules/effect/dist/esm/TestContext.js
var live5 = pipe(annotationsLayer(), merge6(liveLayer()), merge6(sizedLayer(100)), merge6(pipe(defaultTestClock, provideMerge(merge6(liveLayer(), annotationsLayer())))), merge6(testConfigLayer({
  repeats: 100,
  retries: 100,
  samples: 200,
  shrinks: 1e3
})));
var LiveContext = syncContext(() => liveServices);
var TestContext = provideMerge(live5, LiveContext);

// ../../node_modules/effect/dist/esm/Trie.js
var Trie_exports = {};
__export(Trie_exports, {
  compact: () => compact6,
  empty: () => empty60,
  entries: () => entries6,
  entriesWithPrefix: () => entriesWithPrefix2,
  filter: () => filter25,
  filterMap: () => filterMap15,
  forEach: () => forEach28,
  fromIterable: () => fromIterable33,
  get: () => get47,
  has: () => has18,
  insert: () => insert4,
  insertMany: () => insertMany2,
  isEmpty: () => isEmpty31,
  keys: () => keys14,
  keysWithPrefix: () => keysWithPrefix2,
  longestPrefixOf: () => longestPrefixOf2,
  make: () => make150,
  map: () => map48,
  modify: () => modify21,
  reduce: () => reduce30,
  remove: () => remove20,
  removeMany: () => removeMany4,
  size: () => size39,
  toEntries: () => toEntries3,
  toEntriesWithPrefix: () => toEntriesWithPrefix2,
  unsafeGet: () => unsafeGet13,
  values: () => values14,
  valuesWithPrefix: () => valuesWithPrefix2
});

// ../../node_modules/effect/dist/esm/internal/trie.js
var TrieSymbolKey = "effect/Trie";
var TrieTypeId = Symbol.for(TrieSymbolKey);
var trieVariance = {
  /* c8 ignore next */
  _Value: (_) => _
};
var TrieProto = {
  [TrieTypeId]: trieVariance,
  [Symbol.iterator]() {
    return new TrieIterator(this, (k, v) => [k, v], () => true);
  },
  [symbol2]() {
    let hash4 = hash(TrieSymbolKey);
    for (const item of this) {
      hash4 ^= pipe(hash(item[0]), combine2(hash(item[1])));
    }
    return cached(this, hash4);
  },
  [symbol3](that) {
    if (isTrie(that)) {
      const entries7 = Array.from(that);
      return Array.from(this).every((itemSelf, i) => {
        const itemThat = entries7[i];
        return equals(itemSelf[0], itemThat[0]) && equals(itemSelf[1], itemThat[1]);
      });
    }
    return false;
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Trie",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl6 = (root) => {
  const trie = Object.create(TrieProto);
  trie._root = root;
  trie._count = root?.count ?? 0;
  return trie;
};
var TrieIterator = class _TrieIterator {
  trie;
  f;
  filter;
  stack = [];
  constructor(trie, f, filter26) {
    this.trie = trie;
    this.f = f;
    this.filter = filter26;
    const root = trie._root !== void 0 ? trie._root : void 0;
    if (root !== void 0) {
      this.stack.push([root, "", false]);
    }
  }
  next() {
    while (this.stack.length > 0) {
      const [node, keyString, isAdded] = this.stack.pop();
      if (isAdded) {
        const value10 = node.value;
        if (value10 !== void 0) {
          const key = keyString + node.key;
          if (this.filter(key, value10)) {
            return {
              done: false,
              value: this.f(key, value10)
            };
          }
        }
      } else {
        this.addToStack(node, keyString);
      }
    }
    return {
      done: true,
      value: void 0
    };
  }
  addToStack(node, keyString) {
    if (node.right !== void 0) {
      this.stack.push([node.right, keyString, false]);
    }
    if (node.mid !== void 0) {
      this.stack.push([node.mid, keyString + node.key, false]);
    }
    this.stack.push([node, keyString, true]);
    if (node.left !== void 0) {
      this.stack.push([node.left, keyString, false]);
    }
  }
  [Symbol.iterator]() {
    return new _TrieIterator(this.trie, this.f, this.filter);
  }
};
var isTrie = (u) => hasProperty(u, TrieTypeId);
var empty59 = () => makeImpl6(void 0);
var fromIterable32 = (entries7) => {
  let trie = empty59();
  for (const [key, value10] of entries7) {
    trie = insert3(trie, key, value10);
  }
  return trie;
};
var make149 = (...entries7) => {
  return fromIterable32(entries7);
};
var insert3 = dual(3, (self, key, value10) => {
  if (key.length === 0) return self;
  const dStack = [];
  const nStack = [];
  let n = self._root ?? {
    key: key[0],
    count: 0
  };
  const count9 = n.count + 1;
  let cIndex = 0;
  while (cIndex < key.length) {
    const c = key[cIndex];
    nStack.push(n);
    if (c > n.key) {
      dStack.push(1);
      if (n.right === void 0) {
        n = {
          key: c,
          count: count9
        };
      } else {
        n = n.right;
      }
    } else if (c < n.key) {
      dStack.push(-1);
      if (n.left === void 0) {
        n = {
          key: c,
          count: count9
        };
      } else {
        n = n.left;
      }
    } else {
      if (cIndex === key.length - 1) {
        n.value = value10;
      } else if (n.mid === void 0) {
        dStack.push(0);
        n = {
          key: key[cIndex + 1],
          count: count9
        };
      } else {
        dStack.push(0);
        n = n.mid;
      }
      cIndex += 1;
    }
  }
  for (let s = nStack.length - 2; s >= 0; --s) {
    const n2 = nStack[s];
    const d = dStack[s];
    if (d === -1) {
      nStack[s] = {
        key: n2.key,
        count: count9,
        value: n2.value,
        left: nStack[s + 1],
        mid: n2.mid,
        right: n2.right
      };
    } else if (d === 1) {
      nStack[s] = {
        key: n2.key,
        count: count9,
        value: n2.value,
        left: n2.left,
        mid: n2.mid,
        right: nStack[s + 1]
      };
    } else {
      nStack[s] = {
        key: n2.key,
        count: count9,
        value: n2.value,
        left: n2.left,
        mid: nStack[s + 1],
        right: n2.right
      };
    }
  }
  nStack[0].count = count9;
  return makeImpl6(nStack[0]);
});
var size38 = (self) => self._root?.count ?? 0;
var isEmpty30 = (self) => size38(self) === 0;
var keys13 = (self) => new TrieIterator(self, (key) => key, () => true);
var values13 = (self) => new TrieIterator(self, (_, value10) => value10, () => true);
var entries5 = (self) => new TrieIterator(self, (key, value10) => [key, value10], () => true);
var reduce29 = dual(3, (self, zero3, f) => {
  let accumulator = zero3;
  for (const entry of self) {
    accumulator = f(accumulator, entry[1], entry[0]);
  }
  return accumulator;
});
var map47 = dual(2, (self, f) => reduce29(self, empty59(), (trie, value10, key) => insert3(trie, key, f(value10, key))));
var filter24 = dual(2, (self, f) => reduce29(self, empty59(), (trie, value10, key) => f(value10, key) ? insert3(trie, key, value10) : trie));
var filterMap14 = dual(2, (self, f) => reduce29(self, empty59(), (trie, value10, key) => {
  const option11 = f(value10, key);
  return isSome2(option11) ? insert3(trie, key, option11.value) : trie;
}));
var compact5 = (self) => filterMap14(self, identity);
var forEach27 = dual(2, (self, f) => reduce29(self, void 0, (_, value10, key) => f(value10, key)));
var keysWithPrefix = dual(2, (self, prefix) => new TrieIterator(self, (key) => key, (key) => key.startsWith(prefix)));
var valuesWithPrefix = dual(2, (self, prefix) => new TrieIterator(self, (_, value10) => value10, (key) => key.startsWith(prefix)));
var entriesWithPrefix = dual(2, (self, prefix) => new TrieIterator(self, (key, value10) => [key, value10], (key) => key.startsWith(prefix)));
var toEntriesWithPrefix = dual(2, (self, prefix) => Array.from(entriesWithPrefix(self, prefix)));
var get46 = dual(2, (self, key) => {
  let n = self._root;
  if (n === void 0 || key.length === 0) return none2();
  let cIndex = 0;
  while (cIndex < key.length) {
    const c = key[cIndex];
    if (c > n.key) {
      if (n.right === void 0) {
        return none2();
      } else {
        n = n.right;
      }
    } else if (c < n.key) {
      if (n.left === void 0) {
        return none2();
      } else {
        n = n.left;
      }
    } else {
      if (cIndex === key.length - 1) {
        return fromNullable2(n.value);
      } else {
        if (n.mid === void 0) {
          return none2();
        } else {
          n = n.mid;
          cIndex += 1;
        }
      }
    }
  }
  return none2();
});
var has17 = dual(2, (self, key) => isSome2(get46(self, key)));
var unsafeGet12 = dual(2, (self, key) => {
  const element2 = get46(self, key);
  if (isNone2(element2)) {
    throw new Error("Expected trie to contain key");
  }
  return element2.value;
});
var remove19 = dual(2, (self, key) => {
  let n = self._root;
  if (n === void 0 || key.length === 0) return self;
  const count9 = n.count - 1;
  const dStack = [];
  const nStack = [];
  let cIndex = 0;
  while (cIndex < key.length) {
    const c = key[cIndex];
    if (c > n.key) {
      if (n.right === void 0) {
        return self;
      } else {
        nStack.push(n);
        dStack.push(1);
        n = n.right;
      }
    } else if (c < n.key) {
      if (n.left === void 0) {
        return self;
      } else {
        nStack.push(n);
        dStack.push(-1);
        n = n.left;
      }
    } else {
      if (cIndex === key.length - 1) {
        if (n.value !== void 0) {
          nStack.push(n);
          dStack.push(0);
          cIndex += 1;
        } else {
          return self;
        }
      } else {
        if (n.mid === void 0) {
          return self;
        } else {
          nStack.push(n);
          dStack.push(0);
          n = n.mid;
          cIndex += 1;
        }
      }
    }
  }
  const removeNode = nStack[nStack.length - 1];
  nStack[nStack.length - 1] = {
    key: removeNode.key,
    count: count9,
    left: removeNode.left,
    mid: removeNode.mid,
    right: removeNode.right
  };
  for (let s = nStack.length - 2; s >= 0; --s) {
    const n2 = nStack[s];
    const d = dStack[s];
    const child = nStack[s + 1];
    const nc = child.left === void 0 && child.mid === void 0 && child.right === void 0 ? void 0 : child;
    if (d === -1) {
      nStack[s] = {
        key: n2.key,
        count: count9,
        value: n2.value,
        left: nc,
        mid: n2.mid,
        right: n2.right
      };
    } else if (d === 1) {
      nStack[s] = {
        key: n2.key,
        count: count9,
        value: n2.value,
        left: n2.left,
        mid: n2.mid,
        right: nc
      };
    } else {
      nStack[s] = {
        key: n2.key,
        count: count9,
        value: n2.value,
        left: n2.left,
        mid: nc,
        right: n2.right
      };
    }
  }
  nStack[0].count = count9;
  return makeImpl6(nStack[0]);
});
var removeMany3 = dual(2, (self, keys15) => {
  let trie = self;
  for (const key of keys15) {
    trie = remove19(key)(trie);
  }
  return trie;
});
var insertMany = dual(2, (self, iter) => {
  let trie = self;
  for (const [key, value10] of iter) {
    trie = insert3(key, value10)(trie);
  }
  return trie;
});
var modify20 = dual(3, (self, key, f) => {
  let n = self._root;
  if (n === void 0 || key.length === 0) return self;
  const dStack = [];
  const nStack = [];
  let cIndex = 0;
  while (cIndex < key.length) {
    const c = key[cIndex];
    if (c > n.key) {
      if (n.right === void 0) {
        return self;
      } else {
        nStack.push(n);
        dStack.push(1);
        n = n.right;
      }
    } else if (c < n.key) {
      if (n.left === void 0) {
        return self;
      } else {
        nStack.push(n);
        dStack.push(-1);
        n = n.left;
      }
    } else {
      if (cIndex === key.length - 1) {
        if (n.value !== void 0) {
          nStack.push(n);
          dStack.push(0);
          cIndex += 1;
        } else {
          return self;
        }
      } else {
        if (n.mid === void 0) {
          return self;
        } else {
          nStack.push(n);
          dStack.push(0);
          n = n.mid;
          cIndex += 1;
        }
      }
    }
  }
  const updateNode = nStack[nStack.length - 1];
  if (updateNode.value === void 0) {
    return self;
  }
  nStack[nStack.length - 1] = {
    key: updateNode.key,
    count: updateNode.count,
    value: f(updateNode.value),
    // Update
    left: updateNode.left,
    mid: updateNode.mid,
    right: updateNode.right
  };
  for (let s = nStack.length - 2; s >= 0; --s) {
    const n2 = nStack[s];
    const d = dStack[s];
    const child = nStack[s + 1];
    if (d === -1) {
      nStack[s] = {
        key: n2.key,
        count: n2.count,
        value: n2.value,
        left: child,
        mid: n2.mid,
        right: n2.right
      };
    } else if (d === 1) {
      nStack[s] = {
        key: n2.key,
        count: n2.count,
        value: n2.value,
        left: n2.left,
        mid: n2.mid,
        right: child
      };
    } else {
      nStack[s] = {
        key: n2.key,
        count: n2.count,
        value: n2.value,
        left: n2.left,
        mid: child,
        right: n2.right
      };
    }
  }
  return makeImpl6(nStack[0]);
});
var longestPrefixOf = dual(2, (self, key) => {
  let n = self._root;
  if (n === void 0 || key.length === 0) return none2();
  let longestPrefixNode = void 0;
  let cIndex = 0;
  while (cIndex < key.length) {
    const c = key[cIndex];
    if (n.value !== void 0) {
      longestPrefixNode = [key.slice(0, cIndex + 1), n.value];
    }
    if (c > n.key) {
      if (n.right === void 0) {
        break;
      } else {
        n = n.right;
      }
    } else if (c < n.key) {
      if (n.left === void 0) {
        break;
      } else {
        n = n.left;
      }
    } else {
      if (n.mid === void 0) {
        break;
      } else {
        n = n.mid;
        cIndex += 1;
      }
    }
  }
  return fromNullable2(longestPrefixNode);
});

// ../../node_modules/effect/dist/esm/Trie.js
var empty60 = empty59;
var fromIterable33 = fromIterable32;
var make150 = make149;
var insert4 = insert3;
var keys14 = keys13;
var values14 = values13;
var entries6 = entries5;
var toEntries3 = (self) => Array.from(entries6(self));
var keysWithPrefix2 = keysWithPrefix;
var valuesWithPrefix2 = valuesWithPrefix;
var entriesWithPrefix2 = entriesWithPrefix;
var toEntriesWithPrefix2 = toEntriesWithPrefix;
var longestPrefixOf2 = longestPrefixOf;
var size39 = size38;
var get47 = get46;
var has18 = has17;
var isEmpty31 = isEmpty30;
var unsafeGet13 = unsafeGet12;
var remove20 = remove19;
var reduce30 = reduce29;
var map48 = map47;
var filter25 = filter24;
var filterMap15 = filterMap14;
var compact6 = compact5;
var forEach28 = forEach27;
var modify21 = modify20;
var removeMany4 = removeMany3;
var insertMany2 = insertMany;

// ../../node_modules/effect/dist/esm/Types.js
var Types_exports = {};

// ../../node_modules/effect/dist/esm/Unify.js
var Unify_exports = {};
__export(Unify_exports, {
  unify: () => unify2
});
var unify2 = identity;

// ../../node_modules/effect/dist/esm/UpstreamPullRequest.js
var UpstreamPullRequest_exports = {};
__export(UpstreamPullRequest_exports, {
  NoUpstream: () => NoUpstream2,
  Pulled: () => Pulled2,
  UpstreamPullRequestTypeId: () => UpstreamPullRequestTypeId2,
  isNoUpstream: () => isNoUpstream2,
  isPulled: () => isPulled2,
  isUpstreamPullRequest: () => isUpstreamPullRequest2,
  match: () => match41
});
var UpstreamPullRequestTypeId2 = UpstreamPullRequestTypeId;
var Pulled2 = Pulled;
var NoUpstream2 = NoUpstream;
var isUpstreamPullRequest2 = isUpstreamPullRequest;
var isPulled2 = isPulled;
var isNoUpstream2 = isNoUpstream;
var match41 = match24;

// ../../node_modules/effect/dist/esm/UpstreamPullStrategy.js
var UpstreamPullStrategy_exports = {};
__export(UpstreamPullStrategy_exports, {
  PullAfterAllEnqueued: () => PullAfterAllEnqueued2,
  PullAfterNext: () => PullAfterNext2,
  UpstreamPullStrategyTypeId: () => UpstreamPullStrategyTypeId2,
  isPullAfterAllEnqueued: () => isPullAfterAllEnqueued2,
  isPullAfterNext: () => isPullAfterNext2,
  isUpstreamPullStrategy: () => isUpstreamPullStrategy2,
  match: () => match42
});
var UpstreamPullStrategyTypeId2 = UpstreamPullStrategyTypeId;
var PullAfterNext2 = PullAfterNext;
var PullAfterAllEnqueued2 = PullAfterAllEnqueued;
var isUpstreamPullStrategy2 = isUpstreamPullStrategy;
var isPullAfterNext2 = isPullAfterNext;
var isPullAfterAllEnqueued2 = isPullAfterAllEnqueued;
var match42 = match23;

export {
  identity,
  unsafeCoerce,
  absurd,
  pipe,
  flow,
  hole,
  Function_exports,
  Equivalence_exports,
  GlobalValue_exports,
  Predicate_exports,
  Utils_exports,
  Hash_exports,
  Equal_exports,
  Inspectable_exports,
  Pipeable_exports,
  Either_exports,
  Order_exports,
  Option_exports,
  Tuple_exports,
  Iterable_exports,
  Record_exports,
  Array_exports,
  FastCheck_exports,
  Number_exports,
  RegExp_exports,
  SchemaAST_exports,
  Arbitrary_exports,
  BigDecimal_exports,
  BigInt_exports,
  Boolean_exports,
  Brand_exports,
  Context_exports,
  Chunk_exports,
  Duration_exports,
  HashSet_exports,
  MutableRef_exports,
  FiberId_exports,
  HashMap_exports,
  List_exports,
  RuntimeFlagsPatch_exports,
  Deferred_exports,
  Exit_exports,
  MutableHashMap_exports,
  MutableList_exports,
  MutableQueue_exports,
  Clock_exports,
  FiberRefs_exports,
  LogLevel_exports,
  LogSpan_exports,
  Effectable_exports,
  Readable_exports,
  Ref_exports,
  Tracer_exports,
  ExecutionStrategy_exports,
  FiberRefsPatch_exports,
  FiberStatus_exports,
  Micro_exports,
  Scheduler_exports,
  RedBlackTree_exports,
  SortedSet_exports,
  Differ_exports,
  Cache_exports,
  Cause_exports,
  ScheduleInterval_exports,
  ScheduleIntervals_exports,
  ScheduleDecision_exports,
  Scope_exports,
  Fiber_exports,
  Data_exports,
  String_exports,
  Cron_exports,
  Random_exports,
  Request_exports,
  Effect_exports,
  FiberRef_exports,
  Layer_exports,
  PubSub_exports,
  Queue_exports,
  MergeDecision_exports,
  RcRef_exports,
  Runtime_exports,
  Schedule_exports,
  StreamHaltStrategy_exports,
  TPubSub_exports,
  TQueue_exports,
  Channel_exports,
  ChildExecutorDecision_exports,
  ConfigError_exports,
  Config_exports,
  ConfigProvider_exports,
  ConfigProviderPathPatch_exports,
  Console_exports,
  DateTime_exports,
  DefaultServices_exports,
  Encoding_exports,
  ExecutionPlan_exports,
  FiberHandle_exports,
  FiberMap_exports,
  FiberSet_exports,
  GroupBy_exports,
  HKT_exports,
  decodeUnknown2 as decodeUnknown,
  ArrayFormatter,
  ParseResult_exports,
  JSONSchema_exports,
  KeyedPool_exports,
  RcMap_exports,
  LayerMap_exports,
  Logger_exports,
  Mailbox_exports,
  ManagedRuntime_exports,
  Match_exports,
  MergeState_exports,
  MergeStrategy_exports,
  Metric_exports,
  MetricBoundaries_exports,
  MetricHook_exports,
  MetricKey_exports,
  MetricKeyType_exports,
  MetricLabel_exports,
  MetricPair_exports,
  MetricPolling_exports,
  MetricRegistry_exports,
  MetricState_exports,
  ModuleVersion_exports,
  MutableHashSet_exports,
  NonEmptyIterable_exports,
  Ordering_exports,
  Pool_exports,
  Pretty_exports,
  PrimaryKey_exports,
  RateLimiter_exports,
  Redacted_exports,
  Reloadable_exports,
  RequestBlock_exports,
  RequestResolver_exports,
  Resource_exports,
  RuntimeFlags_exports,
  STM_exports,
  Struct_exports,
  Schema_exports,
  ScopedCache_exports,
  ScopedRef_exports,
  Secret_exports,
  SingleProducerAsyncInput_exports,
  Sink_exports,
  SortedMap_exports,
  Stream_exports,
  StreamEmit_exports,
  Streamable_exports,
  Subscribable_exports,
  SynchronizedRef_exports,
  SubscriptionRef_exports,
  Supervisor_exports,
  Symbol_exports,
  TArray_exports,
  TDeferred_exports,
  TMap_exports,
  TPriorityQueue_exports,
  TRandom_exports,
  TReentrantLock_exports,
  TRef_exports,
  TSemaphore_exports,
  TSet_exports,
  TSubscriptionRef_exports,
  Take_exports,
  TestAnnotation_exports,
  TestAnnotationMap_exports,
  TestAnnotations_exports,
  TestLive_exports,
  TestClock_exports,
  TestConfig_exports,
  TestSized_exports,
  TestServices_exports,
  TestContext_exports,
  Trie_exports,
  Types_exports,
  Unify_exports,
  UpstreamPullRequest_exports,
  UpstreamPullStrategy_exports
};
//# sourceMappingURL=chunk-2GVWGMWC.js.map
